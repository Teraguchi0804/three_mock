{"version":3,"sources":["webpack:///index.js","webpack:///webpack/bootstrap 50a4f013a530453067de","webpack:///./src/js/app.js","webpack:///./src/js/main.js","webpack:///./~/jquery/dist/jquery.js","webpack:///./~/three/build/three.js","webpack:///./src/js/libs/stats.js","webpack:///./~/dat-gui/index.js","webpack:///./~/dat-gui/vendor/dat.gui.js","webpack:///./~/dat-gui/vendor/dat.color.js","webpack:///./src/js/object/Plane.js","webpack:///./src/js/object/Scene.js","webpack:///./src/js/object/Camera.js","webpack:///./src/js/object/Cube.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","$","window","THREE","Stats","dat","Scene","Camera","Cube","undefined","gb","in","sample","MainDisplay","PlaneObject","Plane","initStats","stats","setMode","domElement","style","position","left","top","document","getElementById","appendChild","init","s","prototype","renderScene","self","this","$window","$MainDisplay","timer","renderer","WebGLRenderer","antialias","alert","setClearColor","Color","setSize","innerWidth","innerHeight","shadowMap","enabled","pixelRatio","Math","min","devicePixelRatio","setPixelRatio","scene","camera","ambientLight","AmbientLight","add","spotLight","SpotLight","set","castShadow","on","e","onResize","trigger","CubeObject","cube","sphereGeometry","SphereGeometry","sphereMaterial","MeshLambertMaterial","color","wireframe","sphere","Mesh","x","y","z","update","rotation","step","lookat_x","sin","lookat_y","cos","lookAt","Vector3","requestAnimationFrame","render","bind","controls","rotationSpeed","bouncingSpeed","gui","GUI","updateAnimation","width","height","aspect","updateProjectionMatrix","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","global","factory","w","Error","noGlobal","DOMEval","code","doc","script","createElement","text","head","parentNode","removeChild","isArrayLike","obj","length","type","jQuery","isWindow","winnow","elements","qualifier","not","isFunction","grep","elem","i","nodeType","indexOf","risSimple","test","filter","sibling","cur","dir","createOptions","options","object","each","match","rnothtmlwhite","_","flag","Identity","v","Thrower","ex","adoptValue","value","resolve","reject","method","promise","done","fail","then","completed","removeEventListener","ready","Data","expando","uid","getData","data","rbrace","JSON","parse","dataAttr","key","name","replace","rmultiDash","toLowerCase","getAttribute","dataUser","adjustCSS","prop","valueParts","tween","adjusted","scale","maxIterations","currentValue","css","initial","unit","cssNumber","initialInUnit","rcssNum","exec","start","end","getDefaultDisplay","temp","ownerDocument","nodeName","display","defaultDisplayMap","body","showHide","show","values","index","dataPriv","get","isHiddenWithinTree","getAll","context","tag","ret","getElementsByTagName","querySelectorAll","merge","setGlobalEval","elems","refElements","l","buildFragment","scripts","selection","ignored","tmp","wrap","contains","j","fragment","createDocumentFragment","nodes","rhtml","rtagName","wrapMap","_default","innerHTML","htmlPrefilter","lastChild","childNodes","firstChild","textContent","push","createTextNode","inArray","rscriptType","returnTrue","returnFalse","safeActiveElement","activeElement","err","types","selector","fn","one","origFn","event","off","apply","arguments","guid","manipulationTarget","content","disableScript","restoreScript","rscriptTypeMasked","removeAttribute","cloneCopyEvent","src","dest","pdataOld","pdataCur","udataOld","udataCur","events","hasData","access","handle","extend","fixInput","rcheckableType","checked","defaultValue","domManip","collection","args","callback","concat","first","hasScripts","node","iNoClone","support","checkClone","rchecked","eq","html","map","clone","_evalUrl","rcleanScript","remove","keepData","cleanData","curCSS","computed","minWidth","maxWidth","getStyles","getPropertyValue","pixelMarginRight","rnumnonpx","rmargin","addGetHookIf","conditionFn","hookFn","vendorPropName","emptyStyle","capName","toUpperCase","slice","cssPrefixes","setPositiveNumber","subtract","matches","max","augmentWidthOrHeight","extra","isBorderBox","styles","val","cssExpand","getWidthOrHeight","valueIsBorderBox","getClientRects","getBoundingClientRect","boxSizingReliable","parseFloat","Tween","easing","raf","timerId","fx","tick","createFxNow","setTimeout","fxNow","now","genFx","includeWidth","which","attrs","opacity","createTween","animation","Animation","tweeners","defaultPrefilter","props","opts","toggle","hooks","oldfire","propTween","restoreDisplay","isBox","anim","orig","hidden","dataShow","queue","_queueHooks","unqueued","empty","fire","always","rfxtypes","isEmptyObject","overflow","overflowX","overflowY","propFilter","specialEasing","camelCase","isArray","cssHooks","expand","properties","result","stopped","prefilters","deferred","Deferred","currentTime","remaining","startTime","duration","percent","tweens","run","notifyWith","resolveWith","originalProperties","originalOptions","stop","gotoEnd","rejectWith","proxy","progress","complete","stripAndCollapse","tokens","join","getClass","buildParams","prefix","traditional","rbracket","addToPrefiltersOrTransports","structure","dataTypeExpression","func","dataType","dataTypes","unshift","inspectPrefiltersOrTransports","jqXHR","inspect","selected","inspected","prefilterOrFactory","dataTypeOrTransport","seekingTransport","transports","ajaxExtend","target","deep","flatOptions","ajaxSettings","ajaxHandleResponses","responses","ct","finalDataType","firstDataType","contents","shift","mimeType","getResponseHeader","converters","ajaxConvert","response","isSuccess","conv2","current","conv","prev","responseFields","dataFilter","split","throws","state","error","getWindow","defaultView","arr","getProto","Object","getPrototypeOf","class2type","toString","hasOwn","hasOwnProperty","fnToString","ObjectFunctionString","version","rtrim","rmsPrefix","rdashAlpha","fcamelCase","all","letter","jquery","constructor","toArray","num","pushStack","prevObject","last","len","sort","splice","copy","copyIsArray","isPlainObject","random","isReady","msg","noop","Array","isNumeric","isNaN","proto","Ctor","globalEval","string","trim","makeArray","results","second","invert","callbackInverse","callbackExpect","arg","Date","Symbol","iterator","Sizzle","seed","nid","groups","newSelector","newContext","preferredDoc","setDocument","documentIsHTML","rquickExpr","getElementsByClassName","qsa","compilerCache","rbuggyQSA","rcssescape","fcssescape","setAttribute","tokenize","toSelector","rsibling","testContext","qsaError","select","createCache","cache","keys","Expr","cacheLength","markFunction","assert","el","addHandle","handler","attrHandle","siblingCheck","a","b","diff","sourceIndex","nextSibling","createInputPseudo","createButtonPseudo","createDisabledPseudo","disabled","isDisabled","disabledAncestor","createPositionalPseudo","argument","matchIndexes","setFilters","addCombinator","matcher","combinator","base","skip","next","checkNonElements","doneName","xml","oldCache","uniqueCache","outerCache","newCache","dirruns","uniqueID","elementMatcher","matchers","multipleContexts","contexts","condense","unmatched","newUnmatched","mapped","setMatcher","preFilter","postFilter","postFinder","postSelector","preMap","postMap","preexisting","matcherIn","matcherOut","matcherFromTokens","checkContext","leadingRelative","relative","implicitRelative","matchContext","matchAnyContext","outermostContext","matcherFromGroupMatchers","elementMatchers","setMatchers","bySet","byElement","superMatcher","outermost","matchedCount","setMatched","contextBackup","find","dirrunsUnique","pop","uniqueSort","getText","isXML","compile","sortInput","hasDuplicate","docElem","rbuggyMatches","classCache","tokenCache","sortOrder","push_native","list","booleans","whitespace","identifier","attributes","pseudos","rwhitespace","RegExp","rcomma","rcombinators","rattributeQuotes","rpseudo","ridentifier","matchExpr","ID","CLASS","TAG","ATTR","PSEUDO","CHILD","bool","needsContext","rinputs","rheader","rnative","runescape","funescape","escaped","escapedWhitespace","high","String","fromCharCode","ch","asCodePoint","charCodeAt","unloadHandler","els","documentElement","hasCompare","subWindow","addEventListener","attachEvent","className","createComment","getById","getElementsByName","attrId","getAttributeNode","input","matchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","msMatchesSelector","disconnectedMatch","compareDocumentPosition","adown","bup","compare","sortDetached","aup","ap","bp","expr","attr","specified","escape","sel","duplicates","detectDuplicates","sortStable","nodeValue","selectors","createPseudo",">"," ","+","~","excess","unquoted","nodeNameSelector","pattern","operator","check","what","simple","forward","ofType","nodeIndex","parent","useCache","pseudo","idx","matched","has","innerText","lang","elemLang","hash","location","root","focus","hasFocus","href","tabIndex","selectedIndex","header","button","even","odd","lt","gt","radio","checkbox","file","password","image","submit","reset","filters","parseOnly","soFar","preFilters","cached","token","compiled","unique","isXMLDoc","escapeSelector","until","truncate","is","siblings","n","rneedsContext","rsingleTag","rootjQuery","parseHTML","rparentsprev","guaranteedUnique","children","targets","closest","prevAll","addBack","parents","parentsUntil","nextAll","nextUntil","prevUntil","contentDocument","reverse","Callbacks","firing","memory","fired","locked","firingIndex","once","stopOnFalse","disable","lock","fireWith","tuples","catch","pipe","fns","newDefer","tuple","returned","notify","onFulfilled","onRejected","onProgress","depth","special","that","mightThrow","maxDepth","TypeError","process","exceptionHook","stackTrace","getStackHook","stateString","when","singleValue","resolveContexts","resolveValues","master","updateFunc","rerrorNames","stack","console","warn","message","readyException","readyList","readyWait","holdReady","hold","wait","readyState","doScroll","chainable","emptyGet","raw","bulk","acceptData","owner","defineProperty","configurable","removeData","_data","_removeData","dequeue","startLength","setter","clearQueue","count","defer","pnum","source","swap","old","hide","option","thead","col","tr","td","optgroup","tbody","tfoot","colgroup","caption","th","div","cloneNode","noCloneChecked","rkeyEvent","rmouseEvent","rtypenamespace","handleObjIn","eventHandle","t","handleObj","handlers","namespaces","origType","elemData","triggered","dispatch","delegateType","bindType","namespace","delegateCount","setup","mappedTypes","origCount","teardown","removeEvent","nativeEvent","handlerQueue","fix","delegateTarget","preDispatch","isPropagationStopped","currentTarget","isImmediatePropagationStopped","rnamespace","preventDefault","stopPropagation","postDispatch","matchedHandlers","matchedSelectors","addProp","hook","Event","enumerable","originalEvent","writable","load","noBubble","blur","click","beforeunload","returnValue","isDefaultPrevented","defaultPrevented","relatedTarget","timeStamp","isSimulated","stopImmediatePropagation","altKey","bubbles","cancelable","changedTouches","ctrlKey","detail","eventPhase","metaKey","pageX","pageY","shiftKey","view","char","charCode","keyCode","buttons","clientX","clientY","offsetX","offsetY","pointerId","pointerType","screenX","screenY","targetTouches","toElement","touches","mouseenter","mouseleave","pointerenter","pointerleave","related","rxhtmlTag","rnoInnerhtml","dataAndEvents","deepDataAndEvents","srcElements","destElements","inPage","detach","append","prepend","insertBefore","before","after","replaceWith","replaceChild","appendTo","prependTo","insertAfter","replaceAll","original","insert","opener","getComputedStyle","computeStyleTests","cssText","container","divStyle","pixelPositionVal","reliableMarginLeftVal","marginLeft","boxSizingReliableVal","marginRight","pixelMarginRightVal","backgroundClip","clearCloneStyle","pixelPosition","reliableMarginLeft","rdisplayswap","cssShow","visibility","cssNormalTransform","letterSpacing","fontWeight","animationIterationCount","columnCount","fillOpacity","flexGrow","flexShrink","lineHeight","order","orphans","widows","zIndex","zoom","cssProps","float","origName","isFinite","margin","padding","border","suffix","expanded","parts","propHooks","eased","pos","scrollTop","scrollLeft","linear","swing","PI","rrun","*","tweener","prefilter","speed","opt","speeds","fadeTo","to","animate","optall","doAnimation","finish","stopQueue","timers","cssFn","slideDown","slideUp","slideToggle","fadeIn","fadeOut","fadeToggle","interval","setInterval","cancelAnimationFrame","clearInterval","slow","fast","delay","time","timeout","clearTimeout","checkOn","optSelected","radioValue","boolHook","removeAttr","nType","attrHooks","attrNames","getter","lowercaseName","rfocusable","rclickable","removeProp","propFix","tabindex","parseInt","for","class","addClass","classes","curValue","clazz","finalValue","removeClass","toggleClass","stateVal","classNames","hasClass","rreturn","valHooks","optionSet","rfocusMorph","onlyHandlers","bubbleType","ontype","eventPath","isTrigger","parentWindow","simulate","triggerHandler","hover","fnOver","fnOut","focusin","attaches","nonce","rquery","parseXML","DOMParser","parseFromString","rCRLF","rsubmitterTypes","rsubmittable","param","valueOrFunction","encodeURIComponent","serialize","serializeArray","r20","rhash","rantiCache","rheaders","rlocalProtocol","rnoContent","rprotocol","allTypes","originAnchor","active","lastModified","etag","url","isLocal","protocol","processData","async","contentType","accepts","json","* text","text html","text json","text xml","ajaxSetup","settings","ajaxPrefilter","ajaxTransport","ajax","status","nativeStatusText","headers","success","modified","statusText","timeoutTimer","transport","responseHeadersString","ifModified","cacheURL","callbackContext","statusCode","fireGlobals","globalEventContext","completeDeferred","responseHeaders","urlAnchor","uncached","requestHeaders","requestHeadersNames","strAbort","getAllResponseHeaders","setRequestHeader","overrideMimeType","abort","finalText","crossDomain","host","hasContent","beforeSend","send","getJSON","getScript","wrapAll","firstElementChild","wrapInner","unwrap","visible","offsetWidth","offsetHeight","xhr","XMLHttpRequest","xhrSuccessStatus","0","1223","xhrSupported","cors","errorCallback","open","username","xhrFields","onload","onerror","onabort","onreadystatechange","responseType","responseText","binary","text script","charset","scriptCharset","evt","oldCallbacks","rjsonp","jsonp","jsonpCallback","originalSettings","callbackName","overwritten","responseContainer","jsonProp","createHTMLDocument","implementation","keepScripts","parsed","params","animated","offset","setOffset","curPosition","curLeft","curCSSTop","curTop","curOffset","curCSSLeft","calculatePosition","curElem","using","win","rect","pageYOffset","clientTop","pageXOffset","clientLeft","offsetParent","parentOffset","scrollTo","Height","Width","","defaultExtra","funcName","unbind","delegate","undelegate","parseJSON","_jQuery","_$","noConflict","EventDispatcher","Vector2","Texture","mapping","wrapS","wrapT","magFilter","minFilter","format","anisotropy","encoding","TextureIdCount","uuid","_Math","generateUUID","sourceFile","DEFAULT_IMAGE","mipmaps","DEFAULT_MAPPING","ClampToEdgeWrapping","LinearFilter","LinearMipMapLinearFilter","RGBAFormat","UnsignedByteType","repeat","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","LinearEncoding","onUpdate","Vector4","WebGLRenderTarget","scissor","scissorTest","viewport","texture","depthBuffer","stencilBuffer","depthTexture","WebGLRenderTargetCube","activeCubeFace","activeMipMapLevel","Quaternion","_x","_y","_z","_w","Matrix4","Float32Array","CubeTexture","images","CubeReflectionMapping","UniformContainer","seq","flatten","array","nBlocks","blockSize","firstElem","r","arrayCacheF32","allocTexUnits","arrayCacheI32","Int32Array","allocTextureUnit","setValue1f","gl","uniform1f","addr","setValue1i","uniform1i","setValue2fv","uniform2fv","uniform2f","setValue3fv","uniform3f","g","uniform3fv","setValue4fv","uniform4fv","uniform4f","setValue2fm","uniformMatrix2fv","setValue3fm","uniformMatrix3fv","setValue4fm","uniformMatrix4fv","setValueT1","setTexture2D","emptyTexture","setValueT6","setTextureCube","emptyCubeTexture","setValue2iv","uniform2iv","setValue3iv","uniform3iv","setValue4iv","uniform4iv","getSingularSetter","setValue1fv","uniform1fv","setValue1iv","uniform1iv","setValueV2a","size","setValueV3a","setValueV4a","setValueM2a","setValueM3a","setValueM4a","setValueT1a","units","setValueT6a","getPureArraySetter","SingleUniform","activeInfo","setValue","PureArrayUniform","StructuredUniform","addUniform","uniformObject","parseUniform","path","pathLength","RePathPart","lastIndex","matchEnd","idIsIndex","subscript","WebGLUniforms","program","getProgramParameter","ACTIVE_UNIFORMS","info","getActiveUniform","getUniformLocation","setRGB","Box2","Infinity","LensFlarePlugin","flares","vertices","faces","Uint16Array","vertexBuffer","createBuffer","elementBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","ELEMENT_ARRAY_BUFFER","tempTexture","createTexture","occlusionTexture","bindTexture","TEXTURE_2D","texImage2D","RGB","UNSIGNED_BYTE","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","NEAREST","TEXTURE_MIN_FILTER","RGBA","shader","vertexShader","fragmentShader","createProgram","vertex","getAttribLocation","uv","uniforms","renderType","occlusionMap","screenPosition","createShader","FRAGMENT_SHADER","VERTEX_SHADER","getPrecision","shaderSource","compileShader","attachShader","linkProgram","tempPosition","invAspect","halfViewportWidth","halfViewportHeight","screenPositionPixels","validArea","useProgram","initAttributes","enableAttribute","disableUnusedAttributes","vertexAttribPointer","FLOAT","CULL_FACE","setDepthWrite","flare","matrixWorld","applyMatrix4","matrixWorldInverse","applyProjection","projectionMatrix","containsPoint","activeTexture","TEXTURE0","TEXTURE1","copyTexImage2D","BLEND","enable","DEPTH_TEST","drawElements","TRIANGLES","UNSIGNED_SHORT","positionScreen","customUpdateCallback","updateLensFlares","jl","lensFlares","sprite","setBlending","blending","blendEquation","blendSrc","blendDst","resetGLState","SpritePlugin","sprites","uvOffset","uvScale","modelViewMatrix","fogType","fogDensity","fogNear","fogFar","fogColor","alphaTest","canvas","createElementNS","getContext","fillStyle","fillRect","needsUpdate","painterSortStable","renderOrder","spritePosition","spriteRotation","spriteScale","oldFogType","sceneFogType","fog","isFog","near","far","isFogExp2","density","multiplyMatrices","material","decompose","setDepthTest","depthTest","depthWrite","Material","MaterialIdCount","lights","NormalBlending","side","FrontSide","shading","SmoothShading","vertexColors","NoColors","transparent","SrcAlphaFactor","OneMinusSrcAlphaFactor","AddEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","depthFunc","LessEqualDepth","clippingPlanes","clipIntersection","clipShadows","colorWrite","precision","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","premultipliedAlpha","overdraw","_needsUpdate","count$1","ShaderMaterial","parameters","defines","linewidth","wireframeLinewidth","clipping","skinning","morphTargets","morphNormals","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","uv2","index0AttributeName","setValues","MeshDepthMaterial","depthPacking","BasicDepthPacking","alphaMap","displacementMap","displacementScale","displacementBias","Box3","Sphere","center","radius","Matrix3","normal","constant","Frustum","p0","p1","p2","p3","p4","p5","planes","WebGLShadowMap","_renderer","_lights","_objects","capabilities","getDepthMaterial","isPointLight","lightPositionWorld","geometry","materialVariants","_depthMaterials","customMaterial","customDepthMaterial","_distanceMaterials","customDistanceMaterial","useMorphing","isBufferGeometry","morphAttributes","isGeometry","useSkinning","isSkinnedMesh","variantIndex","_MorphingFlag","_SkinningFlag","localClippingEnabled","keyA","keyB","materialsForVariant","_materialCache","cachedMaterial","scope","renderSingleSided","DoubleSide","renderReverseSided","BackSide","lightPos","projectObject","shadowCamera","layers","mask","isMesh","isLine","isPoints","frustumCulled","_frustum","intersectsObject","_renderList","_gl","_state","_projScreenMatrix","_lightShadows","shadows","_shadowMapSize","_maxShadowMapSize","maxTextureSize","_lookTarget","_lightPositionWorld","_NumberOfMaterialVariants","cubeDirections","cubeUps","cube2DViewPorts","depthMaterialTemplate","RGBADepthPacking","distanceShader","ShaderLib","distanceUniforms","UniformsUtils","depthMaterial","distanceMaterial","USE_SHADOWMAP","autoUpdate","PCFShadowMap","clearColor","setScissorTest","faceCount","il","light","shadow","mapSize","vpWidth","vpHeight","pars","NearestFilter","isSpotLightShadow","shadowMatrix","matrix","setFromMatrixPosition","setRenderTarget","clear","face","up","vpDimensions","updateMatrixWorld","getInverse","multiply","setFromMatrix","isMultiMaterial","materials","k","kl","group","groupMaterial","materialIndex","renderBufferDirect","getClearColor","clearAlpha","getClearAlpha","Ray","origin","direction","Euler","_order","DefaultOrder","Layers","Object3D","onRotationChange","quaternion","setFromEuler","onQuaternionChange","setFromQuaternion","Object3DIdCount","DefaultUp","onChange","defineProperties","normalMatrix","matrixAutoUpdate","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","receiveShadow","userData","onBeforeRender","onAfterRender","count$2","Line3","Triangle","Face3","isVector3","vertexNormals","isColor","MeshBasicMaterial","aoMap","aoMapIntensity","specularMap","envMap","combine","MultiplyOperation","reflectivity","refractionRatio","wireframeLinecap","wireframeLinejoin","BufferAttribute","itemSize","normalized","dynamic","updateRange","Int8Attribute","Int8Array","Uint8Attribute","Uint8Array","Uint8ClampedAttribute","Uint8ClampedArray","Int16Attribute","Int16Array","Uint16Attribute","Int32Attribute","Uint32Attribute","Uint32Array","Float32Attribute","Float64Attribute","Float64Array","DynamicBufferAttribute","setDynamic","Geometry","GeometryIdCount","colors","faceVertexUvs","skinWeights","skinIndices","lineDistances","boundingBox","boundingSphere","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","count$3","DirectGeometry","indices","normals","uvs","uvs2","BufferGeometry","drawRange","drawMode","TrianglesDrawMode","updateMorphTargets","BoxBufferGeometry","widthSegments","heightSegments","depthSegments","calculateVertexCount","h","d","calculateIndexCount","buildPlane","u","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","groupCount","vector","iy","ix","vertexBufferOffset","uvBufferOffset","numberOfVertices","indexBufferOffset","addGroup","groupStart","floor","vertexCount","indexCount","setIndex","addAttribute","PlaneBufferGeometry","width_half","height_half","segment_width","segment_height","offset2","PerspectiveCamera","fov","filmGauge","filmOffset","OrthographicCamera","right","bottom","WebGLIndexedBufferRenderer","infoRender","mode","UNSIGNED_INT","calls","renderInstances","extension","drawElementsInstancedANGLE","maxInstancedCount","WebGLBufferRenderer","drawArrays","isInterleavedBufferAttribute","drawArraysInstancedANGLE","WebGLLights","shadowBias","shadowRadius","shadowMapSize","distance","coneCos","penumbraCos","decay","skyColor","groundColor","addLineNumbers","lines","WebGLShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","getEncodingComponents","sRGBEncoding","RGBEEncoding","RGBM7Encoding","RGBM16Encoding","RGBDEncoding","GammaEncoding","getTexelDecodingFunction","functionName","components","getTexelEncodingFunction","getToneMappingFunction","toneMapping","toneMappingName","LinearToneMapping","ReinhardToneMapping","Uncharted2ToneMapping","CineonToneMapping","generateExtensions","rendererExtensions","chunks","envMapCubeUV","bumpMap","normalMap","flatShading","logarithmicDepthBuffer","filterEmptyLine","generateDefines","fetchAttributeLocations","identifiers","ACTIVE_ATTRIBUTES","getActiveAttrib","replaceLightNums","numDirLights","numSpotLights","numPointLights","numHemiLights","parseIncludes","include","ShaderChunk","unrollLoops","snippet","unroll","WebGLProgram","__webglShader","shadowMapTypeDefine","shadowMapType","PCFSoftShadowMap","envMapTypeDefine","envMapModeDefine","envMapBlendingDefine","CubeRefractionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","MixOperation","AddOperation","prefixVertex","prefixFragment","gammaFactorDefine","gammaFactor","customExtensions","customDefines","isRawShaderMaterial","supportsVertexTextures","maxBones","lightMap","emissiveMap","roughnessMap","metalnessMap","useVertexTexture","doubleSided","flipSided","numClippingPlanes","shadowMapEnabled","sizeAttenuation","useFog","fogExp","numClipIntersection","physicallyCorrectLights","NoToneMapping","outputEncoding","mapEncoding","envMapEncoding","emissiveMapEncoding","isShaderMaterial","vertexGlsl","fragmentGlsl","glVertexShader","glFragmentShader","bindAttribLocation","programLog","getProgramInfoLog","vertexLog","fragmentLog","runnable","haveDiagnostics","LINK_STATUS","getError","VALIDATE_STATUS","diagnostics","log","deleteShader","cachedUniforms","getUniforms","cachedAttributes","getAttributes","destroy","deleteProgram","programIdCount","usedTimes","WebGLPrograms","allocateBones","floatVertexTextures","skeleton","nVertexUniforms","maxVertexUniforms","nVertexMatrices","bones","getTextureEncodingFromMap","gammaOverrideLinear","isTexture","isWebGLRenderTarget","programs","shaderIDs","MeshNormalMaterial","MeshPhongMaterial","MeshStandardMaterial","MeshPhysicalMaterial","LineBasicMaterial","LineDashedMaterial","PointsMaterial","parameterNames","getParameters","nClipPlanes","nClipIntersection","shaderID","getMaxPrecision","currentRenderTarget","getCurrentRenderTarget","vertexTextures","gammaOutput","gammaInput","envMapMode","FlatShading","maxMorphTargets","maxMorphNormals","directional","point","spot","hemi","getProgramCode","acquireProgram","pl","programInfo","releaseProgram","WebGLGeometries","onGeometryDispose","buffergeometry","geometries","deleteAttribute","deleteAttributes","property","delete","bufferproperty","getAttributeBuffer","attribute","__webglBuffer","buffer","deleteBuffer","removeAttributeBuffer","_bufferGeometry","setFromObject","WebGLObjects","updateFromObject","updateAttribute","bufferType","attributeProperties","updateBuffer","usage","DYNAMIC_DRAW","bufferSubData","BYTES_PER_ELEMENT","subarray","getWireframeAttribute","TypeArray","WebGLTextures","paramThreeToGL","clampToMaxSize","maxSize","drawImage","isPowerOfTwo","makePowerOfTwo","HTMLImageElement","HTMLCanvasElement","nearestPowerOfTwo","textureNeedsPowerOfTwo","filterFallback","f","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LINEAR","onTextureDispose","deallocateTexture","_infoMemory","textures","onRenderTargetDispose","renderTarget","deallocateRenderTarget","textureProperties","__image__webglTextureCube","deleteTexture","__webglInit","__webglTexture","renderTargetProperties","dispose","isWebGLRenderTargetCube","deleteFramebuffer","__webglFramebuffer","__webglDepthbuffer","deleteRenderbuffer","slot","__version","uploadTexture","TEXTURE_CUBE_MAP","pixelStorei","UNPACK_FLIP_Y_WEBGL","isCompressed","isCompressedTexture","isDataTexture","cubeImage","maxCubemapSize","isPowerOfTwoImage","glFormat","glType","setTextureParameters","mipmap","RGBFormat","getCompressedTextureFormats","compressedTexImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","generateMipmap","setTextureCubeDynamic","textureType","FloatType","HalfFloatType","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","getMaxAnisotropy","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","isDepthTexture","internalFormat","DEPTH_COMPONENT","_isWebGL2","DEPTH_COMPONENT32F","DEPTH_COMPONENT16","DepthStencilFormat","DEPTH_STENCIL","setupFrameBufferTexture","framebuffer","attachment","textureTarget","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","setupRenderBufferStorage","renderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL_ATTACHMENT","RGBA4","setupDepthTexture","isCube","webglDepthTexture","DepthFormat","setupDepthRenderbuffer","createRenderbuffer","setupRenderTarget","isTargetPowerOfTwo","createFramebuffer","COLOR_ATTACHMENT0","updateRenderTargetMipmap","webglTexture","WebGL2RenderingContext","WebGLProperties","WebGLState","ColorBuffer","currentColorMask","currentColorClear","setMask","colorMask","setLocked","setClear","equals","DepthBuffer","currentDepthMask","currentDepthFunc","currentDepthClear","setTest","depthMask","setFunc","NeverDepth","NEVER","AlwaysDepth","ALWAYS","LessDepth","LESS","LEQUAL","EqualDepth","EQUAL","GreaterEqualDepth","GEQUAL","GreaterDepth","GREATER","NotEqualDepth","NOTEQUAL","clearDepth","StencilBuffer","currentStencilMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilClear","stencilTest","STENCIL_TEST","stencilMask","stencilFunc","stencilRef","setOp","stencilFail","stencilZFail","stencilZPass","stencilOp","stencil","clearStencil","setDepthFunc","setFlipSided","setCullFace","CullFaceBack","newAttributes","enabledAttributes","enableVertexAttribArray","attributeDivisors","vertexAttribDivisorANGLE","enableAttributeAndDivisor","meshPerAttribute","disableVertexAttribArray","compressedTextureFormats","formats","getParameter","COMPRESSED_TEXTURE_FORMATS","NoBlending","currentBlending","currentPremultipledAlpha","AdditiveBlending","blendEquationSeparate","FUNC_ADD","blendFuncSeparate","ONE","blendFunc","SRC_ALPHA","SubtractiveBlending","ZERO","ONE_MINUS_SRC_COLOR","ONE_MINUS_SRC_ALPHA","MultiplyBlending","SRC_COLOR","CustomBlending","currentBlendEquation","currentBlendEquationAlpha","currentBlendSrc","currentBlendDst","currentBlendSrcAlpha","currentBlendDstAlpha","setColorWrite","colorBuffer","setStencilTest","setStencilWrite","stencilWrite","setStencilFunc","setStencilOp","currentFlipSided","frontFace","CW","CCW","cullFace","CullFaceNone","currentCullFace","BACK","CullFaceFront","FRONT","FRONT_AND_BACK","setLineWidth","currentLineWidth","lineWidth","setPolygonOffset","factor","POLYGON_OFFSET_FILL","currentPolygonOffsetFactor","currentPolygonOffsetUnits","getScissorTest","currentScissorTest","SCISSOR_TEST","webglSlot","maxTextures","currentTextureSlot","webglType","boundTexture","currentBoundTextures","emptyTextures","currentScissor","currentViewport","maxVertexAttributes","MAX_VERTEX_ATTRIBS","MAX_TEXTURE_IMAGE_UNITS","buffers","WebGLCapabilities","maxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getShaderPrecisionFormat","HIGH_FLOAT","MEDIUM_FLOAT","maxPrecision","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","MAX_TEXTURE_SIZE","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","floatFragmentTextures","WebGLExtensions","getExtension","WebGLClipping","resetGlobalState","uniform","globalState","numGlobalPlanes","numPlanes","numIntersection","projectPlanes","dstOffset","skipTransform","nPlanes","dstArray","flatSize","viewMatrix","viewNormalMatrix","getNormalMatrix","i4","plane","renderingShadows","enableLocalClipping","beginShadows","endShadows","setState","fromCache","nGlobal","lGlobal","clippingState","getTargetPixelRatio","_currentRenderTarget","_pixelRatio","glClearColor","_premultipliedAlpha","setDefaultGLState","_currentScissor","_scissor","multiplyScalar","_currentViewport","_viewport","_clearColor","_clearAlpha","_currentProgram","_currentCamera","_currentGeometryProgram","_currentMaterialId","onContextLost","onMaterialDispose","deallocateMaterial","releaseMaterialProgramReference","programCache","setupVertexAttributes","startIndex","isInstancedBufferGeometry","geometryAttributes","programAttributes","materialDefaultAttributeValues","programAttribute","geometryAttribute","SHORT","INT","BYTE","objects","stride","isInstancedInterleavedBuffer","isInstancedBufferAttribute","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","absNumericalSort","abs","reversePainterSortStable","pushRenderItem","transparentObjects","transparentObjectsLastIndex","opaqueObjects","opaqueObjectsLastIndex","renderItem","_vector3","isObjectViewable","computeBoundingSphere","_sphere","isSphereViewable","isSpriteViewable","intersectsSphere","_clipping","_this","negRad","distanceToPoint","isLight","isSprite","isLensFlare","isImmediateRenderObject","sortObjects","renderObjects","renderList","overrideMaterial","setMaterial","setProgram","renderBufferImmediate","initMaterial","materialProperties","programChange","numSupportedMorphTargets","numSupportedMorphNormals","lightsHash","ambientLightColor","ambient","directionalLights","spotLights","pointLights","hemisphereLights","directionalShadowMap","directionalShadowMatrix","spotShadowMap","spotShadowMatrix","pointShadowMap","pointShadowMatrix","progUniforms","uniformsList","seqWithValue","_usedTextureUnits","_clippingEnabled","_localClippingEnabled","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","LN2","isMeshPhongMaterial","isMeshStandardMaterial","uCamPos","cameraPosition","isMeshLambertMaterial","isMeshBasicMaterial","setOptional","markUniformsLightsNeedsUpdate","refreshUniformsFog","isMeshDepthMaterial","refreshUniformsCommon","isLineBasicMaterial","refreshUniformsLine","isLineDashedMaterial","refreshUniformsDash","isPointsMaterial","refreshUniformsPoints","refreshUniformsLambert","refreshUniformsPhong","isMeshPhysicalMaterial","refreshUniformsPhysical","refreshUniformsStandard","isMeshNormalMaterial","upload","diffuse","emissive","emissiveIntensity","uvScaleMap","offsetRepeat","flipEnvMap","isCubeTexture","dashSize","totalSize","gapSize","_height","lightMapIntensity","specular","shininess","bumpScale","normalScale","roughness","metalness","envMapIntensity","clearCoat","clearCoatRoughness","setupShadows","lightShadowsLength","setupLights","ll","intensity","directionalLength","pointLength","spotLength","hemiLength","isAmbientLight","isDirectionalLight","lightCache","sub","transformDirection","bias","isSpotLight","angle","penumbra","negate","identity","setPosition","isHemisphereLight","normalize","textureUnit","RepeatWrapping","REPEAT","MirroredRepeatWrapping","MIRRORED_REPEAT","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LinearMipMapNearestFilter","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","UnsignedShort4444Type","UNSIGNED_SHORT_4_4_4_4","UnsignedShort5551Type","UNSIGNED_SHORT_5_5_5_1","UnsignedShort565Type","UNSIGNED_SHORT_5_6_5","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","HALF_FLOAT_OES","AlphaFormat","ALPHA","LuminanceFormat","LUMINANCE","LuminanceAlphaFormat","LUMINANCE_ALPHA","SubtractEquation","FUNC_SUBTRACT","ReverseSubtractEquation","FUNC_REVERSE_SUBTRACT","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","DstAlphaFactor","DST_ALPHA","OneMinusDstAlphaFactor","ONE_MINUS_DST_ALPHA","DstColorFactor","DST_COLOR","OneMinusDstColorFactor","ONE_MINUS_DST_COLOR","SrcAlphaSaturateFactor","SRC_ALPHA_SATURATE","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","RGB_ETC1_Format","COMPRESSED_RGB_ETC1_WEBGL","MinEquation","MaxEquation","MIN_EXT","MAX_EXT","UnsignedInt248Type","UNSIGNED_INT_24_8_WEBGL","REVISION","_canvas","_context","_alpha","alpha","_depth","_stencil","_antialias","_preserveDrawingBuffer","preserveDrawingBuffer","morphInfluences","autoClear","autoClearColor","autoClearDepth","autoClearStencil","toneMappingExposure","toneMappingWhitePoint","_currentFramebuffer","_currentScissorTest","_width","_scissorTest","_infoRender","points","rangeMin","rangeMax","MaxIndex","bufferRenderer","indexedBufferRenderer","backgroundCamera","backgroundCamera2","backgroundPlaneMesh","backgroundBoxShader","backgroundBoxMesh","spritePlugin","lensFlarePlugin","getContextAttributes","forceContextLoss","loseContext","getPixelRatio","getSize","updateStyle","setViewport","setScissor","boolean","setClearAlpha","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearTarget","hasPositions","hasNormals","hasUvs","hasColors","positionArray","normalArray","nx","ny","nz","uvArray","colorArray","updateBuffers","geometryProgram","morphTargetInfluences","activeInfluences","influence","rangeFactor","dataCount","rangeStart","rangeCount","drawStart","drawEnd","drawCount","LINES","TriangleStripDrawMode","TRIANGLE_STRIP","TriangleFanDrawMode","TRIANGLE_FAN","isLineSegments","LINE_STRIP","POINTS","forceClear","isCamera","background","extractRotation","setFaceCulling","frontFaceDirection","FrontFaceDirectionCW","warned","setTexture","readRenderTargetPixels","restore","textureFormat","IMPLEMENTATION_COLOR_READ_FORMAT","IMPLEMENTATION_COLOR_READ_TYPE","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","FogExp2","Fog","LensFlare","SpriteMaterial","Sprite","LOD","levels","DataTexture","Skeleton","boneInverses","identityMatrix","sqrt","nextPowerOfTwo","ceil","boneTextureWidth","boneTextureHeight","boneMatrices","boneTexture","calculateInverses","bl","Bone","skin","SkinnedMesh","bindMode","bindMatrix","bindMatrixInverse","bone","gbone","fromArray","rotq","scl","normalizeSkinWeights","linecap","linejoin","Line","LineSegments","Points","Group","VideoTexture","video","HAVE_CURRENT_DATA","CompressedTexture","CanvasTexture","DepthTexture","WireframeGeometry","sortFunction","edge","numEdges","edges","coords","o","ol","index2","getX","getY","getZ","numTris","index1","ParametricBufferGeometry","slices","stacks","sliceCount","computeVertexNormals","ParametricGeometry","fromBufferGeometry","mergeVertices","PolyhedronBufferGeometry","subdivide","getVertexByIndex","subdivideFace","cols","pow","aj","lerp","bj","rows","pushVertex","appplyRadius","generateUVs","azimuth","inclination","uvBuffer","correctUVs","correctSeam","x0","x1","x2","centroid","uvA","uvB","uvC","divideScalar","azi","correctUV","atan2","normalizeNormals","TetrahedronBufferGeometry","TetrahedronGeometry","OctahedronBufferGeometry","OctahedronGeometry","IcosahedronBufferGeometry","IcosahedronGeometry","DodecahedronBufferGeometry","DodecahedronGeometry","PolyhedronGeometry","TubeBufferGeometry","tubularSegments","radialSegments","closed","generateBufferData","generateSegment","generateIndices","P","getPointAt","N","frames","B","binormals","computeFrenetFrames","tangents","TubeGeometry","taper","bufferGeometry","TorusKnotBufferGeometry","tube","q","calculatePositionOnCurve","cu","su","quOverP","cs","indexOffset","P1","P2","T","subVectors","addVectors","crossVectors","cx","cy","setXYZ","setXY","setX","TorusKnotGeometry","heightScale","TorusBufferGeometry","arc","TorusGeometry","ExtrudeGeometry","shapes","addShapeList","computeFaceNormals","TextGeometry","font","isFont","generateShapes","curveSegments","amount","bevelThickness","bevelSize","bevelEnabled","SphereBufferGeometry","phiStart","phiLength","thetaStart","thetaLength","thetaEnd","positions","verticesRow","px","py","pz","v1","v2","v3","v4","RingBufferGeometry","innerRadius","outerRadius","thetaSegments","phiSegments","segment","radiusStep","thetaSegmentLevel","RingGeometry","PlaneGeometry","LatheBufferGeometry","segments","clamp","inverseSegments","phi","n1","n2","LatheGeometry","ShapeGeometry","EdgesGeometry","thresholdAngle","geometry2","thresholdDot","DEG2RAD","vert1","vert2","face1","face2","dot","CylinderBufferGeometry","radiusTop","radiusBottom","openEnded","nbCap","generateTorso","slope","indexRow","theta","sinTheta","cosTheta","halfHeight","indexArray","i1","i2","i3","generateCap","centerIndexStart","centerIndexEnd","sign","CylinderGeometry","ConeGeometry","ConeBufferGeometry","CircleBufferGeometry","ii","CircleGeometry","BoxGeometry","ShadowMaterial","UniformsLib","RawShaderMaterial","MultiMaterial","STANDARD","PHYSICAL","LoadingManager","onLoad","onError","isLoading","itemsLoaded","itemsTotal","onStart","itemStart","itemEnd","itemError","XHRLoader","manager","DefaultLoadingManager","CompressedTextureLoader","_parser","BinaryTextureLoader","ImageLoader","CubeTextureLoader","TextureLoader","Light","HemisphereLight","updateMatrix","LightShadow","SpotLightShadow","power","PointLight","DirectionalLightShadow","DirectionalLight","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","valueSize","CubicInterpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","LinearInterpolant","DiscreteInterpolant","KeyframeTrackConstructor","times","interpolation","AnimationUtils","convertArray","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","validate","optimize","VectorKeyframeTrack","QuaternionLinearInterpolant","QuaternionKeyframeTrack","NumberKeyframeTrack","StringKeyframeTrack","BooleanKeyframeTrack","ColorKeyframeTrack","KeyframeTrack","AnimationClip","tracks","resetDuration","MaterialLoader","BufferGeometryLoader","Loader","onLoadStart","onLoadProgress","onLoadComplete","JSONLoader","withCredentials","ObjectLoader","texturePath","Curve","LineCurve","CurvePath","curves","autoClose","EllipseCurve","aX","aY","xRadius","yRadius","aStartAngle","aEndAngle","aClockwise","aRotation","SplineCurve","CubicBezierCurve","v0","QuadraticBezierCurve","Shape","Path","holes","currentPoint","fromPoints","ShapePath","subPaths","currentPath","Font","FontLoader","getAudioContext","AudioContext","webkitAudioContext","AudioLoader","StereoCamera","eyeSep","cameraL","cameraR","CubeCamera","cubeResolution","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","updateCubeMap","AudioListener","gain","createGain","connect","destination","Audio","listener","createBufferSource","onended","onEnded","getInput","autoplay","playbackRate","isPlaying","hasPlaybackControl","sourceType","PositionalAudio","panner","createPanner","AudioAnalyser","audio","fftSize","analyser","createAnalyser","frequencyBinCount","getOutput","PropertyMixer","binding","typeName","mixFunction","_slerp","_select","_lerp","_mixBufferRegion","cumulativeWeight","useCount","referenceCount","PropertyBinding","rootNode","parsedPath","parseTrackName","findNode","AnimationObjectGroup","var_args","nCachedObjects_","_indicesByUUID","_paths","_parsedPaths","_bindings","_bindingsIndicesByPath","total","inUse","bindingsPerObject","AnimationAction","mixer","clip","localRoot","_mixer","_clip","_localRoot","nTracks","interpolants","interpolantSettings","endingStart","ZeroCurvatureEnding","endingEnd","interpolant","createInterpolant","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","loop","LoopRepeat","_loopCount","_startTime","timeScale","_effectiveTimeScale","weight","_effectiveWeight","repetitions","paused","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","AnimationMixer","_root","_initMemoryManager","_accuIndex","Uniform","InstancedBufferGeometry","InterleavedBufferAttribute","interleavedBuffer","InterleavedBuffer","InstancedInterleavedBuffer","InstancedBufferAttribute","Raycaster","ray","threshold","PointCloud","ascSort","intersectObject","raycaster","intersects","recursive","raycast","Clock","autoStart","oldTime","elapsedTime","running","Spline","interpolate","t2","t3","intPoint","w2","w3","pa","pb","pc","pd","initFromArray","getPoint","getControlPointsArray","getLength","nSubDivisions","nSamples","oldIntPoint","oldPosition","tmpVec","chunkLengths","totalLength","distanceTo","reparametrizeByArcLength","samplingCoef","indexCurrent","indexNext","realDistance","sampling","newpoints","sl","Spherical","MorphBlendMesh","animationsMap","animationsList","numFrames","startFrame","endFrame","fps","createAnimation","setAnimationWeight","ImmediateRenderObject","renderCallback","VertexNormalsHelper","hex","nNormals","objGeometry","SpotLightHelper","cone","SkeletonHelper","getBoneList","isBone","VertexColors","PointLightHelper","sphereSize","HemisphereLightHelper","rotateX","FaceColors","lightSphere","GridHelper","divisions","color1","color2","FaceNormalsHelper","DirectionalLightHelper","CameraHelper","addLine","addPoint","pointMap","hexFrustum","hexCone","hexUp","hexTarget","hexCross","BoundingBoxHelper","box","BoxHelper","ArrowHelper","headLength","headWidth","line","lineGeometry","coneGeometry","setDirection","setLength","AxisHelper","ClosedSplineCurve3","CatmullRomCurve3","ArcCurve","aRadius","Face4","ParticleSystem","PointCloudMaterial","ParticleBasicMaterial","ParticleSystemMaterial","Vertex","EdgesHelper","WireframeHelper","Projector","projectVector","project","unprojectVector","unproject","pickingRay","CanvasRenderer","Number","EPSILON","Function","assign","output","nextKey","_listeners","listeners","hasEventListener","listenerArray","dispatchEvent","MOUSE","LEFT","MIDDLE","RIGHT","CullFaceFrontBack","FrontFaceDirectionCCW","BasicShadowMap","BlendingMode","UVMapping","TextureMapping","TextureWrapping","TextureFilter","RGBEFormat","LoopOnce","LoopPingPong","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","ZeroSlopeEnding","WrapAroundEnding","LogLuvEncoding","RAD2DEG","chars","rnd","euclideanModulo","mapLinear","a1","a2","b1","b2","smoothstep","smootherstep","random16","randInt","low","randFloat","randFloatSpread","range","degToRad","degrees","radToDeg","radians","round","isVector2","setScalar","scalar","setY","setComponent","getComponent","addScalar","addScaledVector","subScalar","divide","clampScalar","minVal","maxVal","clampLength","roundToZero","lengthSq","lengthManhattan","distanceToSquared","dx","dy","distanceToManhattan","lerpVectors","fromAttribute","rotateAround","toJSON","meta","getDataURL","toDataURL","metadata","generator","transformUv","isVector4","setZ","setW","setAxisAngleFromQuaternion","acos","setAxisAngleFromRotationMatrix","epsilon","epsilon2","te","m11","m12","m13","m21","m22","m23","m31","m32","m33","xx","yy","zz","xy","xz","yz","create","onChangeCallback","euler","isEuler","c1","c2","c3","s1","s2","s3","setFromAxisAngle","axis","halfAngle","setFromRotationMatrix","trace","setFromUnitVectors","EPS","vFrom","vTo","inverse","conjugate","multiplyQuaternions","premultiply","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","slerp","qb","cosHalfTheta","sinHalfTheta","halfTheta","ratioA","ratioB","qa","qm","slerpFlat","dst","src0","srcOffset0","src1","srcOffset1","y0","z0","w0","y1","z1","w1","sqrSin","tDir","multiplyVectors","applyEuler","applyQuaternion","applyAxisAngle","applyMatrix3","qx","qy","qz","qw","iz","iw","cross","ax","ay","az","bx","by","bz","projectOnVector","projectOnPlane","planeNormal","reflect","angleTo","dz","setFromSpherical","sinPhiRadius","setFromMatrixColumn","setFromMatrixScale","sx","sy","sz","isMatrix4","n11","n12","n13","n14","n21","n22","n23","n24","n31","n32","n33","n34","n41","n42","n43","n44","copyPosition","me","extractBasis","xAxis","yAxis","zAxis","makeBasis","scaleX","scaleY","scaleZ","makeRotationFromEuler","ae","af","be","bf","ce","cf","de","df","ac","ad","bc","bd","makeRotationFromQuaternion","y2","z2","wx","wy","wz","eye","a11","a12","a13","a14","a21","a22","a23","a24","a31","a32","a33","a34","a41","a42","a43","a44","b11","b12","b13","b14","b21","b22","b23","b24","b31","b32","b33","b34","b41","b42","b43","b44","multiplyToArray","applyToVector3Array","applyToBuffer","determinant","transpose","flattenToArrayOffset","getPosition","throwOnDegenerate","t11","t12","t13","t14","det","detInv","getMaxScaleOnAxis","scaleXSq","scaleYSq","scaleZSq","makeTranslation","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","tx","ty","makeScale","compose","invSX","invSY","invSZ","makeFrustum","makePerspective","ymax","tan","ymin","xmin","xmax","makeOrthographic","merged","uniforms_src","uniforms_dst","parameter_src","isMatrix3","alphamap_fragment","alphamap_pars_fragment","alphatest_fragment","aomap_fragment","aomap_pars_fragment","begin_vertex","beginnormal_vertex","bsdfs","bumpmap_pars_fragment","clipping_planes_fragment","clipping_planes_pars_fragment","clipping_planes_pars_vertex","clipping_planes_vertex","color_fragment","color_pars_fragment","color_pars_vertex","color_vertex","common","cube_uv_reflection_fragment","defaultnormal_vertex","displacementmap_pars_vertex","displacementmap_vertex","emissivemap_fragment","emissivemap_pars_fragment","encodings_fragment","encodings_pars_fragment","envmap_fragment","envmap_pars_fragment","envmap_pars_vertex","envmap_vertex","fog_fragment","fog_pars_fragment","lightmap_fragment","lightmap_pars_fragment","lights_lambert_vertex","lights_pars","lights_phong_fragment","lights_phong_pars_fragment","lights_physical_fragment","lights_physical_pars_fragment","lights_template","logdepthbuf_fragment","logdepthbuf_pars_fragment","logdepthbuf_pars_vertex","logdepthbuf_vertex","map_fragment","map_pars_fragment","map_particle_fragment","map_particle_pars_fragment","metalnessmap_fragment","metalnessmap_pars_fragment","morphnormal_vertex","morphtarget_pars_vertex","morphtarget_vertex","normal_flip","normal_fragment","normalmap_pars_fragment","packing","premultiplied_alpha_fragment","project_vertex","roughnessmap_fragment","roughnessmap_pars_fragment","shadowmap_pars_fragment","shadowmap_pars_vertex","shadowmap_vertex","shadowmask_pars_fragment","skinbase_vertex","skinning_pars_vertex","skinning_vertex","skinnormal_vertex","specularmap_fragment","specularmap_pars_fragment","tonemapping_fragment","tonemapping_pars_fragment","uv_pars_fragment","uv_pars_vertex","uv_vertex","uv2_pars_fragment","uv2_pars_vertex","uv2_vertex","worldpos_vertex","cube_frag","cube_vert","depth_frag","depth_vert","distanceRGBA_frag","distanceRGBA_vert","equirect_frag","equirect_vert","linedashed_frag","linedashed_vert","meshbasic_frag","meshbasic_vert","meshlambert_frag","meshlambert_vert","meshphong_frag","meshphong_vert","meshphysical_frag","meshphysical_vert","normal_frag","normal_vert","points_frag","points_vert","shadow_frag","shadow_vert","setHex","setStyle","setHSL","hue2rgb","handleAlpha","charAt","ColorKeywords","copyGammaToLinear","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","getHex","getHexString","getHSL","optionalTarget","hue","saturation","hsl","lightness","delta","getStyle","offsetHSL","addColors","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","aomap","lightmap","emissivemap","bumpmap","normalmap","displacementmap","roughnessmap","metalnessmap","basic","lambert","phong","standard","dashed","tCube","tFlip","equirect","tEquirect","distanceRGBA","physical","setFromPoints","makeEmpty","expandByPoint","setFromCenterAndSize","halfSize","isEmpty","getCenter","expandByVector","expandByScalar","containsBox","intersectsBox","clampPoint","clampedPoint","intersect","union","translate","isMaterial","newValue","extractFromCache","isRoot","srcPlanes","dstPlanes","isBox3","setFromArray","minX","minY","minZ","maxX","maxY","maxZ","traverse","closestPoint","intersectsPlane","getBoundingSphere","optionalCenter","maxRadiusSq","radiusSum","deltaLengthSq","getBoundingBox","setFromMatrix4","matrix4","transposeIntoArray","setComponents","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","orthoPoint","perpendicularMagnitude","intersectLine","denominator","intersectsLine","startSign","endSign","coplanarPoint","m1","optionalNormalMatrix","referencePoint","frustum","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","intersectsSprite","negRadius","d1","d2","at","recast","closestPointToPoint","directionDistance","distanceSqToPoint","distanceSqToSegment","segCenter","segDir","optionalPointOnRay","optionalPointOnSegment","s0","sqrDist","extDet","segExtent","a01","b0","invDet","intersectSphere","tca","radius2","thc","t0","t1","distanceToPlane","intersectPlane","distToPoint","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","edge1","edge2","backfaceCulling","DdN","DdQxE2","DdE1xQ","QdN","RotationOrders","asin","setFromVector3","reorder","newOrder","toVector3","optionalResult","channel","isObject3D","applyMatrix","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","q1","rotateY","rotateZ","translateOnAxis","translateX","translateY","translateZ","localToWorld","worldToLocal","getObjectById","getObjectByProperty","getObjectByName","child","getWorldPosition","getWorldQuaternion","getWorldRotation","getWorldScale","getWorldDirection","traverseVisible","traverseAncestors","force","isRootObject","stringify","distanceSq","closestPointToPointParameter","startP","startEnd","clampToLine","startEnd2","startEnd_startP","resultLengthSq","barycoordFromPoint","dot00","dot01","dot02","dot11","dot12","denom","invDenom","setFromPointsAndIndices","i0","triangle","area","midpoint","edgeList","projectedPoint","minDistance","isBufferAttribute","setArray","copyAt","copyArray","copyColorsArray","copyIndicesArray","copyVector2sArray","vectors","copyVector3sArray","copyVector4sArray","getW","setXYZW","computeBoundingBox","addFace","tempNormals","tempUVs","tempUVs2","cb","ab","fl","vA","vB","vC","areaWeighted","vl","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","faceNormal","dstNormalsFace","dstNormalsVertex","computeTangents","computeLineDistances","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","uvs1","colors1","colors2","vertexCopy","faceCopy","faceVertexNormals","faceVertexColors","uvCopy","mergeMesh","mesh","verticesMap","changes","precisionPoints","faceIndicesToRemove","dupIndex","sortFacesByMaterialIndex","materialIndexSort","_id","newUvs1","newUvs2","setBit","getNormalIndex","normalsHash","getColorIndex","colorsHash","getUvIndex","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","faceType","uvsCopy","computeGroups","fromGeometry","morphTargetsPosition","hasFaceVertexUv2","morphTargetsLength","morphTargetsNormal","morphNormalsLength","hasSkinIndices","hasSkinWeights","vertexUvs","morphTarget","morphNormal","getIndex","clearGroups","setDrawRange","direct","__directGeometry","lineDistance","fromDirectGeometry","pA","pB","pC","attribute1","attributeArray1","attribute2","attributeArray2","attributeSize","toNonIndexed","array2","setDrawMode","morphTargetDictionary","ml","uvIntersection","uv1","uv3","barycoord","checkIntersection","intersectionPointWorld","checkBufferGeometryIntersection","intersection","intersectionPoint","faceIndex","inverseMatrix","tempA","tempB","tempC","fvA","fvB","fvC","isFaceMaterial","faceMaterial","tl","uvs_f","isPerspectiveCamera","setFocalLength","focalLength","vExtentSlope","getFilmHeight","atan","getFocalLength","getEffectiveFOV","getFilmWidth","setViewOffset","fullWidth","fullHeight","clearViewOffset","skew","isOrthographicCamera","zoomW","zoomH","scaleW","scaleH","vecX","vecY","wantedRotation","matrixPosition","guessSizeSq","level","addLevel","getObjectForDistance","pose","offsetMatrix","sw","vec","skinWeight","linePrecision","precisionSq","vStart","vEnd","interSegment","interRay","distSq","nbVertices","testPoint","rayPointDistanceSq","localThresholdSq","intersectPoint","distanceToRay","localThreshold","ShapeUtils","contour","triangulate","snip","verts","bX","bY","cX","cY","apx","apy","bpx","bpy","cpx","cpy","cCROSSap","bCROSScp","aCROSSbp","vertIndices","nv","triangulateShape","removeDupEndPts","point_in_segment_2D_colin","inSegPt1","inSegPt2","inOtherPt","intersect_segments_2D","inSeg1Pt1","inSeg1Pt2","inSeg2Pt1","inSeg2Pt2","inExcludeAdjacentSegs","seg1dx","seg1dy","seg2dx","seg2dy","seg1seg2dx","seg1seg2dy","limit","perpSeg1","perpSeg2","factorSeg1","seg1Pt","seg2Pt","seg1min","seg1max","seg1minVal","seg1maxVal","seg2min","seg2max","seg2minVal","seg2maxVal","isPointInsideAngle","inVertex","inLegFromPt","inLegToPt","legFromPtX","legFromPtY","legToPtX","legToPtY","otherPtX","otherPtY","from2toAngle","from2otherAngle","other2toAngle","removeHoles","isCutLineInsideAngles","inShapeIdx","inHoleIdx","lastShapeIdx","shape","prevShapeIdx","nextShapeIdx","insideAngle","hole","lastHoleIdx","prevHoleIdx","nextHoleIdx","intersectsShapeEdge","inShapePt","inHolePt","sIdx","nextIdx","intersectsHoleEdge","ihIdx","chkHole","hIdx","indepHoles","holeIndex","shapeIndex","shapePt","holePt","holeIdx","cutKey","tmpShape1","tmpShape2","tmpHole1","tmpHole2","failedCuts","hl","minShapeIndex","counter","h2","forEach","allPointsMap","allpoints","shapeWithoutHoles","triangles","isClockWise","pts","b2p0","b2p1","b2p2","b3","b3p0","b3p1","b3p2","b3p3","addShape","scalePt2","pt","getBevelVec","inPt","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","buildLidFaces","layer","vlen","flen","f3","steps","bevelSegments","buildSideFaces","layeroffset","sidewalls","ahole","slen1","slen2","f4","shapesOffset","uvgen","generateTopUV","wallContour","stepIndex","stepsLength","contourIndex1","contourIndex2","generateSideWallUV","extrudePts","splineTube","binormal","position2","extrudePath","extrudeByPath","UVGenerator","WorldUVGenerator","getSpacedPoints","shapePoints","extractPoints","bs","vert","contourMovements","oneHoleMovements","holesMovements","verticesMovements","indexA","indexB","indexC","indexD","Geometries","freeze","isShadowMaterial","Materials","Cache","files","dataUriRegex","dataUriRegexResult","isBase64","decodeURIComponent","atob","ArrayBuffer","Blob","parser","request","setPath","setResponseType","setWithCredentials","loadTexture","loader","texDatas","mipmapCount","isCubemap","DataTextureLoader","texData","URL","revokeObjectURL","blob","createObjectURL","setCrossOrigin","crossOrigin","urls","isJPEG","search","arraySlice","from","isTypedArray","forceClone","isView","DataView","getKeyframeOrder","compareTime","sortedArray","nValues","srcOffset","flattenJSON","jsonKeys","valuePropertyName","evaluate","pp","validate_interval","seek","linear_scan","forward_scan","giveUpAt","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","DefaultSettings_","getSettings_","copySampleValue_","iPrev","iNext","tPrev","tNext","halfDt","o1","o0","oP","oN","wP","wN","ppp","sP","sN","offset1","offset0","weight1","weight0","KeyframeTrackPrototype","InterpolantFactoryMethodDiscrete","getValueSize","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","ValueTypeName","getInterpolation","timeOffset","endTime","nKeys","valid","prevTime","currTime","smoothInterpolation","writeIndex","keep","timeNext","offsetP","offsetN","readOffset","writeOffset","trackType","_getTrackTypeForValueTypeName","track","jsonTracks","frameTime","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","findByName","objectOrClipArray","clipArray","animations","CreateClipsFromMorphTargetSequences","animationToMorphTargets","animationMorphTargets","clips","parseAnimation","addNonemptyTrack","trackName","animationKeys","propertyName","destTracks","clipName","hierarchyTracks","hierarchy","morphTargetNames","morphTargetName","animationKey","boneName","setTextures","getTexture","TYPED_ARRAYS","typedArray","drawcalls","offsets","extractUrlBase","initMaterials","createMaterial","textureLoader","materialLoader","fullPath","Handlers","mapDiffuseRepeat","mapDiffuseOffset","mapDiffuseWrap","mapDiffuseAnisotropy","mapEmissiveRepeat","mapEmissiveOffset","mapEmissiveWrap","mapEmissiveAnisotropy","mapLightRepeat","mapLightOffset","mapLightWrap","mapLightAnisotropy","mapAORepeat","mapAOOffset","mapAOWrap","mapAOAnisotropy","mapBumpRepeat","mapBumpOffset","mapBumpWrap","mapBumpAnisotropy","mapNormalRepeat","mapNormalOffset","mapNormalWrap","mapNormalAnisotropy","mapSpecularRepeat","mapSpecularOffset","mapSpecularWrap","mapSpecularAnisotropy","mapMetalnessRepeat","mapMetalnessOffset","mapMetalnessWrap","mapMetalnessAnisotropy","mapRoughnessRepeat","mapRoughnessOffset","mapRoughnessWrap","mapRoughnessAnisotropy","mapAlphaRepeat","mapAlphaOffset","mapAlphaWrap","mapAlphaAnisotropy","regex","setTexturePath","parseModel","isBitSet","fi","zLength","colorIndex","normalIndex","uvIndex","isQuad","faceA","faceB","uvLayer","nUvLayers","parseSkin","influencesPerVertex","parseMorphing","dstVertices","srcVertices","morphColors","parseAnimations","outputAnimations","morphAnimationClips","substring","lastIndexOf","parseGeometries","parseImages","parseTextures","parseMaterials","parseObject","geometryLoader","bufferGeometryLoader","loadImage","parseConstant","getGeometry","getMaterial","isInteger","getUtoTmapping","getPoints","lengths","getLengths","cacheArcLengths","sum","updateArcLengths","targetArcLength","arcLengths","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","pt1","pt2","getTangentAt","mat","MAX_VALUE","tz","getPointFunc","isLineCurve","tangent","curve","closePath","startPoint","endPoint","curveLengths","getCurveLengths","lens","cacheLengths","sums","resolution","isEllipseCurve","isSplineCurve","createPointsGeometry","createGeometry","createSpacedPointsGeometry","twoPi","deltaAngle","samePoints","CurveUtils","tangentQuadraticBezier","tangentCubicBezier","tangentSpline","h00","h10","h01","h11","point0","point1","point2","point3","PathPrototype","moveTo","lineTo","quadraticCurveTo","aCPx","aCPy","bezierCurveTo","aCP1x","aCP1y","aCP2x","aCP2y","splineThru","npts","absarc","absellipse","ellipse","firstPoint","lastPoint","getPointsHoles","holesPts","extractAllPoints","toShapes","isCCW","noHoles","toShapesNoHoles","inSubpaths","tmpPath","tmpShape","isPointInsidePolygon","inPolygon","polyLen","inside","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","solid","holesFirst","tmpPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","ambiguous","toChange","sLen","sho","ho","hole_unassigned","s2Idx","froms","tos","tmpHoles","createPaths","paths","createPath","glyph","glyphs","cpx0","cpy0","cpx1","cpy1","cpx2","cpy2","laste","outline","_cachedOutline","action","ha","decodeAudioData","audioBuffer","instance","eyeRight","eyeLeft","eyeSepOnProjection","removeFilter","disconnect","getFilter","setFilter","getMasterVolume","setMasterVolume","orientation","setOrientation","setNodeSource","audioNode","setBuffer","play","pause","getFilters","setPlaybackRate","getPlaybackRate","getLoop","setLoop","getVolume","setVolume","getRefDistance","refDistance","setRefDistance","getRolloffFactor","rolloffFactor","setRolloffFactor","getDistanceModel","distanceModel","setDistanceModel","getMaxDistance","maxDistance","setMaxDistance","getFrequencyData","getByteFrequencyData","getAverageFrequency","accumulate","accuIndex","currentWeight","mix","originalValueOffset","saveOriginalState","getValue","restoreOriginalState","targetArray","sourceArray","targetObject","objectName","propertyIndex","_getValue_unavailable","_setValue_unavailable","objectIndex","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","ArrayElement","resolvedProperty","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","_getValue_unbound","_setValue_unbound","Composite","targetGroup","optionalParsedPath","_targetGroup","subscribe_","firstValidIndex","bindings","isAnimationObjectGroup","re","searchSkeleton","searchNodeSubtree","childNode","subTreeNode","nObjects","nCachedObjects","indicesByUUID","parsedPaths","nBindings","knownObject","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","lastCachedIndex","firstActiveObject","firstActive","uncache","lastObject","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath","_activateAction","_deactivateAction","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setEffectiveWeight","getEffectiveWeight","_scheduleFading","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","halt","startTimeScale","endTimeScale","_lendControlInterpolant","timeScaleInterpolant","getMixer","getClip","getRoot","_update","deltaTime","timeDirection","timeRunning","_updateTimeScale","clipTime","_updateTime","_updateWeight","propertyMixers","interpolantValue","loopCount","_setEndings","handle_stop","pingPong","loopDelta","pending","atStart","atEnd","weightNow","weightThen","clipAction","optionalRoot","rootUuid","clipObject","clipUuid","actionsForClip","_actionsByClip","prototypeAction","existingAction","actionByRoot","knownActions","newAction","_bindAction","_addInactiveAction","stopAllAction","actions","_actions","nActions","_nActiveActions","_nActiveBindings","uncacheClip","actionsByClip","actionsToRemove","cacheIndex","lastInactiveAction","_removeInactiveBindingsForAction","uncacheRoot","_removeInactiveAction","bindingsByRoot","_bindingsByRootAndName","bindingByName","_removeInactiveBinding","uncacheAction","bindingsByName","_addInactiveBinding","_lendBinding","_lendAction","_takeBackBinding","_takeBackAction","_controlInterpolants","_nActiveControlInterpolants","controlInterpolants","knownActionsForClip","lastKnownAction","byClipCacheIndex","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","propBinding","lastInactiveBinding","remove_empty_map","firstInactiveBinding","lastActiveBinding","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","isInterleavedBuffer","setFromCamera","intersectObjects","performance","getElapsedTime","getDelta","newTime","other","makeSafe","vec3","lastFrame","currentFrame","directionBackwards","mirroredLoop","autoCreateAnimations","firstAnimation","frameRanges","morph","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","stopAnimation","keyframe","objPos","objNorm","vector2","coneLength","coneWidth","boneList","matrixWorldInv","boneMatrix","setColors","lightPlane","targetLine","setPoint","setColor","CubicPoly","c0","initNonuniformCatmullRom","x3","dt0","dt1","dt2","initCatmullRom","tension","calc","SplineCurve3","CubicBezierCurve3","QuadraticBezierCurve3","LineCurve3","SceneUtils","createMultiMaterialObject","attach","LineStrip","LinePieces","isIntersectionBox","isIntersectionSphere","multiplyVector3","multiplyVector3Array","extractPosition","multiplyVector4","rotateAxis","crossVector","rotateByAxis","isIntersectionLine","isIntersectionPlane","extrude","makeGeometry","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","getColumnFromMatrix","getChildByName","renderDepth","eulerOrder","useQuaternion","setLens","onlyShadow","shadowCameraFov","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraNear","shadowCameraFar","shadowCameraVisible","shadowDarkness","shadowMapWidth","shadowMapHeight","addIndex","addDrawCall","clearDrawCalls","computeOffsets","wrapAround","wrapRGB","metal","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","supportsInstancedArrays","enableScissorTest","addPrePlugin","addPostPlugin","updateShadowMap","shadowMapCullFace","audioLoader","GeometryUtils","geometry1","ImageUtils","loadTextureCube","loadCompressedTexture","loadCompressedTextureCube","CubeGeometry","MeshFaceMaterial","Particle","addPanel","panel","dom","showPanel","beginTime","fpsPanel","Panel","msPanel","memPanel","begin","usedJSHeapSize","jsHeapSizeLimit","fg","bg","PR","WIDTH","HEIGHT","TEXT_X","TEXT_Y","GRAPH_X","GRAPH_Y","GRAPH_WIDTH","GRAPH_HEIGHT","textBaseline","fillText","globalAlpha","maxValue","utils","controllers","link","rel","inject","injected","ARR_EACH","ARR_SLICE","BREAK","isUndefined","defaults","toCall","itr","fnc","isNull","isObject","isNumber","isString","isBoolean","Controller","initialValue","__onChange","__onFinishChange","onFinishChange","updateDisplay","isModified","cssValueToPixels","CSS_VALUE_PIXELS","EVENT_MAP","HTMLEvents","MouseEvents","KeyboardEvents","EVENT_MAP_INV","makeSelectable","selectable","onselectstart","MozUserSelect","KhtmlUserSelect","unselectable","makeFullscreen","horizontal","vertical","fakeEvent","eventType","aux","createEvent","initMouseEvent","clickCount","initKeyboardEvent","initKeyEvent","initEvent","detachEvent","getWidth","getHeight","getOffset","offsetLeft","offsetTop","isActive","OptionController","superclass","__select","element","desiredValue","toReturn","NumberController","numDecimals","__min","__max","__step","__impliedStep","LN10","__precision","NumberControllerBox","roundToDecimal","decimals","tenTo","attempted","__input","onBlur","onMouseDown","onMouseDrag","onMouseUp","prev_y","__truncationSuspended","NumberControllerSlider","styleSheet","o2","__background","__foreground","useDefaultStyles","pct","FunctionController","__button","BooleanController","__prev","__checkbox","interpret","INTERPRETATIONS","family","litmus","conversions","conversion","conversionName","read","THREE_CHAR_HEX","space","write","SIX_CHAR_HEX","CSS_RGB","CSS_RGBA","HEX","RGB_ARRAY","RGBA_ARRAY","RGBA_OBJ","RGB_OBJ","HSVA_OBJ","HSV_OBJ","saveDialogueContents","controllerFactory","ColorController","CenteredDiv","controller","factoryArgs","__li","recallSavedValue","li","addRow","CLASS_CONTROLLER_ROW","augmentController","__controllers","liBefore","__ul","__gui","nextElementSibling","listen","borderLeftColor","__color","__preset_select","markPresetModified","matched_index","__rememberedObjects","controller_map","__rememberedObjectIndecesToControllers","remembered","preset","preset_map","DEFAULT_DEFAULT_PRESET_NAME","getLocalStorageHash","addSaveMenu","showHideExplain","explain","useLocalStorage","__save_row","gears","button2","button3","addPresetOption","SUPPORTS_LOCAL_STORAGE","saveLocally","localStorageCheckBox","localStorage","getItem","newConstructorTextArea","SAVE_DIALOGUE","getSaveObject","save","presetName","prompt","saveAs","revert","addResizeHandle","dragStart","pmouseX","__closeButton","CLASS_DRAG","drag","dragStop","__resize_handle","cursor","setWidth","autoPlace","getCurrentPreset","useInitialValues","saved_values","setSelected","setPresetSelectIndex","updateDisplays","controllerArray","auto_place_container","CSS_NAMESPACE","HIDE_KEY_CODE","CLOSE_BUTTON_HEIGHT","auto_place_virgin","hideable_guis","saveToLocalStorage","setItem","resetWidth","__folders","__listening","DEFAULT_WIDTH","resizable","hideable","scrollable","use_local_storage","title_row_name","CLASS_CLOSED","TEXT_OPEN","TEXT_CLOSED","CLASS_MAIN","saved_gui","CLASS_CLOSE_BUTTON","title_row","on_click_title","CLASS_AUTO_PLACE_CONTAINER","CLASS_AUTO_PLACE","toggleHide","CLASS_TOO_TALL","addColor","addFolder","new_gui_params","folders","close","remember","folder","StringController","linearGradient","vendors","vendor","hueGradient","fieldDown","setSV","unbindSV","__state","toOriginal","unbindH","setH","__saturation_field","__hue_field","__temp","__selector","__field_knob","__field_knob_border","__hue_knob","__input_textShadow","value_field","backgroundColor","boxShadow","borderRadius","borderRight","textAlign","textShadow","mismatch","COMPONENTS","component","flip","_flip","marginTop","math","defineRGBComponent","componentHexIndex","recalculateRGB","defineHSVComponent","recalculateHSV","component_from_hex","hsv_to_rgb","rgb_to_hsv","rgb_to_hex","tmpComponent","hi","NaN","hex_with_component","componentIndex","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","backgroundElement","WebkitTransition","webkitTransform","layout","planeGeometry","planeMaterial","setEvents"],"mappings":"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AAAm7F,kBACAn7F,EAAAo7F,wBACAp7F,EAAA+3F,yBACA/3F,EAAAm3F,kBACAn3F,EAAAy7F,cACAz7F,EAAAm4F,eACAn4F,EAAAw9F,cACAx9F,EAAA63F,aACA73F,EAAAq7F,UACAr7F,EAAAi1I,SACAj1I,EAAA49F,eACA59F,EAAA04F,mBACA14F,EAAAiE,aACAjE,EAAA44F,cACA54F,EAAAu4F,mBACAv4F,EAAA64F,0BACA74F,EAAA84F,oBACA94F,EAAA8D,gBACA9D,EAAAy4F,eACAz4F,EAAAs4F,SACAt4F,EAAA69F,gBACA79F,EAAAszD,qBACAtzD,EAAA0zD,sBACA1zD,EAAAi+F,cACAj+F,EAAAc,UACAd,EAAA0+F,iBACA1+F,EAAA0/F,mBACA1/F,EAAAy9F,mBACAz9F,EAAA6/F,iBACA7/F,EAAA++F,SACA/+F,EAAAw6F,uBACAx6F,EAAA46F,uBACA56F,EAAA06F,2BACA16F,EAAA26F,uBACA36F,EAAA86F,sBACA96F,EAAA66F,wBACA76F,EAAAogG,iBACApgG,EAAA+gG,mBACA/gG,EAAA+6F,iBACA/6F,EAAAg6F,kBACAh6F,EAAAohG,wBACAphG,EAAAkkG,kBACAlkG,EAAAg7F,iBACAh7F,EAAAskG,WACAtkG,EAAAukG,2BACAvkG,EAAAswD,kBACAtwD,EAAAivD,mBACAjvD,EAAAgvD,YACAhvD,EAAAwkG,8BACAxkG,EAAA2kG,8BACA3kG,EAAA0kG,qBACA1kG,EAAA4kG,4BACA5kG,EAAA8uD,0BACA9uD,EAAA4uD,oBACA5uD,EAAA2uD,oBACA3uD,EAAAyuD,mBACAzuD,EAAAwuD,kBACAxuD,EAAAuuD;AACAvuD,EAAAquD,kBACAruD,EAAAmuD,yBACAnuD,EAAAiuD,kBACAjuD,EAAA+tD,iBACA/tD,EAAA0tD,mBACA1tD,EAAA2sD,SACA3sD,EAAA4rD,mBACA5rD,EAAAsrD,YACAtrD,EAAA6kG,aACA7kG,EAAAqrD,UACArrD,EAAAivC,kBACAjvC,EAAAulG,SACAvlG,EAAAy6F,+BACAz6F,EAAA25F,qBACA35F,EAAA45F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","file":"index.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar cats = __webpack_require__(1);\n\t\n\t// console.log(cats);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function($) {window.THREE = __webpack_require__(3);\n\tvar Stats = __webpack_require__(4);\n\tvar dat = __webpack_require__(5);\n\t\n\t__webpack_require__(8);\n\t// require('./libs/ParametricGeometries.js');\n\t// require('./libs/ConvexGeometry.js');\n\t\n\tvar Scene = __webpack_require__(9);\n\tvar Camera = __webpack_require__(10);\n\t\n\tvar Cube = __webpack_require__(11);\n\t\n\t'use strict';\n\t\n\t(function () {\n\t\n\t  // globalオブジェクト\n\t  if (window.gb === undefined) window.gb = {};\n\t  window.gb.in = {}; //instance\n\t\n\t  var sample = window.sample || {};\n\t  window.sample = sample;\n\t\n\t  //初期化実行\n\t  $(function () {\n\t    new sample.MainDisplay();\n\t  });\n\t})();\n\t\n\t//Planeをインスタンス化\n\tvar PlaneObject = new Plane();\n\t\n\t(function () {\n\t  var sample = window.sample || {};\n\t  window.sample = sample;\n\t\n\t  /**\n\t   * メインクラス\n\t   */\n\t  sample.MainDisplay = function () {\n\t    //イニシャライズ\n\t    p.init();\n\t  };\n\t\n\t  var p, s;\n\t\n\t  s = sample.MainDisplay;\n\t  p = s.prototype;\n\t\n\t  var renderScene;\n\t\n\t  /**\n\t   * イニシャライズ\n\t   */\n\t  p.init = function () {\n\t    var self = this;\n\t\n\t    var stats = initStats();\n\t\n\t    this.$window = $(window);\n\t    this.$MainDisplay = $('#WebGL-output');\n\t\n\t    this.timer += 0.01;\n\t\n\t    //WebGL renderer\n\t    gb.in.renderer = this.renderer = new THREE.WebGLRenderer({ antialias: true });\n\t    if (!this.renderer) {\n\t      alert('Three.jsの初期化に失敗しました。');\n\t    }\n\t    this.renderer.setClearColor(new THREE.Color(0xEEEEEE));\n\t    this.renderer.setSize(window.innerWidth, window.innerHeight);\n\t    this.renderer.shadowMap.enabled = true;\n\t\n\t    // 高解像度対応\n\t    var pixelRatio = Math.min(window.devicePixelRatio || 1, 2);\n\t    this.renderer.setPixelRatio(pixelRatio);\n\t\n\t    //scene\n\t    gb.in.scene = new Scene();\n\t    this.scene = gb.in.scene.scene;\n\t\n\t    //camera\n\t    gb.in.camera = new Camera();\n\t    this.camera = gb.in.camera.camera;\n\t\n\t    // add subtle ambient lighting\n\t    var ambientLight = new THREE.AmbientLight(0x090909);\n\t    this.scene.add(ambientLight);\n\t\n\t    // add spotlight for the shadows\n\t    var spotLight = new THREE.SpotLight(0xffffff);\n\t    spotLight.position.set(-25, 25, 32);\n\t    spotLight.castShadow = true;\n\t    this.scene.add(spotLight);\n\t\n\t    // window resize\n\t    this.$window.on('resize', function (e) {\n\t      self.onResize();\n\t    });\n\t\n\t    // resizeイベントを発火してキャンバスサイズをリサイズ\n\t    this.$window.trigger('resize');\n\t\n\t    //Planeをシーンに追加\n\t    this.scene.add(PlaneObject.init());\n\t\n\t    //Cubeをインスタンス化\n\t    gb.in.CubeObject = new Cube();\n\t    this.CubeObject = gb.in.CubeObject.cube;\n\t    // window.console.log(this.CubeObject);\n\t\n\t    // //Cubeをシーンに追加\n\t    this.scene.add(this.CubeObject);\n\t\n\t    //sphereGeometry\n\t    var sphereGeometry = new THREE.SphereGeometry(4, 20, 20);\n\t\n\t    //sphereMaterial\n\t    var sphereMaterial = new THREE.MeshLambertMaterial({\n\t      color: 0x7777ff, wireframe: false\n\t    });\n\t\n\t    //sphere\n\t    var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);\n\t    sphere.castShadow = true;\n\t    //sphereを回転\n\t    sphere.position.x = 20;\n\t    sphere.position.y = 4;\n\t    sphere.position.z = 2;\n\t    // this.scene.add(sphere);\n\t\n\t\n\t    document.getElementById(\"WebGL-output\").appendChild(this.renderer.domElement);\n\t\n\t    // window.console.log(this.CubeObject.setup());\n\t\n\t    renderScene = function () {\n\t      stats.update();\n\t\n\t      // rotate the cube around its axes\n\t      this.CubeObject.rotation.x += 0.02;\n\t      this.CubeObject.rotation.y += 0.02;\n\t      this.CubeObject.rotation.z += 0.02;\n\t\n\t      step += 0.01;\n\t      this.camera.position.z += (this.CubeObject.position.z + 100 - this.camera.position.z) * 0.1;\n\t      this.camera.position.y += (this.CubeObject.position.y + 50 - this.camera.position.y) * 0.1;\n\t      // this.camera.position.x = Math.cos(step) * 200;\n\t      // this.camera.position.y = Math.sin(step*2) * 90;\n\t      // this.camera.position.z = Math.sin(step) * 90 + 200;\n\t\n\t      this.lookat_x = Math.sin(step * 0.4) * 50;\n\t      this.lookat_y = Math.cos(step * 1.4) * 50;\n\t      this.camera.lookAt(new THREE.Vector3(this.lookat_x, this.lookat_y, 0));\n\t\n\t      // bounce the sphere up and down\n\t      // step += 0.04;\n\t      // sphere.position.x = 20 + ( 10 * (Math.cos(step)));\n\t      // sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step)));\n\t\n\t      // render using requestAnimationFrame\n\t      requestAnimationFrame(renderScene);\n\t      this.renderer.render(this.scene, this.camera);\n\t      // this.updateAnimation();\n\t    }.bind(this);\n\t\n\t    // call the render function\n\t    var step = 0;\n\t    renderScene();\n\t\n\t    /**\n\t     * dat.gui\n\t     * dat.guiのコントローラーを定義\n\t     */\n\t    var controls = new function () {\n\t      this.rotationSpeed = 0.001;\n\t      this.bouncingSpeed = 0.001;\n\t    }();\n\t\n\t    var gui = new dat.GUI();\n\t    gui.add(controls, 'rotationSpeed', 0, 0.1);\n\t    gui.add(controls, 'bouncingSpeed', 0, 0.1);\n\t\n\t    // var render =  function() {\n\t    //   stats.update();\n\t    //\n\t    //\n\t    //\n\t    //\n\t    //   // window.console.log('CubeX',CubeObject.init().rotation.x);\n\t    //   // rotate the cube around its axes\n\t    //   // CubeObject.init().rotation.x += controls.rotationSpeed;\n\t    //   // CubeObject.init().rotation.y += controls.rotationSpeed;\n\t    //   // CubeObject.init().rotation.z += controls.rotationSpeed;\n\t    //\n\t    //   // bounce the sphere up and down\n\t    //   // step += controls.bouncingSpeed;\n\t    //   // sphere.position.x = 20 + ( 10 * (Math.cos(step)));\n\t    //   // sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step)));\n\t    //\n\t    //   requestAnimationFrame(render);\n\t    //   this.renderer.render(this.scene, this.camera);\n\t    // }.bind(this);\n\t    // render();\n\t  };\n\t\n\t  //Stats表示設定\n\t  function initStats() {\n\t\n\t    var stats = gb.in.stats = new Stats();\n\t\n\t    stats.setMode(0); // 0: fps, 1: ms\n\t\n\t    // Align top-left\n\t    stats.domElement.style.position = 'absolute';\n\t    stats.domElement.style.left = '0px';\n\t    stats.domElement.style.top = '0px';\n\t\n\t    document.getElementById(\"Stats-output\").appendChild(stats.domElement);\n\t\n\t    return stats;\n\t  }\n\t\n\t  /**\n\t   * アニメーション開始\n\t   */\n\t  // p.start = function() {\n\t  //   var self = this;\n\t  //\n\t  //   var enterFrameHandler = function() {\n\t  //     requestAnimationFrame(enterFrameHandler);\n\t  //     self.update();\n\t  //   };\n\t  //\n\t  //   enterFrameHandler();\n\t  // }\n\t\n\t  /**\n\t   * アニメーションループ内で実行される\n\t   */\n\t  p.updateAnimation = function () {\n\t    requestAnimationFrame(renderScene);\n\t    this.renderer.render(this.scene, this.camera);\n\t  };\n\t\n\t  /**\n\t   * リサイズ処理\n\t   */\n\t  p.onResize = function () {\n\t\n\t    this.width = this.$window.width();\n\t    this.height = this.$window.height();\n\t\n\t    this.camera.aspect = this.width / this.height;\n\t    this.camera.updateProjectionMatrix();\n\t\n\t    this.renderer.setSize(this.width, this.height);\n\t  };\n\t\n\t  // p.createDatGUIBox = function () {\n\t\n\t  // };\n\t})();\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * jQuery JavaScript Library v3.1.1\n\t * https://jquery.com/\n\t *\n\t * Includes Sizzle.js\n\t * https://sizzlejs.com/\n\t *\n\t * Copyright jQuery Foundation and other contributors\n\t * Released under the MIT license\n\t * https://jquery.org/license\n\t *\n\t * Date: 2016-09-22T22:30Z\n\t */\n\t( function( global, factory ) {\n\t\n\t\t\"use strict\";\n\t\n\t\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\n\t\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t\t// is present, execute the factory and get jQuery.\n\t\t\t// For environments that do not have a `window` with a `document`\n\t\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t\t// This accentuates the need for the creation of a real `window`.\n\t\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t\t// See ticket #14549 for more info.\n\t\t\tmodule.exports = global.document ?\n\t\t\t\tfactory( global, true ) :\n\t\t\t\tfunction( w ) {\n\t\t\t\t\tif ( !w.document ) {\n\t\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t\t}\n\t\t\t\t\treturn factory( w );\n\t\t\t\t};\n\t\t} else {\n\t\t\tfactory( global );\n\t\t}\n\t\n\t// Pass this if window is not defined yet\n\t} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\t\n\t// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n\t// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n\t// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n\t// enough that all such attempts are guarded in a try block.\n\t\"use strict\";\n\t\n\tvar arr = [];\n\t\n\tvar document = window.document;\n\t\n\tvar getProto = Object.getPrototypeOf;\n\t\n\tvar slice = arr.slice;\n\t\n\tvar concat = arr.concat;\n\t\n\tvar push = arr.push;\n\t\n\tvar indexOf = arr.indexOf;\n\t\n\tvar class2type = {};\n\t\n\tvar toString = class2type.toString;\n\t\n\tvar hasOwn = class2type.hasOwnProperty;\n\t\n\tvar fnToString = hasOwn.toString;\n\t\n\tvar ObjectFunctionString = fnToString.call( Object );\n\t\n\tvar support = {};\n\t\n\t\n\t\n\t\tfunction DOMEval( code, doc ) {\n\t\t\tdoc = doc || document;\n\t\n\t\t\tvar script = doc.createElement( \"script\" );\n\t\n\t\t\tscript.text = code;\n\t\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t\t}\n\t/* global Symbol */\n\t// Defining this global in .eslintrc.json would create a danger of using the global\n\t// unguarded in another place, it seems safer to define global only for this module\n\t\n\t\n\t\n\tvar\n\t\tversion = \"3.1.1\",\n\t\n\t\t// Define a local copy of jQuery\n\t\tjQuery = function( selector, context ) {\n\t\n\t\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\t\treturn new jQuery.fn.init( selector, context );\n\t\t},\n\t\n\t\t// Support: Android <=4.0 only\n\t\t// Make sure we trim BOM and NBSP\n\t\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\t\n\t\t// Matches dashed string for camelizing\n\t\trmsPrefix = /^-ms-/,\n\t\trdashAlpha = /-([a-z])/g,\n\t\n\t\t// Used by jQuery.camelCase as callback to replace()\n\t\tfcamelCase = function( all, letter ) {\n\t\t\treturn letter.toUpperCase();\n\t\t};\n\t\n\tjQuery.fn = jQuery.prototype = {\n\t\n\t\t// The current version of jQuery being used\n\t\tjquery: version,\n\t\n\t\tconstructor: jQuery,\n\t\n\t\t// The default length of a jQuery object is 0\n\t\tlength: 0,\n\t\n\t\ttoArray: function() {\n\t\t\treturn slice.call( this );\n\t\t},\n\t\n\t\t// Get the Nth element in the matched element set OR\n\t\t// Get the whole matched element set as a clean array\n\t\tget: function( num ) {\n\t\n\t\t\t// Return all the elements in a clean array\n\t\t\tif ( num == null ) {\n\t\t\t\treturn slice.call( this );\n\t\t\t}\n\t\n\t\t\t// Return just the one element from the set\n\t\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t\t},\n\t\n\t\t// Take an array of elements and push it onto the stack\n\t\t// (returning the new matched element set)\n\t\tpushStack: function( elems ) {\n\t\n\t\t\t// Build a new jQuery matched element set\n\t\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\t\n\t\t\t// Add the old object onto the stack (as a reference)\n\t\t\tret.prevObject = this;\n\t\n\t\t\t// Return the newly-formed element set\n\t\t\treturn ret;\n\t\t},\n\t\n\t\t// Execute a callback for every element in the matched set.\n\t\teach: function( callback ) {\n\t\t\treturn jQuery.each( this, callback );\n\t\t},\n\t\n\t\tmap: function( callback ) {\n\t\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\t\treturn callback.call( elem, i, elem );\n\t\t\t} ) );\n\t\t},\n\t\n\t\tslice: function() {\n\t\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t\t},\n\t\n\t\tfirst: function() {\n\t\t\treturn this.eq( 0 );\n\t\t},\n\t\n\t\tlast: function() {\n\t\t\treturn this.eq( -1 );\n\t\t},\n\t\n\t\teq: function( i ) {\n\t\t\tvar len = this.length,\n\t\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t\t},\n\t\n\t\tend: function() {\n\t\t\treturn this.prevObject || this.constructor();\n\t\t},\n\t\n\t\t// For internal use only.\n\t\t// Behaves like an Array's method, not like a jQuery method.\n\t\tpush: push,\n\t\tsort: arr.sort,\n\t\tsplice: arr.splice\n\t};\n\t\n\tjQuery.extend = jQuery.fn.extend = function() {\n\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\ttarget = arguments[ 0 ] || {},\n\t\t\ti = 1,\n\t\t\tlength = arguments.length,\n\t\t\tdeep = false;\n\t\n\t\t// Handle a deep copy situation\n\t\tif ( typeof target === \"boolean\" ) {\n\t\t\tdeep = target;\n\t\n\t\t\t// Skip the boolean and the target\n\t\t\ttarget = arguments[ i ] || {};\n\t\t\ti++;\n\t\t}\n\t\n\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\n\t\t\ttarget = {};\n\t\t}\n\t\n\t\t// Extend jQuery itself if only one argument is passed\n\t\tif ( i === length ) {\n\t\t\ttarget = this;\n\t\t\ti--;\n\t\t}\n\t\n\t\tfor ( ; i < length; i++ ) {\n\t\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif ( ( options = arguments[ i ] ) != null ) {\n\t\n\t\t\t\t// Extend the base object\n\t\t\t\tfor ( name in options ) {\n\t\t\t\t\tsrc = target[ name ];\n\t\t\t\t\tcopy = options[ name ];\n\t\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif ( target === copy ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t\t( copyIsArray = jQuery.isArray( copy ) ) ) ) {\n\t\n\t\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && jQuery.isArray( src ) ? src : [];\n\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\t\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\t\n\tjQuery.extend( {\n\t\n\t\t// Unique for each copy of jQuery on the page\n\t\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\t\n\t\t// Assume jQuery is ready without the ready module\n\t\tisReady: true,\n\t\n\t\terror: function( msg ) {\n\t\t\tthrow new Error( msg );\n\t\t},\n\t\n\t\tnoop: function() {},\n\t\n\t\tisFunction: function( obj ) {\n\t\t\treturn jQuery.type( obj ) === \"function\";\n\t\t},\n\t\n\t\tisArray: Array.isArray,\n\t\n\t\tisWindow: function( obj ) {\n\t\t\treturn obj != null && obj === obj.window;\n\t\t},\n\t\n\t\tisNumeric: function( obj ) {\n\t\n\t\t\t// As of jQuery 3.0, isNumeric is limited to\n\t\t\t// strings and numbers (primitives or objects)\n\t\t\t// that can be coerced to finite numbers (gh-2662)\n\t\t\tvar type = jQuery.type( obj );\n\t\t\treturn ( type === \"number\" || type === \"string\" ) &&\n\t\n\t\t\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t\t\t// subtraction forces infinities to NaN\n\t\t\t\t!isNaN( obj - parseFloat( obj ) );\n\t\t},\n\t\n\t\tisPlainObject: function( obj ) {\n\t\t\tvar proto, Ctor;\n\t\n\t\t\t// Detect obvious negatives\n\t\t\t// Use toString instead of jQuery.type to catch host objects\n\t\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tproto = getProto( obj );\n\t\n\t\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\t\tif ( !proto ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t\t},\n\t\n\t\tisEmptyObject: function( obj ) {\n\t\n\t\t\t/* eslint-disable no-unused-vars */\n\t\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\t\tvar name;\n\t\n\t\t\tfor ( name in obj ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\n\t\ttype: function( obj ) {\n\t\t\tif ( obj == null ) {\n\t\t\t\treturn obj + \"\";\n\t\t\t}\n\t\n\t\t\t// Support: Android <=2.3 only (functionish RegExp)\n\t\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\t\t\ttypeof obj;\n\t\t},\n\t\n\t\t// Evaluates a script in a global context\n\t\tglobalEval: function( code ) {\n\t\t\tDOMEval( code );\n\t\t},\n\t\n\t\t// Convert dashed to camelCase; used by the css and data modules\n\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t// Microsoft forgot to hump their vendor prefix (#9572)\n\t\tcamelCase: function( string ) {\n\t\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t\t},\n\t\n\t\tnodeName: function( elem, name ) {\n\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t\t},\n\t\n\t\teach: function( obj, callback ) {\n\t\t\tvar length, i = 0;\n\t\n\t\t\tif ( isArrayLike( obj ) ) {\n\t\t\t\tlength = obj.length;\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn obj;\n\t\t},\n\t\n\t\t// Support: Android <=4.0 only\n\t\ttrim: function( text ) {\n\t\t\treturn text == null ?\n\t\t\t\t\"\" :\n\t\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t\t},\n\t\n\t\t// results is for internal usage only\n\t\tmakeArray: function( arr, results ) {\n\t\t\tvar ret = results || [];\n\t\n\t\t\tif ( arr != null ) {\n\t\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t\t[ arr ] : arr\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tpush.call( ret, arr );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn ret;\n\t\t},\n\t\n\t\tinArray: function( elem, arr, i ) {\n\t\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t\t},\n\t\n\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\tmerge: function( first, second ) {\n\t\t\tvar len = +second.length,\n\t\t\t\tj = 0,\n\t\t\t\ti = first.length;\n\t\n\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\tfirst[ i++ ] = second[ j ];\n\t\t\t}\n\t\n\t\t\tfirst.length = i;\n\t\n\t\t\treturn first;\n\t\t},\n\t\n\t\tgrep: function( elems, callback, invert ) {\n\t\t\tvar callbackInverse,\n\t\t\t\tmatches = [],\n\t\t\t\ti = 0,\n\t\t\t\tlength = elems.length,\n\t\t\t\tcallbackExpect = !invert;\n\t\n\t\t\t// Go through the array, only saving the items\n\t\t\t// that pass the validator function\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn matches;\n\t\t},\n\t\n\t\t// arg is for internal usage only\n\t\tmap: function( elems, callback, arg ) {\n\t\t\tvar length, value,\n\t\t\t\ti = 0,\n\t\t\t\tret = [];\n\t\n\t\t\t// Go through the array, translating each of the items to their new values\n\t\t\tif ( isArrayLike( elems ) ) {\n\t\t\t\tlength = elems.length;\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\t\n\t\t\t\t\tif ( value != null ) {\n\t\t\t\t\t\tret.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t// Go through every key on the object,\n\t\t\t} else {\n\t\t\t\tfor ( i in elems ) {\n\t\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\t\n\t\t\t\t\tif ( value != null ) {\n\t\t\t\t\t\tret.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Flatten any nested arrays\n\t\t\treturn concat.apply( [], ret );\n\t\t},\n\t\n\t\t// A global GUID counter for objects\n\t\tguid: 1,\n\t\n\t\t// Bind a function to a context, optionally partially applying any\n\t\t// arguments.\n\t\tproxy: function( fn, context ) {\n\t\t\tvar tmp, args, proxy;\n\t\n\t\t\tif ( typeof context === \"string\" ) {\n\t\t\t\ttmp = fn[ context ];\n\t\t\t\tcontext = fn;\n\t\t\t\tfn = tmp;\n\t\t\t}\n\t\n\t\t\t// Quick check to determine if target is callable, in the spec\n\t\t\t// this throws a TypeError, but we will just return undefined.\n\t\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\n\t\t\t// Simulated bind\n\t\t\targs = slice.call( arguments, 2 );\n\t\t\tproxy = function() {\n\t\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t\t};\n\t\n\t\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\t\n\t\t\treturn proxy;\n\t\t},\n\t\n\t\tnow: Date.now,\n\t\n\t\t// jQuery.support is not used in Core but other projects attach their\n\t\t// properties to it so it needs to exist.\n\t\tsupport: support\n\t} );\n\t\n\tif ( typeof Symbol === \"function\" ) {\n\t\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n\t}\n\t\n\t// Populate the class2type map\n\tjQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\n\tfunction( i, name ) {\n\t\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n\t} );\n\t\n\tfunction isArrayLike( obj ) {\n\t\n\t\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t\t// `in` check used to prevent JIT error (gh-2145)\n\t\t// hasOwn isn't used here due to false negatives\n\t\t// regarding Nodelist length in IE\n\t\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\t\ttype = jQuery.type( obj );\n\t\n\t\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\treturn type === \"array\" || length === 0 ||\n\t\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n\t}\n\tvar Sizzle =\n\t/*!\n\t * Sizzle CSS Selector Engine v2.3.3\n\t * https://sizzlejs.com/\n\t *\n\t * Copyright jQuery Foundation and other contributors\n\t * Released under the MIT license\n\t * http://jquery.org/license\n\t *\n\t * Date: 2016-08-08\n\t */\n\t(function( window ) {\n\t\n\tvar i,\n\t\tsupport,\n\t\tExpr,\n\t\tgetText,\n\t\tisXML,\n\t\ttokenize,\n\t\tcompile,\n\t\tselect,\n\t\toutermostContext,\n\t\tsortInput,\n\t\thasDuplicate,\n\t\n\t\t// Local document vars\n\t\tsetDocument,\n\t\tdocument,\n\t\tdocElem,\n\t\tdocumentIsHTML,\n\t\trbuggyQSA,\n\t\trbuggyMatches,\n\t\tmatches,\n\t\tcontains,\n\t\n\t\t// Instance-specific data\n\t\texpando = \"sizzle\" + 1 * new Date(),\n\t\tpreferredDoc = window.document,\n\t\tdirruns = 0,\n\t\tdone = 0,\n\t\tclassCache = createCache(),\n\t\ttokenCache = createCache(),\n\t\tcompilerCache = createCache(),\n\t\tsortOrder = function( a, b ) {\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\t\n\t\t// Instance methods\n\t\thasOwn = ({}).hasOwnProperty,\n\t\tarr = [],\n\t\tpop = arr.pop,\n\t\tpush_native = arr.push,\n\t\tpush = arr.push,\n\t\tslice = arr.slice,\n\t\t// Use a stripped-down indexOf as it's faster than native\n\t\t// https://jsperf.com/thor-indexof-vs-for/5\n\t\tindexOf = function( list, elem ) {\n\t\t\tvar i = 0,\n\t\t\t\tlen = list.length;\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tif ( list[i] === elem ) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t},\n\t\n\t\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\t\n\t\t// Regular expressions\n\t\n\t\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\t\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t\n\t\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\t\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\t\n\t\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\t\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t\t// Operator (capture 2)\n\t\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\t\"*\\\\]\",\n\t\n\t\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t\t// 2. simple (capture 6)\n\t\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t\t// 3. anything else (capture 2)\n\t\t\t\".*\" +\n\t\t\t\")\\\\)|)\",\n\t\n\t\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\t\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\t\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\t\n\t\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\t\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\t\n\t\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\t\n\t\trpseudo = new RegExp( pseudos ),\n\t\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\t\n\t\tmatchExpr = {\n\t\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t\t// For use in libraries implementing .is()\n\t\t\t// We use this for POS matching in `select`\n\t\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t\t},\n\t\n\t\trinputs = /^(?:input|select|textarea|button)$/i,\n\t\trheader = /^h\\d$/i,\n\t\n\t\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\t\n\t\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\t\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\t\n\t\trsibling = /[+~]/,\n\t\n\t\t// CSS escapes\n\t\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\t\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\t\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t\t// NaN means non-codepoint\n\t\t\t// Support: Firefox<24\n\t\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\t\treturn high !== high || escapedWhitespace ?\n\t\t\t\tescaped :\n\t\t\t\thigh < 0 ?\n\t\t\t\t\t// BMP codepoint\n\t\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t\t},\n\t\n\t\t// CSS string/identifier serialization\n\t\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\t\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\t\tfcssescape = function( ch, asCodePoint ) {\n\t\t\tif ( asCodePoint ) {\n\t\n\t\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\t\treturn \"\\uFFFD\";\n\t\t\t\t}\n\t\n\t\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t\t}\n\t\n\t\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\t\treturn \"\\\\\" + ch;\n\t\t},\n\t\n\t\t// Used for iframes\n\t\t// See setDocument()\n\t\t// Removing the function wrapper causes a \"Permission Denied\"\n\t\t// error in IE\n\t\tunloadHandler = function() {\n\t\t\tsetDocument();\n\t\t},\n\t\n\t\tdisabledAncestor = addCombinator(\n\t\t\tfunction( elem ) {\n\t\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t\t},\n\t\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t\t);\n\t\n\t// Optimize for push.apply( _, NodeList )\n\ttry {\n\t\tpush.apply(\n\t\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\t\tpreferredDoc.childNodes\n\t\t);\n\t\t// Support: Android<4.0\n\t\t// Detect silently failing push.apply\n\t\tarr[ preferredDoc.childNodes.length ].nodeType;\n\t} catch ( e ) {\n\t\tpush = { apply: arr.length ?\n\t\n\t\t\t// Leverage slice if possible\n\t\t\tfunction( target, els ) {\n\t\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t\t} :\n\t\n\t\t\t// Support: IE<9\n\t\t\t// Otherwise append directly\n\t\t\tfunction( target, els ) {\n\t\t\t\tvar j = target.length,\n\t\t\t\t\ti = 0;\n\t\t\t\t// Can't trust NodeList.length\n\t\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\t\ttarget.length = j - 1;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction Sizzle( selector, context, results, seed ) {\n\t\tvar m, i, elem, nid, match, groups, newSelector,\n\t\t\tnewContext = context && context.ownerDocument,\n\t\n\t\t\t// nodeType defaults to 9, since context defaults to document\n\t\t\tnodeType = context ? context.nodeType : 9;\n\t\n\t\tresults = results || [];\n\t\n\t\t// Return early from calls with invalid selector or context\n\t\tif ( typeof selector !== \"string\" || !selector ||\n\t\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\t\n\t\t\treturn results;\n\t\t}\n\t\n\t\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\t\tif ( !seed ) {\n\t\n\t\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\t\tsetDocument( context );\n\t\t\t}\n\t\t\tcontext = context || document;\n\t\n\t\t\tif ( documentIsHTML ) {\n\t\n\t\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\t\n\t\t\t\t\t// ID selector\n\t\t\t\t\tif ( (m = match[1]) ) {\n\t\n\t\t\t\t\t\t// Document context\n\t\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\t\n\t\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Element context\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\t\telem.id === m ) {\n\t\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t// Type selector\n\t\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\t\treturn results;\n\t\n\t\t\t\t\t// Class selector\n\t\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\t\tcontext.getElementsByClassName ) {\n\t\n\t\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Take advantage of querySelectorAll\n\t\t\t\tif ( support.qsa &&\n\t\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\n\t\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\t\tnewContext = context;\n\t\t\t\t\t\tnewSelector = selector;\n\t\n\t\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t\t// Support: IE <=8\n\t\t\t\t\t// Exclude object elements\n\t\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\t\n\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\t\ti = groups.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewSelector = groups.join( \",\" );\n\t\n\t\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\t\tcontext;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( newSelector ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// All others\n\t\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n\t}\n\t\n\t/**\n\t * Create key-value caches of limited size\n\t * @returns {function(string, object)} Returns the Object data after storing it on itself with\n\t *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n\t *\tdeleting the oldest entry\n\t */\n\tfunction createCache() {\n\t\tvar keys = [];\n\t\n\t\tfunction cache( key, value ) {\n\t\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t\t// Only keep the most recent entries\n\t\t\t\tdelete cache[ keys.shift() ];\n\t\t\t}\n\t\t\treturn (cache[ key + \" \" ] = value);\n\t\t}\n\t\treturn cache;\n\t}\n\t\n\t/**\n\t * Mark a function for special use by Sizzle\n\t * @param {Function} fn The function to mark\n\t */\n\tfunction markFunction( fn ) {\n\t\tfn[ expando ] = true;\n\t\treturn fn;\n\t}\n\t\n\t/**\n\t * Support testing using an element\n\t * @param {Function} fn Passed the created element and returns a boolean result\n\t */\n\tfunction assert( fn ) {\n\t\tvar el = document.createElement(\"fieldset\");\n\t\n\t\ttry {\n\t\t\treturn !!fn( el );\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t} finally {\n\t\t\t// Remove from its parent by default\n\t\t\tif ( el.parentNode ) {\n\t\t\t\tel.parentNode.removeChild( el );\n\t\t\t}\n\t\t\t// release memory in IE\n\t\t\tel = null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Adds the same handler for all of the specified attrs\n\t * @param {String} attrs Pipe-separated list of attributes\n\t * @param {Function} handler The method that will be applied\n\t */\n\tfunction addHandle( attrs, handler ) {\n\t\tvar arr = attrs.split(\"|\"),\n\t\t\ti = arr.length;\n\t\n\t\twhile ( i-- ) {\n\t\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t\t}\n\t}\n\t\n\t/**\n\t * Checks document order of two siblings\n\t * @param {Element} a\n\t * @param {Element} b\n\t * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n\t */\n\tfunction siblingCheck( a, b ) {\n\t\tvar cur = b && a,\n\t\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t\ta.sourceIndex - b.sourceIndex;\n\t\n\t\t// Use IE sourceIndex if available on both nodes\n\t\tif ( diff ) {\n\t\t\treturn diff;\n\t\t}\n\t\n\t\t// Check if b follows a\n\t\tif ( cur ) {\n\t\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\t\tif ( cur === b ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn a ? 1 : -1;\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for input types\n\t * @param {String} type\n\t */\n\tfunction createInputPseudo( type ) {\n\t\treturn function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === type;\n\t\t};\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for buttons\n\t * @param {String} type\n\t */\n\tfunction createButtonPseudo( type ) {\n\t\treturn function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t\t};\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for :enabled/:disabled\n\t * @param {Boolean} disabled true for :disabled; false for :enabled\n\t */\n\tfunction createDisabledPseudo( disabled ) {\n\t\n\t\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\t\treturn function( elem ) {\n\t\n\t\t\t// Only certain elements can match :enabled or :disabled\n\t\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\t\tif ( \"form\" in elem ) {\n\t\n\t\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t\t// * option elements in a disabled optgroup\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t\t// All such elements have a \"form\" property.\n\t\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\t\n\t\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\t\treturn elem.isDisabled === disabled ||\n\t\n\t\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t\t}\n\t\n\t\t\t\treturn elem.disabled === disabled;\n\t\n\t\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t\t// even exist on them, let alone have a boolean value.\n\t\t\t} else if ( \"label\" in elem ) {\n\t\t\t\treturn elem.disabled === disabled;\n\t\t\t}\n\t\n\t\t\t// Remaining elements are neither :enabled nor :disabled\n\t\t\treturn false;\n\t\t};\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for positionals\n\t * @param {Function} fn\n\t */\n\tfunction createPositionalPseudo( fn ) {\n\t\treturn markFunction(function( argument ) {\n\t\t\targument = +argument;\n\t\t\treturn markFunction(function( seed, matches ) {\n\t\t\t\tvar j,\n\t\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\t\ti = matchIndexes.length;\n\t\n\t\t\t\t// Match elements found at the specified indexes\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\t\n\t/**\n\t * Checks a node for validity as a Sizzle context\n\t * @param {Element|Object=} context\n\t * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n\t */\n\tfunction testContext( context ) {\n\t\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n\t}\n\t\n\t// Expose support vars for convenience\n\tsupport = Sizzle.support = {};\n\t\n\t/**\n\t * Detects XML nodes\n\t * @param {Element|Object} elem An element or a document\n\t * @returns {Boolean} True iff elem is a non-HTML XML node\n\t */\n\tisXML = Sizzle.isXML = function( elem ) {\n\t\t// documentElement is verified for cases where it doesn't yet exist\n\t\t// (such as loading iframes in IE - #4833)\n\t\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\t\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n\t};\n\t\n\t/**\n\t * Sets document-related variables once based on the current document\n\t * @param {Element|Object} [doc] An element or document object to use to set the document\n\t * @returns {Object} Returns the current document\n\t */\n\tsetDocument = Sizzle.setDocument = function( node ) {\n\t\tvar hasCompare, subWindow,\n\t\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\t\n\t\t// Return early if doc is invalid or already selected\n\t\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\t\treturn document;\n\t\t}\n\t\n\t\t// Update global variables\n\t\tdocument = doc;\n\t\tdocElem = document.documentElement;\n\t\tdocumentIsHTML = !isXML( document );\n\t\n\t\t// Support: IE 9-11, Edge\n\t\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\t\tif ( preferredDoc !== document &&\n\t\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\t\n\t\t\t// Support: IE 11, Edge\n\t\t\tif ( subWindow.addEventListener ) {\n\t\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\t\n\t\t\t// Support: IE 9 - 10 only\n\t\t\t} else if ( subWindow.attachEvent ) {\n\t\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t\t}\n\t\t}\n\t\n\t\t/* Attributes\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// Support: IE<8\n\t\t// Verify that getAttribute really returns attributes and not properties\n\t\t// (excepting IE8 booleans)\n\t\tsupport.attributes = assert(function( el ) {\n\t\t\tel.className = \"i\";\n\t\t\treturn !el.getAttribute(\"className\");\n\t\t});\n\t\n\t\t/* getElement(s)By*\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// Check if getElementsByTagName(\"*\") returns only elements\n\t\tsupport.getElementsByTagName = assert(function( el ) {\n\t\t\tel.appendChild( document.createComment(\"\") );\n\t\t\treturn !el.getElementsByTagName(\"*\").length;\n\t\t});\n\t\n\t\t// Support: IE<9\n\t\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\t\n\t\t// Support: IE<10\n\t\t// Check if getElementById returns elements by name\n\t\t// The broken getElementById methods don't pick up programmatically-set names,\n\t\t// so use a roundabout getElementsByName test\n\t\tsupport.getById = assert(function( el ) {\n\t\t\tdocElem.appendChild( el ).id = expando;\n\t\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t\t});\n\t\n\t\t// ID filter and find\n\t\tif ( support.getById ) {\n\t\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t\t}\n\t\t\t};\n\t\t} else {\n\t\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\t\treturn node && node.value === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\n\t\t\t// Support: IE 6 - 7 only\n\t\t\t// getElementById is not reliable as a find shortcut\n\t\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\t\tvar node, i, elems,\n\t\t\t\t\t\telem = context.getElementById( id );\n\t\n\t\t\t\t\tif ( elem ) {\n\t\n\t\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\t// Tag\n\t\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\t\tfunction( tag, context ) {\n\t\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\t\treturn context.getElementsByTagName( tag );\n\t\n\t\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t\t} else if ( support.qsa ) {\n\t\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t\t}\n\t\t\t} :\n\t\n\t\t\tfunction( tag, context ) {\n\t\t\t\tvar elem,\n\t\t\t\t\ttmp = [],\n\t\t\t\t\ti = 0,\n\t\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\t\tresults = context.getElementsByTagName( tag );\n\t\n\t\t\t\t// Filter out possible comments\n\t\t\t\tif ( tag === \"*\" ) {\n\t\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn tmp;\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\t\n\t\t// Class\n\t\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\t\treturn context.getElementsByClassName( className );\n\t\t\t}\n\t\t};\n\t\n\t\t/* QSA/matchesSelector\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// QSA and matchesSelector support\n\t\n\t\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\t\trbuggyMatches = [];\n\t\n\t\t// qSa(:focus) reports false when true (Chrome 21)\n\t\t// We allow this because of a bug in IE8/9 that throws an error\n\t\t// whenever `document.activeElement` is accessed on an iframe\n\t\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t\t// See https://bugs.jquery.com/ticket/13378\n\t\trbuggyQSA = [];\n\t\n\t\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t\t// Build QSA regex\n\t\t\t// Regex strategy adopted from Diego Perini\n\t\t\tassert(function( el ) {\n\t\t\t\t// Select is set to empty string on purpose\n\t\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t\t// setting a boolean content attribute,\n\t\t\t\t// since its presence should be enough\n\t\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\t\"<option selected=''></option></select>\";\n\t\n\t\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Support: IE8\n\t\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t\t}\n\t\n\t\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t\t}\n\t\n\t\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tassert(function( el ) {\n\t\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\t\n\t\t\t\t// Support: Windows 8 Native Apps\n\t\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\t\tvar input = document.createElement(\"input\");\n\t\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\t\n\t\t\t\t// Support: IE8\n\t\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t\t}\n\t\n\t\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Support: IE9-11+\n\t\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\t\trbuggyQSA.push(\",.*:\");\n\t\t\t});\n\t\t}\n\t\n\t\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\t\tdocElem.webkitMatchesSelector ||\n\t\t\tdocElem.mozMatchesSelector ||\n\t\t\tdocElem.oMatchesSelector ||\n\t\t\tdocElem.msMatchesSelector) )) ) {\n\t\n\t\t\tassert(function( el ) {\n\t\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t\t// on a disconnected node (IE 9)\n\t\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\t\n\t\t\t\t// This should fail with an exception\n\t\t\t\t// Gecko does not error, returns false instead\n\t\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t\t});\n\t\t}\n\t\n\t\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\t\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\t\n\t\t/* Contains\n\t\t---------------------------------------------------------------------- */\n\t\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\t\n\t\t// Element contains another\n\t\t// Purposefully self-exclusive\n\t\t// As in, an element does not contain itself\n\t\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\t\tfunction( a, b ) {\n\t\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\t\tbup = b && b.parentNode;\n\t\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\t\tadown.contains ?\n\t\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t\t));\n\t\t\t} :\n\t\t\tfunction( a, b ) {\n\t\t\t\tif ( b ) {\n\t\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\t\n\t\t/* Sorting\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// Document order sorting\n\t\tsortOrder = hasCompare ?\n\t\tfunction( a, b ) {\n\t\n\t\t\t// Flag for duplicate removal\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\t\tif ( compare ) {\n\t\t\t\treturn compare;\n\t\t\t}\n\t\n\t\t\t// Calculate position if both inputs belong to the same document\n\t\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\t\ta.compareDocumentPosition( b ) :\n\t\n\t\t\t\t// Otherwise we know they are disconnected\n\t\t\t\t1;\n\t\n\t\t\t// Disconnected nodes\n\t\t\tif ( compare & 1 ||\n\t\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\t\n\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\n\t\t\t\t// Maintain original order\n\t\t\t\treturn sortInput ?\n\t\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t\t0;\n\t\t\t}\n\t\n\t\t\treturn compare & 4 ? -1 : 1;\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\t// Exit early if the nodes are identical\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\tvar cur,\n\t\t\t\ti = 0,\n\t\t\t\taup = a.parentNode,\n\t\t\t\tbup = b.parentNode,\n\t\t\t\tap = [ a ],\n\t\t\t\tbp = [ b ];\n\t\n\t\t\t// Parentless nodes are either documents or disconnected\n\t\t\tif ( !aup || !bup ) {\n\t\t\t\treturn a === document ? -1 :\n\t\t\t\t\tb === document ? 1 :\n\t\t\t\t\taup ? -1 :\n\t\t\t\t\tbup ? 1 :\n\t\t\t\t\tsortInput ?\n\t\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t\t0;\n\t\n\t\t\t// If the nodes are siblings, we can do a quick check\n\t\t\t} else if ( aup === bup ) {\n\t\t\t\treturn siblingCheck( a, b );\n\t\t\t}\n\t\n\t\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\t\tcur = a;\n\t\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\t\tap.unshift( cur );\n\t\t\t}\n\t\t\tcur = b;\n\t\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\t\tbp.unshift( cur );\n\t\t\t}\n\t\n\t\t\t// Walk down the tree looking for a discrepancy\n\t\t\twhile ( ap[i] === bp[i] ) {\n\t\t\t\ti++;\n\t\t\t}\n\t\n\t\t\treturn i ?\n\t\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\t\n\t\t\t\t// Otherwise nodes in our document sort first\n\t\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t\t0;\n\t\t};\n\t\n\t\treturn document;\n\t};\n\t\n\tSizzle.matches = function( expr, elements ) {\n\t\treturn Sizzle( expr, null, null, elements );\n\t};\n\t\n\tSizzle.matchesSelector = function( elem, expr ) {\n\t\t// Set document vars if needed\n\t\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\t\tsetDocument( elem );\n\t\t}\n\t\n\t\t// Make sure that attribute selectors are quoted\n\t\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\t\n\t\tif ( support.matchesSelector && documentIsHTML &&\n\t\t\t!compilerCache[ expr + \" \" ] &&\n\t\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\t\n\t\t\ttry {\n\t\t\t\tvar ret = matches.call( elem, expr );\n\t\n\t\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t\n\t\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n\t};\n\t\n\tSizzle.contains = function( context, elem ) {\n\t\t// Set document vars if needed\n\t\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\treturn contains( context, elem );\n\t};\n\t\n\tSizzle.attr = function( elem, name ) {\n\t\t// Set document vars if needed\n\t\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\t\tsetDocument( elem );\n\t\t}\n\t\n\t\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\t\tundefined;\n\t\n\t\treturn val !== undefined ?\n\t\t\tval :\n\t\t\tsupport.attributes || !documentIsHTML ?\n\t\t\t\telem.getAttribute( name ) :\n\t\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t};\n\t\n\tSizzle.escape = function( sel ) {\n\t\treturn (sel + \"\").replace( rcssescape, fcssescape );\n\t};\n\t\n\tSizzle.error = function( msg ) {\n\t\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n\t};\n\t\n\t/**\n\t * Document sorting and removing duplicates\n\t * @param {ArrayLike} results\n\t */\n\tSizzle.uniqueSort = function( results ) {\n\t\tvar elem,\n\t\t\tduplicates = [],\n\t\t\tj = 0,\n\t\t\ti = 0;\n\t\n\t\t// Unless we *know* we can detect duplicates, assume their presence\n\t\thasDuplicate = !support.detectDuplicates;\n\t\tsortInput = !support.sortStable && results.slice( 0 );\n\t\tresults.sort( sortOrder );\n\t\n\t\tif ( hasDuplicate ) {\n\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\t\tj = duplicates.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile ( j-- ) {\n\t\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t\t}\n\t\t}\n\t\n\t\t// Clear input after sorting to release objects\n\t\t// See https://github.com/jquery/sizzle/pull/225\n\t\tsortInput = null;\n\t\n\t\treturn results;\n\t};\n\t\n\t/**\n\t * Utility function for retrieving the text value of an array of DOM nodes\n\t * @param {Array|Element} elem\n\t */\n\tgetText = Sizzle.getText = function( elem ) {\n\t\tvar node,\n\t\t\tret = \"\",\n\t\t\ti = 0,\n\t\t\tnodeType = elem.nodeType;\n\t\n\t\tif ( !nodeType ) {\n\t\t\t// If no nodeType, this is expected to be an array\n\t\t\twhile ( (node = elem[i++]) ) {\n\t\t\t\t// Do not traverse comment nodes\n\t\t\t\tret += getText( node );\n\t\t\t}\n\t\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t\t// Use textContent for elements\n\t\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\t\treturn elem.textContent;\n\t\t\t} else {\n\t\t\t\t// Traverse its children\n\t\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\t\tret += getText( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\t\treturn elem.nodeValue;\n\t\t}\n\t\t// Do not include comment or processing instruction nodes\n\t\n\t\treturn ret;\n\t};\n\t\n\tExpr = Sizzle.selectors = {\n\t\n\t\t// Can be adjusted by the user\n\t\tcacheLength: 50,\n\t\n\t\tcreatePseudo: markFunction,\n\t\n\t\tmatch: matchExpr,\n\t\n\t\tattrHandle: {},\n\t\n\t\tfind: {},\n\t\n\t\trelative: {\n\t\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\t\" \": { dir: \"parentNode\" },\n\t\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\t\"~\": { dir: \"previousSibling\" }\n\t\t},\n\t\n\t\tpreFilter: {\n\t\t\t\"ATTR\": function( match ) {\n\t\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\t\n\t\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\t\n\t\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t\t}\n\t\n\t\t\t\treturn match.slice( 0, 4 );\n\t\t\t},\n\t\n\t\t\t\"CHILD\": function( match ) {\n\t\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t\t1 type (only|nth|...)\n\t\t\t\t\t2 what (child|of-type)\n\t\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t\t5 sign of xn-component\n\t\t\t\t\t6 x of xn-component\n\t\t\t\t\t7 sign of y-component\n\t\t\t\t\t8 y of y-component\n\t\t\t\t*/\n\t\t\t\tmatch[1] = match[1].toLowerCase();\n\t\n\t\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t\t// nth-* requires argument\n\t\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\t\n\t\t\t\t// other types prohibit arguments\n\t\t\t\t} else if ( match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\t\n\t\t\t\treturn match;\n\t\t\t},\n\t\n\t\t\t\"PSEUDO\": function( match ) {\n\t\t\t\tvar excess,\n\t\t\t\t\tunquoted = !match[6] && match[2];\n\t\n\t\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\t// Accept quoted arguments as-is\n\t\t\t\tif ( match[3] ) {\n\t\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\t\n\t\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\t\n\t\t\t\t\t// excess is a negative index\n\t\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t\t}\n\t\n\t\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\t\treturn match.slice( 0, 3 );\n\t\t\t}\n\t\t},\n\t\n\t\tfilter: {\n\t\n\t\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\t\tfunction() { return true; } :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t\"CLASS\": function( className ) {\n\t\t\t\tvar pattern = classCache[ className + \" \" ];\n\t\n\t\t\t\treturn pattern ||\n\t\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t\t});\n\t\t\t},\n\t\n\t\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar result = Sizzle.attr( elem, name );\n\t\n\t\t\t\t\tif ( result == null ) {\n\t\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t\t}\n\t\t\t\t\tif ( !operator ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tresult += \"\";\n\t\n\t\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\t\tfalse;\n\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\t\tofType = what === \"of-type\";\n\t\n\t\t\t\treturn first === 1 && last === 0 ?\n\t\n\t\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t\t} :\n\t\n\t\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\t\tdiff = false;\n\t\n\t\t\t\t\t\tif ( parent ) {\n\t\n\t\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\t\n\t\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\t\tif ( forward && useCache ) {\n\t\n\t\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\t\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\t\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\t\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\n\t\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\t\n\t\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\t\n\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\t\n\t\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\t\n\t\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t\t++diff ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\t\n\t\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t\t// pseudo-class names are case-insensitive\n\t\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\t\tvar args,\n\t\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\t\n\t\t\t\t// The user may use createPseudo to indicate that\n\t\t\t\t// arguments are needed to create the filter function\n\t\t\t\t// just as Sizzle does\n\t\t\t\tif ( fn[ expando ] ) {\n\t\t\t\t\treturn fn( argument );\n\t\t\t\t}\n\t\n\t\t\t\t// But maintain support for old signatures\n\t\t\t\tif ( fn.length > 1 ) {\n\t\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}) :\n\t\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\treturn fn;\n\t\t\t}\n\t\t},\n\t\n\t\tpseudos: {\n\t\t\t// Potentially complex pseudos\n\t\t\t\"not\": markFunction(function( selector ) {\n\t\t\t\t// Trim the selector passed to compile\n\t\t\t\t// to avoid treating leading and trailing\n\t\t\t\t// spaces as combinators\n\t\t\t\tvar input = [],\n\t\t\t\t\tresults = [],\n\t\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\t\n\t\t\t\treturn matcher[ expando ] ?\n\t\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\t\tvar elem,\n\t\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\t\ti = seed.length;\n\t\n\t\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\t\tinput[0] = null;\n\t\t\t\t\t\treturn !results.pop();\n\t\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t\"has\": markFunction(function( selector ) {\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t\"contains\": markFunction(function( text ) {\n\t\t\t\ttext = text.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t// \"Whether an element is represented by a :lang() selector\n\t\t\t// is based solely on the element's language value\n\t\t\t// being equal to the identifier C,\n\t\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t\t// The identifier C does not have to be a valid language name.\"\n\t\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t\t// lang value must be a valid identifier\n\t\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t\t}\n\t\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar elemLang;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\t\n\t\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t// Miscellaneous\n\t\t\t\"target\": function( elem ) {\n\t\t\t\tvar hash = window.location && window.location.hash;\n\t\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t\t},\n\t\n\t\t\t\"root\": function( elem ) {\n\t\t\t\treturn elem === docElem;\n\t\t\t},\n\t\n\t\t\t\"focus\": function( elem ) {\n\t\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t\t},\n\t\n\t\t\t// Boolean properties\n\t\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\t\"disabled\": createDisabledPseudo( true ),\n\t\n\t\t\t\"checked\": function( elem ) {\n\t\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t\t},\n\t\n\t\t\t\"selected\": function( elem ) {\n\t\t\t\t// Accessing this property makes selected-by-default\n\t\t\t\t// options in Safari work properly\n\t\t\t\tif ( elem.parentNode ) {\n\t\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t\t}\n\t\n\t\t\t\treturn elem.selected === true;\n\t\t\t},\n\t\n\t\t\t// Contents\n\t\t\t\"empty\": function( elem ) {\n\t\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\t\n\t\t\t\"parent\": function( elem ) {\n\t\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t\t},\n\t\n\t\t\t// Element/input types\n\t\t\t\"header\": function( elem ) {\n\t\t\t\treturn rheader.test( elem.nodeName );\n\t\t\t},\n\t\n\t\t\t\"input\": function( elem ) {\n\t\t\t\treturn rinputs.test( elem.nodeName );\n\t\t\t},\n\t\n\t\t\t\"button\": function( elem ) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t\t},\n\t\n\t\t\t\"text\": function( elem ) {\n\t\t\t\tvar attr;\n\t\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\t\telem.type === \"text\" &&\n\t\n\t\t\t\t\t// Support: IE<8\n\t\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t\t},\n\t\n\t\t\t// Position-in-collection\n\t\t\t\"first\": createPositionalPseudo(function() {\n\t\t\t\treturn [ 0 ];\n\t\t\t}),\n\t\n\t\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\treturn [ length - 1 ];\n\t\t\t}),\n\t\n\t\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t\t}),\n\t\n\t\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\n\t\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\tvar i = 1;\n\t\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\n\t\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\n\t\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t})\n\t\t}\n\t};\n\t\n\tExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\t\n\t// Add button/input type pseudos\n\tfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\t\tExpr.pseudos[ i ] = createInputPseudo( i );\n\t}\n\tfor ( i in { submit: true, reset: true } ) {\n\t\tExpr.pseudos[ i ] = createButtonPseudo( i );\n\t}\n\t\n\t// Easy API for creating new setFilters\n\tfunction setFilters() {}\n\tsetFilters.prototype = Expr.filters = Expr.pseudos;\n\tExpr.setFilters = new setFilters();\n\t\n\ttokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\t\tvar matched, match, tokens, type,\n\t\t\tsoFar, groups, preFilters,\n\t\t\tcached = tokenCache[ selector + \" \" ];\n\t\n\t\tif ( cached ) {\n\t\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t\t}\n\t\n\t\tsoFar = selector;\n\t\tgroups = [];\n\t\tpreFilters = Expr.preFilter;\n\t\n\t\twhile ( soFar ) {\n\t\n\t\t\t// Comma and first run\n\t\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\t\tif ( match ) {\n\t\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t\t}\n\t\t\t\tgroups.push( (tokens = []) );\n\t\t\t}\n\t\n\t\t\tmatched = false;\n\t\n\t\t\t// Combinators\n\t\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\t// Cast descendant combinators to space\n\t\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\n\t\t\t// Filters\n\t\t\tfor ( type in Expr.filter ) {\n\t\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\ttokens.push({\n\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\tmatches: match\n\t\t\t\t\t});\n\t\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( !matched ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the length of the invalid excess\n\t\t// if we're just parsing\n\t\t// Otherwise, throw an error or return tokens\n\t\treturn parseOnly ?\n\t\t\tsoFar.length :\n\t\t\tsoFar ?\n\t\t\t\tSizzle.error( selector ) :\n\t\t\t\t// Cache the tokens\n\t\t\t\ttokenCache( selector, groups ).slice( 0 );\n\t};\n\t\n\tfunction toSelector( tokens ) {\n\t\tvar i = 0,\n\t\t\tlen = tokens.length,\n\t\t\tselector = \"\";\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tselector += tokens[i].value;\n\t\t}\n\t\treturn selector;\n\t}\n\t\n\tfunction addCombinator( matcher, combinator, base ) {\n\t\tvar dir = combinator.dir,\n\t\t\tskip = combinator.next,\n\t\t\tkey = skip || dir,\n\t\t\tcheckNonElements = base && key === \"parentNode\",\n\t\t\tdoneName = done++;\n\t\n\t\treturn combinator.first ?\n\t\t\t// Check against closest ancestor/preceding element\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} :\n\t\n\t\t\t// Check against all ancestor/preceding elements\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\t\tnewCache = [ dirruns, doneName ];\n\t\n\t\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\t\tif ( xml ) {\n\t\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\t\n\t\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\t\n\t\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\t\n\t\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\t}\n\t\n\tfunction elementMatcher( matchers ) {\n\t\treturn matchers.length > 1 ?\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\tvar i = matchers.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} :\n\t\t\tmatchers[0];\n\t}\n\t\n\tfunction multipleContexts( selector, contexts, results ) {\n\t\tvar i = 0,\n\t\t\tlen = contexts.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tSizzle( selector, contexts[i], results );\n\t\t}\n\t\treturn results;\n\t}\n\t\n\tfunction condense( unmatched, map, filter, context, xml ) {\n\t\tvar elem,\n\t\t\tnewUnmatched = [],\n\t\t\ti = 0,\n\t\t\tlen = unmatched.length,\n\t\t\tmapped = map != null;\n\t\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\t\tif ( mapped ) {\n\t\t\t\t\t\tmap.push( i );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn newUnmatched;\n\t}\n\t\n\tfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\t\tif ( postFilter && !postFilter[ expando ] ) {\n\t\t\tpostFilter = setMatcher( postFilter );\n\t\t}\n\t\tif ( postFinder && !postFinder[ expando ] ) {\n\t\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t\t}\n\t\treturn markFunction(function( seed, results, context, xml ) {\n\t\t\tvar temp, i, elem,\n\t\t\t\tpreMap = [],\n\t\t\t\tpostMap = [],\n\t\t\t\tpreexisting = results.length,\n\t\n\t\t\t\t// Get initial elements from seed or context\n\t\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\t\n\t\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\t\telems,\n\t\n\t\t\t\tmatcherOut = matcher ?\n\t\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\t\n\t\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t\t[] :\n\t\n\t\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\t\tresults :\n\t\t\t\t\tmatcherIn;\n\t\n\t\t\t// Find primary matches\n\t\t\tif ( matcher ) {\n\t\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t\t}\n\t\n\t\t\t// Apply postFilter\n\t\t\tif ( postFilter ) {\n\t\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\t\tpostFilter( temp, [], context, xml );\n\t\n\t\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\t\ti = temp.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( seed ) {\n\t\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\t\ttemp = [];\n\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\t\n\t\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t// Add elements to results, through postFinder if defined\n\t\t\t} else {\n\t\t\t\tmatcherOut = condense(\n\t\t\t\t\tmatcherOut === results ?\n\t\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\t\tmatcherOut\n\t\t\t\t);\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t\t} else {\n\t\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\t\n\tfunction matcherFromTokens( tokens ) {\n\t\tvar checkContext, matcher, j,\n\t\t\tlen = tokens.length,\n\t\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\t\ti = leadingRelative ? 1 : 0,\n\t\n\t\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\t\treturn elem === checkContext;\n\t\t\t}, implicitRelative, true ),\n\t\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t\t}, implicitRelative, true ),\n\t\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\t\tcheckContext = null;\n\t\t\t\treturn ret;\n\t\t\t} ];\n\t\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t\t} else {\n\t\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\t\n\t\t\t\t// Return special upon seeing a positional matcher\n\t\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\t\tj = ++i;\n\t\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn setMatcher(\n\t\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\t\tmatcher,\n\t\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tmatchers.push( matcher );\n\t\t\t}\n\t\t}\n\t\n\t\treturn elementMatcher( matchers );\n\t}\n\t\n\tfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\t\tvar bySet = setMatchers.length > 0,\n\t\t\tbyElement = elementMatchers.length > 0,\n\t\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\t\tvar elem, j, matcher,\n\t\t\t\t\tmatchedCount = 0,\n\t\t\t\t\ti = \"0\",\n\t\t\t\t\tunmatched = seed && [],\n\t\t\t\t\tsetMatched = [],\n\t\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\t\tlen = elems.length;\n\t\n\t\t\t\tif ( outermost ) {\n\t\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t\t}\n\t\n\t\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t\t// Support: IE<9, Safari\n\t\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\t\tif ( bySet ) {\n\t\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t\t// makes the latter nonnegative.\n\t\t\t\tmatchedCount += i;\n\t\n\t\t\t\t// Apply set filters to unmatched elements\n\t\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t\t// no element matchers and no seed.\n\t\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t\t// numerically zero.\n\t\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Add matches to results\n\t\t\t\t\tpush.apply( results, setMatched );\n\t\n\t\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\t\n\t\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Override manipulation of globals by nested matchers\n\t\t\t\tif ( outermost ) {\n\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\toutermostContext = contextBackup;\n\t\t\t\t}\n\t\n\t\t\t\treturn unmatched;\n\t\t\t};\n\t\n\t\treturn bySet ?\n\t\t\tmarkFunction( superMatcher ) :\n\t\t\tsuperMatcher;\n\t}\n\t\n\tcompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\t\tvar i,\n\t\t\tsetMatchers = [],\n\t\t\telementMatchers = [],\n\t\t\tcached = compilerCache[ selector + \" \" ];\n\t\n\t\tif ( !cached ) {\n\t\t\t// Generate a function of recursive functions that can be used to check each element\n\t\t\tif ( !match ) {\n\t\t\t\tmatch = tokenize( selector );\n\t\t\t}\n\t\t\ti = match.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\t\tif ( cached[ expando ] ) {\n\t\t\t\t\tsetMatchers.push( cached );\n\t\t\t\t} else {\n\t\t\t\t\telementMatchers.push( cached );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Cache the compiled function\n\t\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\t\n\t\t\t// Save selector and tokenization\n\t\t\tcached.selector = selector;\n\t\t}\n\t\treturn cached;\n\t};\n\t\n\t/**\n\t * A low-level selection function that works with Sizzle's compiled\n\t *  selector functions\n\t * @param {String|Function} selector A selector or a pre-compiled\n\t *  selector function built with Sizzle.compile\n\t * @param {Element} context\n\t * @param {Array} [results]\n\t * @param {Array} [seed] A set of elements to match against\n\t */\n\tselect = Sizzle.select = function( selector, context, results, seed ) {\n\t\tvar i, tokens, token, type, find,\n\t\t\tcompiled = typeof selector === \"function\" && selector,\n\t\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\t\n\t\tresults = results || [];\n\t\n\t\t// Try to minimize operations if there is only one selector in the list and no seed\n\t\t// (the latter of which guarantees us context)\n\t\tif ( match.length === 1 ) {\n\t\n\t\t\t// Reduce context if the leading compound selector is an ID\n\t\t\ttokens = match[0] = match[0].slice( 0 );\n\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\t\n\t\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\t\tif ( !context ) {\n\t\t\t\t\treturn results;\n\t\n\t\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t\t} else if ( compiled ) {\n\t\t\t\t\tcontext = context.parentNode;\n\t\t\t\t}\n\t\n\t\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t\t}\n\t\n\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\ttoken = tokens[i];\n\t\n\t\t\t\t// Abort if we hit a combinator\n\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif ( (seed = find(\n\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t\t)) ) {\n\t\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Compile and execute a filtering function if one is not provided\n\t\t// Provide `match` to avoid retokenization if we modified the selector above\n\t\t( compiled || compile( selector, match ) )(\n\t\t\tseed,\n\t\t\tcontext,\n\t\t\t!documentIsHTML,\n\t\t\tresults,\n\t\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t\t);\n\t\treturn results;\n\t};\n\t\n\t// One-time assignments\n\t\n\t// Sort stability\n\tsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\t\n\t// Support: Chrome 14-35+\n\t// Always assume duplicates if they aren't passed to the comparison function\n\tsupport.detectDuplicates = !!hasDuplicate;\n\t\n\t// Initialize against the default document\n\tsetDocument();\n\t\n\t// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n\t// Detached nodes confoundingly follow *each other*\n\tsupport.sortDetached = assert(function( el ) {\n\t\t// Should return 1, but returns 4 (following)\n\t\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n\t});\n\t\n\t// Support: IE<8\n\t// Prevent attribute/property \"interpolation\"\n\t// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\tif ( !assert(function( el ) {\n\t\tel.innerHTML = \"<a href='#'></a>\";\n\t\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n\t}) ) {\n\t\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t\t}\n\t\t});\n\t}\n\t\n\t// Support: IE<9\n\t// Use defaultValue in place of getAttribute(\"value\")\n\tif ( !support.attributes || !assert(function( el ) {\n\t\tel.innerHTML = \"<input/>\";\n\t\tel.firstChild.setAttribute( \"value\", \"\" );\n\t\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n\t}) ) {\n\t\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\t\treturn elem.defaultValue;\n\t\t\t}\n\t\t});\n\t}\n\t\n\t// Support: IE<9\n\t// Use getAttributeNode to fetch booleans when getAttribute lies\n\tif ( !assert(function( el ) {\n\t\treturn el.getAttribute(\"disabled\") == null;\n\t}) ) {\n\t\taddHandle( booleans, function( elem, name, isXML ) {\n\t\t\tvar val;\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t\t\t}\n\t\t});\n\t}\n\t\n\treturn Sizzle;\n\t\n\t})( window );\n\t\n\t\n\t\n\tjQuery.find = Sizzle;\n\tjQuery.expr = Sizzle.selectors;\n\t\n\t// Deprecated\n\tjQuery.expr[ \":\" ] = jQuery.expr.pseudos;\n\tjQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n\tjQuery.text = Sizzle.getText;\n\tjQuery.isXMLDoc = Sizzle.isXML;\n\tjQuery.contains = Sizzle.contains;\n\tjQuery.escapeSelector = Sizzle.escape;\n\t\n\t\n\t\n\t\n\tvar dir = function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\ttruncate = until !== undefined;\n\t\n\t\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push( elem );\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t};\n\t\n\t\n\tvar siblings = function( n, elem ) {\n\t\tvar matched = [];\n\t\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tmatched.push( n );\n\t\t\t}\n\t\t}\n\t\n\t\treturn matched;\n\t};\n\t\n\t\n\tvar rneedsContext = jQuery.expr.match.needsContext;\n\t\n\tvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\t\n\t\n\t\n\tvar risSimple = /^.[^:#\\[\\.,]*$/;\n\t\n\t// Implement the identical functionality for filter and not\n\tfunction winnow( elements, qualifier, not ) {\n\t\tif ( jQuery.isFunction( qualifier ) ) {\n\t\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t\t} );\n\t\t}\n\t\n\t\t// Single element\n\t\tif ( qualifier.nodeType ) {\n\t\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\t\treturn ( elem === qualifier ) !== not;\n\t\t\t} );\n\t\t}\n\t\n\t\t// Arraylike of elements (jQuery, arguments, Array)\n\t\tif ( typeof qualifier !== \"string\" ) {\n\t\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t\t} );\n\t\t}\n\t\n\t\t// Simple selector that can be filtered directly, removing non-Elements\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\t\n\t\t// Complex selector, compare the two sets, removing non-Elements\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\n\t\t} );\n\t}\n\t\n\tjQuery.filter = function( expr, elems, not ) {\n\t\tvar elem = elems[ 0 ];\n\t\n\t\tif ( not ) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\t\n\t\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t\t}\n\t\n\t\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t} ) );\n\t};\n\t\n\tjQuery.fn.extend( {\n\t\tfind: function( selector ) {\n\t\t\tvar i, ret,\n\t\t\t\tlen = this.length,\n\t\t\t\tself = this;\n\t\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} ) );\n\t\t\t}\n\t\n\t\t\tret = this.pushStack( [] );\n\t\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t\t}\n\t\n\t\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t\t},\n\t\tfilter: function( selector ) {\n\t\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t\t},\n\t\tnot: function( selector ) {\n\t\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t\t},\n\t\tis: function( selector ) {\n\t\t\treturn !!winnow(\n\t\t\t\tthis,\n\t\n\t\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\t\tjQuery( selector ) :\n\t\t\t\t\tselector || [],\n\t\t\t\tfalse\n\t\t\t).length;\n\t\t}\n\t} );\n\t\n\t\n\t// Initialize a jQuery object\n\t\n\t\n\t// A central reference to the root jQuery(document)\n\tvar rootjQuery,\n\t\n\t\t// A simple way to check for HTML strings\n\t\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t\t// Strict HTML recognition (#11290: must start with <)\n\t\t// Shortcut simple #id case for speed\n\t\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\t\n\t\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\t\tvar match, elem;\n\t\n\t\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\t\tif ( !selector ) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\n\t\t\t// Method init() accepts an alternate rootjQuery\n\t\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\t\troot = root || rootjQuery;\n\t\n\t\t\t// Handle HTML strings\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\t\tselector.length >= 3 ) {\n\t\n\t\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\t\tmatch = [ null, selector, null ];\n\t\n\t\t\t\t} else {\n\t\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t\t}\n\t\n\t\t\t\t// Match html or make sure no context is specified for #id\n\t\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\t\n\t\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\t\n\t\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t) );\n\t\n\t\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\t\tfor ( match in context ) {\n\t\n\t\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\t\n\t\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\t\n\t\t\t\t\t\tif ( elem ) {\n\t\n\t\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\n\t\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\t\treturn ( context || root ).find( selector );\n\t\n\t\t\t\t// HANDLE: $(expr, context)\n\t\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t\t} else {\n\t\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t\t}\n\t\n\t\t\t// HANDLE: $(DOMElement)\n\t\t\t} else if ( selector.nodeType ) {\n\t\t\t\tthis[ 0 ] = selector;\n\t\t\t\tthis.length = 1;\n\t\t\t\treturn this;\n\t\n\t\t\t// HANDLE: $(function)\n\t\t\t// Shortcut for document ready\n\t\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\t\treturn root.ready !== undefined ?\n\t\t\t\t\troot.ready( selector ) :\n\t\n\t\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\t\tselector( jQuery );\n\t\t\t}\n\t\n\t\t\treturn jQuery.makeArray( selector, this );\n\t\t};\n\t\n\t// Give the init function the jQuery prototype for later instantiation\n\tinit.prototype = jQuery.fn;\n\t\n\t// Initialize central reference\n\trootjQuery = jQuery( document );\n\t\n\t\n\tvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t\n\t\t// Methods guaranteed to produce a unique set when starting from a unique set\n\t\tguaranteedUnique = {\n\t\t\tchildren: true,\n\t\t\tcontents: true,\n\t\t\tnext: true,\n\t\t\tprev: true\n\t\t};\n\t\n\tjQuery.fn.extend( {\n\t\thas: function( target ) {\n\t\t\tvar targets = jQuery( target, this ),\n\t\t\t\tl = targets.length;\n\t\n\t\t\treturn this.filter( function() {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tclosest: function( selectors, context ) {\n\t\t\tvar cur,\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length,\n\t\t\t\tmatched = [],\n\t\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\t\n\t\t\t// Positional selectors never match, since there's no _selection_ context\n\t\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\t\n\t\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\t\n\t\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\t\n\t\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t\t},\n\t\n\t\t// Determine the position of an element within the set\n\t\tindex: function( elem ) {\n\t\n\t\t\t// No argument, return index in parent\n\t\t\tif ( !elem ) {\n\t\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t\t}\n\t\n\t\t\t// Index in selector\n\t\t\tif ( typeof elem === \"string\" ) {\n\t\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t\t}\n\t\n\t\t\t// Locate the position of the desired element\n\t\t\treturn indexOf.call( this,\n\t\n\t\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t\t);\n\t\t},\n\t\n\t\tadd: function( selector, context ) {\n\t\t\treturn this.pushStack(\n\t\t\t\tjQuery.uniqueSort(\n\t\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\t\n\t\taddBack: function( selector ) {\n\t\t\treturn this.add( selector == null ?\n\t\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t\t);\n\t\t}\n\t} );\n\t\n\tfunction sibling( cur, dir ) {\n\t\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\t\treturn cur;\n\t}\n\t\n\tjQuery.each( {\n\t\tparent: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t\t},\n\t\tparents: function( elem ) {\n\t\t\treturn dir( elem, \"parentNode\" );\n\t\t},\n\t\tparentsUntil: function( elem, i, until ) {\n\t\t\treturn dir( elem, \"parentNode\", until );\n\t\t},\n\t\tnext: function( elem ) {\n\t\t\treturn sibling( elem, \"nextSibling\" );\n\t\t},\n\t\tprev: function( elem ) {\n\t\t\treturn sibling( elem, \"previousSibling\" );\n\t\t},\n\t\tnextAll: function( elem ) {\n\t\t\treturn dir( elem, \"nextSibling\" );\n\t\t},\n\t\tprevAll: function( elem ) {\n\t\t\treturn dir( elem, \"previousSibling\" );\n\t\t},\n\t\tnextUntil: function( elem, i, until ) {\n\t\t\treturn dir( elem, \"nextSibling\", until );\n\t\t},\n\t\tprevUntil: function( elem, i, until ) {\n\t\t\treturn dir( elem, \"previousSibling\", until );\n\t\t},\n\t\tsiblings: function( elem ) {\n\t\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t\t},\n\t\tchildren: function( elem ) {\n\t\t\treturn siblings( elem.firstChild );\n\t\t},\n\t\tcontents: function( elem ) {\n\t\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t\t}\n\t}, function( name, fn ) {\n\t\tjQuery.fn[ name ] = function( until, selector ) {\n\t\t\tvar matched = jQuery.map( this, fn, until );\n\t\n\t\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\t\tselector = until;\n\t\t\t}\n\t\n\t\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t\t}\n\t\n\t\t\tif ( this.length > 1 ) {\n\t\n\t\t\t\t// Remove duplicates\n\t\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t\t}\n\t\n\t\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\t\tmatched.reverse();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this.pushStack( matched );\n\t\t};\n\t} );\n\tvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\t\n\t\n\t\n\t// Convert String-formatted options into Object-formatted ones\n\tfunction createOptions( options ) {\n\t\tvar object = {};\n\t\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\t\tobject[ flag ] = true;\n\t\t} );\n\t\treturn object;\n\t}\n\t\n\t/*\n\t * Create a callback list using the following parameters:\n\t *\n\t *\toptions: an optional list of space-separated options that will change how\n\t *\t\t\tthe callback list behaves or a more traditional option object\n\t *\n\t * By default a callback list will act like an event callback list and can be\n\t * \"fired\" multiple times.\n\t *\n\t * Possible options:\n\t *\n\t *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n\t *\n\t *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n\t *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n\t *\t\t\t\t\tvalues (like a Deferred)\n\t *\n\t *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n\t *\n\t *\tstopOnFalse:\tinterrupt callings when a callback returns false\n\t *\n\t */\n\tjQuery.Callbacks = function( options ) {\n\t\n\t\t// Convert options from String-formatted to Object-formatted if needed\n\t\t// (we check in cache first)\n\t\toptions = typeof options === \"string\" ?\n\t\t\tcreateOptions( options ) :\n\t\t\tjQuery.extend( {}, options );\n\t\n\t\tvar // Flag to know if list is currently firing\n\t\t\tfiring,\n\t\n\t\t\t// Last fire value for non-forgettable lists\n\t\t\tmemory,\n\t\n\t\t\t// Flag to know if list was already fired\n\t\t\tfired,\n\t\n\t\t\t// Flag to prevent firing\n\t\t\tlocked,\n\t\n\t\t\t// Actual callback list\n\t\t\tlist = [],\n\t\n\t\t\t// Queue of execution data for repeatable lists\n\t\t\tqueue = [],\n\t\n\t\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\t\tfiringIndex = -1,\n\t\n\t\t\t// Fire callbacks\n\t\t\tfire = function() {\n\t\n\t\t\t\t// Enforce single-firing\n\t\t\t\tlocked = options.once;\n\t\n\t\t\t\t// Execute callbacks for all pending executions,\n\t\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\t\tfired = firing = true;\n\t\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\t\tmemory = queue.shift();\n\t\t\t\t\twhile ( ++firingIndex < list.length ) {\n\t\n\t\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\t\toptions.stopOnFalse ) {\n\t\n\t\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Forget the data if we're done with it\n\t\t\t\tif ( !options.memory ) {\n\t\t\t\t\tmemory = false;\n\t\t\t\t}\n\t\n\t\t\t\tfiring = false;\n\t\n\t\t\t\t// Clean up if we're done firing for good\n\t\t\t\tif ( locked ) {\n\t\n\t\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\t\tif ( memory ) {\n\t\t\t\t\t\tlist = [];\n\t\n\t\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlist = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t// Actual Callbacks object\n\t\t\tself = {\n\t\n\t\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\t\tadd: function() {\n\t\t\t\t\tif ( list ) {\n\t\n\t\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\n\t\n\t\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} )( arguments );\n\t\n\t\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\t\tfire();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// Remove a callback from the list\n\t\t\t\tremove: function() {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// Check if a given callback is in the list.\n\t\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\t\thas: function( fn ) {\n\t\t\t\t\treturn fn ?\n\t\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\t\tlist.length > 0;\n\t\t\t\t},\n\t\n\t\t\t\t// Remove all callbacks from the list\n\t\t\t\tempty: function() {\n\t\t\t\t\tif ( list ) {\n\t\t\t\t\t\tlist = [];\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// Disable .fire and .add\n\t\t\t\t// Abort any current/pending executions\n\t\t\t\t// Clear all callbacks and values\n\t\t\t\tdisable: function() {\n\t\t\t\t\tlocked = queue = [];\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tdisabled: function() {\n\t\t\t\t\treturn !list;\n\t\t\t\t},\n\t\n\t\t\t\t// Disable .fire\n\t\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t\t// Abort any pending executions\n\t\t\t\tlock: function() {\n\t\t\t\t\tlocked = queue = [];\n\t\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tlocked: function() {\n\t\t\t\t\treturn !!locked;\n\t\t\t\t},\n\t\n\t\t\t\t// Call all callbacks with the given context and arguments\n\t\t\t\tfireWith: function( context, args ) {\n\t\t\t\t\tif ( !locked ) {\n\t\t\t\t\t\targs = args || [];\n\t\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\t\tqueue.push( args );\n\t\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\t\tfire();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// Call all the callbacks with the given arguments\n\t\t\t\tfire: function() {\n\t\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// To know if the callbacks have already been called at least once\n\t\t\t\tfired: function() {\n\t\t\t\t\treturn !!fired;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\treturn self;\n\t};\n\t\n\t\n\tfunction Identity( v ) {\n\t\treturn v;\n\t}\n\tfunction Thrower( ex ) {\n\t\tthrow ex;\n\t}\n\t\n\tfunction adoptValue( value, resolve, reject ) {\n\t\tvar method;\n\t\n\t\ttry {\n\t\n\t\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\t\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\n\t\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\t\n\t\t\t// Other thenables\n\t\t\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\n\t\t\t\tmethod.call( value, resolve, reject );\n\t\n\t\t\t// Other non-thenables\n\t\t\t} else {\n\t\n\t\t\t\t// Support: Android 4.0 only\n\t\t\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\t\t\tresolve.call( undefined, value );\n\t\t\t}\n\t\n\t\t// For Promises/A+, convert exceptions into rejections\n\t\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t\t// Deferred#then to conditionally suppress rejection.\n\t\t} catch ( value ) {\n\t\n\t\t\t// Support: Android 4.0 only\n\t\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\t\treject.call( undefined, value );\n\t\t}\n\t}\n\t\n\tjQuery.extend( {\n\t\n\t\tDeferred: function( func ) {\n\t\t\tvar tuples = [\n\t\n\t\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t\t],\n\t\t\t\tstate = \"pending\",\n\t\t\t\tpromise = {\n\t\t\t\t\tstate: function() {\n\t\t\t\t\t\treturn state;\n\t\t\t\t\t},\n\t\t\t\t\talways: function() {\n\t\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Keep pipe for back-compat\n\t\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\t\tvar fns = arguments;\n\t\n\t\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\n\t\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\t\n\t\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tfns = null;\n\t\t\t\t\t\t} ).promise();\n\t\t\t\t\t},\n\t\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\t\tvar returned, then;\n\t\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\t\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\t\tthen = returned &&\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\t\treturned.then;\n\t\n\t\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\t\tif ( jQuery.isFunction( then ) ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\t\n\t\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\n\t\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\n\t\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\t\tjQuery.isFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\t\tjQuery.isFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\t\tjQuery.isFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} ).promise();\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Get a promise for this deferred\n\t\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdeferred = {};\n\t\n\t\t\t// Add list-specific methods\n\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\tvar list = tuple[ 2 ],\n\t\t\t\t\tstateString = tuple[ 5 ];\n\t\n\t\t\t\t// promise.progress = list.add\n\t\t\t\t// promise.done = list.add\n\t\t\t\t// promise.fail = list.add\n\t\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\t\n\t\t\t\t// Handle state\n\t\t\t\tif ( stateString ) {\n\t\t\t\t\tlist.add(\n\t\t\t\t\t\tfunction() {\n\t\n\t\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t\t},\n\t\n\t\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\t\n\t\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\t\ttuples[ 0 ][ 2 ].lock\n\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\t// progress_handlers.fire\n\t\t\t\t// fulfilled_handlers.fire\n\t\t\t\t// rejected_handlers.fire\n\t\t\t\tlist.add( tuple[ 3 ].fire );\n\t\n\t\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\t\n\t\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t\t} );\n\t\n\t\t\t// Make the deferred a promise\n\t\t\tpromise.promise( deferred );\n\t\n\t\t\t// Call given func if any\n\t\t\tif ( func ) {\n\t\t\t\tfunc.call( deferred, deferred );\n\t\t\t}\n\t\n\t\t\t// All done!\n\t\t\treturn deferred;\n\t\t},\n\t\n\t\t// Deferred helper\n\t\twhen: function( singleValue ) {\n\t\t\tvar\n\t\n\t\t\t\t// count of uncompleted subordinates\n\t\t\t\tremaining = arguments.length,\n\t\n\t\t\t\t// count of unprocessed arguments\n\t\t\t\ti = remaining,\n\t\n\t\t\t\t// subordinate fulfillment data\n\t\t\t\tresolveContexts = Array( i ),\n\t\t\t\tresolveValues = slice.call( arguments ),\n\t\n\t\t\t\t// the master Deferred\n\t\t\t\tmaster = jQuery.Deferred(),\n\t\n\t\t\t\t// subordinate callback factory\n\t\t\t\tupdateFunc = function( i ) {\n\t\t\t\t\treturn function( value ) {\n\t\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\n\t\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\t\tif ( remaining <= 1 ) {\n\t\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );\n\t\n\t\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\t\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\t\n\t\t\t\t\treturn master.then();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\t\twhile ( i-- ) {\n\t\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t\t}\n\t\n\t\t\treturn master.promise();\n\t\t}\n\t} );\n\t\n\t\n\t// These usually indicate a programmer mistake during development,\n\t// warn about them ASAP rather than swallowing them by default.\n\tvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\t\n\tjQuery.Deferred.exceptionHook = function( error, stack ) {\n\t\n\t\t// Support: IE 8 - 9 only\n\t\t// Console exists when dev tools are open, which can happen at any time\n\t\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t\t}\n\t};\n\t\n\t\n\t\n\t\n\tjQuery.readyException = function( error ) {\n\t\twindow.setTimeout( function() {\n\t\t\tthrow error;\n\t\t} );\n\t};\n\t\n\t\n\t\n\t\n\t// The deferred used on DOM ready\n\tvar readyList = jQuery.Deferred();\n\t\n\tjQuery.fn.ready = function( fn ) {\n\t\n\t\treadyList\n\t\t\t.then( fn )\n\t\n\t\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t\t// happens at the time of error handling instead of callback\n\t\t\t// registration.\n\t\t\t.catch( function( error ) {\n\t\t\t\tjQuery.readyException( error );\n\t\t\t} );\n\t\n\t\treturn this;\n\t};\n\t\n\tjQuery.extend( {\n\t\n\t\t// Is the DOM ready to be used? Set to true once it occurs.\n\t\tisReady: false,\n\t\n\t\t// A counter to track how many items to wait for before\n\t\t// the ready event fires. See #6781\n\t\treadyWait: 1,\n\t\n\t\t// Hold (or release) the ready event\n\t\tholdReady: function( hold ) {\n\t\t\tif ( hold ) {\n\t\t\t\tjQuery.readyWait++;\n\t\t\t} else {\n\t\t\t\tjQuery.ready( true );\n\t\t\t}\n\t\t},\n\t\n\t\t// Handle when the DOM is ready\n\t\tready: function( wait ) {\n\t\n\t\t\t// Abort if there are pending holds or we're already ready\n\t\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Remember that the DOM is ready\n\t\t\tjQuery.isReady = true;\n\t\n\t\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// If there are functions bound, to execute\n\t\t\treadyList.resolveWith( document, [ jQuery ] );\n\t\t}\n\t} );\n\t\n\tjQuery.ready.then = readyList.then;\n\t\n\t// The ready event handler and self cleanup method\n\tfunction completed() {\n\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\t\twindow.removeEventListener( \"load\", completed );\n\t\tjQuery.ready();\n\t}\n\t\n\t// Catch cases where $(document).ready() is called\n\t// after the browser event has already occurred.\n\t// Support: IE <=9 - 10 only\n\t// Older IE sometimes signals \"interactive\" too soon\n\tif ( document.readyState === \"complete\" ||\n\t\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\t\n\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\twindow.setTimeout( jQuery.ready );\n\t\n\t} else {\n\t\n\t\t// Use the handy event callback\n\t\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\t\n\t\t// A fallback to window.onload, that will always work\n\t\twindow.addEventListener( \"load\", completed );\n\t}\n\t\n\t\n\t\n\t\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it's a function\n\tvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\t\tvar i = 0,\n\t\t\tlen = elems.length,\n\t\t\tbulk = key == null;\n\t\n\t\t// Sets many values\n\t\tif ( jQuery.type( key ) === \"object\" ) {\n\t\t\tchainable = true;\n\t\t\tfor ( i in key ) {\n\t\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t\t}\n\t\n\t\t// Sets one value\n\t\t} else if ( value !== undefined ) {\n\t\t\tchainable = true;\n\t\n\t\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\t\traw = true;\n\t\t\t}\n\t\n\t\t\tif ( bulk ) {\n\t\n\t\t\t\t// Bulk operations run against the entire set\n\t\t\t\tif ( raw ) {\n\t\t\t\t\tfn.call( elems, value );\n\t\t\t\t\tfn = null;\n\t\n\t\t\t\t// ...except when executing function values\n\t\t\t\t} else {\n\t\t\t\t\tbulk = fn;\n\t\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( fn ) {\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tfn(\n\t\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\t\tvalue :\n\t\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tif ( chainable ) {\n\t\t\treturn elems;\n\t\t}\n\t\n\t\t// Gets\n\t\tif ( bulk ) {\n\t\t\treturn fn.call( elems );\n\t\t}\n\t\n\t\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n\t};\n\tvar acceptData = function( owner ) {\n\t\n\t\t// Accepts only:\n\t\t//  - Node\n\t\t//    - Node.ELEMENT_NODE\n\t\t//    - Node.DOCUMENT_NODE\n\t\t//  - Object\n\t\t//    - Any\n\t\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n\t};\n\t\n\t\n\t\n\t\n\tfunction Data() {\n\t\tthis.expando = jQuery.expando + Data.uid++;\n\t}\n\t\n\tData.uid = 1;\n\t\n\tData.prototype = {\n\t\n\t\tcache: function( owner ) {\n\t\n\t\t\t// Check if the owner object already has a cache\n\t\t\tvar value = owner[ this.expando ];\n\t\n\t\t\t// If not, create one\n\t\t\tif ( !value ) {\n\t\t\t\tvalue = {};\n\t\n\t\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t\t// but we should not, see #8335.\n\t\t\t\t// Always return an empty object.\n\t\t\t\tif ( acceptData( owner ) ) {\n\t\n\t\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t\t// use plain assignment\n\t\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\t\towner[ this.expando ] = value;\n\t\n\t\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t\t// deleted when data is removed\n\t\t\t\t\t} else {\n\t\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn value;\n\t\t},\n\t\tset: function( owner, data, value ) {\n\t\t\tvar prop,\n\t\t\t\tcache = this.cache( owner );\n\t\n\t\t\t// Handle: [ owner, key, value ] args\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\tif ( typeof data === \"string\" ) {\n\t\t\t\tcache[ jQuery.camelCase( data ) ] = value;\n\t\n\t\t\t// Handle: [ owner, { properties } ] args\n\t\t\t} else {\n\t\n\t\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cache;\n\t\t},\n\t\tget: function( owner, key ) {\n\t\t\treturn key === undefined ?\n\t\t\t\tthis.cache( owner ) :\n\t\n\t\t\t\t// Always use camelCase key (gh-2257)\n\t\t\t\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\n\t\t},\n\t\taccess: function( owner, key, value ) {\n\t\n\t\t\t// In cases where either:\n\t\t\t//\n\t\t\t//   1. No key was specified\n\t\t\t//   2. A string key was specified, but no value provided\n\t\t\t//\n\t\t\t// Take the \"read\" path and allow the get method to determine\n\t\t\t// which value to return, respectively either:\n\t\t\t//\n\t\t\t//   1. The entire cache object\n\t\t\t//   2. The data stored at the key\n\t\t\t//\n\t\t\tif ( key === undefined ||\n\t\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\t\n\t\t\t\treturn this.get( owner, key );\n\t\t\t}\n\t\n\t\t\t// When the key is not a string, or both a key and value\n\t\t\t// are specified, set or extend (existing objects) with either:\n\t\t\t//\n\t\t\t//   1. An object of properties\n\t\t\t//   2. A key and value\n\t\t\t//\n\t\t\tthis.set( owner, key, value );\n\t\n\t\t\t// Since the \"set\" path can have two possible entry points\n\t\t\t// return the expected data based on which path was taken[*]\n\t\t\treturn value !== undefined ? value : key;\n\t\t},\n\t\tremove: function( owner, key ) {\n\t\t\tvar i,\n\t\t\t\tcache = owner[ this.expando ];\n\t\n\t\t\tif ( cache === undefined ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( key !== undefined ) {\n\t\n\t\t\t\t// Support array or space separated string of keys\n\t\t\t\tif ( jQuery.isArray( key ) ) {\n\t\n\t\t\t\t\t// If key is an array of keys...\n\t\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\t\tkey = key.map( jQuery.camelCase );\n\t\t\t\t} else {\n\t\t\t\t\tkey = jQuery.camelCase( key );\n\t\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tkey = key in cache ?\n\t\t\t\t\t\t[ key ] :\n\t\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t\t}\n\t\n\t\t\t\ti = key.length;\n\t\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Remove the expando if there's no more data\n\t\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\t\n\t\t\t\t// Support: Chrome <=35 - 45\n\t\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t\t} else {\n\t\t\t\t\tdelete owner[ this.expando ];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thasData: function( owner ) {\n\t\t\tvar cache = owner[ this.expando ];\n\t\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t\t}\n\t};\n\tvar dataPriv = new Data();\n\t\n\tvar dataUser = new Data();\n\t\n\t\n\t\n\t//\tImplementation Summary\n\t//\n\t//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n\t//\t2. Improve the module's maintainability by reducing the storage\n\t//\t\tpaths to a single mechanism.\n\t//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n\t//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n\t//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n\t//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\t\n\tvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\t\trmultiDash = /[A-Z]/g;\n\t\n\tfunction getData( data ) {\n\t\tif ( data === \"true\" ) {\n\t\t\treturn true;\n\t\t}\n\t\n\t\tif ( data === \"false\" ) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tif ( data === \"null\" ) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\t// Only convert to a number if it doesn't change the string\n\t\tif ( data === +data + \"\" ) {\n\t\t\treturn +data;\n\t\t}\n\t\n\t\tif ( rbrace.test( data ) ) {\n\t\t\treturn JSON.parse( data );\n\t\t}\n\t\n\t\treturn data;\n\t}\n\t\n\tfunction dataAttr( elem, key, data ) {\n\t\tvar name;\n\t\n\t\t// If nothing was found internally, try to fetch any\n\t\t// data from the HTML5 data-* attribute\n\t\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\t\tdata = elem.getAttribute( name );\n\t\n\t\t\tif ( typeof data === \"string\" ) {\n\t\t\t\ttry {\n\t\t\t\t\tdata = getData( data );\n\t\t\t\t} catch ( e ) {}\n\t\n\t\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\t\tdataUser.set( elem, key, data );\n\t\t\t} else {\n\t\t\t\tdata = undefined;\n\t\t\t}\n\t\t}\n\t\treturn data;\n\t}\n\t\n\tjQuery.extend( {\n\t\thasData: function( elem ) {\n\t\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t\t},\n\t\n\t\tdata: function( elem, name, data ) {\n\t\t\treturn dataUser.access( elem, name, data );\n\t\t},\n\t\n\t\tremoveData: function( elem, name ) {\n\t\t\tdataUser.remove( elem, name );\n\t\t},\n\t\n\t\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t\t// with direct calls to dataPriv methods, these can be deprecated.\n\t\t_data: function( elem, name, data ) {\n\t\t\treturn dataPriv.access( elem, name, data );\n\t\t},\n\t\n\t\t_removeData: function( elem, name ) {\n\t\t\tdataPriv.remove( elem, name );\n\t\t}\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\tdata: function( key, value ) {\n\t\t\tvar i, name, data,\n\t\t\t\telem = this[ 0 ],\n\t\t\t\tattrs = elem && elem.attributes;\n\t\n\t\t\t// Gets all values\n\t\t\tif ( key === undefined ) {\n\t\t\t\tif ( this.length ) {\n\t\t\t\t\tdata = dataUser.get( elem );\n\t\n\t\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\t\ti = attrs.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\n\t\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\t\t}\n\t\n\t\t\t// Sets multiple values\n\t\t\tif ( typeof key === \"object\" ) {\n\t\t\t\treturn this.each( function() {\n\t\t\t\t\tdataUser.set( this, key );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\treturn access( this, function( value ) {\n\t\t\t\tvar data;\n\t\n\t\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\t\tif ( elem && value === undefined ) {\n\t\n\t\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// Set the data...\n\t\t\t\tthis.each( function() {\n\t\n\t\t\t\t\t// We always store the camelCased key\n\t\t\t\t\tdataUser.set( this, key, value );\n\t\t\t\t} );\n\t\t\t}, null, value, arguments.length > 1, null, true );\n\t\t},\n\t\n\t\tremoveData: function( key ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.remove( this, key );\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\t\n\tjQuery.extend( {\n\t\tqueue: function( elem, type, data ) {\n\t\t\tvar queue;\n\t\n\t\t\tif ( elem ) {\n\t\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\t\tqueue = dataPriv.get( elem, type );\n\t\n\t\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\t\tif ( data ) {\n\t\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueue.push( data );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn queue || [];\n\t\t\t}\n\t\t},\n\t\n\t\tdequeue: function( elem, type ) {\n\t\t\ttype = type || \"fx\";\n\t\n\t\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\t\tstartLength = queue.length,\n\t\t\t\tfn = queue.shift(),\n\t\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\t\tnext = function() {\n\t\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t\t};\n\t\n\t\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\t\tif ( fn === \"inprogress\" ) {\n\t\t\t\tfn = queue.shift();\n\t\t\t\tstartLength--;\n\t\t\t}\n\t\n\t\t\tif ( fn ) {\n\t\n\t\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t\t// automatically dequeued\n\t\t\t\tif ( type === \"fx\" ) {\n\t\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Clear up the last queue stop function\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tfn.call( elem, next, hooks );\n\t\t\t}\n\t\n\t\t\tif ( !startLength && hooks ) {\n\t\t\t\thooks.empty.fire();\n\t\t\t}\n\t\t},\n\t\n\t\t// Not public - generate a queueHooks object, or return the current one\n\t\t_queueHooks: function( elem, type ) {\n\t\t\tvar key = type + \"queueHooks\";\n\t\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t\t} )\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\tqueue: function( type, data ) {\n\t\t\tvar setter = 2;\n\t\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tdata = type;\n\t\t\t\ttype = \"fx\";\n\t\t\t\tsetter--;\n\t\t\t}\n\t\n\t\t\tif ( arguments.length < setter ) {\n\t\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t\t}\n\t\n\t\t\treturn data === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function() {\n\t\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\t\n\t\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\t\tjQuery._queueHooks( this, type );\n\t\n\t\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t},\n\t\tdequeue: function( type ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t} );\n\t\t},\n\t\tclearQueue: function( type ) {\n\t\t\treturn this.queue( type || \"fx\", [] );\n\t\t},\n\t\n\t\t// Get a promise resolved when queues of a certain type\n\t\t// are emptied (fx is the type by default)\n\t\tpromise: function( type, obj ) {\n\t\t\tvar tmp,\n\t\t\t\tcount = 1,\n\t\t\t\tdefer = jQuery.Deferred(),\n\t\t\t\telements = this,\n\t\t\t\ti = this.length,\n\t\t\t\tresolve = function() {\n\t\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tobj = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\ttype = type || \"fx\";\n\t\n\t\t\twhile ( i-- ) {\n\t\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp.empty.add( resolve );\n\t\t\t\t}\n\t\t\t}\n\t\t\tresolve();\n\t\t\treturn defer.promise( obj );\n\t\t}\n\t} );\n\tvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\t\n\tvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\t\n\t\n\tvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\t\n\tvar isHiddenWithinTree = function( elem, el ) {\n\t\n\t\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t\t// in that case, element will be second argument\n\t\t\telem = el || elem;\n\t\n\t\t\t// Inline style trumps all\n\t\t\treturn elem.style.display === \"none\" ||\n\t\t\t\telem.style.display === \"\" &&\n\t\n\t\t\t\t// Otherwise, check computed style\n\t\t\t\t// Support: Firefox <=43 - 45\n\t\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t\t// in the document.\n\t\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\t\n\t\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t\t};\n\t\n\tvar swap = function( elem, options, callback, args ) {\n\t\tvar ret, name,\n\t\t\told = {};\n\t\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\t\n\t\tret = callback.apply( elem, args || [] );\n\t\n\t\t// Revert the old values\n\t\tfor ( name in options ) {\n\t\t\telem.style[ name ] = old[ name ];\n\t\t}\n\t\n\t\treturn ret;\n\t};\n\t\n\t\n\t\n\t\n\tfunction adjustCSS( elem, prop, valueParts, tween ) {\n\t\tvar adjusted,\n\t\t\tscale = 1,\n\t\t\tmaxIterations = 20,\n\t\t\tcurrentValue = tween ?\n\t\t\t\tfunction() {\n\t\t\t\t\treturn tween.cur();\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t\t},\n\t\t\tinitial = currentValue(),\n\t\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\t\n\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\t\n\t\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\t\n\t\t\t// Trust units reported by jQuery.css\n\t\t\tunit = unit || initialInUnit[ 3 ];\n\t\n\t\t\t// Make sure we update the tween properties later on\n\t\t\tvalueParts = valueParts || [];\n\t\n\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\tinitialInUnit = +initial || 1;\n\t\n\t\t\tdo {\n\t\n\t\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\t\tscale = scale || \".5\";\n\t\n\t\t\t\t// Adjust and apply\n\t\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\n\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t// Break the loop if scale is unchanged or perfect, or if we've just had enough.\n\t\t\t} while (\n\t\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t\t);\n\t\t}\n\t\n\t\tif ( valueParts ) {\n\t\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\t\n\t\t\t// Apply relative offset (+=/-=) if specified\n\t\t\tadjusted = valueParts[ 1 ] ?\n\t\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t\t+valueParts[ 2 ];\n\t\t\tif ( tween ) {\n\t\t\t\ttween.unit = unit;\n\t\t\t\ttween.start = initialInUnit;\n\t\t\t\ttween.end = adjusted;\n\t\t\t}\n\t\t}\n\t\treturn adjusted;\n\t}\n\t\n\t\n\tvar defaultDisplayMap = {};\n\t\n\tfunction getDefaultDisplay( elem ) {\n\t\tvar temp,\n\t\t\tdoc = elem.ownerDocument,\n\t\t\tnodeName = elem.nodeName,\n\t\t\tdisplay = defaultDisplayMap[ nodeName ];\n\t\n\t\tif ( display ) {\n\t\t\treturn display;\n\t\t}\n\t\n\t\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\t\tdisplay = jQuery.css( temp, \"display\" );\n\t\n\t\ttemp.parentNode.removeChild( temp );\n\t\n\t\tif ( display === \"none\" ) {\n\t\t\tdisplay = \"block\";\n\t\t}\n\t\tdefaultDisplayMap[ nodeName ] = display;\n\t\n\t\treturn display;\n\t}\n\t\n\tfunction showHide( elements, show ) {\n\t\tvar display, elem,\n\t\t\tvalues = [],\n\t\t\tindex = 0,\n\t\t\tlength = elements.length;\n\t\n\t\t// Determine new display value for elements that need to change\n\t\tfor ( ; index < length; index++ ) {\n\t\t\telem = elements[ index ];\n\t\t\tif ( !elem.style ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tdisplay = elem.style.display;\n\t\t\tif ( show ) {\n\t\n\t\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t\t// inline or about-to-be-restored)\n\t\t\t\tif ( display === \"none\" ) {\n\t\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ( display !== \"none\" ) {\n\t\t\t\t\tvalues[ index ] = \"none\";\n\t\n\t\t\t\t\t// Remember what we're overwriting\n\t\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Set the display of the elements in a second loop to avoid constant reflow\n\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\tif ( values[ index ] != null ) {\n\t\t\t\telements[ index ].style.display = values[ index ];\n\t\t\t}\n\t\t}\n\t\n\t\treturn elements;\n\t}\n\t\n\tjQuery.fn.extend( {\n\t\tshow: function() {\n\t\t\treturn showHide( this, true );\n\t\t},\n\t\thide: function() {\n\t\t\treturn showHide( this );\n\t\t},\n\t\ttoggle: function( state ) {\n\t\t\tif ( typeof state === \"boolean\" ) {\n\t\t\t\treturn state ? this.show() : this.hide();\n\t\t\t}\n\t\n\t\t\treturn this.each( function() {\n\t\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\t\tjQuery( this ).show();\n\t\t\t\t} else {\n\t\t\t\t\tjQuery( this ).hide();\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t} );\n\tvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\t\n\tvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\t\n\tvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\t\n\t\n\t\n\t// We have to close these tags to support XHTML (#13200)\n\tvar wrapMap = {\n\t\n\t\t// Support: IE <=9 only\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\t\n\t\t// XHTML parsers do not magically insert elements in the\n\t\t// same way that tag soup parsers do. So we cannot shorten\n\t\t// this by omitting <tbody> or other required elements.\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\t\n\t\t_default: [ 0, \"\", \"\" ]\n\t};\n\t\n\t// Support: IE <=9 only\n\twrapMap.optgroup = wrapMap.option;\n\t\n\twrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n\twrapMap.th = wrapMap.td;\n\t\n\t\n\tfunction getAll( context, tag ) {\n\t\n\t\t// Support: IE <=9 - 11 only\n\t\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\t\tvar ret;\n\t\n\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\tret = context.getElementsByTagName( tag || \"*\" );\n\t\n\t\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\t\tret = context.querySelectorAll( tag || \"*\" );\n\t\n\t\t} else {\n\t\t\tret = [];\n\t\t}\n\t\n\t\tif ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {\n\t\t\treturn jQuery.merge( [ context ], ret );\n\t\t}\n\t\n\t\treturn ret;\n\t}\n\t\n\t\n\t// Mark scripts as having already been evaluated\n\tfunction setGlobalEval( elems, refElements ) {\n\t\tvar i = 0,\n\t\t\tl = elems.length;\n\t\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tdataPriv.set(\n\t\t\t\telems[ i ],\n\t\t\t\t\"globalEval\",\n\t\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t\t);\n\t\t}\n\t}\n\t\n\t\n\tvar rhtml = /<|&#?\\w+;/;\n\t\n\tfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\tfragment = context.createDocumentFragment(),\n\t\t\tnodes = [],\n\t\t\ti = 0,\n\t\t\tl = elems.length;\n\t\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\t\n\t\t\tif ( elem || elem === 0 ) {\n\t\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\n\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\t\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\t\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\t\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\t\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\t\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\t\n\t\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = \"\";\n\t\n\t\ti = 0;\n\t\twhile ( ( elem = nodes[ i++ ] ) ) {\n\t\n\t\t\t// Skip elements already in the context collection (trac-4087)\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\t\tif ( ignored ) {\n\t\t\t\t\tignored.push( elem );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\t\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\t\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\t\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn fragment;\n\t}\n\t\n\t\n\t( function() {\n\t\tvar fragment = document.createDocumentFragment(),\n\t\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\t\tinput = document.createElement( \"input\" );\n\t\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Check state lost if the name is set (#11217)\n\t\t// Support: Windows Web Apps (WWA)\n\t\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\t\tinput.setAttribute( \"type\", \"radio\" );\n\t\tinput.setAttribute( \"checked\", \"checked\" );\n\t\tinput.setAttribute( \"name\", \"t\" );\n\t\n\t\tdiv.appendChild( input );\n\t\n\t\t// Support: Android <=4.1 only\n\t\t// Older WebKit doesn't clone checked state correctly in fragments\n\t\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\t\n\t\t// Support: IE <=11 only\n\t\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\t\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\t} )();\n\tvar documentElement = document.documentElement;\n\t\n\t\n\t\n\tvar\n\t\trkeyEvent = /^key/,\n\t\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\t\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\t\n\tfunction returnTrue() {\n\t\treturn true;\n\t}\n\t\n\tfunction returnFalse() {\n\t\treturn false;\n\t}\n\t\n\t// Support: IE <=9 only\n\t// See #13393 for more info\n\tfunction safeActiveElement() {\n\t\ttry {\n\t\t\treturn document.activeElement;\n\t\t} catch ( err ) { }\n\t}\n\t\n\tfunction on( elem, types, selector, data, fn, one ) {\n\t\tvar origFn, type;\n\t\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn elem;\n\t\t}\n\t\n\t\tif ( data == null && fn == null ) {\n\t\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn elem;\n\t\t}\n\t\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn elem.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t} );\n\t}\n\t\n\t/*\n\t * Helper functions for managing events -- not part of the public interface.\n\t * Props to Dean Edwards' addEvent library for many of the ideas.\n\t */\n\tjQuery.event = {\n\t\n\t\tglobal: {},\n\t\n\t\tadd: function( elem, types, handler, data, selector ) {\n\t\n\t\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\t\tevents, t, handleObj,\n\t\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\t\telemData = dataPriv.get( elem );\n\t\n\t\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\t\tif ( !elemData ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\t\tif ( handler.handler ) {\n\t\t\t\thandleObjIn = handler;\n\t\t\t\thandler = handleObjIn.handler;\n\t\t\t\tselector = handleObjIn.selector;\n\t\t\t}\n\t\n\t\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\t\tif ( selector ) {\n\t\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t\t}\n\t\n\t\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\t\tif ( !handler.guid ) {\n\t\t\t\thandler.guid = jQuery.guid++;\n\t\t\t}\n\t\n\t\t\t// Init the element's event structure and main handler, if this is the first\n\t\t\tif ( !( events = elemData.events ) ) {\n\t\t\t\tevents = elemData.events = {};\n\t\t\t}\n\t\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\t\teventHandle = elemData.handle = function( e ) {\n\t\n\t\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// Handle multiple events separated by a space\n\t\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\t\tt = types.length;\n\t\t\twhile ( t-- ) {\n\t\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\t\ttype = origType = tmp[ 1 ];\n\t\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\t\n\t\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\t\tif ( !type ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\n\t\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\n\t\t\t\t// Update special based on newly reset type\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\n\t\t\t\t// handleObj is passed to all event handlers\n\t\t\t\thandleObj = jQuery.extend( {\n\t\t\t\t\ttype: type,\n\t\t\t\t\torigType: origType,\n\t\t\t\t\tdata: data,\n\t\t\t\t\thandler: handler,\n\t\t\t\t\tguid: handler.guid,\n\t\t\t\t\tselector: selector,\n\t\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t\t}, handleObjIn );\n\t\n\t\t\t\t// Init the event handler queue if we're the first\n\t\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\t\thandlers.delegateCount = 0;\n\t\n\t\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\t\tif ( !special.setup ||\n\t\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\n\t\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif ( special.add ) {\n\t\t\t\t\tspecial.add.call( elem, handleObj );\n\t\n\t\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Add to the element's handler list, delegates in front\n\t\t\t\tif ( selector ) {\n\t\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t\t} else {\n\t\t\t\t\thandlers.push( handleObj );\n\t\t\t\t}\n\t\n\t\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\t\tjQuery.event.global[ type ] = true;\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t// Detach an event or set of events from an element\n\t\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\t\n\t\t\tvar j, origCount, tmp,\n\t\t\t\tevents, t, handleObj,\n\t\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\t\n\t\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Once for each type.namespace in types; type may be omitted\n\t\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\t\tt = types.length;\n\t\t\twhile ( t-- ) {\n\t\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\t\ttype = origType = tmp[ 1 ];\n\t\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\t\n\t\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\t\tif ( !type ) {\n\t\t\t\t\tfor ( type in events ) {\n\t\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\t\thandlers = events[ type ] || [];\n\t\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\t\n\t\t\t\t// Remove matching events\n\t\t\t\torigCount = j = handlers.length;\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\thandleObj = handlers[ j ];\n\t\n\t\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\t\thandlers.splice( j, 1 );\n\t\n\t\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\n\t\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdelete events[ type ];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Remove data and the expando if it's no longer used\n\t\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t\t}\n\t\t},\n\t\n\t\tdispatch: function( nativeEvent ) {\n\t\n\t\t\t// Make a writable jQuery.Event from the native event object\n\t\t\tvar event = jQuery.event.fix( nativeEvent );\n\t\n\t\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\t\targs = new Array( arguments.length ),\n\t\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\t\n\t\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\t\targs[ 0 ] = event;\n\t\n\t\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\t\targs[ i ] = arguments[ i ];\n\t\t\t}\n\t\n\t\t\tevent.delegateTarget = this;\n\t\n\t\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Determine handlers\n\t\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\t\n\t\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\t\ti = 0;\n\t\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\t\tevent.currentTarget = matched.elem;\n\t\n\t\t\t\tj = 0;\n\t\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\t\n\t\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\t\n\t\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\t\tevent.data = handleObj.data;\n\t\n\t\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\t\n\t\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Call the postDispatch hook for the mapped type\n\t\t\tif ( special.postDispatch ) {\n\t\t\t\tspecial.postDispatch.call( this, event );\n\t\t\t}\n\t\n\t\t\treturn event.result;\n\t\t},\n\t\n\t\thandlers: function( event, handlers ) {\n\t\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\t\thandlerQueue = [],\n\t\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\t\tcur = event.target;\n\t\n\t\t\t// Find delegate handlers\n\t\t\tif ( delegateCount &&\n\t\n\t\t\t\t// Support: IE <=9\n\t\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\t\tcur.nodeType &&\n\t\n\t\t\t\t// Support: Firefox <=42\n\t\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t\t// Support: IE 11 only\n\t\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\t\n\t\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\t\n\t\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\t\thandleObj = handlers[ i ];\n\t\n\t\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\t\n\t\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Add the remaining (directly-bound) handlers\n\t\t\tcur = this;\n\t\t\tif ( delegateCount < handlers.length ) {\n\t\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t\t}\n\t\n\t\t\treturn handlerQueue;\n\t\t},\n\t\n\t\taddProp: function( name, hook ) {\n\t\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\n\t\t\t\tget: jQuery.isFunction( hook ) ?\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t\t}\n\t\t\t\t\t} :\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\n\t\t\t\tset: function( value ) {\n\t\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tfix: function( originalEvent ) {\n\t\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\t\toriginalEvent :\n\t\t\t\tnew jQuery.Event( originalEvent );\n\t\t},\n\t\n\t\tspecial: {\n\t\t\tload: {\n\t\n\t\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\t\tnoBubble: true\n\t\t\t},\n\t\t\tfocus: {\n\t\n\t\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusin\"\n\t\t\t},\n\t\t\tblur: {\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\t\tthis.blur();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusout\"\n\t\t\t},\n\t\t\tclick: {\n\t\n\t\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\t\tthis.click();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t\t_default: function( event ) {\n\t\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tbeforeunload: {\n\t\t\t\tpostDispatch: function( event ) {\n\t\n\t\t\t\t\t// Support: Firefox 20+\n\t\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\tjQuery.removeEvent = function( elem, type, handle ) {\n\t\n\t\t// This \"if\" is needed for plain objects\n\t\tif ( elem.removeEventListener ) {\n\t\t\telem.removeEventListener( type, handle );\n\t\t}\n\t};\n\t\n\tjQuery.Event = function( src, props ) {\n\t\n\t\t// Allow instantiation without the 'new' keyword\n\t\tif ( !( this instanceof jQuery.Event ) ) {\n\t\t\treturn new jQuery.Event( src, props );\n\t\t}\n\t\n\t\t// Event object\n\t\tif ( src && src.type ) {\n\t\t\tthis.originalEvent = src;\n\t\t\tthis.type = src.type;\n\t\n\t\t\t// Events bubbling up the document may have been marked as prevented\n\t\t\t// by a handler lower down the tree; reflect the correct value.\n\t\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\n\t\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\t\tsrc.returnValue === false ?\n\t\t\t\treturnTrue :\n\t\t\t\treturnFalse;\n\t\n\t\t\t// Create target properties\n\t\t\t// Support: Safari <=6 - 7 only\n\t\t\t// Target should not be a text node (#504, #13143)\n\t\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\t\tsrc.target.parentNode :\n\t\t\t\tsrc.target;\n\t\n\t\t\tthis.currentTarget = src.currentTarget;\n\t\t\tthis.relatedTarget = src.relatedTarget;\n\t\n\t\t// Event type\n\t\t} else {\n\t\t\tthis.type = src;\n\t\t}\n\t\n\t\t// Put explicitly provided properties onto the event object\n\t\tif ( props ) {\n\t\t\tjQuery.extend( this, props );\n\t\t}\n\t\n\t\t// Create a timestamp if incoming event doesn't have one\n\t\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\t\n\t\t// Mark it as fixed\n\t\tthis[ jQuery.expando ] = true;\n\t};\n\t\n\t// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n\t// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\tjQuery.Event.prototype = {\n\t\tconstructor: jQuery.Event,\n\t\tisDefaultPrevented: returnFalse,\n\t\tisPropagationStopped: returnFalse,\n\t\tisImmediatePropagationStopped: returnFalse,\n\t\tisSimulated: false,\n\t\n\t\tpreventDefault: function() {\n\t\t\tvar e = this.originalEvent;\n\t\n\t\t\tthis.isDefaultPrevented = returnTrue;\n\t\n\t\t\tif ( e && !this.isSimulated ) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t},\n\t\tstopPropagation: function() {\n\t\t\tvar e = this.originalEvent;\n\t\n\t\t\tthis.isPropagationStopped = returnTrue;\n\t\n\t\t\tif ( e && !this.isSimulated ) {\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\t\t},\n\t\tstopImmediatePropagation: function() {\n\t\t\tvar e = this.originalEvent;\n\t\n\t\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\n\t\t\tif ( e && !this.isSimulated ) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t}\n\t\n\t\t\tthis.stopPropagation();\n\t\t}\n\t};\n\t\n\t// Includes all common event props including KeyEvent and MouseEvent specific props\n\tjQuery.each( {\n\t\taltKey: true,\n\t\tbubbles: true,\n\t\tcancelable: true,\n\t\tchangedTouches: true,\n\t\tctrlKey: true,\n\t\tdetail: true,\n\t\teventPhase: true,\n\t\tmetaKey: true,\n\t\tpageX: true,\n\t\tpageY: true,\n\t\tshiftKey: true,\n\t\tview: true,\n\t\t\"char\": true,\n\t\tcharCode: true,\n\t\tkey: true,\n\t\tkeyCode: true,\n\t\tbutton: true,\n\t\tbuttons: true,\n\t\tclientX: true,\n\t\tclientY: true,\n\t\toffsetX: true,\n\t\toffsetY: true,\n\t\tpointerId: true,\n\t\tpointerType: true,\n\t\tscreenX: true,\n\t\tscreenY: true,\n\t\ttargetTouches: true,\n\t\ttoElement: true,\n\t\ttouches: true,\n\t\n\t\twhich: function( event ) {\n\t\t\tvar button = event.button;\n\t\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t\t}\n\t\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\t\tif ( button & 1 ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\n\t\t\t\tif ( button & 2 ) {\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\n\t\t\t\tif ( button & 4 ) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\treturn event.which;\n\t\t}\n\t}, jQuery.event.addProp );\n\t\n\t// Create mouseenter/leave events using mouseover/out and event-time checks\n\t// so that event delegation works in jQuery.\n\t// Do the same for pointerenter/pointerleave and pointerover/pointerout\n\t//\n\t// Support: Safari 7 only\n\t// Safari sends mouseenter too often; see:\n\t// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n\t// for the description of the bug (it existed in older Chrome versions as well).\n\tjQuery.each( {\n\t\tmouseenter: \"mouseover\",\n\t\tmouseleave: \"mouseout\",\n\t\tpointerenter: \"pointerover\",\n\t\tpointerleave: \"pointerout\"\n\t}, function( orig, fix ) {\n\t\tjQuery.event.special[ orig ] = {\n\t\t\tdelegateType: fix,\n\t\t\tbindType: fix,\n\t\n\t\t\thandle: function( event ) {\n\t\t\t\tvar ret,\n\t\t\t\t\ttarget = this,\n\t\t\t\t\trelated = event.relatedTarget,\n\t\t\t\t\thandleObj = event.handleObj;\n\t\n\t\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\t\tevent.type = fix;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t};\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\n\t\ton: function( types, selector, data, fn ) {\n\t\t\treturn on( this, types, selector, data, fn );\n\t\t},\n\t\tone: function( types, selector, data, fn ) {\n\t\t\treturn on( this, types, selector, data, fn, 1 );\n\t\t},\n\t\toff: function( types, selector, fn ) {\n\t\t\tvar handleObj, type;\n\t\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\n\t\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\t\thandleObj = types.handleObj;\n\t\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\t\thandleObj.namespace ?\n\t\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\t\thandleObj.origType,\n\t\t\t\t\thandleObj.selector,\n\t\t\t\t\thandleObj.handler\n\t\t\t\t);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ( typeof types === \"object\" ) {\n\t\n\t\t\t\t// ( types-object [, selector] )\n\t\t\t\tfor ( type in types ) {\n\t\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\n\t\t\t\t// ( types [, fn] )\n\t\t\t\tfn = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tif ( fn === false ) {\n\t\t\t\tfn = returnFalse;\n\t\t\t}\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\t\n\tvar\n\t\n\t\t/* eslint-disable max-len */\n\t\n\t\t// See https://github.com/eslint/eslint/issues/3229\n\t\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\t\n\t\t/* eslint-enable */\n\t\n\t\t// Support: IE <=10 - 11, Edge 12 - 13\n\t\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\t\trnoInnerhtml = /<script|<style|<link/i,\n\t\n\t\t// checked=\"checked\" or checked\n\t\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\t\trscriptTypeMasked = /^true\\/(.*)/,\n\t\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\t\n\tfunction manipulationTarget( elem, content ) {\n\t\tif ( jQuery.nodeName( elem, \"table\" ) &&\n\t\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\t\n\t\t\treturn elem.getElementsByTagName( \"tbody\" )[ 0 ] || elem;\n\t\t}\n\t\n\t\treturn elem;\n\t}\n\t\n\t// Replace/restore the type attribute of script elements for safe DOM manipulation\n\tfunction disableScript( elem ) {\n\t\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\t\treturn elem;\n\t}\n\tfunction restoreScript( elem ) {\n\t\tvar match = rscriptTypeMasked.exec( elem.type );\n\t\n\t\tif ( match ) {\n\t\t\telem.type = match[ 1 ];\n\t\t} else {\n\t\t\telem.removeAttribute( \"type\" );\n\t\t}\n\t\n\t\treturn elem;\n\t}\n\t\n\tfunction cloneCopyEvent( src, dest ) {\n\t\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\t\n\t\tif ( dest.nodeType !== 1 ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// 1. Copy private data: events, handlers, etc.\n\t\tif ( dataPriv.hasData( src ) ) {\n\t\t\tpdataOld = dataPriv.access( src );\n\t\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\t\tevents = pdataOld.events;\n\t\n\t\t\tif ( events ) {\n\t\t\t\tdelete pdataCur.handle;\n\t\t\t\tpdataCur.events = {};\n\t\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// 2. Copy user data\n\t\tif ( dataUser.hasData( src ) ) {\n\t\t\tudataOld = dataUser.access( src );\n\t\t\tudataCur = jQuery.extend( {}, udataOld );\n\t\n\t\t\tdataUser.set( dest, udataCur );\n\t\t}\n\t}\n\t\n\t// Fix IE bugs, see support tests\n\tfunction fixInput( src, dest ) {\n\t\tvar nodeName = dest.nodeName.toLowerCase();\n\t\n\t\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\t\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\t\tdest.checked = src.checked;\n\t\n\t\t// Fails to return the selected option to the default selected state when cloning options\n\t\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\t\tdest.defaultValue = src.defaultValue;\n\t\t}\n\t}\n\t\n\tfunction domManip( collection, args, callback, ignored ) {\n\t\n\t\t// Flatten any nested arrays\n\t\targs = concat.apply( [], args );\n\t\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\ti = 0,\n\t\t\tl = collection.length,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[ 0 ],\n\t\t\tisFunction = jQuery.isFunction( value );\n\t\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction ||\n\t\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\treturn collection.each( function( index ) {\n\t\t\t\tvar self = collection.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tdomManip( self, args, callback, ignored );\n\t\t\t} );\n\t\t}\n\t\n\t\tif ( l ) {\n\t\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\t\tfirst = fragment.firstChild;\n\t\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\t\n\t\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\t\tif ( first || ignored ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\t\n\t\t\t\t// Use the original fragment for the last item\n\t\t\t\t// instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\t\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\t\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\n\t\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\t\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\t\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\t\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\n\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn collection;\n\t}\n\t\n\tfunction remove( elem, selector, keepData ) {\n\t\tvar node,\n\t\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\t\ti = 0;\n\t\n\t\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t\t}\n\t\n\t\t\tif ( node.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t\t}\n\t\t\t\tnode.parentNode.removeChild( node );\n\t\t\t}\n\t\t}\n\t\n\t\treturn elem;\n\t}\n\t\n\tjQuery.extend( {\n\t\thtmlPrefilter: function( html ) {\n\t\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t\t},\n\t\n\t\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\t\tvar i, l, srcElements, destElements,\n\t\t\t\tclone = elem.cloneNode( true ),\n\t\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\t\n\t\t\t// Fix IE cloning issues\n\t\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\t\n\t\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\t\tdestElements = getAll( clone );\n\t\t\t\tsrcElements = getAll( elem );\n\t\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Copy the events from the original to the clone\n\t\t\tif ( dataAndEvents ) {\n\t\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\t\tdestElements = destElements || getAll( clone );\n\t\n\t\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Preserve script evaluation history\n\t\t\tdestElements = getAll( clone, \"script\" );\n\t\t\tif ( destElements.length > 0 ) {\n\t\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t\t}\n\t\n\t\t\t// Return the cloned set\n\t\t\treturn clone;\n\t\t},\n\t\n\t\tcleanData: function( elems ) {\n\t\t\tvar data, elem, type,\n\t\t\t\tspecial = jQuery.event.special,\n\t\t\t\ti = 0;\n\t\n\t\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\t\n\t\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\t\n\t\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\tdetach: function( selector ) {\n\t\t\treturn remove( this, selector, true );\n\t\t},\n\t\n\t\tremove: function( selector ) {\n\t\t\treturn remove( this, selector );\n\t\t},\n\t\n\t\ttext: function( value ) {\n\t\t\treturn access( this, function( value ) {\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\tjQuery.text( this ) :\n\t\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t}, null, value, arguments.length );\n\t\t},\n\t\n\t\tappend: function() {\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\t\ttarget.appendChild( elem );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tprepend: function() {\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tbefore: function() {\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tif ( this.parentNode ) {\n\t\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tafter: function() {\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tif ( this.parentNode ) {\n\t\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tempty: function() {\n\t\t\tvar elem,\n\t\t\t\ti = 0;\n\t\n\t\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\n\t\t\t\t\t// Prevent memory leaks\n\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\n\t\t\t\t\t// Remove any remaining nodes\n\t\t\t\t\telem.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\t\n\t\t\treturn this.map( function() {\n\t\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t\t} );\n\t\t},\n\t\n\t\thtml: function( value ) {\n\t\t\treturn access( this, function( value ) {\n\t\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\t\ti = 0,\n\t\t\t\t\tl = this.length;\n\t\n\t\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\t\treturn elem.innerHTML;\n\t\t\t\t}\n\t\n\t\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\t\n\t\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\t\telem = this[ i ] || {};\n\t\n\t\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\telem = 0;\n\t\n\t\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t\t} catch ( e ) {}\n\t\t\t\t}\n\t\n\t\t\t\tif ( elem ) {\n\t\t\t\t\tthis.empty().append( value );\n\t\t\t\t}\n\t\t\t}, null, value, arguments.length );\n\t\t},\n\t\n\t\treplaceWith: function() {\n\t\t\tvar ignored = [];\n\t\n\t\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tvar parent = this.parentNode;\n\t\n\t\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\t\tif ( parent ) {\n\t\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t// Force callback invocation\n\t\t\t}, ignored );\n\t\t}\n\t} );\n\t\n\tjQuery.each( {\n\t\tappendTo: \"append\",\n\t\tprependTo: \"prepend\",\n\t\tinsertBefore: \"before\",\n\t\tinsertAfter: \"after\",\n\t\treplaceAll: \"replaceWith\"\n\t}, function( name, original ) {\n\t\tjQuery.fn[ name ] = function( selector ) {\n\t\t\tvar elems,\n\t\t\t\tret = [],\n\t\t\t\tinsert = jQuery( selector ),\n\t\t\t\tlast = insert.length - 1,\n\t\t\t\ti = 0;\n\t\n\t\t\tfor ( ; i <= last; i++ ) {\n\t\t\t\telems = i === last ? this : this.clone( true );\n\t\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\t\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tpush.apply( ret, elems.get() );\n\t\t\t}\n\t\n\t\t\treturn this.pushStack( ret );\n\t\t};\n\t} );\n\tvar rmargin = ( /^margin/ );\n\t\n\tvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\t\n\tvar getStyles = function( elem ) {\n\t\n\t\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t\t// IE throws on elements created in popups\n\t\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\t\tvar view = elem.ownerDocument.defaultView;\n\t\n\t\t\tif ( !view || !view.opener ) {\n\t\t\t\tview = window;\n\t\t\t}\n\t\n\t\t\treturn view.getComputedStyle( elem );\n\t\t};\n\t\n\t\n\t\n\t( function() {\n\t\n\t\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t\t// so they're executed at the same time to save the second computation.\n\t\tfunction computeStyleTests() {\n\t\n\t\t\t// This is a singleton, we need to execute it only once\n\t\t\tif ( !div ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tdiv.style.cssText =\n\t\t\t\t\"box-sizing:border-box;\" +\n\t\t\t\t\"position:relative;display:block;\" +\n\t\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\t\"top:1%;width:50%\";\n\t\t\tdiv.innerHTML = \"\";\n\t\t\tdocumentElement.appendChild( container );\n\t\n\t\t\tvar divStyle = window.getComputedStyle( div );\n\t\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\t\n\t\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\t\treliableMarginLeftVal = divStyle.marginLeft === \"2px\";\n\t\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\t\n\t\t\t// Support: Android 4.0 - 4.3 only\n\t\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\t\tdiv.style.marginRight = \"50%\";\n\t\t\tpixelMarginRightVal = divStyle.marginRight === \"4px\";\n\t\n\t\t\tdocumentElement.removeChild( container );\n\t\n\t\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t\t// it will also be a sign that checks already performed\n\t\t\tdiv = null;\n\t\t}\n\t\n\t\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\n\t\t\tcontainer = document.createElement( \"div\" ),\n\t\t\tdiv = document.createElement( \"div\" );\n\t\n\t\t// Finish early in limited (non-browser) environments\n\t\tif ( !div.style ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// Support: IE <=9 - 11 only\n\t\t// Style of cloned element affects source element cloned (#8908)\n\t\tdiv.style.backgroundClip = \"content-box\";\n\t\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\t\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\t\n\t\tcontainer.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\n\t\t\t\"padding:0;margin-top:1px;position:absolute\";\n\t\tcontainer.appendChild( div );\n\t\n\t\tjQuery.extend( support, {\n\t\t\tpixelPosition: function() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn pixelPositionVal;\n\t\t\t},\n\t\t\tboxSizingReliable: function() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn boxSizingReliableVal;\n\t\t\t},\n\t\t\tpixelMarginRight: function() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn pixelMarginRightVal;\n\t\t\t},\n\t\t\treliableMarginLeft: function() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn reliableMarginLeftVal;\n\t\t\t}\n\t\t} );\n\t} )();\n\t\n\t\n\tfunction curCSS( elem, name, computed ) {\n\t\tvar width, minWidth, maxWidth, ret,\n\t\t\tstyle = elem.style;\n\t\n\t\tcomputed = computed || getStyles( elem );\n\t\n\t\t// Support: IE <=9 only\n\t\t// getPropertyValue is only needed for .css('filter') (#12537)\n\t\tif ( computed ) {\n\t\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\t\n\t\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\tret = jQuery.style( elem, name );\n\t\t\t}\n\t\n\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t\t// Android Browser returns percentage for some values,\n\t\t\t// but width seems to be reliably pixels.\n\t\t\t// This is against the CSSOM draft spec:\n\t\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\t\n\t\t\t\t// Remember the original values\n\t\t\t\twidth = style.width;\n\t\t\t\tminWidth = style.minWidth;\n\t\t\t\tmaxWidth = style.maxWidth;\n\t\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\tret = computed.width;\n\t\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.width = width;\n\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t}\n\t\t}\n\t\n\t\treturn ret !== undefined ?\n\t\n\t\t\t// Support: IE <=9 - 11 only\n\t\t\t// IE returns zIndex value as an integer.\n\t\t\tret + \"\" :\n\t\t\tret;\n\t}\n\t\n\t\n\tfunction addGetHookIf( conditionFn, hookFn ) {\n\t\n\t\t// Define the hook, we'll check on the first run if it's really needed.\n\t\treturn {\n\t\t\tget: function() {\n\t\t\t\tif ( conditionFn() ) {\n\t\n\t\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t\t// to missing dependency), remove it.\n\t\t\t\t\tdelete this.get;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t\t}\n\t\t};\n\t}\n\t\n\t\n\tvar\n\t\n\t\t// Swappable if display is none or starts with table\n\t\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\t\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\t\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\t\tcssNormalTransform = {\n\t\t\tletterSpacing: \"0\",\n\t\t\tfontWeight: \"400\"\n\t\t},\n\t\n\t\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\t\temptyStyle = document.createElement( \"div\" ).style;\n\t\n\t// Return a css property mapped to a potentially vendor prefixed property\n\tfunction vendorPropName( name ) {\n\t\n\t\t// Shortcut for names that are not vendor prefixed\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t\n\t\t// Check for vendor prefixed names\n\t\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\t\ti = cssPrefixes.length;\n\t\n\t\twhile ( i-- ) {\n\t\t\tname = cssPrefixes[ i ] + capName;\n\t\t\tif ( name in emptyStyle ) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction setPositiveNumber( elem, value, subtract ) {\n\t\n\t\t// Any relative (+/-) values have already been\n\t\t// normalized at this point\n\t\tvar matches = rcssNum.exec( value );\n\t\treturn matches ?\n\t\n\t\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\t\tvalue;\n\t}\n\t\n\tfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\t\tvar i,\n\t\t\tval = 0;\n\t\n\t\t// If we already have the right measurement, avoid augmentation\n\t\tif ( extra === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\t\ti = 4;\n\t\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\t} else {\n\t\t\ti = name === \"width\" ? 1 : 0;\n\t\t}\n\t\n\t\tfor ( ; i < 4; i += 2 ) {\n\t\n\t\t\t// Both box models exclude margin, so add it if we want it\n\t\t\tif ( extra === \"margin\" ) {\n\t\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t\t}\n\t\n\t\t\tif ( isBorderBox ) {\n\t\n\t\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\t\tif ( extra === \"content\" ) {\n\t\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t\t}\n\t\n\t\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t\t}\n\t\t\t} else {\n\t\n\t\t\t\t// At this point, extra isn't content, so add padding\n\t\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\n\t\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn val;\n\t}\n\t\n\tfunction getWidthOrHeight( elem, name, extra ) {\n\t\n\t\t// Start with offset property, which is equivalent to the border-box value\n\t\tvar val,\n\t\t\tvalueIsBorderBox = true,\n\t\t\tstyles = getStyles( elem ),\n\t\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\t\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a disconnected node\n\t\t// in IE throws an error.\n\t\tif ( elem.getClientRects().length ) {\n\t\t\tval = elem.getBoundingClientRect()[ name ];\n\t\t}\n\t\n\t\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\t\tif ( val <= 0 || val == null ) {\n\t\n\t\t\t// Fall back to computed then uncomputed css if necessary\n\t\t\tval = curCSS( elem, name, styles );\n\t\t\tif ( val < 0 || val == null ) {\n\t\t\t\tval = elem.style[ name ];\n\t\t\t}\n\t\n\t\t\t// Computed unit is not pixels. Stop here and return.\n\t\t\tif ( rnumnonpx.test( val ) ) {\n\t\t\t\treturn val;\n\t\t\t}\n\t\n\t\t\t// Check for style in case a browser which returns unreliable values\n\t\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\t\n\t\t\t// Normalize \"\", auto, and prepare for extra\n\t\t\tval = parseFloat( val ) || 0;\n\t\t}\n\t\n\t\t// Use the active box-sizing model to add/subtract irrelevant styles\n\t\treturn ( val +\n\t\t\taugmentWidthOrHeight(\n\t\t\t\telem,\n\t\t\t\tname,\n\t\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\t\tvalueIsBorderBox,\n\t\t\t\tstyles\n\t\t\t)\n\t\t) + \"px\";\n\t}\n\t\n\tjQuery.extend( {\n\t\n\t\t// Add in style property hooks for overriding the default\n\t\t// behavior of getting and setting a style property\n\t\tcssHooks: {\n\t\t\topacity: {\n\t\t\t\tget: function( elem, computed ) {\n\t\t\t\t\tif ( computed ) {\n\t\n\t\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\t// Don't automatically add \"px\" to these possibly-unitless properties\n\t\tcssNumber: {\n\t\t\t\"animationIterationCount\": true,\n\t\t\t\"columnCount\": true,\n\t\t\t\"fillOpacity\": true,\n\t\t\t\"flexGrow\": true,\n\t\t\t\"flexShrink\": true,\n\t\t\t\"fontWeight\": true,\n\t\t\t\"lineHeight\": true,\n\t\t\t\"opacity\": true,\n\t\t\t\"order\": true,\n\t\t\t\"orphans\": true,\n\t\t\t\"widows\": true,\n\t\t\t\"zIndex\": true,\n\t\t\t\"zoom\": true\n\t\t},\n\t\n\t\t// Add in properties whose names you wish to fix before\n\t\t// setting or getting the value\n\t\tcssProps: {\n\t\t\t\"float\": \"cssFloat\"\n\t\t},\n\t\n\t\t// Get and set the style property on a DOM Node\n\t\tstyle: function( elem, name, value, extra ) {\n\t\n\t\t\t// Don't set styles on text and comment nodes\n\t\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Make sure that we're working with the right name\n\t\t\tvar ret, type, hooks,\n\t\t\t\torigName = jQuery.camelCase( name ),\n\t\t\t\tstyle = elem.style;\n\t\n\t\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\t\n\t\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\t\n\t\t\t// Check if we're setting a value\n\t\t\tif ( value !== undefined ) {\n\t\t\t\ttype = typeof value;\n\t\n\t\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\t\n\t\t\t\t\t// Fixes bug #9237\n\t\t\t\t\ttype = \"number\";\n\t\t\t\t}\n\t\n\t\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\t\tif ( value == null || value !== value ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\t\tif ( type === \"number\" ) {\n\t\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t\t}\n\t\n\t\t\t\t// background-* props affect original clone's values\n\t\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t\t}\n\t\n\t\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\t\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\t\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\n\t\t\t\t// Otherwise just get the value from the style object\n\t\t\t\treturn style[ name ];\n\t\t\t}\n\t\t},\n\t\n\t\tcss: function( elem, name, extra, styles ) {\n\t\t\tvar val, num, hooks,\n\t\t\t\torigName = jQuery.camelCase( name );\n\t\n\t\t\t// Make sure that we're working with the right name\n\t\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\t\n\t\t\t// Try prefixed name followed by the unprefixed name\n\t\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\t\n\t\t\t// If a hook was provided get the computed value from there\n\t\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\t\tval = hooks.get( elem, true, extra );\n\t\t\t}\n\t\n\t\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\t\tif ( val === undefined ) {\n\t\t\t\tval = curCSS( elem, name, styles );\n\t\t\t}\n\t\n\t\t\t// Convert \"normal\" to computed value\n\t\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\t\tval = cssNormalTransform[ name ];\n\t\t\t}\n\t\n\t\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\t\tif ( extra === \"\" || extra ) {\n\t\t\t\tnum = parseFloat( val );\n\t\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t} );\n\t\n\tjQuery.each( [ \"height\", \"width\" ], function( i, name ) {\n\t\tjQuery.cssHooks[ name ] = {\n\t\t\tget: function( elem, computed, extra ) {\n\t\t\t\tif ( computed ) {\n\t\n\t\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\t\n\t\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t\t} ) :\n\t\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tset: function( elem, value, extra ) {\n\t\t\t\tvar matches,\n\t\t\t\t\tstyles = extra && getStyles( elem ),\n\t\t\t\t\tsubtract = extra && augmentWidthOrHeight(\n\t\t\t\t\t\telem,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\textra,\n\t\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\t\tstyles\n\t\t\t\t\t);\n\t\n\t\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\t\n\t\t\t\t\telem.style[ name ] = value;\n\t\t\t\t\tvalue = jQuery.css( elem, name );\n\t\t\t\t}\n\t\n\t\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t\t}\n\t\t};\n\t} );\n\t\n\tjQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t\t} )\n\t\t\t\t\t) + \"px\";\n\t\t\t}\n\t\t}\n\t);\n\t\n\t// These hooks are used by animate to expand properties\n\tjQuery.each( {\n\t\tmargin: \"\",\n\t\tpadding: \"\",\n\t\tborder: \"Width\"\n\t}, function( prefix, suffix ) {\n\t\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\t\texpand: function( value ) {\n\t\t\t\tvar i = 0,\n\t\t\t\t\texpanded = {},\n\t\n\t\t\t\t\t// Assumes a single number if not a string\n\t\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\t\n\t\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t\t}\n\t\n\t\t\t\treturn expanded;\n\t\t\t}\n\t\t};\n\t\n\t\tif ( !rmargin.test( prefix ) ) {\n\t\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t\t}\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\tcss: function( name, value ) {\n\t\t\treturn access( this, function( elem, name, value ) {\n\t\t\t\tvar styles, len,\n\t\t\t\t\tmap = {},\n\t\t\t\t\ti = 0;\n\t\n\t\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\t\tstyles = getStyles( elem );\n\t\t\t\t\tlen = name.length;\n\t\n\t\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\t\n\t\t\t\treturn value !== undefined ?\n\t\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\t\tjQuery.css( elem, name );\n\t\t\t}, name, value, arguments.length > 1 );\n\t\t}\n\t} );\n\t\n\t\n\tfunction Tween( elem, options, prop, end, easing ) {\n\t\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n\t}\n\tjQuery.Tween = Tween;\n\t\n\tTween.prototype = {\n\t\tconstructor: Tween,\n\t\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\t\tthis.elem = elem;\n\t\t\tthis.prop = prop;\n\t\t\tthis.easing = easing || jQuery.easing._default;\n\t\t\tthis.options = options;\n\t\t\tthis.start = this.now = this.cur();\n\t\t\tthis.end = end;\n\t\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t\t},\n\t\tcur: function() {\n\t\t\tvar hooks = Tween.propHooks[ this.prop ];\n\t\n\t\t\treturn hooks && hooks.get ?\n\t\t\t\thooks.get( this ) :\n\t\t\t\tTween.propHooks._default.get( this );\n\t\t},\n\t\trun: function( percent ) {\n\t\t\tvar eased,\n\t\t\t\thooks = Tween.propHooks[ this.prop ];\n\t\n\t\t\tif ( this.options.duration ) {\n\t\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.pos = eased = percent;\n\t\t\t}\n\t\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\t\n\t\t\tif ( this.options.step ) {\n\t\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t\t}\n\t\n\t\t\tif ( hooks && hooks.set ) {\n\t\t\t\thooks.set( this );\n\t\t\t} else {\n\t\t\t\tTween.propHooks._default.set( this );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t};\n\t\n\tTween.prototype.init.prototype = Tween.prototype;\n\t\n\tTween.propHooks = {\n\t\t_default: {\n\t\t\tget: function( tween ) {\n\t\t\t\tvar result;\n\t\n\t\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t\t// or when there is no matching style property that exists.\n\t\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t\t}\n\t\n\t\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\n\t\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t\t},\n\t\t\tset: function( tween ) {\n\t\n\t\t\t\t// Use step hook for back compat.\n\t\t\t\t// Use cssHook if its there.\n\t\t\t\t// Use .style if available and use plain properties where available.\n\t\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t\t} else {\n\t\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\t// Support: IE <=9 only\n\t// Panic based approach to setting things on disconnected nodes\n\tTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\t\tset: function( tween ) {\n\t\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t};\n\t\n\tjQuery.easing = {\n\t\tlinear: function( p ) {\n\t\t\treturn p;\n\t\t},\n\t\tswing: function( p ) {\n\t\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t\t},\n\t\t_default: \"swing\"\n\t};\n\t\n\tjQuery.fx = Tween.prototype.init;\n\t\n\t// Back compat <1.8 extension point\n\tjQuery.fx.step = {};\n\t\n\t\n\t\n\t\n\tvar\n\t\tfxNow, timerId,\n\t\trfxtypes = /^(?:toggle|show|hide)$/,\n\t\trrun = /queueHooks$/;\n\t\n\tfunction raf() {\n\t\tif ( timerId ) {\n\t\t\twindow.requestAnimationFrame( raf );\n\t\t\tjQuery.fx.tick();\n\t\t}\n\t}\n\t\n\t// Animations created synchronously will run synchronously\n\tfunction createFxNow() {\n\t\twindow.setTimeout( function() {\n\t\t\tfxNow = undefined;\n\t\t} );\n\t\treturn ( fxNow = jQuery.now() );\n\t}\n\t\n\t// Generate parameters to create a standard animation\n\tfunction genFx( type, includeWidth ) {\n\t\tvar which,\n\t\t\ti = 0,\n\t\t\tattrs = { height: type };\n\t\n\t\t// If we include width, step value is 1 to do all cssExpand values,\n\t\t// otherwise step value is 2 to skip over Left and Right\n\t\tincludeWidth = includeWidth ? 1 : 0;\n\t\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\t\twhich = cssExpand[ i ];\n\t\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t\t}\n\t\n\t\tif ( includeWidth ) {\n\t\t\tattrs.opacity = attrs.width = type;\n\t\t}\n\t\n\t\treturn attrs;\n\t}\n\t\n\tfunction createTween( value, prop, animation ) {\n\t\tvar tween,\n\t\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\t\tindex = 0,\n\t\t\tlength = collection.length;\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\t\n\t\t\t\t// We're done with this property\n\t\t\t\treturn tween;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction defaultPrefilter( elem, props, opts ) {\n\t\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\t\tisBox = \"width\" in props || \"height\" in props,\n\t\t\tanim = this,\n\t\t\torig = {},\n\t\t\tstyle = elem.style,\n\t\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\t\n\t\t// Queue-skipping animations hijack the fx hooks\n\t\tif ( !opts.queue ) {\n\t\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\t\tif ( hooks.unqueued == null ) {\n\t\t\t\thooks.unqueued = 0;\n\t\t\t\toldfire = hooks.empty.fire;\n\t\t\t\thooks.empty.fire = function() {\n\t\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\t\toldfire();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\thooks.unqueued++;\n\t\n\t\t\tanim.always( function() {\n\t\n\t\t\t\t// Ensure the complete handler is called before this completes\n\t\t\t\tanim.always( function() {\n\t\t\t\t\thooks.unqueued--;\n\t\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\t\thooks.empty.fire();\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t\n\t\t// Detect show/hide animations\n\t\tfor ( prop in props ) {\n\t\t\tvalue = props[ prop ];\n\t\t\tif ( rfxtypes.test( value ) ) {\n\t\t\t\tdelete props[ prop ];\n\t\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\t\n\t\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\t\thidden = true;\n\t\n\t\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t\t}\n\t\t}\n\t\n\t\t// Bail out if this is a no-op like .hide().hide()\n\t\tpropTween = !jQuery.isEmptyObject( props );\n\t\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// Restrict \"overflow\" and \"display\" styles during box animations\n\t\tif ( isBox && elem.nodeType === 1 ) {\n\t\n\t\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t\t// from identically-valued overflowX and overflowY\n\t\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\t\n\t\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\t\trestoreDisplay = dataShow && dataShow.display;\n\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t\t}\n\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tif ( restoreDisplay ) {\n\t\t\t\t\tdisplay = restoreDisplay;\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Animate inline elements as inline-block\n\t\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\t\n\t\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\t\tif ( !propTween ) {\n\t\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tif ( opts.overflow ) {\n\t\t\tstyle.overflow = \"hidden\";\n\t\t\tanim.always( function() {\n\t\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t\t} );\n\t\t}\n\t\n\t\t// Implement show/hide animations\n\t\tpropTween = false;\n\t\tfor ( prop in orig ) {\n\t\n\t\t\t// General show/hide setup for this element animation\n\t\t\tif ( !propTween ) {\n\t\t\t\tif ( dataShow ) {\n\t\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t\t}\n\t\n\t\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\t\tif ( toggle ) {\n\t\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t\t}\n\t\n\t\t\t\t// Show elements before animating them\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\t}\n\t\n\t\t\t\t/* eslint-disable no-loop-func */\n\t\n\t\t\t\tanim.done( function() {\n\t\n\t\t\t\t/* eslint-enable no-loop-func */\n\t\n\t\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\t\tif ( !hidden ) {\n\t\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\t// Per-property setup\n\t\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\t\tpropTween.start = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction propFilter( props, specialEasing ) {\n\t\tvar index, name, easing, value, hooks;\n\t\n\t\t// camelCase, specialEasing and expand cssHook pass\n\t\tfor ( index in props ) {\n\t\t\tname = jQuery.camelCase( index );\n\t\t\teasing = specialEasing[ name ];\n\t\t\tvalue = props[ index ];\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\teasing = value[ 1 ];\n\t\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t\t}\n\t\n\t\t\tif ( index !== name ) {\n\t\t\t\tprops[ name ] = value;\n\t\t\t\tdelete props[ index ];\n\t\t\t}\n\t\n\t\t\thooks = jQuery.cssHooks[ name ];\n\t\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\t\tvalue = hooks.expand( value );\n\t\t\t\tdelete props[ name ];\n\t\n\t\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\t\tfor ( index in value ) {\n\t\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tspecialEasing[ name ] = easing;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction Animation( elem, properties, options ) {\n\t\tvar result,\n\t\t\tstopped,\n\t\t\tindex = 0,\n\t\t\tlength = Animation.prefilters.length,\n\t\t\tdeferred = jQuery.Deferred().always( function() {\n\t\n\t\t\t\t// Don't match elem in the :animated selector\n\t\t\t\tdelete tick.elem;\n\t\t\t} ),\n\t\t\ttick = function() {\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\n\t\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\t\tpercent = 1 - temp,\n\t\t\t\t\tindex = 0,\n\t\t\t\t\tlength = animation.tweens.length;\n\t\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t\t}\n\t\n\t\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\t\n\t\t\t\tif ( percent < 1 && length ) {\n\t\t\t\t\treturn remaining;\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tanimation = deferred.promise( {\n\t\t\t\telem: elem,\n\t\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\t\topts: jQuery.extend( true, {\n\t\t\t\t\tspecialEasing: {},\n\t\t\t\t\teasing: jQuery.easing._default\n\t\t\t\t}, options ),\n\t\t\t\toriginalProperties: properties,\n\t\t\t\toriginalOptions: options,\n\t\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\t\tduration: options.duration,\n\t\t\t\ttweens: [],\n\t\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\t\treturn tween;\n\t\t\t\t},\n\t\t\t\tstop: function( gotoEnd ) {\n\t\t\t\t\tvar index = 0,\n\t\n\t\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\t\tif ( stopped ) {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t\tstopped = true;\n\t\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t} ),\n\t\t\tprops = animation.props;\n\t\n\t\tpropFilter( props, animation.opts.specialEasing );\n\t\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\t\tif ( result ) {\n\t\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\n\t\tjQuery.map( props, createTween, animation );\n\t\n\t\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\t\tanimation.opts.start.call( elem, animation );\n\t\t}\n\t\n\t\tjQuery.fx.timer(\n\t\t\tjQuery.extend( tick, {\n\t\t\t\telem: elem,\n\t\t\t\tanim: animation,\n\t\t\t\tqueue: animation.opts.queue\n\t\t\t} )\n\t\t);\n\t\n\t\t// attach callbacks from options\n\t\treturn animation.progress( animation.opts.progress )\n\t\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t\t.fail( animation.opts.fail )\n\t\t\t.always( animation.opts.always );\n\t}\n\t\n\tjQuery.Animation = jQuery.extend( Animation, {\n\t\n\t\ttweeners: {\n\t\t\t\"*\": [ function( prop, value ) {\n\t\t\t\tvar tween = this.createTween( prop, value );\n\t\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\t\treturn tween;\n\t\t\t} ]\n\t\t},\n\t\n\t\ttweener: function( props, callback ) {\n\t\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\t\tcallback = props;\n\t\t\t\tprops = [ \"*\" ];\n\t\t\t} else {\n\t\t\t\tprops = props.match( rnothtmlwhite );\n\t\t\t}\n\t\n\t\t\tvar prop,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = props.length;\n\t\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tprop = props[ index ];\n\t\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t\t}\n\t\t},\n\t\n\t\tprefilters: [ defaultPrefilter ],\n\t\n\t\tprefilter: function( callback, prepend ) {\n\t\t\tif ( prepend ) {\n\t\t\t\tAnimation.prefilters.unshift( callback );\n\t\t\t} else {\n\t\t\t\tAnimation.prefilters.push( callback );\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tjQuery.speed = function( speed, easing, fn ) {\n\t\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\t\tcomplete: fn || !fn && easing ||\n\t\t\t\tjQuery.isFunction( speed ) && speed,\n\t\t\tduration: speed,\n\t\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t\t};\n\t\n\t\t// Go to the end state if fx are off or if document is hidden\n\t\tif ( jQuery.fx.off || document.hidden ) {\n\t\t\topt.duration = 0;\n\t\n\t\t} else {\n\t\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\t\n\t\t\t\t} else {\n\t\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\t\tif ( opt.queue == null || opt.queue === true ) {\n\t\t\topt.queue = \"fx\";\n\t\t}\n\t\n\t\t// Queueing\n\t\topt.old = opt.complete;\n\t\n\t\topt.complete = function() {\n\t\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\t\topt.old.call( this );\n\t\t\t}\n\t\n\t\t\tif ( opt.queue ) {\n\t\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t\t}\n\t\t};\n\t\n\t\treturn opt;\n\t};\n\t\n\tjQuery.fn.extend( {\n\t\tfadeTo: function( speed, to, easing, callback ) {\n\t\n\t\t\t// Show any hidden elements after setting opacity to 0\n\t\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\t\n\t\t\t\t// Animate to the value specified\n\t\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t\t},\n\t\tanimate: function( prop, speed, easing, callback ) {\n\t\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\t\tdoAnimation = function() {\n\t\n\t\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\t\n\t\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\t\tanim.stop( true );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tdoAnimation.finish = doAnimation;\n\t\n\t\t\treturn empty || optall.queue === false ?\n\t\t\t\tthis.each( doAnimation ) :\n\t\t\t\tthis.queue( optall.queue, doAnimation );\n\t\t},\n\t\tstop: function( type, clearQueue, gotoEnd ) {\n\t\t\tvar stopQueue = function( hooks ) {\n\t\t\t\tvar stop = hooks.stop;\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tstop( gotoEnd );\n\t\t\t};\n\t\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tgotoEnd = clearQueue;\n\t\t\t\tclearQueue = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\tif ( clearQueue && type !== false ) {\n\t\t\t\tthis.queue( type || \"fx\", [] );\n\t\t\t}\n\t\n\t\t\treturn this.each( function() {\n\t\t\t\tvar dequeue = true,\n\t\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\t\ttimers = jQuery.timers,\n\t\t\t\t\tdata = dataPriv.get( this );\n\t\n\t\t\t\tif ( index ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( index in data ) {\n\t\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\t\n\t\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\t\tdequeue = false;\n\t\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\tfinish: function( type ) {\n\t\t\tif ( type !== false ) {\n\t\t\t\ttype = type || \"fx\";\n\t\t\t}\n\t\t\treturn this.each( function() {\n\t\t\t\tvar index,\n\t\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\t\ttimers = jQuery.timers,\n\t\t\t\t\tlength = queue ? queue.length : 0;\n\t\n\t\t\t\t// Enable finishing flag on private data\n\t\t\t\tdata.finish = true;\n\t\n\t\t\t\t// Empty the queue first\n\t\t\t\tjQuery.queue( this, type, [] );\n\t\n\t\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\t\thooks.stop.call( this, true );\n\t\t\t\t}\n\t\n\t\t\t\t// Look for any active animations, and finish them\n\t\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Look for any animations in the old queue and finish them\n\t\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Turn off finishing flag\n\t\t\t\tdelete data.finish;\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\t\tvar cssFn = jQuery.fn[ name ];\n\t\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\t\tcssFn.apply( this, arguments ) :\n\t\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t\t};\n\t} );\n\t\n\t// Generate shortcuts for custom animations\n\tjQuery.each( {\n\t\tslideDown: genFx( \"show\" ),\n\t\tslideUp: genFx( \"hide\" ),\n\t\tslideToggle: genFx( \"toggle\" ),\n\t\tfadeIn: { opacity: \"show\" },\n\t\tfadeOut: { opacity: \"hide\" },\n\t\tfadeToggle: { opacity: \"toggle\" }\n\t}, function( name, props ) {\n\t\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\t\treturn this.animate( props, speed, easing, callback );\n\t\t};\n\t} );\n\t\n\tjQuery.timers = [];\n\tjQuery.fx.tick = function() {\n\t\tvar timer,\n\t\t\ti = 0,\n\t\t\ttimers = jQuery.timers;\n\t\n\t\tfxNow = jQuery.now();\n\t\n\t\tfor ( ; i < timers.length; i++ ) {\n\t\t\ttimer = timers[ i ];\n\t\n\t\t\t// Checks the timer has not already been removed\n\t\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\t\ttimers.splice( i--, 1 );\n\t\t\t}\n\t\t}\n\t\n\t\tif ( !timers.length ) {\n\t\t\tjQuery.fx.stop();\n\t\t}\n\t\tfxNow = undefined;\n\t};\n\t\n\tjQuery.fx.timer = function( timer ) {\n\t\tjQuery.timers.push( timer );\n\t\tif ( timer() ) {\n\t\t\tjQuery.fx.start();\n\t\t} else {\n\t\t\tjQuery.timers.pop();\n\t\t}\n\t};\n\t\n\tjQuery.fx.interval = 13;\n\tjQuery.fx.start = function() {\n\t\tif ( !timerId ) {\n\t\t\ttimerId = window.requestAnimationFrame ?\n\t\t\t\twindow.requestAnimationFrame( raf ) :\n\t\t\t\twindow.setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t\t}\n\t};\n\t\n\tjQuery.fx.stop = function() {\n\t\tif ( window.cancelAnimationFrame ) {\n\t\t\twindow.cancelAnimationFrame( timerId );\n\t\t} else {\n\t\t\twindow.clearInterval( timerId );\n\t\t}\n\t\n\t\ttimerId = null;\n\t};\n\t\n\tjQuery.fx.speeds = {\n\t\tslow: 600,\n\t\tfast: 200,\n\t\n\t\t// Default speed\n\t\t_default: 400\n\t};\n\t\n\t\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tjQuery.fn.delay = function( time, type ) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\t\ttype = type || \"fx\";\n\t\n\t\treturn this.queue( type, function( next, hooks ) {\n\t\t\tvar timeout = window.setTimeout( next, time );\n\t\t\thooks.stop = function() {\n\t\t\t\twindow.clearTimeout( timeout );\n\t\t\t};\n\t\t} );\n\t};\n\t\n\t\n\t( function() {\n\t\tvar input = document.createElement( \"input\" ),\n\t\t\tselect = document.createElement( \"select\" ),\n\t\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\t\n\t\tinput.type = \"checkbox\";\n\t\n\t\t// Support: Android <=4.3 only\n\t\t// Default value for a checkbox should be \"on\"\n\t\tsupport.checkOn = input.value !== \"\";\n\t\n\t\t// Support: IE <=11 only\n\t\t// Must access selectedIndex to make default options select\n\t\tsupport.optSelected = opt.selected;\n\t\n\t\t// Support: IE <=11 only\n\t\t// An input loses its value after becoming a radio\n\t\tinput = document.createElement( \"input\" );\n\t\tinput.value = \"t\";\n\t\tinput.type = \"radio\";\n\t\tsupport.radioValue = input.value === \"t\";\n\t} )();\n\t\n\t\n\tvar boolHook,\n\t\tattrHandle = jQuery.expr.attrHandle;\n\t\n\tjQuery.fn.extend( {\n\t\tattr: function( name, value ) {\n\t\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t\t},\n\t\n\t\tremoveAttr: function( name ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.removeAttr( this, name );\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.extend( {\n\t\tattr: function( elem, name, value ) {\n\t\t\tvar ret, hooks,\n\t\t\t\tnType = elem.nodeType;\n\t\n\t\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Fallback to prop when attributes are not supported\n\t\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\t\treturn jQuery.prop( elem, name, value );\n\t\t\t}\n\t\n\t\t\t// Attribute hooks are determined by the lowercase version\n\t\t\t// Grab necessary hook if one is defined\n\t\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t\t}\n\t\n\t\t\tif ( value !== undefined ) {\n\t\t\t\tif ( value === null ) {\n\t\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\t\n\t\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\n\t\t\tret = jQuery.find.attr( elem, name );\n\t\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ? undefined : ret;\n\t\t},\n\t\n\t\tattrHooks: {\n\t\t\ttype: {\n\t\t\t\tset: function( elem, value ) {\n\t\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tremoveAttr: function( elem, value ) {\n\t\t\tvar name,\n\t\t\t\ti = 0,\n\t\n\t\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\t\n\t\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\t\telem.removeAttribute( name );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t// Hooks for boolean attributes\n\tboolHook = {\n\t\tset: function( elem, value, name ) {\n\t\t\tif ( value === false ) {\n\t\n\t\t\t\t// Remove boolean attributes when set to false\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, name );\n\t\t\t}\n\t\t\treturn name;\n\t\t}\n\t};\n\t\n\tjQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\t\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\t\n\t\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\t\tvar ret, handle,\n\t\t\t\tlowercaseName = name.toLowerCase();\n\t\n\t\t\tif ( !isXML ) {\n\t\n\t\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\t\tlowercaseName :\n\t\t\t\t\tnull;\n\t\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t} );\n\t\n\t\n\t\n\t\n\tvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\t\trclickable = /^(?:a|area)$/i;\n\t\n\tjQuery.fn.extend( {\n\t\tprop: function( name, value ) {\n\t\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t\t},\n\t\n\t\tremoveProp: function( name ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.extend( {\n\t\tprop: function( elem, name, value ) {\n\t\t\tvar ret, hooks,\n\t\t\t\tnType = elem.nodeType;\n\t\n\t\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\n\t\t\t\t// Fix name and attach hooks\n\t\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\t\thooks = jQuery.propHooks[ name ];\n\t\t\t}\n\t\n\t\t\tif ( value !== undefined ) {\n\t\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\n\t\t\t\treturn ( elem[ name ] = value );\n\t\t\t}\n\t\n\t\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\n\t\t\treturn elem[ name ];\n\t\t},\n\t\n\t\tpropHooks: {\n\t\t\ttabIndex: {\n\t\t\t\tget: function( elem ) {\n\t\n\t\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\t\n\t\t\t\t\tif ( tabindex ) {\n\t\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (\n\t\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\t\telem.href\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tpropFix: {\n\t\t\t\"for\": \"htmlFor\",\n\t\t\t\"class\": \"className\"\n\t\t}\n\t} );\n\t\n\t// Support: IE <=11 only\n\t// Accessing the selectedIndex property\n\t// forces the browser to respect setting selected\n\t// on the option\n\t// The getter ensures a default option is selected\n\t// when in an optgroup\n\t// eslint rule \"no-unused-expressions\" is disabled for this code\n\t// since it considers such accessions noop\n\tif ( !support.optSelected ) {\n\t\tjQuery.propHooks.selected = {\n\t\t\tget: function( elem ) {\n\t\n\t\t\t\t/* eslint no-unused-expressions: \"off\" */\n\t\n\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\tset: function( elem ) {\n\t\n\t\t\t\t/* eslint no-unused-expressions: \"off\" */\n\t\n\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.selectedIndex;\n\t\n\t\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\tjQuery.each( [\n\t\t\"tabIndex\",\n\t\t\"readOnly\",\n\t\t\"maxLength\",\n\t\t\"cellSpacing\",\n\t\t\"cellPadding\",\n\t\t\"rowSpan\",\n\t\t\"colSpan\",\n\t\t\"useMap\",\n\t\t\"frameBorder\",\n\t\t\"contentEditable\"\n\t], function() {\n\t\tjQuery.propFix[ this.toLowerCase() ] = this;\n\t} );\n\t\n\t\n\t\n\t\n\t\t// Strip and collapse whitespace according to HTML spec\n\t\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n\t\tfunction stripAndCollapse( value ) {\n\t\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\t\treturn tokens.join( \" \" );\n\t\t}\n\t\n\t\n\tfunction getClass( elem ) {\n\t\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n\t}\n\t\n\tjQuery.fn.extend( {\n\t\taddClass: function( value ) {\n\t\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\t\ti = 0;\n\t\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each( function( j ) {\n\t\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tif ( typeof value === \"string\" && value ) {\n\t\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\t\n\t\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\t\tcurValue = getClass( elem );\n\t\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\t\n\t\t\t\t\tif ( cur ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tremoveClass: function( value ) {\n\t\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\t\ti = 0;\n\t\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each( function( j ) {\n\t\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tif ( !arguments.length ) {\n\t\t\t\treturn this.attr( \"class\", \"\" );\n\t\t\t}\n\t\n\t\t\tif ( typeof value === \"string\" && value ) {\n\t\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\t\n\t\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\t\tcurValue = getClass( elem );\n\t\n\t\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\t\n\t\t\t\t\tif ( cur ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\n\t\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\ttoggleClass: function( value, stateVal ) {\n\t\t\tvar type = typeof value;\n\t\n\t\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t\t}\n\t\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each( function( i ) {\n\t\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\t\tstateVal\n\t\t\t\t\t);\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\treturn this.each( function() {\n\t\t\t\tvar className, i, self, classNames;\n\t\n\t\t\t\tif ( type === \"string\" ) {\n\t\n\t\t\t\t\t// Toggle individual class names\n\t\t\t\t\ti = 0;\n\t\t\t\t\tself = jQuery( this );\n\t\t\t\t\tclassNames = value.match( rnothtmlwhite ) || [];\n\t\n\t\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\t\n\t\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t// Toggle whole class name\n\t\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\t\tclassName = getClass( this );\n\t\t\t\t\tif ( className ) {\n\t\n\t\t\t\t\t\t// Store className if set\n\t\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\thasClass: function( selector ) {\n\t\t\tvar className, elem,\n\t\t\t\ti = 0;\n\t\n\t\t\tclassName = \" \" + selector + \" \";\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\tvar rreturn = /\\r/g;\n\t\n\tjQuery.fn.extend( {\n\t\tval: function( value ) {\n\t\t\tvar hooks, ret, isFunction,\n\t\t\t\telem = this[ 0 ];\n\t\n\t\t\tif ( !arguments.length ) {\n\t\t\t\tif ( elem ) {\n\t\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\t\n\t\t\t\t\tif ( hooks &&\n\t\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tret = elem.value;\n\t\n\t\t\t\t\t// Handle most common string cases\n\t\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t\t}\n\t\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tisFunction = jQuery.isFunction( value );\n\t\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tvar val;\n\t\n\t\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t\t} else {\n\t\t\t\t\tval = value;\n\t\t\t\t}\n\t\n\t\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\t\tif ( val == null ) {\n\t\t\t\t\tval = \"\";\n\t\n\t\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\t\tval += \"\";\n\t\n\t\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\n\t\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\t\n\t\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\t\tthis.value = val;\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.extend( {\n\t\tvalHooks: {\n\t\t\toption: {\n\t\t\t\tget: function( elem ) {\n\t\n\t\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\t\treturn val != null ?\n\t\t\t\t\t\tval :\n\t\n\t\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t\t}\n\t\t\t},\n\t\t\tselect: {\n\t\t\t\tget: function( elem ) {\n\t\t\t\t\tvar value, option, i,\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\t\tmax = one ? index + 1 : options.length;\n\t\n\t\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\t\ti = max;\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Loop through all the selected options\n\t\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\t\toption = options[ i ];\n\t\n\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\n\t\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t\t!jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\t\n\t\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\t\tvalue = jQuery( option ).val();\n\t\n\t\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn values;\n\t\t\t\t},\n\t\n\t\t\t\tset: function( elem, value ) {\n\t\t\t\t\tvar optionSet, option,\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\t\ti = options.length;\n\t\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\toption = options[ i ];\n\t\n\t\t\t\t\t\t/* eslint-disable no-cond-assign */\n\t\n\t\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn values;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t// Radios and checkboxes getter/setter\n\tjQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\t\tjQuery.valHooks[ this ] = {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif ( !support.checkOn ) {\n\t\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t\t};\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\t// Return jQuery for attributes-only inclusion\n\t\n\t\n\tvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\t\n\tjQuery.extend( jQuery.event, {\n\t\n\t\ttrigger: function( event, data, elem, onlyHandlers ) {\n\t\n\t\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\t\teventPath = [ elem || document ],\n\t\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\t\n\t\t\tcur = tmp = elem = elem || document;\n\t\n\t\t\t// Don't do events on text and comment nodes\n\t\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\t\n\t\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\t\tnamespaces = type.split( \".\" );\n\t\t\t\ttype = namespaces.shift();\n\t\t\t\tnamespaces.sort();\n\t\t\t}\n\t\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\t\n\t\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\t\tevent = event[ jQuery.expando ] ?\n\t\t\t\tevent :\n\t\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\t\n\t\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\t\tevent.namespace = namespaces.join( \".\" );\n\t\t\tevent.rnamespace = event.namespace ?\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\t\tnull;\n\t\n\t\t\t// Clean up the event in case it is being reused\n\t\t\tevent.result = undefined;\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = elem;\n\t\t\t}\n\t\n\t\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\t\tdata = data == null ?\n\t\t\t\t[ event ] :\n\t\t\t\tjQuery.makeArray( data, [ event ] );\n\t\n\t\t\t// Allow special events to draw outside the lines\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\t\n\t\t\t\tbubbleType = special.delegateType || type;\n\t\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t}\n\t\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\t\teventPath.push( cur );\n\t\t\t\t\ttmp = cur;\n\t\t\t\t}\n\t\n\t\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Fire handlers on the event path\n\t\t\ti = 0;\n\t\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\n\t\t\t\tevent.type = i > 1 ?\n\t\t\t\t\tbubbleType :\n\t\t\t\t\tspecial.bindType || type;\n\t\n\t\t\t\t// jQuery handler\n\t\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\t\tif ( handle ) {\n\t\t\t\t\thandle.apply( cur, data );\n\t\t\t\t}\n\t\n\t\t\t\t// Native handler\n\t\t\t\thandle = ontype && cur[ ontype ];\n\t\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent.type = type;\n\t\n\t\t\t// If nobody prevented the default action, do it now\n\t\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\t\n\t\t\t\tif ( ( !special._default ||\n\t\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\t\tacceptData( elem ) ) {\n\t\n\t\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\t\n\t\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\t\ttmp = elem[ ontype ];\n\t\n\t\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\t\telem[ type ]();\n\t\t\t\t\t\tjQuery.event.triggered = undefined;\n\t\n\t\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn event.result;\n\t\t},\n\t\n\t\t// Piggyback on a donor event to simulate a different one\n\t\t// Used only for `focus(in | out)` events\n\t\tsimulate: function( type, elem, event ) {\n\t\t\tvar e = jQuery.extend(\n\t\t\t\tnew jQuery.Event(),\n\t\t\t\tevent,\n\t\t\t\t{\n\t\t\t\t\ttype: type,\n\t\t\t\t\tisSimulated: true\n\t\t\t\t}\n\t\t\t);\n\t\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t}\n\t\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\n\t\ttrigger: function( type, data ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.event.trigger( type, data, this );\n\t\t\t} );\n\t\t},\n\t\ttriggerHandler: function( type, data ) {\n\t\t\tvar elem = this[ 0 ];\n\t\t\tif ( elem ) {\n\t\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t\n\tjQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\t\tfunction( i, name ) {\n\t\n\t\t// Handle event binding\n\t\tjQuery.fn[ name ] = function( data, fn ) {\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\tthis.on( name, null, data, fn ) :\n\t\t\t\tthis.trigger( name );\n\t\t};\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\thover: function( fnOver, fnOut ) {\n\t\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\tsupport.focusin = \"onfocusin\" in window;\n\t\n\t\n\t// Support: Firefox <=44\n\t// Firefox doesn't have focus(in | out) events\n\t// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n\t//\n\t// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n\t// focus(in | out) events fire after focus & blur events,\n\t// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n\t// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n\tif ( !support.focusin ) {\n\t\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\t\n\t\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\t\tvar handler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t\t};\n\t\n\t\t\tjQuery.event.special[ fix ] = {\n\t\t\t\tsetup: function() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\t\n\t\t\t\t\tif ( !attaches ) {\n\t\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t\t},\n\t\t\t\tteardown: function() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\t\n\t\t\t\t\tif ( !attaches ) {\n\t\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\t\tdataPriv.remove( doc, fix );\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t} );\n\t}\n\tvar location = window.location;\n\t\n\tvar nonce = jQuery.now();\n\t\n\tvar rquery = ( /\\?/ );\n\t\n\t\n\t\n\t// Cross-browser xml parsing\n\tjQuery.parseXML = function( data ) {\n\t\tvar xml;\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\t// Support: IE 9 - 11 only\n\t\t// IE throws on parseFromString with invalid input.\n\t\ttry {\n\t\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t\t} catch ( e ) {\n\t\t\txml = undefined;\n\t\t}\n\t\n\t\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\t\tjQuery.error( \"Invalid XML: \" + data );\n\t\t}\n\t\treturn xml;\n\t};\n\t\n\t\n\tvar\n\t\trbracket = /\\[\\]$/,\n\t\trCRLF = /\\r?\\n/g,\n\t\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\t\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\t\n\tfunction buildParams( prefix, obj, traditional, add ) {\n\t\tvar name;\n\t\n\t\tif ( jQuery.isArray( obj ) ) {\n\t\n\t\t\t// Serialize array item.\n\t\t\tjQuery.each( obj, function( i, v ) {\n\t\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\n\t\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\t\tadd( prefix, v );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\t\tbuildParams(\n\t\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\t\tv,\n\t\t\t\t\t\ttraditional,\n\t\t\t\t\t\tadd\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\n\t\t\t// Serialize object item.\n\t\t\tfor ( name in obj ) {\n\t\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t\t}\n\t\n\t\t} else {\n\t\n\t\t\t// Serialize scalar item.\n\t\t\tadd( prefix, obj );\n\t\t}\n\t}\n\t\n\t// Serialize an array of form elements or a set of\n\t// key/values into a query string\n\tjQuery.param = function( a, traditional ) {\n\t\tvar prefix,\n\t\t\ts = [],\n\t\t\tadd = function( key, valueOrFunction ) {\n\t\n\t\t\t\t// If value is a function, invoke it and use its return value\n\t\t\t\tvar value = jQuery.isFunction( valueOrFunction ) ?\n\t\t\t\t\tvalueOrFunction() :\n\t\t\t\t\tvalueOrFunction;\n\t\n\t\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t\t};\n\t\n\t\t// If an array was passed in, assume that it is an array of form elements.\n\t\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\n\t\t\t// Serialize the form elements\n\t\t\tjQuery.each( a, function() {\n\t\t\t\tadd( this.name, this.value );\n\t\t\t} );\n\t\n\t\t} else {\n\t\n\t\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t\t// did it), otherwise encode params recursively.\n\t\t\tfor ( prefix in a ) {\n\t\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the resulting serialization\n\t\treturn s.join( \"&\" );\n\t};\n\t\n\tjQuery.fn.extend( {\n\t\tserialize: function() {\n\t\t\treturn jQuery.param( this.serializeArray() );\n\t\t},\n\t\tserializeArray: function() {\n\t\t\treturn this.map( function() {\n\t\n\t\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t\t} )\n\t\t\t.filter( function() {\n\t\t\t\tvar type = this.type;\n\t\n\t\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t\t} )\n\t\t\t.map( function( i, elem ) {\n\t\t\t\tvar val = jQuery( this ).val();\n\t\n\t\t\t\tif ( val == null ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\tif ( jQuery.isArray( val ) ) {\n\t\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\n\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t} ).get();\n\t\t}\n\t} );\n\t\n\t\n\tvar\n\t\tr20 = /%20/g,\n\t\trhash = /#.*$/,\n\t\trantiCache = /([?&])_=[^&]*/,\n\t\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t\n\t\t// #7653, #8125, #8152: local protocol detection\n\t\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\t\trnoContent = /^(?:GET|HEAD)$/,\n\t\trprotocol = /^\\/\\//,\n\t\n\t\t/* Prefilters\n\t\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t\t * 2) These are called:\n\t\t *    - BEFORE asking for a transport\n\t\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t\t * 3) key is the dataType\n\t\t * 4) the catchall symbol \"*\" can be used\n\t\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t\t */\n\t\tprefilters = {},\n\t\n\t\t/* Transports bindings\n\t\t * 1) key is the dataType\n\t\t * 2) the catchall symbol \"*\" can be used\n\t\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t\t */\n\t\ttransports = {},\n\t\n\t\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\t\tallTypes = \"*/\".concat( \"*\" ),\n\t\n\t\t// Anchor tag for parsing the document origin\n\t\toriginAnchor = document.createElement( \"a\" );\n\t\toriginAnchor.href = location.href;\n\t\n\t// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\tfunction addToPrefiltersOrTransports( structure ) {\n\t\n\t\t// dataTypeExpression is optional and defaults to \"*\"\n\t\treturn function( dataTypeExpression, func ) {\n\t\n\t\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\t\tfunc = dataTypeExpression;\n\t\t\t\tdataTypeExpression = \"*\";\n\t\t\t}\n\t\n\t\t\tvar dataType,\n\t\t\t\ti = 0,\n\t\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\t\n\t\t\tif ( jQuery.isFunction( func ) ) {\n\t\n\t\t\t\t// For each dataType in the dataTypeExpression\n\t\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\t\n\t\t\t\t\t// Prepend if requested\n\t\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\t\n\t\t\t\t\t// Otherwise append\n\t\t\t\t\t} else {\n\t\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\t// Base inspection function for prefilters and transports\n\tfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\t\n\t\tvar inspected = {},\n\t\t\tseekingTransport = ( structure === transports );\n\t\n\t\tfunction inspect( dataType ) {\n\t\t\tvar selected;\n\t\t\tinspected[ dataType ] = true;\n\t\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\n\t\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\t\treturn false;\n\t\t\t\t} else if ( seekingTransport ) {\n\t\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn selected;\n\t\t}\n\t\n\t\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n\t}\n\t\n\t// A special extend for ajax options\n\t// that takes \"flat\" options (not to be deep extended)\n\t// Fixes #9887\n\tfunction ajaxExtend( target, src ) {\n\t\tvar key, deep,\n\t\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\t\n\t\tfor ( key in src ) {\n\t\t\tif ( src[ key ] !== undefined ) {\n\t\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t\t}\n\t\t}\n\t\tif ( deep ) {\n\t\t\tjQuery.extend( true, target, deep );\n\t\t}\n\t\n\t\treturn target;\n\t}\n\t\n\t/* Handles responses to an ajax request:\n\t * - finds the right dataType (mediates between content-type and expected dataType)\n\t * - returns the corresponding response\n\t */\n\tfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\t\n\t\tvar ct, type, finalDataType, firstDataType,\n\t\t\tcontents = s.contents,\n\t\t\tdataTypes = s.dataTypes;\n\t\n\t\t// Remove auto dataType and get content-type in the process\n\t\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\t\tdataTypes.shift();\n\t\t\tif ( ct === undefined ) {\n\t\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t\t}\n\t\t}\n\t\n\t\t// Check if we're dealing with a known content-type\n\t\tif ( ct ) {\n\t\t\tfor ( type in contents ) {\n\t\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\t\tdataTypes.unshift( type );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Check to see if we have a response for the expected dataType\n\t\tif ( dataTypes[ 0 ] in responses ) {\n\t\t\tfinalDataType = dataTypes[ 0 ];\n\t\t} else {\n\t\n\t\t\t// Try convertible dataTypes\n\t\t\tfor ( type in responses ) {\n\t\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\t\tfinalDataType = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( !firstDataType ) {\n\t\t\t\t\tfirstDataType = type;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Or just use first one\n\t\t\tfinalDataType = finalDataType || firstDataType;\n\t\t}\n\t\n\t\t// If we found a dataType\n\t\t// We add the dataType to the list if needed\n\t\t// and return the corresponding response\n\t\tif ( finalDataType ) {\n\t\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\t\tdataTypes.unshift( finalDataType );\n\t\t\t}\n\t\t\treturn responses[ finalDataType ];\n\t\t}\n\t}\n\t\n\t/* Chain conversions given the request and the original response\n\t * Also sets the responseXXX fields on the jqXHR instance\n\t */\n\tfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\t\tvar conv2, current, conv, tmp, prev,\n\t\t\tconverters = {},\n\t\n\t\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\t\tdataTypes = s.dataTypes.slice();\n\t\n\t\t// Create converters map with lowercased keys\n\t\tif ( dataTypes[ 1 ] ) {\n\t\t\tfor ( conv in s.converters ) {\n\t\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t\t}\n\t\t}\n\t\n\t\tcurrent = dataTypes.shift();\n\t\n\t\t// Convert to each sequential dataType\n\t\twhile ( current ) {\n\t\n\t\t\tif ( s.responseFields[ current ] ) {\n\t\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t\t}\n\t\n\t\t\t// Apply the dataFilter if provided\n\t\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t\t}\n\t\n\t\t\tprev = current;\n\t\t\tcurrent = dataTypes.shift();\n\t\n\t\t\tif ( current ) {\n\t\n\t\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\t\tif ( current === \"*\" ) {\n\t\n\t\t\t\t\tcurrent = prev;\n\t\n\t\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\t\n\t\t\t\t\t// Seek a direct converter\n\t\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\t\n\t\t\t\t\t// If none found, seek a pair\n\t\t\t\t\tif ( !conv ) {\n\t\t\t\t\t\tfor ( conv2 in converters ) {\n\t\n\t\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\t\n\t\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\t\tif ( conv ) {\n\t\n\t\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\t\n\t\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\t\tif ( conv !== true ) {\n\t\n\t\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn { state: \"success\", data: response };\n\t}\n\t\n\tjQuery.extend( {\n\t\n\t\t// Counter for holding the number of active queries\n\t\tactive: 0,\n\t\n\t\t// Last-Modified header cache for next request\n\t\tlastModified: {},\n\t\tetag: {},\n\t\n\t\tajaxSettings: {\n\t\t\turl: location.href,\n\t\t\ttype: \"GET\",\n\t\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\t\tglobal: true,\n\t\t\tprocessData: true,\n\t\t\tasync: true,\n\t\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\n\t\t\t/*\n\t\t\ttimeout: 0,\n\t\t\tdata: null,\n\t\t\tdataType: null,\n\t\t\tusername: null,\n\t\t\tpassword: null,\n\t\t\tcache: null,\n\t\t\tthrows: false,\n\t\t\ttraditional: false,\n\t\t\theaders: {},\n\t\t\t*/\n\t\n\t\t\taccepts: {\n\t\t\t\t\"*\": allTypes,\n\t\t\t\ttext: \"text/plain\",\n\t\t\t\thtml: \"text/html\",\n\t\t\t\txml: \"application/xml, text/xml\",\n\t\t\t\tjson: \"application/json, text/javascript\"\n\t\t\t},\n\t\n\t\t\tcontents: {\n\t\t\t\txml: /\\bxml\\b/,\n\t\t\t\thtml: /\\bhtml/,\n\t\t\t\tjson: /\\bjson\\b/\n\t\t\t},\n\t\n\t\t\tresponseFields: {\n\t\t\t\txml: \"responseXML\",\n\t\t\t\ttext: \"responseText\",\n\t\t\t\tjson: \"responseJSON\"\n\t\t\t},\n\t\n\t\t\t// Data converters\n\t\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\t\tconverters: {\n\t\n\t\t\t\t// Convert anything to text\n\t\t\t\t\"* text\": String,\n\t\n\t\t\t\t// Text to html (true = no transformation)\n\t\t\t\t\"text html\": true,\n\t\n\t\t\t\t// Evaluate text as a json expression\n\t\t\t\t\"text json\": JSON.parse,\n\t\n\t\t\t\t// Parse text as xml\n\t\t\t\t\"text xml\": jQuery.parseXML\n\t\t\t},\n\t\n\t\t\t// For options that shouldn't be deep extended:\n\t\t\t// you can add your own custom options here if\n\t\t\t// and when you create one that shouldn't be\n\t\t\t// deep extended (see ajaxExtend)\n\t\t\tflatOptions: {\n\t\t\t\turl: true,\n\t\t\t\tcontext: true\n\t\t\t}\n\t\t},\n\t\n\t\t// Creates a full fledged settings object into target\n\t\t// with both ajaxSettings and settings fields.\n\t\t// If target is omitted, writes into ajaxSettings.\n\t\tajaxSetup: function( target, settings ) {\n\t\t\treturn settings ?\n\t\n\t\t\t\t// Building a settings object\n\t\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\t\n\t\t\t\t// Extending ajaxSettings\n\t\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t\t},\n\t\n\t\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\t\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\t\n\t\t// Main method\n\t\tajax: function( url, options ) {\n\t\n\t\t\t// If url is an object, simulate pre-1.5 signature\n\t\t\tif ( typeof url === \"object\" ) {\n\t\t\t\toptions = url;\n\t\t\t\turl = undefined;\n\t\t\t}\n\t\n\t\t\t// Force options to be an object\n\t\t\toptions = options || {};\n\t\n\t\t\tvar transport,\n\t\n\t\t\t\t// URL without anti-cache param\n\t\t\t\tcacheURL,\n\t\n\t\t\t\t// Response headers\n\t\t\t\tresponseHeadersString,\n\t\t\t\tresponseHeaders,\n\t\n\t\t\t\t// timeout handle\n\t\t\t\ttimeoutTimer,\n\t\n\t\t\t\t// Url cleanup var\n\t\t\t\turlAnchor,\n\t\n\t\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\t\tcompleted,\n\t\n\t\t\t\t// To know if global events are to be dispatched\n\t\t\t\tfireGlobals,\n\t\n\t\t\t\t// Loop variable\n\t\t\t\ti,\n\t\n\t\t\t\t// uncached part of the url\n\t\t\t\tuncached,\n\t\n\t\t\t\t// Create the final options object\n\t\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\n\t\t\t\t// Callbacks context\n\t\t\t\tcallbackContext = s.context || s,\n\t\n\t\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\t\tglobalEventContext = s.context &&\n\t\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\t\tjQuery.event,\n\t\n\t\t\t\t// Deferreds\n\t\t\t\tdeferred = jQuery.Deferred(),\n\t\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\t\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode = s.statusCode || {},\n\t\n\t\t\t\t// Headers (they are sent all at once)\n\t\t\t\trequestHeaders = {},\n\t\t\t\trequestHeadersNames = {},\n\t\n\t\t\t\t// Default abort message\n\t\t\t\tstrAbort = \"canceled\",\n\t\n\t\t\t\t// Fake xhr\n\t\t\t\tjqXHR = {\n\t\t\t\t\treadyState: 0,\n\t\n\t\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\t\tvar match;\n\t\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Raw string\n\t\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Caches the header\n\t\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Overrides response content-type header\n\t\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Status-dependent callbacks\n\t\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\t\tvar code;\n\t\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\t\tif ( completed ) {\n\t\n\t\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Cancel the request\n\t\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t// Attach deferreds\n\t\t\tdeferred.promise( jqXHR );\n\t\n\t\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t\t// We also use the url parameter if available\n\t\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\t\n\t\t\t// Alias method option to type as per ticket #12004\n\t\t\ts.type = options.method || options.type || s.method || s.type;\n\t\n\t\t\t// Extract dataTypes list\n\t\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\t\n\t\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\t\tif ( s.crossDomain == null ) {\n\t\t\t\turlAnchor = document.createElement( \"a\" );\n\t\n\t\t\t\t// Support: IE <=8 - 11, Edge 12 - 13\n\t\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t\t// e.g. http://example.com:80x/\n\t\t\t\ttry {\n\t\t\t\t\turlAnchor.href = s.url;\n\t\n\t\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\t\ts.crossDomain = true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Convert data if not already a string\n\t\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t\t}\n\t\n\t\t\t// Apply prefilters\n\t\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\t\n\t\t\t// If request was aborted inside a prefilter, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\t\n\t\t\t// We can fire global events as of now if asked to\n\t\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\t\tfireGlobals = jQuery.event && s.global;\n\t\n\t\t\t// Watch for a new set of requests\n\t\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t\t}\n\t\n\t\t\t// Uppercase the type\n\t\t\ts.type = s.type.toUpperCase();\n\t\n\t\t\t// Determine if request has content\n\t\t\ts.hasContent = !rnoContent.test( s.type );\n\t\n\t\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t\t// and/or If-None-Match header later on\n\t\t\t// Remove hash to simplify url manipulation\n\t\t\tcacheURL = s.url.replace( rhash, \"\" );\n\t\n\t\t\t// More options handling for requests with no content\n\t\t\tif ( !s.hasContent ) {\n\t\n\t\t\t\t// Remember the hash so we can put it back\n\t\t\t\tuncached = s.url.slice( cacheURL.length );\n\t\n\t\t\t\t// If data is available, append data to url\n\t\t\t\tif ( s.data ) {\n\t\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\t\n\t\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\t\tdelete s.data;\n\t\t\t\t}\n\t\n\t\t\t\t// Add or update anti-cache param if needed\n\t\t\t\tif ( s.cache === false ) {\n\t\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t\t}\n\t\n\t\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\t\ts.url = cacheURL + uncached;\n\t\n\t\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t\t} else if ( s.data && s.processData &&\n\t\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t\t}\n\t\n\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\tif ( s.ifModified ) {\n\t\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t\t}\n\t\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Set the correct header, if data is being sent\n\t\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t\t}\n\t\n\t\t\t// Set the Accepts header for the server, depending on the dataType\n\t\t\tjqXHR.setRequestHeader(\n\t\t\t\t\"Accept\",\n\t\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\t\ts.accepts[ \"*\" ]\n\t\t\t);\n\t\n\t\t\t// Check for headers option\n\t\t\tfor ( i in s.headers ) {\n\t\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t\t}\n\t\n\t\t\t// Allow custom headers/mimetypes and early abort\n\t\t\tif ( s.beforeSend &&\n\t\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\t\n\t\t\t\t// Abort if not done already and return\n\t\t\t\treturn jqXHR.abort();\n\t\t\t}\n\t\n\t\t\t// Aborting is no longer a cancellation\n\t\t\tstrAbort = \"abort\";\n\t\n\t\t\t// Install callbacks on deferreds\n\t\t\tcompleteDeferred.add( s.complete );\n\t\t\tjqXHR.done( s.success );\n\t\t\tjqXHR.fail( s.error );\n\t\n\t\t\t// Get transport\n\t\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\t\n\t\t\t// If no transport, we auto-abort\n\t\t\tif ( !transport ) {\n\t\t\t\tdone( -1, \"No Transport\" );\n\t\t\t} else {\n\t\t\t\tjqXHR.readyState = 1;\n\t\n\t\t\t\t// Send global event\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t\t}\n\t\n\t\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\t\tif ( completed ) {\n\t\t\t\t\treturn jqXHR;\n\t\t\t\t}\n\t\n\t\t\t\t// Timeout\n\t\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t\t}, s.timeout );\n\t\t\t\t}\n\t\n\t\t\t\ttry {\n\t\t\t\t\tcompleted = false;\n\t\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Propagate others as results\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Callback for when everything is done\n\t\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\t\tstatusText = nativeStatusText;\n\t\n\t\t\t\t// Ignore repeat invocations\n\t\t\t\tif ( completed ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tcompleted = true;\n\t\n\t\t\t\t// Clear timeout if it exists\n\t\t\t\tif ( timeoutTimer ) {\n\t\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t\t}\n\t\n\t\t\t\t// Dereference transport for early garbage collection\n\t\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\t\ttransport = undefined;\n\t\n\t\t\t\t// Cache response headers\n\t\t\t\tresponseHeadersString = headers || \"\";\n\t\n\t\t\t\t// Set readyState\n\t\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\t\n\t\t\t\t// Determine if successful\n\t\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\t\n\t\t\t\t// Get response data\n\t\t\t\tif ( responses ) {\n\t\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t\t}\n\t\n\t\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\t\n\t\t\t\t// If successful, handle type chaining\n\t\t\t\tif ( isSuccess ) {\n\t\n\t\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// if no content\n\t\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\t\tstatusText = \"nocontent\";\n\t\n\t\t\t\t\t// if not modified\n\t\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\t\tstatusText = \"notmodified\";\n\t\n\t\t\t\t\t// If we have data, let's convert it\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\t\terror = response.error;\n\t\t\t\t\t\tisSuccess = !error;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\t\terror = statusText;\n\t\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Set data for the fake xhr object\n\t\t\t\tjqXHR.status = status;\n\t\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\t\n\t\t\t\t// Success/Error\n\t\t\t\tif ( isSuccess ) {\n\t\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t\t}\n\t\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tjqXHR.statusCode( statusCode );\n\t\t\t\tstatusCode = undefined;\n\t\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t\t}\n\t\n\t\t\t\t// Complete\n\t\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\t\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\n\t\t\t\t\t// Handle the global AJAX counter\n\t\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn jqXHR;\n\t\t},\n\t\n\t\tgetJSON: function( url, data, callback ) {\n\t\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t\t},\n\t\n\t\tgetScript: function( url, callback ) {\n\t\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t\t}\n\t} );\n\t\n\tjQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\t\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\n\t\t\t// Shift arguments if data argument was omitted\n\t\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\t\ttype = type || callback;\n\t\t\t\tcallback = data;\n\t\t\t\tdata = undefined;\n\t\t\t}\n\t\n\t\t\t// The url can be an options object (which then must have .url)\n\t\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\t\turl: url,\n\t\t\t\ttype: method,\n\t\t\t\tdataType: type,\n\t\t\t\tdata: data,\n\t\t\t\tsuccess: callback\n\t\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t\t};\n\t} );\n\t\n\t\n\tjQuery._evalUrl = function( url ) {\n\t\treturn jQuery.ajax( {\n\t\t\turl: url,\n\t\n\t\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\t\ttype: \"GET\",\n\t\t\tdataType: \"script\",\n\t\t\tcache: true,\n\t\t\tasync: false,\n\t\t\tglobal: false,\n\t\t\t\"throws\": true\n\t\t} );\n\t};\n\t\n\t\n\tjQuery.fn.extend( {\n\t\twrapAll: function( html ) {\n\t\t\tvar wrap;\n\t\n\t\t\tif ( this[ 0 ] ) {\n\t\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t\t}\n\t\n\t\t\t\t// The elements to wrap the target around\n\t\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\t\n\t\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t\t}\n\t\n\t\t\t\twrap.map( function() {\n\t\t\t\t\tvar elem = this;\n\t\n\t\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn elem;\n\t\t\t\t} ).append( this );\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\twrapInner: function( html ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\treturn this.each( function( i ) {\n\t\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\treturn this.each( function() {\n\t\t\t\tvar self = jQuery( this ),\n\t\t\t\t\tcontents = self.contents();\n\t\n\t\t\t\tif ( contents.length ) {\n\t\t\t\t\tcontents.wrapAll( html );\n\t\n\t\t\t\t} else {\n\t\t\t\t\tself.append( html );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\twrap: function( html ) {\n\t\t\tvar isFunction = jQuery.isFunction( html );\n\t\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t\t} );\n\t\t},\n\t\n\t\tunwrap: function( selector ) {\n\t\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t} );\n\t\t\treturn this;\n\t\t}\n\t} );\n\t\n\t\n\tjQuery.expr.pseudos.hidden = function( elem ) {\n\t\treturn !jQuery.expr.pseudos.visible( elem );\n\t};\n\tjQuery.expr.pseudos.visible = function( elem ) {\n\t\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n\t};\n\t\n\t\n\t\n\t\n\tjQuery.ajaxSettings.xhr = function() {\n\t\ttry {\n\t\t\treturn new window.XMLHttpRequest();\n\t\t} catch ( e ) {}\n\t};\n\t\n\tvar xhrSuccessStatus = {\n\t\n\t\t\t// File protocol always yields status code 0, assume 200\n\t\t\t0: 200,\n\t\n\t\t\t// Support: IE <=9 only\n\t\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t\t1223: 204\n\t\t},\n\t\txhrSupported = jQuery.ajaxSettings.xhr();\n\t\n\tsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\n\tsupport.ajax = xhrSupported = !!xhrSupported;\n\t\n\tjQuery.ajaxTransport( function( options ) {\n\t\tvar callback, errorCallback;\n\t\n\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\t\treturn {\n\t\t\t\tsend: function( headers, complete ) {\n\t\t\t\t\tvar i,\n\t\t\t\t\t\txhr = options.xhr();\n\t\n\t\t\t\t\txhr.open(\n\t\t\t\t\t\toptions.type,\n\t\t\t\t\t\toptions.url,\n\t\t\t\t\t\toptions.async,\n\t\t\t\t\t\toptions.username,\n\t\t\t\t\t\toptions.password\n\t\t\t\t\t);\n\t\n\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Set headers\n\t\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Callback\n\t\t\t\t\tcallback = function( type ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\t\n\t\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\t\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcomplete(\n\t\n\t\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\n\t\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\n\t\t\t\t\t// Listen to events\n\t\t\t\t\txhr.onload = callback();\n\t\t\t\t\terrorCallback = xhr.onerror = callback( \"error\" );\n\t\n\t\t\t\t\t// Support: IE 9 only\n\t\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t\t// to handle uncaught aborts\n\t\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t\t} else {\n\t\t\t\t\t\txhr.onreadystatechange = function() {\n\t\n\t\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\t\n\t\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Create the abort callback\n\t\t\t\t\tcallback = callback( \"abort\" );\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\t// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n\tjQuery.ajaxPrefilter( function( s ) {\n\t\tif ( s.crossDomain ) {\n\t\t\ts.contents.script = false;\n\t\t}\n\t} );\n\t\n\t// Install script dataType\n\tjQuery.ajaxSetup( {\n\t\taccepts: {\n\t\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t\t},\n\t\tcontents: {\n\t\t\tscript: /\\b(?:java|ecma)script\\b/\n\t\t},\n\t\tconverters: {\n\t\t\t\"text script\": function( text ) {\n\t\t\t\tjQuery.globalEval( text );\n\t\t\t\treturn text;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t// Handle cache's special case and crossDomain\n\tjQuery.ajaxPrefilter( \"script\", function( s ) {\n\t\tif ( s.cache === undefined ) {\n\t\t\ts.cache = false;\n\t\t}\n\t\tif ( s.crossDomain ) {\n\t\t\ts.type = \"GET\";\n\t\t}\n\t} );\n\t\n\t// Bind script tag hack transport\n\tjQuery.ajaxTransport( \"script\", function( s ) {\n\t\n\t\t// This transport only deals with cross domain requests\n\t\tif ( s.crossDomain ) {\n\t\t\tvar script, callback;\n\t\t\treturn {\n\t\t\t\tsend: function( _, complete ) {\n\t\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\t\tsrc: s.url\n\t\t\t\t\t} ).on(\n\t\t\t\t\t\t\"load error\",\n\t\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\n\t\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t\t},\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\tvar oldCallbacks = [],\n\t\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\t\n\t// Default jsonp settings\n\tjQuery.ajaxSetup( {\n\t\tjsonp: \"callback\",\n\t\tjsonpCallback: function() {\n\t\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\t\tthis[ callback ] = true;\n\t\t\treturn callback;\n\t\t}\n\t} );\n\t\n\t// Detect, normalize options and install callbacks for jsonp requests\n\tjQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\t\n\t\tvar callbackName, overwritten, responseContainer,\n\t\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\t\"url\" :\n\t\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t\t);\n\t\n\t\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\t\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\t\n\t\t\t// Get callback name, remembering preexisting value associated with it\n\t\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\t\ts.jsonpCallback() :\n\t\t\t\ts.jsonpCallback;\n\t\n\t\t\t// Insert callback into url or form data\n\t\t\tif ( jsonProp ) {\n\t\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t\t} else if ( s.jsonp !== false ) {\n\t\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t\t}\n\t\n\t\t\t// Use data converter to retrieve json after script execution\n\t\t\ts.converters[ \"script json\" ] = function() {\n\t\t\t\tif ( !responseContainer ) {\n\t\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t\t}\n\t\t\t\treturn responseContainer[ 0 ];\n\t\t\t};\n\t\n\t\t\t// Force json dataType\n\t\t\ts.dataTypes[ 0 ] = \"json\";\n\t\n\t\t\t// Install callback\n\t\t\toverwritten = window[ callbackName ];\n\t\t\twindow[ callbackName ] = function() {\n\t\t\t\tresponseContainer = arguments;\n\t\t\t};\n\t\n\t\t\t// Clean-up function (fires after converters)\n\t\t\tjqXHR.always( function() {\n\t\n\t\t\t\t// If previous value didn't exist - remove it\n\t\t\t\tif ( overwritten === undefined ) {\n\t\t\t\t\tjQuery( window ).removeProp( callbackName );\n\t\n\t\t\t\t// Otherwise restore preexisting value\n\t\t\t\t} else {\n\t\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t\t}\n\t\n\t\t\t\t// Save back as free\n\t\t\t\tif ( s[ callbackName ] ) {\n\t\n\t\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\t\n\t\t\t\t\t// Save the callback name for future use\n\t\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t\t}\n\t\n\t\t\t\t// Call if it was a function and we have a response\n\t\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t\t}\n\t\n\t\t\t\tresponseContainer = overwritten = undefined;\n\t\t\t} );\n\t\n\t\t\t// Delegate to script\n\t\t\treturn \"script\";\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\t// Support: Safari 8 only\n\t// In Safari 8 documents created via document.implementation.createHTMLDocument\n\t// collapse sibling forms: the second one becomes a child of the first one.\n\t// Because of that, this security measure has to be disabled in Safari 8.\n\t// https://bugs.webkit.org/show_bug.cgi?id=137337\n\tsupport.createHTMLDocument = ( function() {\n\t\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\t\tbody.innerHTML = \"<form></form><form></form>\";\n\t\treturn body.childNodes.length === 2;\n\t} )();\n\t\n\t\n\t// Argument \"data\" should be string of html\n\t// context (optional): If specified, the fragment will be created in this context,\n\t// defaults to document\n\t// keepScripts (optional): If true, will include scripts passed in the html string\n\tjQuery.parseHTML = function( data, context, keepScripts ) {\n\t\tif ( typeof data !== \"string\" ) {\n\t\t\treturn [];\n\t\t}\n\t\tif ( typeof context === \"boolean\" ) {\n\t\t\tkeepScripts = context;\n\t\t\tcontext = false;\n\t\t}\n\t\n\t\tvar base, parsed, scripts;\n\t\n\t\tif ( !context ) {\n\t\n\t\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t\t// by using document.implementation\n\t\t\tif ( support.createHTMLDocument ) {\n\t\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\t\n\t\t\t\t// Set the base href for the created document\n\t\t\t\t// so any parsed elements with URLs\n\t\t\t\t// are based on the document's URL (gh-2965)\n\t\t\t\tbase = context.createElement( \"base\" );\n\t\t\t\tbase.href = document.location.href;\n\t\t\t\tcontext.head.appendChild( base );\n\t\t\t} else {\n\t\t\t\tcontext = document;\n\t\t\t}\n\t\t}\n\t\n\t\tparsed = rsingleTag.exec( data );\n\t\tscripts = !keepScripts && [];\n\t\n\t\t// Single tag\n\t\tif ( parsed ) {\n\t\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t\t}\n\t\n\t\tparsed = buildFragment( [ data ], context, scripts );\n\t\n\t\tif ( scripts && scripts.length ) {\n\t\t\tjQuery( scripts ).remove();\n\t\t}\n\t\n\t\treturn jQuery.merge( [], parsed.childNodes );\n\t};\n\t\n\t\n\t/**\n\t * Load a url into a page\n\t */\n\tjQuery.fn.load = function( url, params, callback ) {\n\t\tvar selector, type, response,\n\t\t\tself = this,\n\t\t\toff = url.indexOf( \" \" );\n\t\n\t\tif ( off > -1 ) {\n\t\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\t\turl = url.slice( 0, off );\n\t\t}\n\t\n\t\t// If it's a function\n\t\tif ( jQuery.isFunction( params ) ) {\n\t\n\t\t\t// We assume that it's the callback\n\t\t\tcallback = params;\n\t\t\tparams = undefined;\n\t\n\t\t// Otherwise, build a param string\n\t\t} else if ( params && typeof params === \"object\" ) {\n\t\t\ttype = \"POST\";\n\t\t}\n\t\n\t\t// If we have elements to modify, make the request\n\t\tif ( self.length > 0 ) {\n\t\t\tjQuery.ajax( {\n\t\t\t\turl: url,\n\t\n\t\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t\t// Make value of this field explicit since\n\t\t\t\t// user can override it through ajaxSetup method\n\t\t\t\ttype: type || \"GET\",\n\t\t\t\tdataType: \"html\",\n\t\t\t\tdata: params\n\t\t\t} ).done( function( responseText ) {\n\t\n\t\t\t\t// Save response for use in complete callback\n\t\t\t\tresponse = arguments;\n\t\n\t\t\t\tself.html( selector ?\n\t\n\t\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\t\n\t\t\t\t\t// Otherwise use the full result\n\t\t\t\t\tresponseText );\n\t\n\t\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t\t// but they are ignored because response was set above.\n\t\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\t\tself.each( function() {\n\t\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t\n\t\treturn this;\n\t};\n\t\n\t\n\t\n\t\n\t// Attach a bunch of functions for handling common AJAX events\n\tjQuery.each( [\n\t\t\"ajaxStart\",\n\t\t\"ajaxStop\",\n\t\t\"ajaxComplete\",\n\t\t\"ajaxError\",\n\t\t\"ajaxSuccess\",\n\t\t\"ajaxSend\"\n\t], function( i, type ) {\n\t\tjQuery.fn[ type ] = function( fn ) {\n\t\t\treturn this.on( type, fn );\n\t\t};\n\t} );\n\t\n\t\n\t\n\t\n\tjQuery.expr.pseudos.animated = function( elem ) {\n\t\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\t\treturn elem === fn.elem;\n\t\t} ).length;\n\t};\n\t\n\t\n\t\n\t\n\t/**\n\t * Gets a window from an element\n\t */\n\tfunction getWindow( elem ) {\n\t\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n\t}\n\t\n\tjQuery.offset = {\n\t\tsetOffset: function( elem, options, i ) {\n\t\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\t\tcurElem = jQuery( elem ),\n\t\t\t\tprops = {};\n\t\n\t\t\t// Set position first, in-case top/left are set even on static elem\n\t\t\tif ( position === \"static\" ) {\n\t\t\t\telem.style.position = \"relative\";\n\t\t\t}\n\t\n\t\t\tcurOffset = curElem.offset();\n\t\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\t\n\t\t\t// Need to be able to calculate position if either\n\t\t\t// top or left is auto and position is either absolute or fixed\n\t\t\tif ( calculatePosition ) {\n\t\t\t\tcurPosition = curElem.position();\n\t\t\t\tcurTop = curPosition.top;\n\t\t\t\tcurLeft = curPosition.left;\n\t\n\t\t\t} else {\n\t\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t\t}\n\t\n\t\t\tif ( jQuery.isFunction( options ) ) {\n\t\n\t\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t\t}\n\t\n\t\t\tif ( options.top != null ) {\n\t\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t\t}\n\t\t\tif ( options.left != null ) {\n\t\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t\t}\n\t\n\t\t\tif ( \"using\" in options ) {\n\t\t\t\toptions.using.call( elem, props );\n\t\n\t\t\t} else {\n\t\t\t\tcurElem.css( props );\n\t\t\t}\n\t\t}\n\t};\n\t\n\tjQuery.fn.extend( {\n\t\toffset: function( options ) {\n\t\n\t\t\t// Preserve chaining for setter\n\t\t\tif ( arguments.length ) {\n\t\t\t\treturn options === undefined ?\n\t\t\t\t\tthis :\n\t\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tvar docElem, win, rect, doc,\n\t\t\t\telem = this[ 0 ];\n\t\n\t\t\tif ( !elem ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Support: IE <=11 only\n\t\t\t// Running getBoundingClientRect on a\n\t\t\t// disconnected node in IE throws an error\n\t\t\tif ( !elem.getClientRects().length ) {\n\t\t\t\treturn { top: 0, left: 0 };\n\t\t\t}\n\t\n\t\t\trect = elem.getBoundingClientRect();\n\t\n\t\t\t// Make sure element is not hidden (display: none)\n\t\t\tif ( rect.width || rect.height ) {\n\t\t\t\tdoc = elem.ownerDocument;\n\t\t\t\twin = getWindow( doc );\n\t\t\t\tdocElem = doc.documentElement;\n\t\n\t\t\t\treturn {\n\t\t\t\t\ttop: rect.top + win.pageYOffset - docElem.clientTop,\n\t\t\t\t\tleft: rect.left + win.pageXOffset - docElem.clientLeft\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// Return zeros for disconnected and hidden elements (gh-2310)\n\t\t\treturn rect;\n\t\t},\n\t\n\t\tposition: function() {\n\t\t\tif ( !this[ 0 ] ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar offsetParent, offset,\n\t\t\t\telem = this[ 0 ],\n\t\t\t\tparentOffset = { top: 0, left: 0 };\n\t\n\t\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t\t// because it is its only offset parent\n\t\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\n\t\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\t\toffset = elem.getBoundingClientRect();\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// Get *real* offsetParent\n\t\t\t\toffsetParent = this.offsetParent();\n\t\n\t\t\t\t// Get correct offsets\n\t\t\t\toffset = this.offset();\n\t\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t\t}\n\t\n\t\t\t\t// Add offsetParent borders\n\t\t\t\tparentOffset = {\n\t\t\t\t\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true ),\n\t\t\t\t\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true )\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// Subtract parent offsets and element margins\n\t\t\treturn {\n\t\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t\t};\n\t\t},\n\t\n\t\t// This method will return documentElement in the following cases:\n\t\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t\t//    documentElement of the parent window\n\t\t// 2) For the hidden or detached element\n\t\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t\t//\n\t\t// but those exceptions were never presented as a real life use-cases\n\t\t// and might be considered as more preferable results.\n\t\t//\n\t\t// This logic, however, is not guaranteed and can change at any point in the future\n\t\toffsetParent: function() {\n\t\t\treturn this.map( function() {\n\t\t\t\tvar offsetParent = this.offsetParent;\n\t\n\t\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t\t}\n\t\n\t\t\t\treturn offsetParent || documentElement;\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\t// Create scrollLeft and scrollTop methods\n\tjQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\t\tvar top = \"pageYOffset\" === prop;\n\t\n\t\tjQuery.fn[ method ] = function( val ) {\n\t\t\treturn access( this, function( elem, method, val ) {\n\t\t\t\tvar win = getWindow( elem );\n\t\n\t\t\t\tif ( val === undefined ) {\n\t\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t\t}\n\t\n\t\t\t\tif ( win ) {\n\t\t\t\t\twin.scrollTo(\n\t\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t\t);\n\t\n\t\t\t\t} else {\n\t\t\t\t\telem[ method ] = val;\n\t\t\t\t}\n\t\t\t}, method, val, arguments.length );\n\t\t};\n\t} );\n\t\n\t// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n\t// Add the top/left cssHooks using jQuery.fn.position\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n\t// getComputedStyle returns percent when specified for top/left/bottom/right;\n\t// rather than make the css module depend on the offset module, just check for it here\n\tjQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\t\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\t\tfunction( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\tcomputed = curCSS( elem, prop );\n\t\n\t\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\t\tcomputed;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t} );\n\t\n\t\n\t// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\tjQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\t\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\t\tfunction( defaultExtra, funcName ) {\n\t\n\t\t\t// Margin is only for outerHeight, outerWidth\n\t\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\t\n\t\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\t\tvar doc;\n\t\n\t\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\n\t\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Get document width or height\n\t\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\t\tdoc = elem.documentElement;\n\t\n\t\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t\t// whichever is greatest\n\t\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn value === undefined ?\n\t\n\t\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\t\n\t\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t\t};\n\t\t} );\n\t} );\n\t\n\t\n\tjQuery.fn.extend( {\n\t\n\t\tbind: function( types, data, fn ) {\n\t\t\treturn this.on( types, null, data, fn );\n\t\t},\n\t\tunbind: function( types, fn ) {\n\t\t\treturn this.off( types, null, fn );\n\t\t},\n\t\n\t\tdelegate: function( selector, types, data, fn ) {\n\t\t\treturn this.on( types, selector, data, fn );\n\t\t},\n\t\tundelegate: function( selector, types, fn ) {\n\t\n\t\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\t\treturn arguments.length === 1 ?\n\t\t\t\tthis.off( selector, \"**\" ) :\n\t\t\t\tthis.off( types, selector || \"**\", fn );\n\t\t}\n\t} );\n\t\n\tjQuery.parseJSON = JSON.parse;\n\t\n\t\n\t\n\t\n\t// Register as a named AMD module, since jQuery can be concatenated with other\n\t// files that may use define, but not via a proper concatenation script that\n\t// understands anonymous AMD modules. A named AMD is safest and most robust\n\t// way to register. Lowercase jquery is used because AMD module names are\n\t// derived from file names, and jQuery is normally delivered in a lowercase\n\t// file name. Do this after creating the global so that if an AMD module wants\n\t// to call noConflict to hide this version of jQuery, it will work.\n\t\n\t// Note that for maximum portability, libraries that are not jQuery should\n\t// declare themselves as anonymous modules, and avoid setting a global if an\n\t// AMD loader is present. jQuery is a special case. For more information, see\n\t// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\t\n\tif ( true ) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\treturn jQuery;\n\t\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\t\n\t\n\t\n\t\n\tvar\n\t\n\t\t// Map over jQuery in case of overwrite\n\t\t_jQuery = window.jQuery,\n\t\n\t\t// Map over the $ in case of overwrite\n\t\t_$ = window.$;\n\t\n\tjQuery.noConflict = function( deep ) {\n\t\tif ( window.$ === jQuery ) {\n\t\t\twindow.$ = _$;\n\t\t}\n\t\n\t\tif ( deep && window.jQuery === jQuery ) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\t\n\t\treturn jQuery;\n\t};\n\t\n\t// Expose jQuery and $ identifiers, even in AMD\n\t// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n\t// and CommonJS for browser emulators (#13566)\n\tif ( !noGlobal ) {\n\t\twindow.jQuery = window.$ = jQuery;\n\t}\n\t\n\t\n\t\n\t\n\t\n\treturn jQuery;\n\t} );\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t\t true ? factory(exports) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t\t(factory((global.THREE = global.THREE || {})));\n\t}(this, (function (exports) { 'use strict';\n\t\n\t\t// Polyfills\n\t\n\t\tif ( Number.EPSILON === undefined ) {\n\t\n\t\t\tNumber.EPSILON = Math.pow( 2, - 52 );\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tif ( Math.sign === undefined ) {\n\t\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\t\n\t\t\tMath.sign = function ( x ) {\n\t\n\t\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tif ( Function.prototype.name === undefined ) {\n\t\n\t\t\t// Missing in IE9-11.\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\t\n\t\t\tObject.defineProperty( Function.prototype, 'name', {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\n\t\n\t\t\t\t}\n\t\n\t\t\t} );\n\t\n\t\t}\n\t\n\t\tif ( Object.assign === undefined ) {\n\t\n\t\t\t// Missing in IE.\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\t\n\t\t\t( function () {\n\t\n\t\t\t\tObject.assign = function ( target ) {\n\t\n\t\t\t\t\t'use strict';\n\t\n\t\t\t\t\tif ( target === undefined || target === null ) {\n\t\n\t\t\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar output = Object( target );\n\t\n\t\t\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\t\n\t\t\t\t\t\tvar source = arguments[ index ];\n\t\n\t\t\t\t\t\tif ( source !== undefined && source !== null ) {\n\t\n\t\t\t\t\t\t\tfor ( var nextKey in source ) {\n\t\n\t\t\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\t\n\t\t\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn output;\n\t\n\t\t\t\t};\n\t\n\t\t\t} )();\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * https://github.com/mrdoob/eventdispatcher.js/\n\t\t */\n\t\n\t\tfunction EventDispatcher() {}\n\t\n\t\tObject.assign( EventDispatcher.prototype, {\n\t\n\t\t\taddEventListener: function ( type, listener ) {\n\t\n\t\t\t\tif ( this._listeners === undefined ) this._listeners = {};\n\t\n\t\t\t\tvar listeners = this._listeners;\n\t\n\t\t\t\tif ( listeners[ type ] === undefined ) {\n\t\n\t\t\t\t\tlisteners[ type ] = [];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\t\n\t\t\t\t\tlisteners[ type ].push( listener );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\thasEventListener: function ( type, listener ) {\n\t\n\t\t\t\tif ( this._listeners === undefined ) return false;\n\t\n\t\t\t\tvar listeners = this._listeners;\n\t\n\t\t\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t},\n\t\n\t\t\tremoveEventListener: function ( type, listener ) {\n\t\n\t\t\t\tif ( this._listeners === undefined ) return;\n\t\n\t\t\t\tvar listeners = this._listeners;\n\t\t\t\tvar listenerArray = listeners[ type ];\n\t\n\t\t\t\tif ( listenerArray !== undefined ) {\n\t\n\t\t\t\t\tvar index = listenerArray.indexOf( listener );\n\t\n\t\t\t\t\tif ( index !== - 1 ) {\n\t\n\t\t\t\t\t\tlistenerArray.splice( index, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tdispatchEvent: function ( event ) {\n\t\n\t\t\t\tif ( this._listeners === undefined ) return;\n\t\n\t\t\t\tvar listeners = this._listeners;\n\t\t\t\tvar listenerArray = listeners[ event.type ];\n\t\n\t\t\t\tif ( listenerArray !== undefined ) {\n\t\n\t\t\t\t\tevent.target = this;\n\t\n\t\t\t\t\tvar array = [], i = 0;\n\t\t\t\t\tvar length = listenerArray.length;\n\t\n\t\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\t\tarray[ i ] = listenerArray[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\t\tarray[ i ].call( this, event );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar REVISION = '82';\n\t\tvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\n\t\tvar CullFaceNone = 0;\n\t\tvar CullFaceBack = 1;\n\t\tvar CullFaceFront = 2;\n\t\tvar CullFaceFrontBack = 3;\n\t\tvar FrontFaceDirectionCW = 0;\n\t\tvar FrontFaceDirectionCCW = 1;\n\t\tvar BasicShadowMap = 0;\n\t\tvar PCFShadowMap = 1;\n\t\tvar PCFSoftShadowMap = 2;\n\t\tvar FrontSide = 0;\n\t\tvar BackSide = 1;\n\t\tvar DoubleSide = 2;\n\t\tvar FlatShading = 1;\n\t\tvar SmoothShading = 2;\n\t\tvar NoColors = 0;\n\t\tvar FaceColors = 1;\n\t\tvar VertexColors = 2;\n\t\tvar NoBlending = 0;\n\t\tvar NormalBlending = 1;\n\t\tvar AdditiveBlending = 2;\n\t\tvar SubtractiveBlending = 3;\n\t\tvar MultiplyBlending = 4;\n\t\tvar CustomBlending = 5;\n\t\tvar BlendingMode = {\n\t\t\tNoBlending: NoBlending,\n\t\t\tNormalBlending: NormalBlending,\n\t\t\tAdditiveBlending: AdditiveBlending,\n\t\t\tSubtractiveBlending: SubtractiveBlending,\n\t\t\tMultiplyBlending: MultiplyBlending,\n\t\t\tCustomBlending: CustomBlending\n\t\t};\n\t\tvar AddEquation = 100;\n\t\tvar SubtractEquation = 101;\n\t\tvar ReverseSubtractEquation = 102;\n\t\tvar MinEquation = 103;\n\t\tvar MaxEquation = 104;\n\t\tvar ZeroFactor = 200;\n\t\tvar OneFactor = 201;\n\t\tvar SrcColorFactor = 202;\n\t\tvar OneMinusSrcColorFactor = 203;\n\t\tvar SrcAlphaFactor = 204;\n\t\tvar OneMinusSrcAlphaFactor = 205;\n\t\tvar DstAlphaFactor = 206;\n\t\tvar OneMinusDstAlphaFactor = 207;\n\t\tvar DstColorFactor = 208;\n\t\tvar OneMinusDstColorFactor = 209;\n\t\tvar SrcAlphaSaturateFactor = 210;\n\t\tvar NeverDepth = 0;\n\t\tvar AlwaysDepth = 1;\n\t\tvar LessDepth = 2;\n\t\tvar LessEqualDepth = 3;\n\t\tvar EqualDepth = 4;\n\t\tvar GreaterEqualDepth = 5;\n\t\tvar GreaterDepth = 6;\n\t\tvar NotEqualDepth = 7;\n\t\tvar MultiplyOperation = 0;\n\t\tvar MixOperation = 1;\n\t\tvar AddOperation = 2;\n\t\tvar NoToneMapping = 0;\n\t\tvar LinearToneMapping = 1;\n\t\tvar ReinhardToneMapping = 2;\n\t\tvar Uncharted2ToneMapping = 3;\n\t\tvar CineonToneMapping = 4;\n\t\tvar UVMapping = 300;\n\t\tvar CubeReflectionMapping = 301;\n\t\tvar CubeRefractionMapping = 302;\n\t\tvar EquirectangularReflectionMapping = 303;\n\t\tvar EquirectangularRefractionMapping = 304;\n\t\tvar SphericalReflectionMapping = 305;\n\t\tvar CubeUVReflectionMapping = 306;\n\t\tvar CubeUVRefractionMapping = 307;\n\t\tvar TextureMapping = {\n\t\t\tUVMapping: UVMapping,\n\t\t\tCubeReflectionMapping: CubeReflectionMapping,\n\t\t\tCubeRefractionMapping: CubeRefractionMapping,\n\t\t\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\t\t\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\t\t\tSphericalReflectionMapping: SphericalReflectionMapping,\n\t\t\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\t\t\tCubeUVRefractionMapping: CubeUVRefractionMapping\n\t\t};\n\t\tvar RepeatWrapping = 1000;\n\t\tvar ClampToEdgeWrapping = 1001;\n\t\tvar MirroredRepeatWrapping = 1002;\n\t\tvar TextureWrapping = {\n\t\t\tRepeatWrapping: RepeatWrapping,\n\t\t\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\t\t\tMirroredRepeatWrapping: MirroredRepeatWrapping\n\t\t};\n\t\tvar NearestFilter = 1003;\n\t\tvar NearestMipMapNearestFilter = 1004;\n\t\tvar NearestMipMapLinearFilter = 1005;\n\t\tvar LinearFilter = 1006;\n\t\tvar LinearMipMapNearestFilter = 1007;\n\t\tvar LinearMipMapLinearFilter = 1008;\n\t\tvar TextureFilter = {\n\t\t\tNearestFilter: NearestFilter,\n\t\t\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\n\t\t\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\n\t\t\tLinearFilter: LinearFilter,\n\t\t\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\n\t\t\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\n\t\t};\n\t\tvar UnsignedByteType = 1009;\n\t\tvar ByteType = 1010;\n\t\tvar ShortType = 1011;\n\t\tvar UnsignedShortType = 1012;\n\t\tvar IntType = 1013;\n\t\tvar UnsignedIntType = 1014;\n\t\tvar FloatType = 1015;\n\t\tvar HalfFloatType = 1016;\n\t\tvar UnsignedShort4444Type = 1017;\n\t\tvar UnsignedShort5551Type = 1018;\n\t\tvar UnsignedShort565Type = 1019;\n\t\tvar UnsignedInt248Type = 1020;\n\t\tvar AlphaFormat = 1021;\n\t\tvar RGBFormat = 1022;\n\t\tvar RGBAFormat = 1023;\n\t\tvar LuminanceFormat = 1024;\n\t\tvar LuminanceAlphaFormat = 1025;\n\t\tvar RGBEFormat = RGBAFormat;\n\t\tvar DepthFormat = 1026;\n\t\tvar DepthStencilFormat = 1027;\n\t\tvar RGB_S3TC_DXT1_Format = 2001;\n\t\tvar RGBA_S3TC_DXT1_Format = 2002;\n\t\tvar RGBA_S3TC_DXT3_Format = 2003;\n\t\tvar RGBA_S3TC_DXT5_Format = 2004;\n\t\tvar RGB_PVRTC_4BPPV1_Format = 2100;\n\t\tvar RGB_PVRTC_2BPPV1_Format = 2101;\n\t\tvar RGBA_PVRTC_4BPPV1_Format = 2102;\n\t\tvar RGBA_PVRTC_2BPPV1_Format = 2103;\n\t\tvar RGB_ETC1_Format = 2151;\n\t\tvar LoopOnce = 2200;\n\t\tvar LoopRepeat = 2201;\n\t\tvar LoopPingPong = 2202;\n\t\tvar InterpolateDiscrete = 2300;\n\t\tvar InterpolateLinear = 2301;\n\t\tvar InterpolateSmooth = 2302;\n\t\tvar ZeroCurvatureEnding = 2400;\n\t\tvar ZeroSlopeEnding = 2401;\n\t\tvar WrapAroundEnding = 2402;\n\t\tvar TrianglesDrawMode = 0;\n\t\tvar TriangleStripDrawMode = 1;\n\t\tvar TriangleFanDrawMode = 2;\n\t\tvar LinearEncoding = 3000;\n\t\tvar sRGBEncoding = 3001;\n\t\tvar GammaEncoding = 3007;\n\t\tvar RGBEEncoding = 3002;\n\t\tvar LogLuvEncoding = 3003;\n\t\tvar RGBM7Encoding = 3004;\n\t\tvar RGBM16Encoding = 3005;\n\t\tvar RGBDEncoding = 3006;\n\t\tvar BasicDepthPacking = 3200;\n\t\tvar RGBADepthPacking = 3201;\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tvar _Math = {\n\t\n\t\t\tDEG2RAD: Math.PI / 180,\n\t\t\tRAD2DEG: 180 / Math.PI,\n\t\n\t\t\tgenerateUUID: function () {\n\t\n\t\t\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\t\n\t\t\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n\t\t\t\tvar uuid = new Array( 36 );\n\t\t\t\tvar rnd = 0, r;\n\t\n\t\t\t\treturn function generateUUID() {\n\t\n\t\t\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\t\n\t\t\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\t\n\t\t\t\t\t\t\tuuid[ i ] = '-';\n\t\n\t\t\t\t\t\t} else if ( i === 14 ) {\n\t\n\t\t\t\t\t\t\tuuid[ i ] = '4';\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n\t\t\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn uuid.join( '' );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclamp: function ( value, min, max ) {\n\t\n\t\t\t\treturn Math.max( min, Math.min( max, value ) );\n\t\n\t\t\t},\n\t\n\t\t\t// compute euclidian modulo of m % n\n\t\t\t// https://en.wikipedia.org/wiki/Modulo_operation\n\t\n\t\t\teuclideanModulo: function ( n, m ) {\n\t\n\t\t\t\treturn ( ( n % m ) + m ) % m;\n\t\n\t\t\t},\n\t\n\t\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\t\n\t\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\t\n\t\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\t\n\t\t\t},\n\t\n\t\t\t// https://en.wikipedia.org/wiki/Linear_interpolation\n\t\n\t\t\tlerp: function ( x, y, t ) {\n\t\n\t\t\t\treturn ( 1 - t ) * x + t * y;\n\t\n\t\t\t},\n\t\n\t\t\t// http://en.wikipedia.org/wiki/Smoothstep\n\t\n\t\t\tsmoothstep: function ( x, min, max ) {\n\t\n\t\t\t\tif ( x <= min ) return 0;\n\t\t\t\tif ( x >= max ) return 1;\n\t\n\t\t\t\tx = ( x - min ) / ( max - min );\n\t\n\t\t\t\treturn x * x * ( 3 - 2 * x );\n\t\n\t\t\t},\n\t\n\t\t\tsmootherstep: function ( x, min, max ) {\n\t\n\t\t\t\tif ( x <= min ) return 0;\n\t\t\t\tif ( x >= max ) return 1;\n\t\n\t\t\t\tx = ( x - min ) / ( max - min );\n\t\n\t\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\t\n\t\t\t},\n\t\n\t\t\trandom16: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n\t\t\t\treturn Math.random();\n\t\n\t\t\t},\n\t\n\t\t\t// Random integer from <low, high> interval\n\t\n\t\t\trandInt: function ( low, high ) {\n\t\n\t\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\t\n\t\t\t},\n\t\n\t\t\t// Random float from <low, high> interval\n\t\n\t\t\trandFloat: function ( low, high ) {\n\t\n\t\t\t\treturn low + Math.random() * ( high - low );\n\t\n\t\t\t},\n\t\n\t\t\t// Random float from <-range/2, range/2> interval\n\t\n\t\t\trandFloatSpread: function ( range ) {\n\t\n\t\t\t\treturn range * ( 0.5 - Math.random() );\n\t\n\t\t\t},\n\t\n\t\t\tdegToRad: function ( degrees ) {\n\t\n\t\t\t\treturn degrees * _Math.DEG2RAD;\n\t\n\t\t\t},\n\t\n\t\t\tradToDeg: function ( radians ) {\n\t\n\t\t\t\treturn radians * _Math.RAD2DEG;\n\t\n\t\t\t},\n\t\n\t\t\tisPowerOfTwo: function ( value ) {\n\t\n\t\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\t\n\t\t\t},\n\t\n\t\t\tnearestPowerOfTwo: function ( value ) {\n\t\n\t\t\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\t\n\t\t\t},\n\t\n\t\t\tnextPowerOfTwo: function ( value ) {\n\t\n\t\t\t\tvalue --;\n\t\t\t\tvalue |= value >> 1;\n\t\t\t\tvalue |= value >> 2;\n\t\t\t\tvalue |= value >> 4;\n\t\t\t\tvalue |= value >> 8;\n\t\t\t\tvalue |= value >> 16;\n\t\t\t\tvalue ++;\n\t\n\t\t\t\treturn value;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author philogb / http://blog.thejit.org/\n\t\t * @author egraether / http://egraether.com/\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t */\n\t\n\t\tfunction Vector2( x, y ) {\n\t\n\t\t\tthis.x = x || 0;\n\t\t\tthis.y = y || 0;\n\t\n\t\t}\n\t\n\t\tVector2.prototype = {\n\t\n\t\t\tconstructor: Vector2,\n\t\n\t\t\tisVector2: true,\n\t\n\t\t\tget width() {\n\t\n\t\t\t\treturn this.x;\n\t\n\t\t\t},\n\t\n\t\t\tset width( value ) {\n\t\n\t\t\t\tthis.x = value;\n\t\n\t\t\t},\n\t\n\t\t\tget height() {\n\t\n\t\t\t\treturn this.y;\n\t\n\t\t\t},\n\t\n\t\t\tset height( value ) {\n\t\n\t\t\t\tthis.y = value;\n\t\n\t\t\t},\n\t\n\t\t\t//\n\t\n\t\t\tset: function ( x, y ) {\n\t\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.x = scalar;\n\t\t\t\tthis.y = scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( x ) {\n\t\n\t\t\t\tthis.x = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( y ) {\n\t\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetComponent: function ( index ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: return this.x;\n\t\t\t\t\tcase 1: return this.y;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.x, this.y );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( v ) {\n\t\n\t\t\t\tthis.x = v.x;\n\t\t\t\tthis.y = v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x += v.x;\n\t\t\t\tthis.y += v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScalar: function ( s ) {\n\t\n\t\t\t\tthis.x += s;\n\t\t\t\tthis.y += s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x + b.x;\n\t\t\t\tthis.y = a.y + b.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\t\tthis.x += v.x * s;\n\t\t\t\tthis.y += v.y * s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsub: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x -= v.x;\n\t\t\t\tthis.y -= v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubScalar: function ( s ) {\n\t\n\t\t\t\tthis.x -= s;\n\t\t\t\tthis.y -= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x - b.x;\n\t\t\t\tthis.y = a.y - b.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiply: function ( v ) {\n\t\n\t\t\t\tthis.x *= v.x;\n\t\t\t\tthis.y *= v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\t\tif ( isFinite( scalar ) ) {\n\t\n\t\t\t\t\tthis.x *= scalar;\n\t\t\t\t\tthis.y *= scalar;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.x = 0;\n\t\t\t\t\tthis.y = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdivide: function ( v ) {\n\t\n\t\t\t\tthis.x /= v.x;\n\t\t\t\tthis.y /= v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t\t},\n\t\n\t\t\tmin: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\t\tthis.y = Math.min( this.y, v.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmax: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\t\tthis.y = Math.max( this.y, v.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclamp: function ( min, max ) {\n\t\n\t\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\t\n\t\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclampScalar: function () {\n\t\n\t\t\t\tvar min, max;\n\t\n\t\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\t\tif ( min === undefined ) {\n\t\n\t\t\t\t\t\tmin = new Vector2();\n\t\t\t\t\t\tmax = new Vector2();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmin.set( minVal, minVal );\n\t\t\t\t\tmax.set( maxVal, maxVal );\n\t\n\t\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclampLength: function ( min, max ) {\n\t\n\t\t\t\tvar length = this.length();\n\t\n\t\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\t\n\t\t\t},\n\t\n\t\t\tfloor: function () {\n\t\n\t\t\t\tthis.x = Math.floor( this.x );\n\t\t\t\tthis.y = Math.floor( this.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tceil: function () {\n\t\n\t\t\t\tthis.x = Math.ceil( this.x );\n\t\t\t\tthis.y = Math.ceil( this.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tround: function () {\n\t\n\t\t\t\tthis.x = Math.round( this.x );\n\t\t\t\tthis.y = Math.round( this.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\troundToZero: function () {\n\t\n\t\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnegate: function () {\n\t\n\t\t\t\tthis.x = - this.x;\n\t\t\t\tthis.y = - this.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdot: function ( v ) {\n\t\n\t\t\t\treturn this.x * v.x + this.y * v.y;\n\t\n\t\t\t},\n\t\n\t\t\tlengthSq: function () {\n\t\n\t\t\t\treturn this.x * this.x + this.y * this.y;\n\t\n\t\t\t},\n\t\n\t\t\tlength: function () {\n\t\n\t\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\t\n\t\t\t},\n\t\n\t\t\tlengthManhattan: function() {\n\t\n\t\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\treturn this.divideScalar( this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tangle: function () {\n\t\n\t\t\t\t// computes the angle in radians with respect to the positive x-axis\n\t\n\t\t\t\tvar angle = Math.atan2( this.y, this.x );\n\t\n\t\t\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\t\n\t\t\t\treturn angle;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceTo: function ( v ) {\n\t\n\t\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToSquared: function ( v ) {\n\t\n\t\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\t\t\treturn dx * dx + dy * dy;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToManhattan: function ( v ) {\n\t\n\t\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\t\n\t\t\t},\n\t\n\t\t\tsetLength: function ( length ) {\n\t\n\t\t\t\treturn this.multiplyScalar( length / this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( v ) {\n\t\n\t\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.x = array[ offset ];\n\t\t\t\tthis.y = array[ offset + 1 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this.x;\n\t\t\t\tarray[ offset + 1 ] = this.y;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tindex = index * attribute.itemSize + offset;\n\t\n\t\t\t\tthis.x = attribute.array[ index ];\n\t\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trotateAround: function ( center, angle ) {\n\t\n\t\t\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\t\n\t\t\t\tvar x = this.x - center.x;\n\t\t\t\tvar y = this.y - center.y;\n\t\n\t\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\t\tthis.y = x * s + y * c + center.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author szimek / https://github.com/szimek/\n\t\t */\n\t\n\t\tfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: TextureIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.sourceFile = '';\n\t\n\t\t\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n\t\t\tthis.mipmaps = [];\n\t\n\t\t\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n\t\n\t\t\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n\t\t\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n\t\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\n\t\n\t\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\t\n\t\t\tthis.format = format !== undefined ? format : RGBAFormat;\n\t\t\tthis.type = type !== undefined ? type : UnsignedByteType;\n\t\n\t\t\tthis.offset = new Vector2( 0, 0 );\n\t\t\tthis.repeat = new Vector2( 1, 1 );\n\t\n\t\t\tthis.generateMipmaps = true;\n\t\t\tthis.premultiplyAlpha = false;\n\t\t\tthis.flipY = true;\n\t\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\t\n\t\n\t\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t\t//\n\t\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\t\t\tthis.encoding = encoding !== undefined ? encoding :  LinearEncoding;\n\t\n\t\t\tthis.version = 0;\n\t\t\tthis.onUpdate = null;\n\t\n\t\t}\n\t\n\t\tTexture.DEFAULT_IMAGE = undefined;\n\t\tTexture.DEFAULT_MAPPING = UVMapping;\n\t\n\t\tTexture.prototype = {\n\t\n\t\t\tconstructor: Texture,\n\t\n\t\t\tisTexture: true,\n\t\n\t\t\tset needsUpdate( value ) {\n\t\n\t\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.image = source.image;\n\t\t\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\t\n\t\t\t\tthis.mapping = source.mapping;\n\t\n\t\t\t\tthis.wrapS = source.wrapS;\n\t\t\t\tthis.wrapT = source.wrapT;\n\t\n\t\t\t\tthis.magFilter = source.magFilter;\n\t\t\t\tthis.minFilter = source.minFilter;\n\t\n\t\t\t\tthis.anisotropy = source.anisotropy;\n\t\n\t\t\t\tthis.format = source.format;\n\t\t\t\tthis.type = source.type;\n\t\n\t\t\t\tthis.offset.copy( source.offset );\n\t\t\t\tthis.repeat.copy( source.repeat );\n\t\n\t\t\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\t\t\tthis.flipY = source.flipY;\n\t\t\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\t\t\tthis.encoding = source.encoding;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\n\t\n\t\t\t\t\treturn meta.textures[ this.uuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getDataURL( image ) {\n\t\n\t\t\t\t\tvar canvas;\n\t\n\t\t\t\t\tif ( image.toDataURL !== undefined ) {\n\t\n\t\t\t\t\t\tcanvas = image;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\t\tcanvas.width = image.width;\n\t\t\t\t\t\tcanvas.height = image.height;\n\t\n\t\t\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\t\n\t\t\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar output = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.4,\n\t\t\t\t\t\ttype: 'Texture',\n\t\t\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t\t\t},\n\t\n\t\t\t\t\tuuid: this.uuid,\n\t\t\t\t\tname: this.name,\n\t\n\t\t\t\t\tmapping: this.mapping,\n\t\n\t\t\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\t\t\twrap: [ this.wrapS, this.wrapT ],\n\t\n\t\t\t\t\tminFilter: this.minFilter,\n\t\t\t\t\tmagFilter: this.magFilter,\n\t\t\t\t\tanisotropy: this.anisotropy,\n\t\n\t\t\t\t\tflipY: this.flipY\n\t\t\t\t};\n\t\n\t\t\t\tif ( this.image !== undefined ) {\n\t\n\t\t\t\t\t// TODO: Move to THREE.Image\n\t\n\t\t\t\t\tvar image = this.image;\n\t\n\t\t\t\t\tif ( image.uuid === undefined ) {\n\t\n\t\t\t\t\t\timage.uuid = _Math.generateUUID(); // UGH\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\n\t\n\t\t\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\toutput.image = image.uuid;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmeta.textures[ this.uuid ] = output;\n\t\n\t\t\t\treturn output;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t},\n\t\n\t\t\ttransformUv: function ( uv ) {\n\t\n\t\t\t\tif ( this.mapping !== UVMapping )  return;\n\t\n\t\t\t\tuv.multiply( this.repeat );\n\t\t\t\tuv.add( this.offset );\n\t\n\t\t\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\t\n\t\t\t\t\tswitch ( this.wrapS ) {\n\t\n\t\t\t\t\t\tcase RepeatWrapping:\n\t\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase ClampToEdgeWrapping:\n\t\n\t\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase MirroredRepeatWrapping:\n\t\n\t\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\t\n\t\t\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\t\n\t\t\t\t\tswitch ( this.wrapT ) {\n\t\n\t\t\t\t\t\tcase RepeatWrapping:\n\t\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase ClampToEdgeWrapping:\n\t\n\t\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase MirroredRepeatWrapping:\n\t\n\t\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\t\n\t\t\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.flipY ) {\n\t\n\t\t\t\t\tuv.y = 1 - uv.y;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tObject.assign( Texture.prototype, EventDispatcher.prototype );\n\t\n\t\tvar count = 0;\n\t\tfunction TextureIdCount() { return count++; }\n\t\n\t\t/**\n\t\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t\t * @author philogb / http://blog.thejit.org/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author egraether / http://egraether.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Vector4( x, y, z, w ) {\n\t\n\t\t\tthis.x = x || 0;\n\t\t\tthis.y = y || 0;\n\t\t\tthis.z = z || 0;\n\t\t\tthis.w = ( w !== undefined ) ? w : 1;\n\t\n\t\t}\n\t\n\t\tVector4.prototype = {\n\t\n\t\t\tconstructor: Vector4,\n\t\n\t\t\tisVector4: true,\n\t\n\t\t\tset: function ( x, y, z, w ) {\n\t\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.z = z;\n\t\t\t\tthis.w = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.x = scalar;\n\t\t\t\tthis.y = scalar;\n\t\t\t\tthis.z = scalar;\n\t\t\t\tthis.w = scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( x ) {\n\t\n\t\t\t\tthis.x = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( y ) {\n\t\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetZ: function ( z ) {\n\t\n\t\t\t\tthis.z = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetW: function ( w ) {\n\t\n\t\t\t\tthis.w = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\t\tcase 3: this.w = value; break;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetComponent: function ( index ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: return this.x;\n\t\t\t\t\tcase 1: return this.y;\n\t\t\t\t\tcase 2: return this.z;\n\t\t\t\t\tcase 3: return this.w;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( v ) {\n\t\n\t\t\t\tthis.x = v.x;\n\t\t\t\tthis.y = v.y;\n\t\t\t\tthis.z = v.z;\n\t\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x += v.x;\n\t\t\t\tthis.y += v.y;\n\t\t\t\tthis.z += v.z;\n\t\t\t\tthis.w += v.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScalar: function ( s ) {\n\t\n\t\t\t\tthis.x += s;\n\t\t\t\tthis.y += s;\n\t\t\t\tthis.z += s;\n\t\t\t\tthis.w += s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x + b.x;\n\t\t\t\tthis.y = a.y + b.y;\n\t\t\t\tthis.z = a.z + b.z;\n\t\t\t\tthis.w = a.w + b.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\t\tthis.x += v.x * s;\n\t\t\t\tthis.y += v.y * s;\n\t\t\t\tthis.z += v.z * s;\n\t\t\t\tthis.w += v.w * s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsub: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x -= v.x;\n\t\t\t\tthis.y -= v.y;\n\t\t\t\tthis.z -= v.z;\n\t\t\t\tthis.w -= v.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubScalar: function ( s ) {\n\t\n\t\t\t\tthis.x -= s;\n\t\t\t\tthis.y -= s;\n\t\t\t\tthis.z -= s;\n\t\t\t\tthis.w -= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x - b.x;\n\t\t\t\tthis.y = a.y - b.y;\n\t\t\t\tthis.z = a.z - b.z;\n\t\t\t\tthis.w = a.w - b.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\t\tif ( isFinite( scalar ) ) {\n\t\n\t\t\t\t\tthis.x *= scalar;\n\t\t\t\t\tthis.y *= scalar;\n\t\t\t\t\tthis.z *= scalar;\n\t\t\t\t\tthis.w *= scalar;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.x = 0;\n\t\t\t\t\tthis.y = 0;\n\t\t\t\t\tthis.z = 0;\n\t\t\t\t\tthis.w = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function ( m ) {\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t\t},\n\t\n\t\t\tsetAxisAngleFromQuaternion: function ( q ) {\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\t\n\t\t\t\t// q is assumed to be normalized\n\t\n\t\t\t\tthis.w = 2 * Math.acos( q.w );\n\t\n\t\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\t\n\t\t\t\tif ( s < 0.0001 ) {\n\t\n\t\t\t\t\t this.x = 1;\n\t\t\t\t\t this.y = 0;\n\t\t\t\t\t this.z = 0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t this.x = q.x / s;\n\t\t\t\t\t this.y = q.y / s;\n\t\t\t\t\t this.z = q.z / s;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\t\n\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\t\n\t\t\t\t\tte = m.elements,\n\t\n\t\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\t\n\t\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\t\n\t\t\t\t\t// singularity found\n\t\t\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t\t\t// in leading diagonal and zero in other terms\n\t\n\t\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\t\n\t\t\t\t\t\t// this singularity is identity matrix so angle = 0\n\t\n\t\t\t\t\t\tthis.set( 1, 0, 0, 0 );\n\t\n\t\t\t\t\t\treturn this; // zero angle, arbitrary axis\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// otherwise this singularity is angle = 180\n\t\n\t\t\t\t\tangle = Math.PI;\n\t\n\t\t\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\t\t\tvar yz = ( m23 + m32 ) / 4;\n\t\n\t\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\t\n\t\t\t\t\t\t// m11 is the largest diagonal term\n\t\n\t\t\t\t\t\tif ( xx < epsilon ) {\n\t\n\t\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\t\tz = 0.707106781;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\t\t\ty = xy / x;\n\t\t\t\t\t\t\tz = xz / x;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( yy > zz ) {\n\t\n\t\t\t\t\t\t// m22 is the largest diagonal term\n\t\n\t\t\t\t\t\tif ( yy < epsilon ) {\n\t\n\t\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\t\tz = 0.707106781;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\t\t\tx = xy / y;\n\t\t\t\t\t\t\tz = yz / y;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// m33 is the largest diagonal term so base result on this\n\t\n\t\t\t\t\t\tif ( zz < epsilon ) {\n\t\n\t\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\t\tz = 0;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\t\t\tx = xz / z;\n\t\t\t\t\t\t\ty = yz / z;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.set( x, y, z, angle );\n\t\n\t\t\t\t\treturn this; // return 180 deg rotation\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// as we have reached here there are no singularities so we can handle normally\n\t\n\t\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\t\n\t\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\t\n\t\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t\t\t// caught by singularity test above, but I've left it in just in case\n\t\n\t\t\t\tthis.x = ( m32 - m23 ) / s;\n\t\t\t\tthis.y = ( m13 - m31 ) / s;\n\t\t\t\tthis.z = ( m21 - m12 ) / s;\n\t\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmin: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\t\tthis.z = Math.min( this.z, v.z );\n\t\t\t\tthis.w = Math.min( this.w, v.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmax: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\t\tthis.z = Math.max( this.z, v.z );\n\t\t\t\tthis.w = Math.max( this.w, v.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclamp: function ( min, max ) {\n\t\n\t\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\t\n\t\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\t\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclampScalar: function () {\n\t\n\t\t\t\tvar min, max;\n\t\n\t\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\t\tif ( min === undefined ) {\n\t\n\t\t\t\t\t\tmin = new Vector4();\n\t\t\t\t\t\tmax = new Vector4();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\t\n\t\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tfloor: function () {\n\t\n\t\t\t\tthis.x = Math.floor( this.x );\n\t\t\t\tthis.y = Math.floor( this.y );\n\t\t\t\tthis.z = Math.floor( this.z );\n\t\t\t\tthis.w = Math.floor( this.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tceil: function () {\n\t\n\t\t\t\tthis.x = Math.ceil( this.x );\n\t\t\t\tthis.y = Math.ceil( this.y );\n\t\t\t\tthis.z = Math.ceil( this.z );\n\t\t\t\tthis.w = Math.ceil( this.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tround: function () {\n\t\n\t\t\t\tthis.x = Math.round( this.x );\n\t\t\t\tthis.y = Math.round( this.y );\n\t\t\t\tthis.z = Math.round( this.z );\n\t\t\t\tthis.w = Math.round( this.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\troundToZero: function () {\n\t\n\t\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnegate: function () {\n\t\n\t\t\t\tthis.x = - this.x;\n\t\t\t\tthis.y = - this.y;\n\t\t\t\tthis.z = - this.z;\n\t\t\t\tthis.w = - this.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdot: function ( v ) {\n\t\n\t\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\t\n\t\t\t},\n\t\n\t\t\tlengthSq: function () {\n\t\n\t\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\t\n\t\t\t},\n\t\n\t\t\tlength: function () {\n\t\n\t\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\t\n\t\t\t},\n\t\n\t\t\tlengthManhattan: function () {\n\t\n\t\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\treturn this.divideScalar( this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tsetLength: function ( length ) {\n\t\n\t\t\t\treturn this.multiplyScalar( length / this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\t\t\tthis.w += ( v.w - this.w ) * alpha;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( v ) {\n\t\n\t\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.x = array[ offset ];\n\t\t\t\tthis.y = array[ offset + 1 ];\n\t\t\t\tthis.z = array[ offset + 2 ];\n\t\t\t\tthis.w = array[ offset + 3 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this.x;\n\t\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\t\tarray[ offset + 2 ] = this.z;\n\t\t\t\tarray[ offset + 3 ] = this.w;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tindex = index * attribute.itemSize + offset;\n\t\n\t\t\t\tthis.x = attribute.array[ index ];\n\t\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\t\tthis.z = attribute.array[ index + 2 ];\n\t\t\t\tthis.w = attribute.array[ index + 3 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author szimek / https://github.com/szimek/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author Marius Kintel / https://github.com/kintel\n\t\t */\n\t\n\t\t/*\n\t\t In options, we can specify:\n\t\t * Texture parameters for an auto-generated target texture\n\t\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n\t\t*/\n\t\tfunction WebGLRenderTarget( width, height, options ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\n\t\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\t\tthis.scissorTest = false;\n\t\n\t\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\t\n\t\t\toptions = options || {};\n\t\n\t\t\tif ( options.minFilter === undefined ) options.minFilter = LinearFilter;\n\t\n\t\t\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\t\n\t\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\t\t\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\t\n\t\t}\n\t\n\t\tObject.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {\n\t\n\t\t\tisWebGLRenderTarget: true,\n\t\n\t\t\tsetSize: function ( width, height ) {\n\t\n\t\t\t\tif ( this.width !== width || this.height !== height ) {\n\t\n\t\t\t\t\tthis.width = width;\n\t\t\t\t\tthis.height = height;\n\t\n\t\t\t\t\tthis.dispose();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.viewport.set( 0, 0, width, height );\n\t\t\t\tthis.scissor.set( 0, 0, width, height );\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.width = source.width;\n\t\t\t\tthis.height = source.height;\n\t\n\t\t\t\tthis.viewport.copy( source.viewport );\n\t\n\t\t\t\tthis.texture = source.texture.clone();\n\t\n\t\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\t\tthis.depthTexture = source.depthTexture;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com\n\t\t */\n\t\n\t\tfunction WebGLRenderTargetCube( width, height, options ) {\n\t\n\t\t\tWebGLRenderTarget.call( this, width, height, options );\n\t\n\t\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\t\t\tthis.activeMipMapLevel = 0;\n\t\n\t\t}\n\t\n\t\tWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\n\t\tWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\n\t\n\t\tWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Quaternion( x, y, z, w ) {\n\t\n\t\t\tthis._x = x || 0;\n\t\t\tthis._y = y || 0;\n\t\t\tthis._z = z || 0;\n\t\t\tthis._w = ( w !== undefined ) ? w : 1;\n\t\n\t\t}\n\t\n\t\tQuaternion.prototype = {\n\t\n\t\t\tconstructor: Quaternion,\n\t\n\t\t\tget x () {\n\t\n\t\t\t\treturn this._x;\n\t\n\t\t\t},\n\t\n\t\t\tset x ( value ) {\n\t\n\t\t\t\tthis._x = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget y () {\n\t\n\t\t\t\treturn this._y;\n\t\n\t\t\t},\n\t\n\t\t\tset y ( value ) {\n\t\n\t\t\t\tthis._y = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget z () {\n\t\n\t\t\t\treturn this._z;\n\t\n\t\t\t},\n\t\n\t\t\tset z ( value ) {\n\t\n\t\t\t\tthis._z = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget w () {\n\t\n\t\t\t\treturn this._w;\n\t\n\t\t\t},\n\t\n\t\t\tset w ( value ) {\n\t\n\t\t\t\tthis._w = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( x, y, z, w ) {\n\t\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\t\t\t\tthis._w = w;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( quaternion ) {\n\t\n\t\t\t\tthis._x = quaternion.x;\n\t\t\t\tthis._y = quaternion.y;\n\t\t\t\tthis._z = quaternion.z;\n\t\t\t\tthis._w = quaternion.w;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromEuler: function ( euler, update ) {\n\t\n\t\t\t\tif ( (euler && euler.isEuler) === false ) {\n\t\n\t\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t\t//\tcontent/SpinCalc.m\n\t\n\t\t\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\t\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\t\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\t\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\t\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\t\t\tvar s3 = Math.sin( euler._z / 2 );\n\t\n\t\t\t\tvar order = euler.order;\n\t\n\t\t\t\tif ( order === 'XYZ' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'YXZ' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'ZXY' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'ZYX' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'YZX' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'XZY' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( update !== false ) this.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromAxisAngle: function ( axis, angle ) {\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\t\n\t\t\t\t// assumes axis is normalized\n\t\n\t\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\t\n\t\t\t\tthis._x = axis.x * s;\n\t\t\t\tthis._y = axis.y * s;\n\t\t\t\tthis._z = axis.z * s;\n\t\t\t\tthis._w = Math.cos( halfAngle );\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromRotationMatrix: function ( m ) {\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\t\n\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\t\tvar te = m.elements,\n\t\n\t\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\t\n\t\t\t\t\ttrace = m11 + m22 + m33,\n\t\t\t\t\ts;\n\t\n\t\t\t\tif ( trace > 0 ) {\n\t\n\t\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\t\n\t\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\t\t\tthis._z = ( m21 - m12 ) * s;\n\t\n\t\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\t\n\t\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\t\n\t\t\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\t\t\tthis._z = ( m13 + m31 ) / s;\n\t\n\t\t\t\t} else if ( m22 > m33 ) {\n\t\n\t\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\t\n\t\t\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\t\tthis._z = ( m23 + m32 ) / s;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\t\n\t\t\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\t\t\tthis._z = 0.25 * s;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromUnitVectors: function () {\n\t\n\t\t\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\t\n\t\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\t\n\t\t\t\tvar v1, r;\n\t\n\t\t\t\tvar EPS = 0.000001;\n\t\n\t\t\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\n\t\t\t\t\tr = vFrom.dot( vTo ) + 1;\n\t\n\t\t\t\t\tif ( r < EPS ) {\n\t\n\t\t\t\t\t\tr = 0;\n\t\n\t\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\t\n\t\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tv1.crossVectors( vFrom, vTo );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis._x = v1.x;\n\t\t\t\t\tthis._y = v1.y;\n\t\t\t\t\tthis._z = v1.z;\n\t\t\t\t\tthis._w = r;\n\t\n\t\t\t\t\treturn this.normalize();\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tinverse: function () {\n\t\n\t\t\t\treturn this.conjugate().normalize();\n\t\n\t\t\t},\n\t\n\t\t\tconjugate: function () {\n\t\n\t\t\t\tthis._x *= - 1;\n\t\t\t\tthis._y *= - 1;\n\t\t\t\tthis._z *= - 1;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdot: function ( v ) {\n\t\n\t\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\t\n\t\t\t},\n\t\n\t\t\tlengthSq: function () {\n\t\n\t\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\t\n\t\t\t},\n\t\n\t\t\tlength: function () {\n\t\n\t\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\tvar l = this.length();\n\t\n\t\t\t\tif ( l === 0 ) {\n\t\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = 0;\n\t\t\t\t\tthis._w = 1;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tl = 1 / l;\n\t\n\t\t\t\t\tthis._x = this._x * l;\n\t\t\t\t\tthis._y = this._y * l;\n\t\t\t\t\tthis._z = this._z * l;\n\t\t\t\t\tthis._w = this._w * l;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiply: function ( q, p ) {\n\t\n\t\t\t\tif ( p !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\t\t\treturn this.multiplyQuaternions( q, p );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.multiplyQuaternions( this, q );\n\t\n\t\t\t},\n\t\n\t\t\tpremultiply: function ( q ) {\n\t\n\t\t\t\treturn this.multiplyQuaternions( q, this );\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyQuaternions: function ( a, b ) {\n\t\n\t\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\t\n\t\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\t\n\t\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tslerp: function ( qb, t ) {\n\t\n\t\t\t\tif ( t === 0 ) return this;\n\t\t\t\tif ( t === 1 ) return this.copy( qb );\n\t\n\t\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\t\n\t\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\t\n\t\t\t\tif ( cosHalfTheta < 0 ) {\n\t\n\t\t\t\t\tthis._w = - qb._w;\n\t\t\t\t\tthis._x = - qb._x;\n\t\t\t\t\tthis._y = - qb._y;\n\t\t\t\t\tthis._z = - qb._z;\n\t\n\t\t\t\t\tcosHalfTheta = - cosHalfTheta;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.copy( qb );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( cosHalfTheta >= 1.0 ) {\n\t\n\t\t\t\t\tthis._w = w;\n\t\t\t\t\tthis._x = x;\n\t\t\t\t\tthis._y = y;\n\t\t\t\t\tthis._z = z;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\t\n\t\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\t\n\t\t\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\t\t\tthis._z = 0.5 * ( z + this._z );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\t\n\t\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( quaternion ) {\n\t\n\t\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis._x = array[ offset ];\n\t\t\t\tthis._y = array[ offset + 1 ];\n\t\t\t\tthis._z = array[ offset + 2 ];\n\t\t\t\tthis._w = array[ offset + 3 ];\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this._x;\n\t\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\t\tarray[ offset + 3 ] = this._w;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tonChange: function ( callback ) {\n\t\n\t\t\t\tthis.onChangeCallback = callback;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tonChangeCallback: function () {}\n\t\n\t\t};\n\t\n\t\tObject.assign( Quaternion, {\n\t\n\t\t\tslerp: function( qa, qb, qm, t ) {\n\t\n\t\t\t\treturn qm.copy( qa ).slerp( qb, t );\n\t\n\t\t\t},\n\t\n\t\t\tslerpFlat: function(\n\t\t\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\t\n\t\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\t\n\t\t\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\t\n\t\t\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\t\n\t\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\t\n\t\t\t\t\tvar s = 1 - t,\n\t\n\t\t\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\n\t\t\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\t\t\tsqrSin = 1 - cos * cos;\n\t\n\t\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\t\t\tif ( sqrSin > Number.EPSILON ) {\n\t\n\t\t\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\t\n\t\t\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\t\t\tt = Math.sin( t * len ) / sin;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar tDir = t * dir;\n\t\n\t\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\t\tw0 = w0 * s + w1 * tDir;\n\t\n\t\t\t\t\t// Normalize in case we just did a lerp:\n\t\t\t\t\tif ( s === 1 - t ) {\n\t\n\t\t\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\t\n\t\t\t\t\t\tx0 *= f;\n\t\t\t\t\t\ty0 *= f;\n\t\t\t\t\t\tz0 *= f;\n\t\t\t\t\t\tw0 *= f;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdst[ dstOffset ] = x0;\n\t\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author *kile / http://kile.stravaganza.org/\n\t\t * @author philogb / http://blog.thejit.org/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author egraether / http://egraether.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Vector3( x, y, z ) {\n\t\n\t\t\tthis.x = x || 0;\n\t\t\tthis.y = y || 0;\n\t\t\tthis.z = z || 0;\n\t\n\t\t}\n\t\n\t\tVector3.prototype = {\n\t\n\t\t\tconstructor: Vector3,\n\t\n\t\t\tisVector3: true,\n\t\n\t\t\tset: function ( x, y, z ) {\n\t\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.z = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.x = scalar;\n\t\t\t\tthis.y = scalar;\n\t\t\t\tthis.z = scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( x ) {\n\t\n\t\t\t\tthis.x = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( y ) {\n\t\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetZ: function ( z ) {\n\t\n\t\t\t\tthis.z = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetComponent: function ( index ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: return this.x;\n\t\t\t\t\tcase 1: return this.y;\n\t\t\t\t\tcase 2: return this.z;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.x, this.y, this.z );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( v ) {\n\t\n\t\t\t\tthis.x = v.x;\n\t\t\t\tthis.y = v.y;\n\t\t\t\tthis.z = v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x += v.x;\n\t\t\t\tthis.y += v.y;\n\t\t\t\tthis.z += v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScalar: function ( s ) {\n\t\n\t\t\t\tthis.x += s;\n\t\t\t\tthis.y += s;\n\t\t\t\tthis.z += s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x + b.x;\n\t\t\t\tthis.y = a.y + b.y;\n\t\t\t\tthis.z = a.z + b.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\t\tthis.x += v.x * s;\n\t\t\t\tthis.y += v.y * s;\n\t\t\t\tthis.z += v.z * s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsub: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x -= v.x;\n\t\t\t\tthis.y -= v.y;\n\t\t\t\tthis.z -= v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubScalar: function ( s ) {\n\t\n\t\t\t\tthis.x -= s;\n\t\t\t\tthis.y -= s;\n\t\t\t\tthis.z -= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x - b.x;\n\t\t\t\tthis.y = a.y - b.y;\n\t\t\t\tthis.z = a.z - b.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiply: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.multiplyVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x *= v.x;\n\t\t\t\tthis.y *= v.y;\n\t\t\t\tthis.z *= v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\t\tif ( isFinite( scalar ) ) {\n\t\n\t\t\t\t\tthis.x *= scalar;\n\t\t\t\t\tthis.y *= scalar;\n\t\t\t\t\tthis.z *= scalar;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.x = 0;\n\t\t\t\t\tthis.y = 0;\n\t\t\t\t\tthis.z = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x * b.x;\n\t\t\t\tthis.y = a.y * b.y;\n\t\t\t\tthis.z = a.z * b.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyEuler: function () {\n\t\n\t\t\t\tvar quaternion;\n\t\n\t\t\t\treturn function applyEuler( euler ) {\n\t\n\t\t\t\t\tif ( (euler && euler.isEuler) === false ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( quaternion === undefined ) quaternion = new Quaternion();\n\t\n\t\t\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyAxisAngle: function () {\n\t\n\t\t\t\tvar quaternion;\n\t\n\t\t\t\treturn function applyAxisAngle( axis, angle ) {\n\t\n\t\t\t\t\tif ( quaternion === undefined ) quaternion = new Quaternion();\n\t\n\t\t\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyMatrix3: function ( m ) {\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function ( m ) {\n\t\n\t\t\t\t// input: THREE.Matrix4 affine matrix\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n\t\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n\t\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyProjection: function ( m ) {\n\t\n\t\t\t\t// input: THREE.Matrix4 projection matrix\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar e = m.elements;\n\t\t\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\n\t\n\t\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\n\t\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\n\t\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyQuaternion: function ( q ) {\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\t\n\t\t\t\t// calculate quat * vector\n\t\n\t\t\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\t\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\t\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\t\t\tvar iw = - qx * x - qy * y - qz * z;\n\t\n\t\t\t\t// calculate result * inverse quat\n\t\n\t\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tproject: function () {\n\t\n\t\t\t\tvar matrix;\n\t\n\t\t\t\treturn function project( camera ) {\n\t\n\t\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\t\n\t\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\t\t\treturn this.applyProjection( matrix );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tunproject: function () {\n\t\n\t\t\t\tvar matrix;\n\t\n\t\t\t\treturn function unproject( camera ) {\n\t\n\t\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\t\n\t\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\t\t\treturn this.applyProjection( matrix );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttransformDirection: function ( m ) {\n\t\n\t\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t\t// vector interpreted as a direction\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n\t\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n\t\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\t\n\t\t\t\treturn this.normalize();\n\t\n\t\t\t},\n\t\n\t\t\tdivide: function ( v ) {\n\t\n\t\t\t\tthis.x /= v.x;\n\t\t\t\tthis.y /= v.y;\n\t\t\t\tthis.z /= v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t\t},\n\t\n\t\t\tmin: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\t\tthis.z = Math.min( this.z, v.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmax: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\t\tthis.z = Math.max( this.z, v.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclamp: function ( min, max ) {\n\t\n\t\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\t\n\t\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclampScalar: function () {\n\t\n\t\t\t\tvar min, max;\n\t\n\t\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\t\tif ( min === undefined ) {\n\t\n\t\t\t\t\t\tmin = new Vector3();\n\t\t\t\t\t\tmax = new Vector3();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\t\t\tmax.set( maxVal, maxVal, maxVal );\n\t\n\t\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclampLength: function ( min, max ) {\n\t\n\t\t\t\tvar length = this.length();\n\t\n\t\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\t\n\t\t\t},\n\t\n\t\t\tfloor: function () {\n\t\n\t\t\t\tthis.x = Math.floor( this.x );\n\t\t\t\tthis.y = Math.floor( this.y );\n\t\t\t\tthis.z = Math.floor( this.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tceil: function () {\n\t\n\t\t\t\tthis.x = Math.ceil( this.x );\n\t\t\t\tthis.y = Math.ceil( this.y );\n\t\t\t\tthis.z = Math.ceil( this.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tround: function () {\n\t\n\t\t\t\tthis.x = Math.round( this.x );\n\t\t\t\tthis.y = Math.round( this.y );\n\t\t\t\tthis.z = Math.round( this.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\troundToZero: function () {\n\t\n\t\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnegate: function () {\n\t\n\t\t\t\tthis.x = - this.x;\n\t\t\t\tthis.y = - this.y;\n\t\t\t\tthis.z = - this.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdot: function ( v ) {\n\t\n\t\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\t\n\t\t\t},\n\t\n\t\t\tlengthSq: function () {\n\t\n\t\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\t\n\t\t\t},\n\t\n\t\t\tlength: function () {\n\t\n\t\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\t\n\t\t\t},\n\t\n\t\t\tlengthManhattan: function () {\n\t\n\t\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\treturn this.divideScalar( this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tsetLength: function ( length ) {\n\t\n\t\t\t\treturn this.multiplyScalar( length / this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t\t},\n\t\n\t\t\tcross: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.crossVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\n\t\t\t\tthis.x = y * v.z - z * v.y;\n\t\t\t\tthis.y = z * v.x - x * v.z;\n\t\t\t\tthis.z = x * v.y - y * v.x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcrossVectors: function ( a, b ) {\n\t\n\t\t\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\t\t\tvar bx = b.x, by = b.y, bz = b.z;\n\t\n\t\t\t\tthis.x = ay * bz - az * by;\n\t\t\t\tthis.y = az * bx - ax * bz;\n\t\t\t\tthis.z = ax * by - ay * bx;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tprojectOnVector: function ( vector ) {\n\t\n\t\t\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\t\n\t\t\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\t\n\t\t\t},\n\t\n\t\t\tprojectOnPlane: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function projectOnPlane( planeNormal ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\n\t\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\t\n\t\t\t\t\treturn this.sub( v1 );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\treflect: function () {\n\t\n\t\t\t\t// reflect incident vector off plane orthogonal to normal\n\t\t\t\t// normal is assumed to have unit length\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function reflect( normal ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\n\t\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tangleTo: function ( v ) {\n\t\n\t\t\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\t\n\t\t\t\t// clamp, to handle numerical problems\n\t\n\t\t\t\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceTo: function ( v ) {\n\t\n\t\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToSquared: function ( v ) {\n\t\n\t\t\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\t\n\t\t\t\treturn dx * dx + dy * dy + dz * dz;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToManhattan: function ( v ) {\n\t\n\t\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\t\n\t\t\t},\n\t\n\t\t\tsetFromSpherical: function( s ) {\n\t\n\t\t\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\t\n\t\t\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\t\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\t\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrixPosition: function ( m ) {\n\t\n\t\t\t\treturn this.setFromMatrixColumn( m, 3 );\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrixScale: function ( m ) {\n\t\n\t\t\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\t\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\t\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\t\n\t\t\t\tthis.x = sx;\n\t\t\t\tthis.y = sy;\n\t\t\t\tthis.z = sz;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrixColumn: function ( m, index ) {\n\t\n\t\t\t\tif ( typeof m === 'number' ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n\t\t\t\t\tvar temp = m;\n\t\t\t\t\tm = index;\n\t\t\t\t\tindex = temp;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.fromArray( m.elements, index * 4 );\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( v ) {\n\t\n\t\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.x = array[ offset ];\n\t\t\t\tthis.y = array[ offset + 1 ];\n\t\t\t\tthis.z = array[ offset + 2 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this.x;\n\t\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\t\tarray[ offset + 2 ] = this.z;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tindex = index * attribute.itemSize + offset;\n\t\n\t\t\t\tthis.x = attribute.array[ index ];\n\t\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\t\tthis.z = attribute.array[ index + 2 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t\t * @author philogb / http://blog.thejit.org/\n\t\t * @author jordi_ros / http://plattsoft.com\n\t\t * @author D1plo1d / http://github.com/D1plo1d\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author timknip / http://www.floorplanner.com/\n\t\t * @author bhouston / http://clara.io\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Matrix4() {\n\t\n\t\t\tthis.elements = new Float32Array( [\n\t\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t] );\n\t\n\t\t\tif ( arguments.length > 0 ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tMatrix4.prototype = {\n\t\n\t\t\tconstructor: Matrix4,\n\t\n\t\t\tisMatrix4: true,\n\t\n\t\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tidentity: function () {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, 0, 0, 0,\n\t\t\t\t\t0, 1, 0, 0,\n\t\t\t\t\t0, 0, 1, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new Matrix4().fromArray( this.elements );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( m ) {\n\t\n\t\t\t\tthis.elements.set( m.elements );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyPosition: function ( m ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\tte[ 12 ] = me[ 12 ];\n\t\t\t\tte[ 13 ] = me[ 13 ];\n\t\t\t\tte[ 14 ] = me[ 14 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\t\n\t\t\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\t\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\t\t\tzAxis.setFromMatrixColumn( this, 2 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\t\n\t\t\t\tthis.set(\n\t\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t\t\t0,       0,       0,       1\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\textractRotation: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function extractRotation( m ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\n\t\t\t\t\tvar te = this.elements;\n\t\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\t\n\t\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\n\t\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\n\t\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmakeRotationFromEuler: function ( euler ) {\n\t\n\t\t\t\tif ( (euler && euler.isEuler) === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\t\n\t\t\t\tif ( euler.order === 'XYZ' ) {\n\t\n\t\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\t\n\t\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\t\tte[ 4 ] = - c * f;\n\t\t\t\t\tte[ 8 ] = d;\n\t\n\t\t\t\t\tte[ 1 ] = af + be * d;\n\t\t\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\t\t\tte[ 9 ] = - b * c;\n\t\n\t\t\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\t\t\tte[ 6 ] = be + af * d;\n\t\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t\t} else if ( euler.order === 'YXZ' ) {\n\t\n\t\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\t\n\t\t\t\t\tte[ 0 ] = ce + df * b;\n\t\t\t\t\tte[ 4 ] = de * b - cf;\n\t\t\t\t\tte[ 8 ] = a * d;\n\t\n\t\t\t\t\tte[ 1 ] = a * f;\n\t\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\t\tte[ 9 ] = - b;\n\t\n\t\t\t\t\tte[ 2 ] = cf * b - de;\n\t\t\t\t\tte[ 6 ] = df + ce * b;\n\t\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t\t} else if ( euler.order === 'ZXY' ) {\n\t\n\t\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\t\n\t\t\t\t\tte[ 0 ] = ce - df * b;\n\t\t\t\t\tte[ 4 ] = - a * f;\n\t\t\t\t\tte[ 8 ] = de + cf * b;\n\t\n\t\t\t\t\tte[ 1 ] = cf + de * b;\n\t\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\t\tte[ 9 ] = df - ce * b;\n\t\n\t\t\t\t\tte[ 2 ] = - a * d;\n\t\t\t\t\tte[ 6 ] = b;\n\t\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t\t} else if ( euler.order === 'ZYX' ) {\n\t\n\t\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\t\n\t\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\t\tte[ 4 ] = be * d - af;\n\t\t\t\t\tte[ 8 ] = ae * d + bf;\n\t\n\t\t\t\t\tte[ 1 ] = c * f;\n\t\t\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\t\t\tte[ 9 ] = af * d - be;\n\t\n\t\t\t\t\tte[ 2 ] = - d;\n\t\t\t\t\tte[ 6 ] = b * c;\n\t\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t\t} else if ( euler.order === 'YZX' ) {\n\t\n\t\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\t\n\t\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\t\t\tte[ 8 ] = bc * f + ad;\n\t\n\t\t\t\t\tte[ 1 ] = f;\n\t\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\t\tte[ 9 ] = - b * e;\n\t\n\t\t\t\t\tte[ 2 ] = - d * e;\n\t\t\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\t\t\tte[ 10 ] = ac - bd * f;\n\t\n\t\t\t\t} else if ( euler.order === 'XZY' ) {\n\t\n\t\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\t\n\t\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\t\tte[ 4 ] = - f;\n\t\t\t\t\tte[ 8 ] = d * e;\n\t\n\t\t\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\t\tte[ 9 ] = ad * f - bc;\n\t\n\t\t\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\t\t\tte[ 6 ] = b * e;\n\t\t\t\t\tte[ 10 ] = bd * f + ac;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// last column\n\t\t\t\tte[ 3 ] = 0;\n\t\t\t\tte[ 7 ] = 0;\n\t\t\t\tte[ 11 ] = 0;\n\t\n\t\t\t\t// bottom row\n\t\t\t\tte[ 12 ] = 0;\n\t\t\t\tte[ 13 ] = 0;\n\t\t\t\tte[ 14 ] = 0;\n\t\t\t\tte[ 15 ] = 1;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationFromQuaternion: function ( q ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\t\n\t\t\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\t\t\tte[ 4 ] = xy - wz;\n\t\t\t\tte[ 8 ] = xz + wy;\n\t\n\t\t\t\tte[ 1 ] = xy + wz;\n\t\t\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\t\t\tte[ 9 ] = yz - wx;\n\t\n\t\t\t\tte[ 2 ] = xz - wy;\n\t\t\t\tte[ 6 ] = yz + wx;\n\t\t\t\tte[ 10 ] = 1 - ( xx + yy );\n\t\n\t\t\t\t// last column\n\t\t\t\tte[ 3 ] = 0;\n\t\t\t\tte[ 7 ] = 0;\n\t\t\t\tte[ 11 ] = 0;\n\t\n\t\t\t\t// bottom row\n\t\t\t\tte[ 12 ] = 0;\n\t\t\t\tte[ 13 ] = 0;\n\t\t\t\tte[ 14 ] = 0;\n\t\t\t\tte[ 15 ] = 1;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlookAt: function () {\n\t\n\t\t\t\tvar x, y, z;\n\t\n\t\t\t\treturn function lookAt( eye, target, up ) {\n\t\n\t\t\t\t\tif ( x === undefined ) {\n\t\n\t\t\t\t\t\tx = new Vector3();\n\t\t\t\t\t\ty = new Vector3();\n\t\t\t\t\t\tz = new Vector3();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\t\tz.subVectors( eye, target ).normalize();\n\t\n\t\t\t\t\tif ( z.lengthSq() === 0 ) {\n\t\n\t\t\t\t\t\tz.z = 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tx.crossVectors( up, z ).normalize();\n\t\n\t\t\t\t\tif ( x.lengthSq() === 0 ) {\n\t\n\t\t\t\t\t\tz.z += 0.0001;\n\t\t\t\t\t\tx.crossVectors( up, z ).normalize();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ty.crossVectors( z, x );\n\t\n\t\n\t\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmultiply: function ( m, n ) {\n\t\n\t\t\t\tif ( n !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\t\t\treturn this.multiplyMatrices( m, n );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.multiplyMatrices( this, m );\n\t\n\t\t\t},\n\t\n\t\t\tpremultiply: function ( m ) {\n\t\n\t\t\t\treturn this.multiplyMatrices( m, this );\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyMatrices: function ( a, b ) {\n\t\n\t\t\t\tvar ae = a.elements;\n\t\t\t\tvar be = b.elements;\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\t\n\t\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\t\n\t\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\t\n\t\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\t\n\t\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\t\n\t\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyToArray: function ( a, b, r ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tthis.multiplyMatrices( a, b );\n\t\n\t\t\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n\t\t\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n\t\t\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n\t\t\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyToVector3Array: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\t\tif ( length === undefined ) length = array.length;\n\t\n\t\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\t\n\t\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\t\tv1.applyMatrix4( this );\n\t\t\t\t\t\tv1.toArray( array, j );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn array;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyToBuffer: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\t\n\t\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\t\n\t\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\t\tv1.z = buffer.getZ( j );\n\t\n\t\t\t\t\t\tv1.applyMatrix4( this );\n\t\n\t\t\t\t\t\tbuffer.setXYZ( j, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn buffer;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tdeterminant: function () {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\t\n\t\t\t\t//TODO: make this more efficient\n\t\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\t\n\t\t\t\treturn (\n\t\t\t\t\tn41 * (\n\t\t\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t\t\t - n13 * n24 * n32\n\t\t\t\t\t\t - n14 * n22 * n33\n\t\t\t\t\t\t + n12 * n24 * n33\n\t\t\t\t\t\t + n13 * n22 * n34\n\t\t\t\t\t\t - n12 * n23 * n34\n\t\t\t\t\t) +\n\t\t\t\t\tn42 * (\n\t\t\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t\t\t - n11 * n24 * n33\n\t\t\t\t\t\t + n14 * n21 * n33\n\t\t\t\t\t\t - n13 * n21 * n34\n\t\t\t\t\t\t + n13 * n24 * n31\n\t\t\t\t\t\t - n14 * n23 * n31\n\t\t\t\t\t) +\n\t\t\t\t\tn43 * (\n\t\t\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t\t\t - n11 * n22 * n34\n\t\t\t\t\t\t - n14 * n21 * n32\n\t\t\t\t\t\t + n12 * n21 * n34\n\t\t\t\t\t\t + n14 * n22 * n31\n\t\t\t\t\t\t - n12 * n24 * n31\n\t\t\t\t\t) +\n\t\t\t\t\tn44 * (\n\t\t\t\t\t\t- n13 * n22 * n31\n\t\t\t\t\t\t - n11 * n23 * n32\n\t\t\t\t\t\t + n11 * n22 * n33\n\t\t\t\t\t\t + n13 * n21 * n32\n\t\t\t\t\t\t - n12 * n21 * n33\n\t\t\t\t\t\t + n12 * n23 * n31\n\t\t\t\t\t)\n\t\n\t\t\t\t);\n\t\n\t\t\t},\n\t\n\t\t\ttranspose: function () {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar tmp;\n\t\n\t\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\t\n\t\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tflattenToArrayOffset: function ( array, offset ) {\n\t\n\t\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\t\"- just use .toArray instead.\" );\n\t\n\t\t\t\treturn this.toArray( array, offset );\n\t\n\t\t\t},\n\t\n\t\t\tgetPosition: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function getPosition() {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\t\n\t\t\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tsetPosition: function ( v ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 12 ] = v.x;\n\t\t\t\tte[ 13 ] = v.y;\n\t\t\t\tte[ 14 ] = v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetInverse: function ( m, throwOnDegenerate ) {\n\t\n\t\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\t\tvar te = this.elements,\n\t\t\t\t\tme = m.elements,\n\t\n\t\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\t\n\t\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\t\n\t\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\t\n\t\t\t\tif ( det === 0 ) {\n\t\n\t\t\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\t\n\t\t\t\t\tif ( throwOnDegenerate === true ) {\n\t\n\t\t\t\t\t\tthrow new Error( msg );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tconsole.warn( msg );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this.identity();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar detInv = 1 / det;\n\t\n\t\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\t\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\t\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\t\n\t\t\t\tte[ 4 ] = t12 * detInv;\n\t\t\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\t\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\t\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\t\n\t\t\t\tte[ 8 ] = t13 * detInv;\n\t\t\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\t\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\t\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\t\n\t\t\t\tte[ 12 ] = t14 * detInv;\n\t\t\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\t\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\t\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tscale: function ( v ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar x = v.x, y = v.y, z = v.z;\n\t\n\t\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetMaxScaleOnAxis: function () {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\t\n\t\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\t\n\t\t\t},\n\t\n\t\t\tmakeTranslation: function ( x, y, z ) {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, 0, 0, x,\n\t\t\t\t\t0, 1, 0, y,\n\t\t\t\t\t0, 0, 1, z,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationX: function ( theta ) {\n\t\n\t\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, 0,  0, 0,\n\t\t\t\t\t0, c, - s, 0,\n\t\t\t\t\t0, s,  c, 0,\n\t\t\t\t\t0, 0,  0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationY: function ( theta ) {\n\t\n\t\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t c, 0, s, 0,\n\t\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t\t- s, 0, c, 0,\n\t\t\t\t\t 0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationZ: function ( theta ) {\n\t\n\t\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\tc, - s, 0, 0,\n\t\t\t\t\ts,  c, 0, 0,\n\t\t\t\t\t0,  0, 1, 0,\n\t\t\t\t\t0,  0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationAxis: function ( axis, angle ) {\n\t\n\t\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\t\n\t\t\t\tvar c = Math.cos( angle );\n\t\t\t\tvar s = Math.sin( angle );\n\t\t\t\tvar t = 1 - c;\n\t\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\t\t\tvar tx = t * x, ty = t * y;\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\t return this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeScale: function ( x, y, z ) {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\tx, 0, 0, 0,\n\t\t\t\t\t0, y, 0, 0,\n\t\t\t\t\t0, 0, z, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcompose: function ( position, quaternion, scale ) {\n\t\n\t\t\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\t\t\tthis.scale( scale );\n\t\t\t\tthis.setPosition( position );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdecompose: function () {\n\t\n\t\t\t\tvar vector, matrix;\n\t\n\t\t\t\treturn function decompose( position, quaternion, scale ) {\n\t\n\t\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\t\tvector = new Vector3();\n\t\t\t\t\t\tmatrix = new Matrix4();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\t\n\t\t\t\t\t// if determine is negative, we need to invert one scale\n\t\t\t\t\tvar det = this.determinant();\n\t\t\t\t\tif ( det < 0 ) {\n\t\n\t\t\t\t\t\tsx = - sx;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tposition.x = te[ 12 ];\n\t\t\t\t\tposition.y = te[ 13 ];\n\t\t\t\t\tposition.z = te[ 14 ];\n\t\n\t\t\t\t\t// scale the rotation part\n\t\n\t\t\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\t\n\t\t\t\t\tvar invSX = 1 / sx;\n\t\t\t\t\tvar invSY = 1 / sy;\n\t\t\t\t\tvar invSZ = 1 / sz;\n\t\n\t\t\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\t\t\tmatrix.elements[ 2 ] *= invSX;\n\t\n\t\t\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\t\t\tmatrix.elements[ 6 ] *= invSY;\n\t\n\t\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\t\n\t\t\t\t\tquaternion.setFromRotationMatrix( matrix );\n\t\n\t\t\t\t\tscale.x = sx;\n\t\t\t\t\tscale.y = sy;\n\t\t\t\t\tscale.z = sz;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar x = 2 * near / ( right - left );\n\t\t\t\tvar y = 2 * near / ( top - bottom );\n\t\n\t\t\t\tvar a = ( right + left ) / ( right - left );\n\t\t\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\t\t\tvar c = - ( far + near ) / ( far - near );\n\t\t\t\tvar d = - 2 * far * near / ( far - near );\n\t\n\t\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakePerspective: function ( fov, aspect, near, far ) {\n\t\n\t\t\t\tvar ymax = near * Math.tan( _Math.DEG2RAD * fov * 0.5 );\n\t\t\t\tvar ymin = - ymax;\n\t\t\t\tvar xmin = ymin * aspect;\n\t\t\t\tvar xmax = ymax * aspect;\n\t\n\t\t\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\t\n\t\t\t},\n\t\n\t\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar w = 1.0 / ( right - left );\n\t\t\t\tvar h = 1.0 / ( top - bottom );\n\t\t\t\tvar p = 1.0 / ( far - near );\n\t\n\t\t\t\tvar x = ( right + left ) * w;\n\t\t\t\tvar y = ( top + bottom ) * h;\n\t\t\t\tvar z = ( far + near ) * p;\n\t\n\t\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( matrix ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = matrix.elements;\n\t\n\t\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\t\n\t\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tfor( var i = 0; i < 16; i ++ ) {\n\t\n\t\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\n\t\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\n\t\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\t\t\tarray[ offset + 9 ]  = te[ 9 ];\n\t\t\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\t\t\tarray[ offset + 11 ] = te[ 11 ];\n\t\n\t\t\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\t\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\t\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\t\t\tarray[ offset + 15 ] = te[ 15 ];\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\t\n\t\t\timages = images !== undefined ? images : [];\n\t\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\t\n\t\t\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\t\tthis.flipY = false;\n\t\n\t\t}\n\t\n\t\tCubeTexture.prototype = Object.create( Texture.prototype );\n\t\tCubeTexture.prototype.constructor = CubeTexture;\n\t\n\t\tCubeTexture.prototype.isCubeTexture = true;\n\t\n\t\tObject.defineProperty( CubeTexture.prototype, 'images', {\n\t\n\t\t\tget: function () {\n\t\n\t\t\t\treturn this.image;\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( value ) {\n\t\n\t\t\t\tthis.image = value;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author tschw\n\t\t *\n\t\t * Uniforms of a program.\n\t\t * Those form a tree structure with a special top-level container for the root,\n\t\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n\t\t *\n\t\t *\n\t\t * Properties of inner nodes including the top-level container:\n\t\t *\n\t\t * .seq - array of nested uniforms\n\t\t * .map - nested uniforms by name\n\t\t *\n\t\t *\n\t\t * Methods of all nodes except the top-level container:\n\t\t *\n\t\t * .setValue( gl, value, [renderer] )\n\t\t *\n\t\t * \t\tuploads a uniform value(s)\n\t\t *  \tthe 'renderer' parameter is needed for sampler uniforms\n\t\t *\n\t\t *\n\t\t * Static methods of the top-level container (renderer factorizations):\n\t\t *\n\t\t * .upload( gl, seq, values, renderer )\n\t\t *\n\t\t * \t\tsets uniforms in 'seq' to 'values[id].value'\n\t\t *\n\t\t * .seqWithValue( seq, values ) : filteredSeq\n\t\t *\n\t\t * \t\tfilters 'seq' entries with corresponding entry in values\n\t\t *\n\t\t *\n\t\t * Methods of the top-level container (renderer factorizations):\n\t\t *\n\t\t * .setValue( gl, name, value )\n\t\t *\n\t\t * \t\tsets uniform with  name 'name' to 'value'\n\t\t *\n\t\t * .set( gl, obj, prop )\n\t\t *\n\t\t * \t\tsets uniform from object and property with same name than uniform\n\t\t *\n\t\t * .setOptional( gl, obj, prop )\n\t\t *\n\t\t * \t\tlike .set for an optional property of the object\n\t\t *\n\t\t */\n\t\n\t\tvar emptyTexture = new Texture();\n\t\tvar emptyCubeTexture = new CubeTexture();\n\t\n\t\t// --- Base for inner nodes (including the root) ---\n\t\n\t\tfunction UniformContainer() {\n\t\n\t\t\tthis.seq = [];\n\t\t\tthis.map = {};\n\t\n\t\t}\n\t\n\t\t// --- Utilities ---\n\t\n\t\t// Array Caches (provide typed arrays for temporary by size)\n\t\n\t\tvar arrayCacheF32 = [];\n\t\tvar arrayCacheI32 = [];\n\t\n\t\t// Flattening for arrays of vectors and matrices\n\t\n\t\tfunction flatten( array, nBlocks, blockSize ) {\n\t\n\t\t\tvar firstElem = array[ 0 ];\n\t\n\t\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t\t// unoptimized: ! isNaN( firstElem )\n\t\t\t// see http://jacksondunstan.com/articles/983\n\t\n\t\t\tvar n = nBlocks * blockSize,\n\t\t\t\tr = arrayCacheF32[ n ];\n\t\n\t\t\tif ( r === undefined ) {\n\t\n\t\t\t\tr = new Float32Array( n );\n\t\t\t\tarrayCacheF32[ n ] = r;\n\t\n\t\t\t}\n\t\n\t\t\tif ( nBlocks !== 0 ) {\n\t\n\t\t\t\tfirstElem.toArray( r, 0 );\n\t\n\t\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\t\n\t\t\t\t\toffset += blockSize;\n\t\t\t\t\tarray[ i ].toArray( r, offset );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn r;\n\t\n\t\t}\n\t\n\t\t// Texture unit allocation\n\t\n\t\tfunction allocTexUnits( renderer, n ) {\n\t\n\t\t\tvar r = arrayCacheI32[ n ];\n\t\n\t\t\tif ( r === undefined ) {\n\t\n\t\t\t\tr = new Int32Array( n );\n\t\t\t\tarrayCacheI32[ n ] = r;\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tr[ i ] = renderer.allocTextureUnit();\n\t\n\t\t\treturn r;\n\t\n\t\t}\n\t\n\t\t// --- Setters ---\n\t\n\t\t// Note: Defining these methods externally, because they come in a bunch\n\t\t// and this way their names minify.\n\t\n\t\t// Single scalar\n\t\n\t\tfunction setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }\n\t\tfunction setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }\n\t\n\t\t// Single float vector (from flat array or THREE.VectorN)\n\t\n\t\tfunction setValue2fv( gl, v ) {\n\t\n\t\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n\t\t\telse gl.uniform2f( this.addr, v.x, v.y );\n\t\n\t\t}\n\t\n\t\tfunction setValue3fv( gl, v ) {\n\t\n\t\t\tif ( v.x !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\t\telse if ( v.r !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\t\telse\n\t\t\t\tgl.uniform3fv( this.addr, v );\n\t\n\t\t}\n\t\n\t\tfunction setValue4fv( gl, v ) {\n\t\n\t\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n\t\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\t\n\t\t}\n\t\n\t\t// Single matrix (from flat array or MatrixN)\n\t\n\t\tfunction setValue2fm( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\t\n\t\t}\n\t\n\t\tfunction setValue3fm( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\t\n\t\t}\n\t\n\t\tfunction setValue4fm( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\t\n\t\t}\n\t\n\t\t// Single texture (2D / Cube)\n\t\n\t\tfunction setValueT1( gl, v, renderer ) {\n\t\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\t\n\t\t}\n\t\n\t\tfunction setValueT6( gl, v, renderer ) {\n\t\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\t\n\t\t}\n\t\n\t\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\t\n\t\tfunction setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }\n\t\tfunction setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }\n\t\tfunction setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }\n\t\n\t\t// Helper to pick the right setter for the singular case\n\t\n\t\tfunction getSingularSetter( type ) {\n\t\n\t\t\tswitch ( type ) {\n\t\n\t\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\t\n\t\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\t\n\t\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\t\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Array of scalars\n\t\n\t\tfunction setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }\n\t\tfunction setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }\n\t\n\t\t// Array of vectors (flat or from THREE classes)\n\t\n\t\tfunction setValueV2a( gl, v ) {\n\t\n\t\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\t\n\t\t}\n\t\n\t\tfunction setValueV3a( gl, v ) {\n\t\n\t\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\t\n\t\t}\n\t\n\t\tfunction setValueV4a( gl, v ) {\n\t\n\t\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\t\n\t\t}\n\t\n\t\t// Array of matrices (flat or from THREE clases)\n\t\n\t\tfunction setValueM2a( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\t\n\t\t}\n\t\n\t\tfunction setValueM3a( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\t\n\t\t}\n\t\n\t\tfunction setValueM4a( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\t\n\t\t}\n\t\n\t\t// Array of textures (2D / Cube)\n\t\n\t\tfunction setValueT1a( gl, v, renderer ) {\n\t\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\t\n\t\t\tgl.uniform1iv( this.addr, units );\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction setValueT6a( gl, v, renderer ) {\n\t\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\t\n\t\t\tgl.uniform1iv( this.addr, units );\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Helper to pick the right setter for a pure (bottom-level) array\n\t\n\t\tfunction getPureArraySetter( type ) {\n\t\n\t\t\tswitch ( type ) {\n\t\n\t\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\t\n\t\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\t\n\t\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\t\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// --- Uniform Classes ---\n\t\n\t\tfunction SingleUniform( id, activeInfo, addr ) {\n\t\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\t\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\t\n\t\t}\n\t\n\t\tfunction PureArrayUniform( id, activeInfo, addr ) {\n\t\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.size = activeInfo.size;\n\t\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\t\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\t\n\t\t}\n\t\n\t\tfunction StructuredUniform( id ) {\n\t\n\t\t\tthis.id = id;\n\t\n\t\t\tUniformContainer.call( this ); // mix-in\n\t\n\t\t}\n\t\n\t\tStructuredUniform.prototype.setValue = function( gl, value ) {\n\t\n\t\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t\t// are not allowed in structured uniforms.\n\t\n\t\t\tvar seq = this.seq;\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ];\n\t\t\t\tu.setValue( gl, value[ u.id ] );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// --- Top-level ---\n\t\n\t\t// Parser - builds up the property tree from the path strings\n\t\n\t\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\n\t\n\t\t// extracts\n\t\t// \t- the identifier (member name or array index)\n\t\t//  - followed by an optional right bracket (found when array index)\n\t\t//  - followed by an optional left bracket or dot (type of subscript)\n\t\t//\n\t\t// Note: These portions can be read in a non-overlapping fashion and\n\t\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t\t// in the uniform names.\n\t\n\t\tfunction addUniform( container, uniformObject ) {\n\t\n\t\t\tcontainer.seq.push( uniformObject );\n\t\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\t\n\t\t}\n\t\n\t\tfunction parseUniform( activeInfo, addr, container ) {\n\t\n\t\t\tvar path = activeInfo.name,\n\t\t\t\tpathLength = path.length;\n\t\n\t\t\t// reset RegExp object, because of the early exit of a previous run\n\t\t\tRePathPart.lastIndex = 0;\n\t\n\t\t\tfor (; ;) {\n\t\n\t\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\t\n\t\t\t\t\tid = match[ 1 ],\n\t\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\t\tsubscript = match[ 3 ];\n\t\n\t\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\t\n\t\t\t\tif ( subscript === undefined ||\n\t\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\n\t\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\t\n\t\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t} else {\n\t\t\t\t\t// step into inner node / create it in case it doesn't exist\n\t\n\t\t\t\t\tvar map = container.map,\n\t\t\t\t\t\tnext = map[ id ];\n\t\n\t\t\t\t\tif ( next === undefined ) {\n\t\n\t\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\t\taddUniform( container, next );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcontainer = next;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Root Container\n\t\n\t\tfunction WebGLUniforms( gl, program, renderer ) {\n\t\n\t\t\tUniformContainer.call( this );\n\t\n\t\t\tthis.renderer = renderer;\n\t\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\t\tpath = info.name,\n\t\t\t\t\taddr = gl.getUniformLocation( program, path );\n\t\n\t\t\t\tparseUniform( info, addr, this );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\t\n\t\t\tvar u = this.map[ name ];\n\t\n\t\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.prototype.set = function( gl, object, name ) {\n\t\n\t\t\tvar u = this.map[ name ];\n\t\n\t\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\t\n\t\t\tvar v = object[ name ];\n\t\n\t\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\t\n\t\t};\n\t\n\t\n\t\t// Static interface\n\t\n\t\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ],\n\t\t\t\t\tv = values[ u.id ];\n\t\n\t\t\t\tif ( v.needsUpdate !== false ) {\n\t\t\t\t\t// note: always updating when .needsUpdate is undefined\n\t\n\t\t\t\t\tu.setValue( gl, v.value, renderer );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.seqWithValue = function( seq, values ) {\n\t\n\t\t\tvar r = [];\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ];\n\t\t\t\tif ( u.id in values ) r.push( u );\n\t\n\t\t\t}\n\t\n\t\t\treturn r;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * Uniform Utilities\n\t\t */\n\t\n\t\tvar UniformsUtils = {\n\t\n\t\t\tmerge: function ( uniforms ) {\n\t\n\t\t\t\tvar merged = {};\n\t\n\t\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\t\n\t\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\t\n\t\t\t\t\tfor ( var p in tmp ) {\n\t\n\t\t\t\t\t\tmerged[ p ] = tmp[ p ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn merged;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function ( uniforms_src ) {\n\t\n\t\t\t\tvar uniforms_dst = {};\n\t\n\t\t\t\tfor ( var u in uniforms_src ) {\n\t\n\t\t\t\t\tuniforms_dst[ u ] = {};\n\t\n\t\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\t\n\t\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\t\n\t\t\t\t\t\tif ( parameter_src && ( parameter_src.isColor ||\n\t\t\t\t\t\t\tparameter_src.isMatrix3 || parameter_src.isMatrix4 ||\n\t\t\t\t\t\t\tparameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||\n\t\t\t\t\t\t\tparameter_src.isTexture ) ) {\n\t\n\t\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\t\n\t\t\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\t\n\t\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn uniforms_dst;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\t\n\t\tvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\t\n\t\tvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\t\n\t\tvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\t\n\t\tvar begin_vertex = \"\\nvec3 transformed = vec3( position );\\n\";\n\t\n\t\tvar beginnormal_vertex = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\t\n\t\tvar bsdfs = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\t\\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\t\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\t\\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\\t\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\t\n\t\tvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = dFdx( surf_pos );\\n\\t\\tvec3 vSigmaY = dFdy( surf_pos );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\\n\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t\\t\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\\t\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\t\n\t\tvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\t\n\t\tvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\t\n\t\tvar color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\t\n\t\tvar color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n\";\n\t\n\t\tvar color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\t\n\t\tvar color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\";\n\t\n\t\tvar common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\n\t\n\t\tvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\t\n\t\tvar defaultnormal_vertex = \"#ifdef FLIP_SIDED\\n\\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\t\n\t\tvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\\n\";\n\t\n\t\tvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\t\n\t\tvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\t\n\t\tvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\t\n\t\tvar encodings_fragment = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\t\n\t\tvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\t\n\t\tvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\t#else\\n\\t\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\t#endif\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\t\n\t\tvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\t\n\t\tvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\t\n\t\tvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\t\n\t\tvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar lights_pars = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\\t\\t\\tdirectLight.color = pointLight.color;\\n\\t\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\t#include <normal_flip>\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\t#include <normal_flip>\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\t\n\t\tvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\\n\";\n\t\n\t\tvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\t\n\t\tvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\t\n\t\tvar lights_template = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t \\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\\t#endif\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\\t#ifndef STANDARD\\n\\t\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\\t#else\\n\\t\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\\t#endif\\n\\t\\t\\n\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\t\n\t\tvar logdepthbuf_fragment = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\t\n\t\tvar logdepthbuf_pars_fragment = \"#ifdef USE_LOGDEPTHBUF\\n\\tuniform float logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n\\tuniform float logDepthBufFC;\\n#endif\";\n\t\n\t\tvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\t\n\t\tvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\t\n\t\tvar map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\t\n\t\tvar map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform vec4 offsetRepeat;\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\t\n\t\tvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\t\n\t\tvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\t\n\t\tvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\t\n\t\tvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\t\n\t\tvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar normal_flip = \"#ifdef DOUBLE_SIDED\\n\\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\t\n\t\tvar normal_fragment = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\t\n\t\tvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\tvec3 q0 = dFdx( eye_pos.xyz );\\n\\t\\tvec3 q1 = dFdy( eye_pos.xyz );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\\t\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\t\n\t\tvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\t\n\t\tvar project_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\t\n\t\tvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\t\n\t\tvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\t\n\t\tvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\\n\";\n\t\n\t\tvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\t\n\t\tvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureWidth;\\n\\t\\tuniform int boneTextureHeight;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureWidth ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureWidth ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureWidth );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureHeight );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\t\n\t\tvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\t\n\t\tvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\t\n\t\tvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\t\n\t\tvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\t\n\t\tvar tonemapping_pars_fragment = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\t\n\t\tvar uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\";\n\t\n\t\tvar uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\t\n\t\tvar uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\t\n\t\tvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\t\n\t\tvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\";\n\t\n\t\tvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\";\n\t\n\t\tvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\t#ifdef USE_SKINNING\\n\\t\\tvec4 worldPosition = modelMatrix * skinned;\\n\\t#else\\n\\t\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\\tgl_FragColor.a *= opacity;\\n}\\n\";\n\t\n\t\tvar cube_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\t\n\t\tvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\\n\";\n\t\n\t\tvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t\tvar distanceRGBA_frag = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\t\n\t\tvar distanceRGBA_vert = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition;\\n}\\n\";\n\t\n\t\tvar equirect_frag = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldPosition );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\";\n\t\n\t\tvar equirect_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\t\n\t\tvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t\tvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight;\\n\\treflectedLight.directDiffuse = vec3( 0.0 );\\n\\treflectedLight.directSpecular = vec3( 0.0 );\\n\\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n}\\n\";\n\t\n\t\tvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t\tvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t\tvar meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t\tvar normal_frag = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\\t#include <logdepthbuf_fragment>\\n}\\n\";\n\t\n\t\tvar normal_vert = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvNormal = normalize( normalMatrix * normal );\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t\tvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\\t#else\\n\\t\\tgl_PointSize = size;\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t\tvar shadow_frag = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\n\t\n\t\tvar shadow_vert = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t\tvar ShaderChunk = {\n\t\t\talphamap_fragment: alphamap_fragment,\n\t\t\talphamap_pars_fragment: alphamap_pars_fragment,\n\t\t\talphatest_fragment: alphatest_fragment,\n\t\t\taomap_fragment: aomap_fragment,\n\t\t\taomap_pars_fragment: aomap_pars_fragment,\n\t\t\tbegin_vertex: begin_vertex,\n\t\t\tbeginnormal_vertex: beginnormal_vertex,\n\t\t\tbsdfs: bsdfs,\n\t\t\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\t\t\tclipping_planes_fragment: clipping_planes_fragment,\n\t\t\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\t\t\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\t\t\tclipping_planes_vertex: clipping_planes_vertex,\n\t\t\tcolor_fragment: color_fragment,\n\t\t\tcolor_pars_fragment: color_pars_fragment,\n\t\t\tcolor_pars_vertex: color_pars_vertex,\n\t\t\tcolor_vertex: color_vertex,\n\t\t\tcommon: common,\n\t\t\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\t\t\tdefaultnormal_vertex: defaultnormal_vertex,\n\t\t\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\t\t\tdisplacementmap_vertex: displacementmap_vertex,\n\t\t\temissivemap_fragment: emissivemap_fragment,\n\t\t\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\t\t\tencodings_fragment: encodings_fragment,\n\t\t\tencodings_pars_fragment: encodings_pars_fragment,\n\t\t\tenvmap_fragment: envmap_fragment,\n\t\t\tenvmap_pars_fragment: envmap_pars_fragment,\n\t\t\tenvmap_pars_vertex: envmap_pars_vertex,\n\t\t\tenvmap_vertex: envmap_vertex,\n\t\t\tfog_fragment: fog_fragment,\n\t\t\tfog_pars_fragment: fog_pars_fragment,\n\t\t\tlightmap_fragment: lightmap_fragment,\n\t\t\tlightmap_pars_fragment: lightmap_pars_fragment,\n\t\t\tlights_lambert_vertex: lights_lambert_vertex,\n\t\t\tlights_pars: lights_pars,\n\t\t\tlights_phong_fragment: lights_phong_fragment,\n\t\t\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\t\t\tlights_physical_fragment: lights_physical_fragment,\n\t\t\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\t\t\tlights_template: lights_template,\n\t\t\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\t\t\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\t\t\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\t\t\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\t\t\tmap_fragment: map_fragment,\n\t\t\tmap_pars_fragment: map_pars_fragment,\n\t\t\tmap_particle_fragment: map_particle_fragment,\n\t\t\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\t\t\tmetalnessmap_fragment: metalnessmap_fragment,\n\t\t\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\t\t\tmorphnormal_vertex: morphnormal_vertex,\n\t\t\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\t\t\tmorphtarget_vertex: morphtarget_vertex,\n\t\t\tnormal_flip: normal_flip,\n\t\t\tnormal_fragment: normal_fragment,\n\t\t\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\t\t\tpacking: packing,\n\t\t\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\t\t\tproject_vertex: project_vertex,\n\t\t\troughnessmap_fragment: roughnessmap_fragment,\n\t\t\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\t\t\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\t\t\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\t\t\tshadowmap_vertex: shadowmap_vertex,\n\t\t\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\t\t\tskinbase_vertex: skinbase_vertex,\n\t\t\tskinning_pars_vertex: skinning_pars_vertex,\n\t\t\tskinning_vertex: skinning_vertex,\n\t\t\tskinnormal_vertex: skinnormal_vertex,\n\t\t\tspecularmap_fragment: specularmap_fragment,\n\t\t\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\t\t\ttonemapping_fragment: tonemapping_fragment,\n\t\t\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\t\t\tuv_pars_fragment: uv_pars_fragment,\n\t\t\tuv_pars_vertex: uv_pars_vertex,\n\t\t\tuv_vertex: uv_vertex,\n\t\t\tuv2_pars_fragment: uv2_pars_fragment,\n\t\t\tuv2_pars_vertex: uv2_pars_vertex,\n\t\t\tuv2_vertex: uv2_vertex,\n\t\t\tworldpos_vertex: worldpos_vertex,\n\t\n\t\t\tcube_frag: cube_frag,\n\t\t\tcube_vert: cube_vert,\n\t\t\tdepth_frag: depth_frag,\n\t\t\tdepth_vert: depth_vert,\n\t\t\tdistanceRGBA_frag: distanceRGBA_frag,\n\t\t\tdistanceRGBA_vert: distanceRGBA_vert,\n\t\t\tequirect_frag: equirect_frag,\n\t\t\tequirect_vert: equirect_vert,\n\t\t\tlinedashed_frag: linedashed_frag,\n\t\t\tlinedashed_vert: linedashed_vert,\n\t\t\tmeshbasic_frag: meshbasic_frag,\n\t\t\tmeshbasic_vert: meshbasic_vert,\n\t\t\tmeshlambert_frag: meshlambert_frag,\n\t\t\tmeshlambert_vert: meshlambert_vert,\n\t\t\tmeshphong_frag: meshphong_frag,\n\t\t\tmeshphong_vert: meshphong_vert,\n\t\t\tmeshphysical_frag: meshphysical_frag,\n\t\t\tmeshphysical_vert: meshphysical_vert,\n\t\t\tnormal_frag: normal_frag,\n\t\t\tnormal_vert: normal_vert,\n\t\t\tpoints_frag: points_frag,\n\t\t\tpoints_vert: points_vert,\n\t\t\tshadow_frag: shadow_frag,\n\t\t\tshadow_vert: shadow_vert\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Color( r, g, b ) {\n\t\n\t\t\tif ( g === undefined && b === undefined ) {\n\t\n\t\t\t\t// r is THREE.Color, hex or string\n\t\t\t\treturn this.set( r );\n\t\n\t\t\t}\n\t\n\t\t\treturn this.setRGB( r, g, b );\n\t\n\t\t}\n\t\n\t\tColor.prototype = {\n\t\n\t\t\tconstructor: Color,\n\t\n\t\t\tisColor: true,\n\t\n\t\t\tr: 1, g: 1, b: 1,\n\t\n\t\t\tset: function ( value ) {\n\t\n\t\t\t\tif ( (value && value.isColor) ) {\n\t\n\t\t\t\t\tthis.copy( value );\n\t\n\t\t\t\t} else if ( typeof value === 'number' ) {\n\t\n\t\t\t\t\tthis.setHex( value );\n\t\n\t\t\t\t} else if ( typeof value === 'string' ) {\n\t\n\t\t\t\t\tthis.setStyle( value );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.r = scalar;\n\t\t\t\tthis.g = scalar;\n\t\t\t\tthis.b = scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetHex: function ( hex ) {\n\t\n\t\t\t\thex = Math.floor( hex );\n\t\n\t\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\t\t\tthis.b = ( hex & 255 ) / 255;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetRGB: function ( r, g, b ) {\n\t\n\t\t\t\tthis.r = r;\n\t\t\t\tthis.g = g;\n\t\t\t\tthis.b = b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetHSL: function () {\n\t\n\t\t\t\tfunction hue2rgb( p, q, t ) {\n\t\n\t\t\t\t\tif ( t < 0 ) t += 1;\n\t\t\t\t\tif ( t > 1 ) t -= 1;\n\t\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\t\t\treturn p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function setHSL( h, s, l ) {\n\t\n\t\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\t\t\th = _Math.euclideanModulo( h, 1 );\n\t\t\t\t\ts = _Math.clamp( s, 0, 1 );\n\t\t\t\t\tl = _Math.clamp( l, 0, 1 );\n\t\n\t\t\t\t\tif ( s === 0 ) {\n\t\n\t\t\t\t\t\tthis.r = this.g = this.b = l;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\t\t\tvar q = ( 2 * l ) - p;\n\t\n\t\t\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tsetStyle: function ( style ) {\n\t\n\t\t\t\tfunction handleAlpha( string ) {\n\t\n\t\t\t\t\tif ( string === undefined ) return;\n\t\n\t\t\t\t\tif ( parseFloat( string ) < 1 ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\tvar m;\n\t\n\t\t\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\t\n\t\t\t\t\t// rgb / hsl\n\t\n\t\t\t\t\tvar color;\n\t\t\t\t\tvar name = m[ 1 ];\n\t\t\t\t\tvar components = m[ 2 ];\n\t\n\t\t\t\t\tswitch ( name ) {\n\t\n\t\t\t\t\t\tcase 'rgb':\n\t\t\t\t\t\tcase 'rgba':\n\t\n\t\t\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\t\n\t\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\t\n\t\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'hsl':\n\t\t\t\t\t\tcase 'hsla':\n\t\n\t\t\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\t\n\t\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\t\n\t\t\t\t\t// hex color\n\t\n\t\t\t\t\tvar hex = m[ 1 ];\n\t\t\t\t\tvar size = hex.length;\n\t\n\t\t\t\t\tif ( size === 3 ) {\n\t\n\t\t\t\t\t\t// #ff0\n\t\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\t\n\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t} else if ( size === 6 ) {\n\t\n\t\t\t\t\t\t// #ff0000\n\t\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\t\n\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( style && style.length > 0 ) {\n\t\n\t\t\t\t\t// color keywords\n\t\t\t\t\tvar hex = ColorKeywords[ style ];\n\t\n\t\t\t\t\tif ( hex !== undefined ) {\n\t\n\t\t\t\t\t\t// red\n\t\t\t\t\t\tthis.setHex( hex );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// unknown color\n\t\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.r, this.g, this.b );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( color ) {\n\t\n\t\t\t\tthis.r = color.r;\n\t\t\t\tthis.g = color.g;\n\t\t\t\tthis.b = color.b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\t\n\t\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\t\n\t\t\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\t\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\t\t\tthis.b = Math.pow( color.b, gammaFactor );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\t\n\t\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\t\n\t\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\t\n\t\t\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\t\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\t\t\tthis.b = Math.pow( color.b, safeInverse );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tconvertGammaToLinear: function () {\n\t\n\t\t\t\tvar r = this.r, g = this.g, b = this.b;\n\t\n\t\t\t\tthis.r = r * r;\n\t\t\t\tthis.g = g * g;\n\t\t\t\tthis.b = b * b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tconvertLinearToGamma: function () {\n\t\n\t\t\t\tthis.r = Math.sqrt( this.r );\n\t\t\t\tthis.g = Math.sqrt( this.g );\n\t\t\t\tthis.b = Math.sqrt( this.b );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetHex: function () {\n\t\n\t\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\t\n\t\t\t},\n\t\n\t\t\tgetHexString: function () {\n\t\n\t\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\t\n\t\t\t},\n\t\n\t\t\tgetHSL: function ( optionalTarget ) {\n\t\n\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\n\t\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\t\n\t\t\t\tvar r = this.r, g = this.g, b = this.b;\n\t\n\t\t\t\tvar max = Math.max( r, g, b );\n\t\t\t\tvar min = Math.min( r, g, b );\n\t\n\t\t\t\tvar hue, saturation;\n\t\t\t\tvar lightness = ( min + max ) / 2.0;\n\t\n\t\t\t\tif ( min === max ) {\n\t\n\t\t\t\t\thue = 0;\n\t\t\t\t\tsaturation = 0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar delta = max - min;\n\t\n\t\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\t\n\t\t\t\t\tswitch ( max ) {\n\t\n\t\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\thue /= 6;\n\t\n\t\t\t\t}\n\t\n\t\t\t\thsl.h = hue;\n\t\t\t\thsl.s = saturation;\n\t\t\t\thsl.l = lightness;\n\t\n\t\t\t\treturn hsl;\n\t\n\t\t\t},\n\t\n\t\t\tgetStyle: function () {\n\t\n\t\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\t\n\t\t\t},\n\t\n\t\t\toffsetHSL: function ( h, s, l ) {\n\t\n\t\t\t\tvar hsl = this.getHSL();\n\t\n\t\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\t\n\t\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( color ) {\n\t\n\t\t\t\tthis.r += color.r;\n\t\t\t\tthis.g += color.g;\n\t\t\t\tthis.b += color.b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddColors: function ( color1, color2 ) {\n\t\n\t\t\t\tthis.r = color1.r + color2.r;\n\t\t\t\tthis.g = color1.g + color2.g;\n\t\t\t\tthis.b = color1.b + color2.b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScalar: function ( s ) {\n\t\n\t\t\t\tthis.r += s;\n\t\t\t\tthis.g += s;\n\t\t\t\tthis.b += s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsub: function( color ) {\n\t\n\t\t\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\t\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\t\t\tthis.b = Math.max( 0, this.b - color.b );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiply: function ( color ) {\n\t\n\t\t\t\tthis.r *= color.r;\n\t\t\t\tthis.g *= color.g;\n\t\t\t\tthis.b *= color.b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\t\tthis.r *= s;\n\t\t\t\tthis.g *= s;\n\t\t\t\tthis.b *= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlerp: function ( color, alpha ) {\n\t\n\t\t\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\t\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\t\t\tthis.b += ( color.b - this.b ) * alpha;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( c ) {\n\t\n\t\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.r = array[ offset ];\n\t\t\t\tthis.g = array[ offset + 1 ];\n\t\t\t\tthis.b = array[ offset + 2 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this.r;\n\t\t\t\tarray[ offset + 1 ] = this.g;\n\t\t\t\tarray[ offset + 2 ] = this.b;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\treturn this.getHex();\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\t\n\t\t/**\n\t\t * Uniforms library for shared webgl shaders\n\t\t */\n\t\n\t\tvar UniformsLib = {\n\t\n\t\t\tcommon: {\n\t\n\t\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\t\topacity: { value: 1.0 },\n\t\n\t\t\t\tmap: { value: null },\n\t\t\t\toffsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },\n\t\n\t\t\t\tspecularMap: { value: null },\n\t\t\t\talphaMap: { value: null },\n\t\n\t\t\t\tenvMap: { value: null },\n\t\t\t\tflipEnvMap: { value: - 1 },\n\t\t\t\treflectivity: { value: 1.0 },\n\t\t\t\trefractionRatio: { value: 0.98 }\n\t\n\t\t\t},\n\t\n\t\t\taomap: {\n\t\n\t\t\t\taoMap: { value: null },\n\t\t\t\taoMapIntensity: { value: 1 }\n\t\n\t\t\t},\n\t\n\t\t\tlightmap: {\n\t\n\t\t\t\tlightMap: { value: null },\n\t\t\t\tlightMapIntensity: { value: 1 }\n\t\n\t\t\t},\n\t\n\t\t\temissivemap: {\n\t\n\t\t\t\temissiveMap: { value: null }\n\t\n\t\t\t},\n\t\n\t\t\tbumpmap: {\n\t\n\t\t\t\tbumpMap: { value: null },\n\t\t\t\tbumpScale: { value: 1 }\n\t\n\t\t\t},\n\t\n\t\t\tnormalmap: {\n\t\n\t\t\t\tnormalMap: { value: null },\n\t\t\t\tnormalScale: { value: new Vector2( 1, 1 ) }\n\t\n\t\t\t},\n\t\n\t\t\tdisplacementmap: {\n\t\n\t\t\t\tdisplacementMap: { value: null },\n\t\t\t\tdisplacementScale: { value: 1 },\n\t\t\t\tdisplacementBias: { value: 0 }\n\t\n\t\t\t},\n\t\n\t\t\troughnessmap: {\n\t\n\t\t\t\troughnessMap: { value: null }\n\t\n\t\t\t},\n\t\n\t\t\tmetalnessmap: {\n\t\n\t\t\t\tmetalnessMap: { value: null }\n\t\n\t\t\t},\n\t\n\t\t\tfog: {\n\t\n\t\t\t\tfogDensity: { value: 0.00025 },\n\t\t\t\tfogNear: { value: 1 },\n\t\t\t\tfogFar: { value: 2000 },\n\t\t\t\tfogColor: { value: new Color( 0xffffff ) }\n\t\n\t\t\t},\n\t\n\t\t\tlights: {\n\t\n\t\t\t\tambientLightColor: { value: [] },\n\t\n\t\t\t\tdirectionalLights: { value: [], properties: {\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tcolor: {},\n\t\n\t\t\t\t\tshadow: {},\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t} },\n\t\n\t\t\t\tdirectionalShadowMap: { value: [] },\n\t\t\t\tdirectionalShadowMatrix: { value: [] },\n\t\n\t\t\t\tspotLights: { value: [], properties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tdistance: {},\n\t\t\t\t\tconeCos: {},\n\t\t\t\t\tpenumbraCos: {},\n\t\t\t\t\tdecay: {},\n\t\n\t\t\t\t\tshadow: {},\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t} },\n\t\n\t\t\t\tspotShadowMap: { value: [] },\n\t\t\t\tspotShadowMatrix: { value: [] },\n\t\n\t\t\t\tpointLights: { value: [], properties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\tdecay: {},\n\t\t\t\t\tdistance: {},\n\t\n\t\t\t\t\tshadow: {},\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t} },\n\t\n\t\t\t\tpointShadowMap: { value: [] },\n\t\t\t\tpointShadowMatrix: { value: [] },\n\t\n\t\t\t\themisphereLights: { value: [], properties: {\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tskyColor: {},\n\t\t\t\t\tgroundColor: {}\n\t\t\t\t} }\n\t\n\t\t\t},\n\t\n\t\t\tpoints: {\n\t\n\t\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\t\topacity: { value: 1.0 },\n\t\t\t\tsize: { value: 1.0 },\n\t\t\t\tscale: { value: 1.0 },\n\t\t\t\tmap: { value: null },\n\t\t\t\toffsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t */\n\t\n\t\tvar ShaderLib = {\n\t\n\t\t\tbasic: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.aomap,\n\t\t\t\t\tUniformsLib.fog\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\t\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\t\n\t\t\t},\n\t\n\t\t\tlambert: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.aomap,\n\t\t\t\t\tUniformsLib.lightmap,\n\t\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\t\tUniformsLib.fog,\n\t\t\t\t\tUniformsLib.lights,\n\t\n\t\t\t\t\t{\n\t\t\t\t\t\temissive : { value: new Color( 0x000000 ) }\n\t\t\t\t\t}\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\t\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\t\n\t\t\t},\n\t\n\t\t\tphong: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.aomap,\n\t\t\t\t\tUniformsLib.lightmap,\n\t\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\t\tUniformsLib.normalmap,\n\t\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\t\tUniformsLib.fog,\n\t\t\t\t\tUniformsLib.lights,\n\t\n\t\t\t\t\t{\n\t\t\t\t\t\temissive : { value: new Color( 0x000000 ) },\n\t\t\t\t\t\tspecular : { value: new Color( 0x111111 ) },\n\t\t\t\t\t\tshininess: { value: 30 }\n\t\t\t\t\t}\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\t\t\tfragmentShader: ShaderChunk.meshphong_frag\n\t\n\t\t\t},\n\t\n\t\t\tstandard: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.aomap,\n\t\t\t\t\tUniformsLib.lightmap,\n\t\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\t\tUniformsLib.normalmap,\n\t\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\t\tUniformsLib.roughnessmap,\n\t\t\t\t\tUniformsLib.metalnessmap,\n\t\t\t\t\tUniformsLib.fog,\n\t\t\t\t\tUniformsLib.lights,\n\t\n\t\t\t\t\t{\n\t\t\t\t\t\temissive : { value: new Color( 0x000000 ) },\n\t\t\t\t\t\troughness: { value: 0.5 },\n\t\t\t\t\t\tmetalness: { value: 0 },\n\t\t\t\t\t\tenvMapIntensity : { value: 1 }, // temporary\n\t\t\t\t\t}\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\t\n\t\t\t},\n\t\n\t\t\tpoints: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.points,\n\t\t\t\t\tUniformsLib.fog\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.points_vert,\n\t\t\t\tfragmentShader: ShaderChunk.points_frag\n\t\n\t\t\t},\n\t\n\t\t\tdashed: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.fog,\n\t\n\t\t\t\t\t{\n\t\t\t\t\t\tscale    : { value: 1 },\n\t\t\t\t\t\tdashSize : { value: 1 },\n\t\t\t\t\t\ttotalSize: { value: 2 }\n\t\t\t\t\t}\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\t\t\tfragmentShader: ShaderChunk.linedashed_frag\n\t\n\t\t\t},\n\t\n\t\t\tdepth: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.displacementmap\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.depth_vert,\n\t\t\t\tfragmentShader: ShaderChunk.depth_frag\n\t\n\t\t\t},\n\t\n\t\t\tnormal: {\n\t\n\t\t\t\tuniforms: {\n\t\n\t\t\t\t\topacity : { value: 1.0 }\n\t\n\t\t\t\t},\n\t\n\t\t\t\tvertexShader: ShaderChunk.normal_vert,\n\t\t\t\tfragmentShader: ShaderChunk.normal_frag\n\t\n\t\t\t},\n\t\n\t\t\t/* -------------------------------------------------------------------------\n\t\t\t//\tCube map shader\n\t\t\t ------------------------------------------------------------------------- */\n\t\n\t\t\tcube: {\n\t\n\t\t\t\tuniforms: {\n\t\t\t\t\ttCube: { value: null },\n\t\t\t\t\ttFlip: { value: - 1 },\n\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t},\n\t\n\t\t\t\tvertexShader: ShaderChunk.cube_vert,\n\t\t\t\tfragmentShader: ShaderChunk.cube_frag\n\t\n\t\t\t},\n\t\n\t\t\t/* -------------------------------------------------------------------------\n\t\t\t//\tCube map shader\n\t\t\t ------------------------------------------------------------------------- */\n\t\n\t\t\tequirect: {\n\t\n\t\t\t\tuniforms: {\n\t\t\t\t\ttEquirect: { value: null },\n\t\t\t\t\ttFlip: { value: - 1 }\n\t\t\t\t},\n\t\n\t\t\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\t\t\tfragmentShader: ShaderChunk.equirect_frag\n\t\n\t\t\t},\n\t\n\t\t\tdistanceRGBA: {\n\t\n\t\t\t\tuniforms: {\n\t\n\t\t\t\t\tlightPos: { value: new Vector3() }\n\t\n\t\t\t\t},\n\t\n\t\t\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\t\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tShaderLib.physical = {\n\t\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\tShaderLib.standard.uniforms,\n\t\n\t\t\t\t{\n\t\t\t\t\tclearCoat: { value: 0 },\n\t\t\t\t\tclearCoatRoughness: { value: 0 }\n\t\t\t\t}\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Box2( min, max ) {\n\t\n\t\t\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\n\t\t\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\n\t\n\t\t}\n\t\n\t\tBox2.prototype = {\n\t\n\t\t\tconstructor: Box2,\n\t\n\t\t\tset: function ( min, max ) {\n\t\n\t\t\t\tthis.min.copy( min );\n\t\t\t\tthis.max.copy( max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPoints: function ( points ) {\n\t\n\t\t\t\tthis.makeEmpty();\n\t\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.expandByPoint( points[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCenterAndSize: function () {\n\t\n\t\t\t\tvar v1 = new Vector2();\n\t\n\t\t\t\treturn function setFromCenterAndSize( center, size ) {\n\t\n\t\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\t\tthis.max.copy( center ).add( halfSize );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( box ) {\n\t\n\t\t\t\tthis.min.copy( box.min );\n\t\t\t\tthis.max.copy( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeEmpty: function () {\n\t\n\t\t\t\tthis.min.x = this.min.y = + Infinity;\n\t\t\t\tthis.max.x = this.max.y = - Infinity;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tisEmpty: function () {\n\t\n\t\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\n\t\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\t\n\t\t\t},\n\t\n\t\t\tgetCenter: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\t\n\t\t\t},\n\t\n\t\t\tgetSize: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );\n\t\n\t\t\t},\n\t\n\t\t\texpandByPoint: function ( point ) {\n\t\n\t\t\t\tthis.min.min( point );\n\t\t\t\tthis.max.max( point );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByVector: function ( vector ) {\n\t\n\t\t\t\tthis.min.sub( vector );\n\t\t\t\tthis.max.add( vector );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.min.addScalar( - scalar );\n\t\t\t\tthis.max.addScalar( scalar );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tcontainsBox: function ( box ) {\n\t\n\t\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t},\n\t\n\t\t\tgetParameter: function ( point, optionalTarget ) {\n\t\n\t\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t\t// has a size dimension of 0.\n\t\n\t\t\t\tvar result = optionalTarget || new Vector2();\n\t\n\t\t\t\treturn result.set(\n\t\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t\t\t);\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\t// using 6 splitting planes to rule out intersections.\n\t\n\t\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function () {\n\t\n\t\t\t\tvar v1 = new Vector2();\n\t\n\t\t\t\treturn function distanceToPoint( point ) {\n\t\n\t\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\t\treturn clampedPoint.sub( point ).length();\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersect: function ( box ) {\n\t\n\t\t\t\tthis.min.max( box.min );\n\t\t\t\tthis.max.min( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tunion: function ( box ) {\n\t\n\t\t\t\tthis.min.min( box.min );\n\t\t\t\tthis.max.max( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttranslate: function ( offset ) {\n\t\n\t\t\t\tthis.min.add( offset );\n\t\t\t\tthis.max.add( offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( box ) {\n\t\n\t\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction LensFlarePlugin( renderer, flares ) {\n\t\n\t\t\tvar gl = renderer.context;\n\t\t\tvar state = renderer.state;\n\t\n\t\t\tvar vertexBuffer, elementBuffer;\n\t\t\tvar shader, program, attributes, uniforms;\n\t\n\t\t\tvar tempTexture, occlusionTexture;\n\t\n\t\t\tfunction init() {\n\t\n\t\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t\t- 1, - 1,  0, 0,\n\t\t\t\t\t 1, - 1,  1, 0,\n\t\t\t\t\t 1,  1,  1, 1,\n\t\t\t\t\t- 1,  1,  0, 1\n\t\t\t\t] );\n\t\n\t\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t0, 2, 3\n\t\t\t\t] );\n\t\n\t\t\t\t// buffers\n\t\n\t\t\t\tvertexBuffer     = gl.createBuffer();\n\t\t\t\telementBuffer    = gl.createBuffer();\n\t\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\t\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\t\n\t\t\t\t// textures\n\t\n\t\t\t\ttempTexture      = gl.createTexture();\n\t\t\t\tocclusionTexture = gl.createTexture();\n\t\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\n\t\t\t\tshader = {\n\t\n\t\t\t\t\tvertexShader: [\n\t\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\n\t\n\t\t\t\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\t\t\t\"uniform vec2 scale;\",\n\t\t\t\t\t\t\"uniform float rotation;\",\n\t\n\t\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\n\t\n\t\t\t\t\t\t\"attribute vec2 position;\",\n\t\t\t\t\t\t\"attribute vec2 uv;\",\n\t\n\t\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\t\"varying float vVisibility;\",\n\t\n\t\t\t\t\t\t\"void main() {\",\n\t\n\t\t\t\t\t\t\t\"vUV = uv;\",\n\t\n\t\t\t\t\t\t\t\"vec2 pos = position;\",\n\t\n\t\t\t\t\t\t\t\"if ( renderType == 2 ) {\",\n\t\n\t\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\t\n\t\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\t\n\t\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\t\n\t\t\t\t\t\t\t\"}\",\n\t\n\t\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\t\n\t\t\t\t\t\t\"}\"\n\t\n\t\t\t\t\t].join( \"\\n\" ),\n\t\n\t\t\t\t\tfragmentShader: [\n\t\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\n\t\n\t\t\t\t\t\t\"uniform sampler2D map;\",\n\t\t\t\t\t\t\"uniform float opacity;\",\n\t\t\t\t\t\t\"uniform vec3 color;\",\n\t\n\t\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\t\"varying float vVisibility;\",\n\t\n\t\t\t\t\t\t\"void main() {\",\n\t\n\t\t\t\t\t\t\t// pink square\n\t\n\t\t\t\t\t\t\t\"if ( renderType == 0 ) {\",\n\t\n\t\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\t\n\t\t\t\t\t\t\t// restore\n\t\n\t\t\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\n\t\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\t\n\t\t\t\t\t\t\t// flare\n\t\n\t\t\t\t\t\t\t\"} else {\",\n\t\n\t\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\t\n\t\t\t\t\t\t\t\"}\",\n\t\n\t\t\t\t\t\t\"}\"\n\t\n\t\t\t\t\t].join( \"\\n\" )\n\t\n\t\t\t\t};\n\t\n\t\t\t\tprogram = createProgram( shader );\n\t\n\t\t\t\tattributes = {\n\t\t\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\n\t\t\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\n\t\t\t\t};\n\t\n\t\t\t\tuniforms = {\n\t\t\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\n\t\t\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\n\t\t\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n\t\t\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\n\t\t\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\n\t\t\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\n\t\t\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\n\t\t\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t/*\n\t\t\t * Render lens flares\n\t\t\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t\t\t *         reads these back and calculates occlusion.\n\t\t\t */\n\t\n\t\t\tthis.render = function ( scene, camera, viewport ) {\n\t\n\t\t\t\tif ( flares.length === 0 ) return;\n\t\n\t\t\t\tvar tempPosition = new Vector3();\n\t\n\t\t\t\tvar invAspect = viewport.w / viewport.z,\n\t\t\t\t\thalfViewportWidth = viewport.z * 0.5,\n\t\t\t\t\thalfViewportHeight = viewport.w * 0.5;\n\t\n\t\t\t\tvar size = 16 / viewport.w,\n\t\t\t\t\tscale = new Vector2( size * invAspect, size );\n\t\n\t\t\t\tvar screenPosition = new Vector3( 1, 1, 0 ),\n\t\t\t\t\tscreenPositionPixels = new Vector2( 1, 1 );\n\t\n\t\t\t\tvar validArea = new Box2();\n\t\n\t\t\t\tvalidArea.min.set( viewport.x, viewport.y );\n\t\t\t\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\n\t\n\t\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t\tinit();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgl.useProgram( program );\n\t\n\t\t\t\tstate.initAttributes();\n\t\t\t\tstate.enableAttribute( attributes.vertex );\n\t\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t\t// loop through all lens flares to update their occlusion and positions\n\t\t\t\t// setup gl and common used attribs/uniforms\n\t\n\t\t\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\n\t\t\t\tgl.uniform1i( uniforms.map, 1 );\n\t\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\t\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\n\t\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\t\tstate.setDepthWrite( false );\n\t\n\t\t\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tsize = 16 / viewport.w;\n\t\t\t\t\tscale.set( size * invAspect, size );\n\t\n\t\t\t\t\t// calc object screen position\n\t\n\t\t\t\t\tvar flare = flares[ i ];\n\t\n\t\t\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\t\n\t\t\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\t\n\t\t\t\t\t// setup arrays for gl programs\n\t\n\t\t\t\t\tscreenPosition.copy( tempPosition );\n\t\n\t\t\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\t\n\t\t\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\t\n\t\t\t\t\t// screen cull\n\t\n\t\t\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\t\n\t\t\t\t\t\t// save current RGB to temp texture\n\t\n\t\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\n\t\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\t\n\t\n\t\t\t\t\t\t// render pink quad\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\n\t\t\t\t\t\tstate.disable( gl.BLEND );\n\t\t\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\n\t\t\t\t\t\t// copy result to occlusionMap\n\t\n\t\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\t\n\t\n\t\t\t\t\t\t// restore graphics\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\n\t\t\t\t\t\t// update object positions\n\t\n\t\t\t\t\t\tflare.positionScreen.copy( screenPosition );\n\t\n\t\t\t\t\t\tif ( flare.customUpdateCallback ) {\n\t\n\t\t\t\t\t\t\tflare.customUpdateCallback( flare );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tflare.updateLensFlares();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// render flares\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\t\t\tstate.enable( gl.BLEND );\n\t\n\t\t\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\n\t\n\t\t\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\t\n\t\t\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\t\n\t\t\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\n\t\n\t\t\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\t\t\tscale.y = size;\n\t\n\t\t\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\n\t\n\t\t\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\t\n\t\t\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\n\t\n\t\t\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// restore gl\n\t\n\t\t\t\tstate.enable( gl.CULL_FACE );\n\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\t\t\tstate.setDepthWrite( true );\n\t\n\t\t\t\trenderer.resetGLState();\n\t\n\t\t\t};\n\t\n\t\t\tfunction createProgram( shader ) {\n\t\n\t\t\t\tvar program = gl.createProgram();\n\t\n\t\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\n\t\t\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\t\n\t\t\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\t\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\t\n\t\t\t\tgl.compileShader( fragmentShader );\n\t\t\t\tgl.compileShader( vertexShader );\n\t\n\t\t\t\tgl.attachShader( program, fragmentShader );\n\t\t\t\tgl.attachShader( program, vertexShader );\n\t\n\t\t\t\tgl.linkProgram( program );\n\t\n\t\t\t\treturn program;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction SpritePlugin( renderer, sprites ) {\n\t\n\t\t\tvar gl = renderer.context;\n\t\t\tvar state = renderer.state;\n\t\n\t\t\tvar vertexBuffer, elementBuffer;\n\t\t\tvar program, attributes, uniforms;\n\t\n\t\t\tvar texture;\n\t\n\t\t\t// decompose matrixWorld\n\t\n\t\t\tvar spritePosition = new Vector3();\n\t\t\tvar spriteRotation = new Quaternion();\n\t\t\tvar spriteScale = new Vector3();\n\t\n\t\t\tfunction init() {\n\t\n\t\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t\t- 0.5, - 0.5,  0, 0,\n\t\t\t\t\t  0.5, - 0.5,  1, 0,\n\t\t\t\t\t  0.5,   0.5,  1, 1,\n\t\t\t\t\t- 0.5,   0.5,  0, 1\n\t\t\t\t] );\n\t\n\t\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t0, 2, 3\n\t\t\t\t] );\n\t\n\t\t\t\tvertexBuffer  = gl.createBuffer();\n\t\t\t\telementBuffer = gl.createBuffer();\n\t\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\t\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\t\n\t\t\t\tprogram = createProgram();\n\t\n\t\t\t\tattributes = {\n\t\t\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\n\t\t\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\n\t\t\t\t};\n\t\n\t\t\t\tuniforms = {\n\t\t\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\n\t\t\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\n\t\n\t\t\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\n\t\t\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\n\t\n\t\t\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\n\t\t\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\n\t\t\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\n\t\n\t\t\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\n\t\n\t\t\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\n\t\t\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\n\t\t\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\n\t\t\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\n\t\t\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\n\t\n\t\t\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\n\t\t\t\t};\n\t\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = 8;\n\t\t\t\tcanvas.height = 8;\n\t\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.fillStyle = 'white';\n\t\t\t\tcontext.fillRect( 0, 0, 8, 8 );\n\t\n\t\t\t\ttexture = new Texture( canvas );\n\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t\tthis.render = function ( scene, camera ) {\n\t\n\t\t\t\tif ( sprites.length === 0 ) return;\n\t\n\t\t\t\t// setup gl\n\t\n\t\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t\tinit();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgl.useProgram( program );\n\t\n\t\t\t\tstate.initAttributes();\n\t\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\t\tstate.enable( gl.BLEND );\n\t\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\t\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\n\t\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\t\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\tgl.uniform1i( uniforms.map, 0 );\n\t\n\t\t\t\tvar oldFogType = 0;\n\t\t\t\tvar sceneFogType = 0;\n\t\t\t\tvar fog = scene.fog;\n\t\n\t\t\t\tif ( fog ) {\n\t\n\t\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\t\n\t\t\t\t\tif ( (fog && fog.isFog) ) {\n\t\n\t\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\t\t\toldFogType = 1;\n\t\t\t\t\t\tsceneFogType = 1;\n\t\n\t\t\t\t\t} else if ( (fog && fog.isFogExp2) ) {\n\t\n\t\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\t\t\toldFogType = 2;\n\t\t\t\t\t\tsceneFogType = 2;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\t\t\toldFogType = 0;\n\t\t\t\t\tsceneFogType = 0;\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\t// update positions and sort\n\t\n\t\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar sprite = sprites[ i ];\n\t\n\t\t\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tsprites.sort( painterSortStable );\n\t\n\t\t\t\t// render all sprites\n\t\n\t\t\t\tvar scale = [];\n\t\n\t\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar sprite = sprites[ i ];\n\t\t\t\t\tvar material = sprite.material;\n\t\n\t\t\t\t\tif ( material.visible === false ) continue;\n\t\n\t\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\t\n\t\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\t\n\t\t\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\t\t\tscale[ 1 ] = spriteScale.y;\n\t\n\t\t\t\t\tvar fogType = 0;\n\t\n\t\t\t\t\tif ( scene.fog && material.fog ) {\n\t\n\t\t\t\t\t\tfogType = sceneFogType;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( oldFogType !== fogType ) {\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\t\t\toldFogType = fogType;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( material.map !== null ) {\n\t\n\t\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\t\n\t\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\t\n\t\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\t\t\tstate.setDepthWrite( material.depthWrite );\n\t\n\t\t\t\t\tif ( material.map ) {\n\t\n\t\t\t\t\t\trenderer.setTexture2D( material.map, 0 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\trenderer.setTexture2D( texture, 0 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// restore gl\n\t\n\t\t\t\tstate.enable( gl.CULL_FACE );\n\t\n\t\t\t\trenderer.resetGLState();\n\t\n\t\t\t};\n\t\n\t\t\tfunction createProgram() {\n\t\n\t\t\t\tvar program = gl.createProgram();\n\t\n\t\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\n\t\t\t\tgl.shaderSource( vertexShader, [\n\t\n\t\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\t\n\t\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t\t'uniform float rotation;',\n\t\t\t\t\t'uniform vec2 scale;',\n\t\t\t\t\t'uniform vec2 uvOffset;',\n\t\t\t\t\t'uniform vec2 uvScale;',\n\t\n\t\t\t\t\t'attribute vec2 position;',\n\t\t\t\t\t'attribute vec2 uv;',\n\t\n\t\t\t\t\t'varying vec2 vUV;',\n\t\n\t\t\t\t\t'void main() {',\n\t\n\t\t\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\t\n\t\t\t\t\t\t'vec2 alignedPosition = position * scale;',\n\t\n\t\t\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\t\n\t\t\t\t\t\t'vec4 finalPosition;',\n\t\n\t\t\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\t\n\t\t\t\t\t\t'gl_Position = finalPosition;',\n\t\n\t\t\t\t\t'}'\n\t\n\t\t\t\t].join( '\\n' ) );\n\t\n\t\t\t\tgl.shaderSource( fragmentShader, [\n\t\n\t\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\t\n\t\t\t\t\t'uniform vec3 color;',\n\t\t\t\t\t'uniform sampler2D map;',\n\t\t\t\t\t'uniform float opacity;',\n\t\n\t\t\t\t\t'uniform int fogType;',\n\t\t\t\t\t'uniform vec3 fogColor;',\n\t\t\t\t\t'uniform float fogDensity;',\n\t\t\t\t\t'uniform float fogNear;',\n\t\t\t\t\t'uniform float fogFar;',\n\t\t\t\t\t'uniform float alphaTest;',\n\t\n\t\t\t\t\t'varying vec2 vUV;',\n\t\n\t\t\t\t\t'void main() {',\n\t\n\t\t\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\t\n\t\t\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\t\n\t\t\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\t\n\t\t\t\t\t\t'if ( fogType > 0 ) {',\n\t\n\t\t\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t\t\t'float fogFactor = 0.0;',\n\t\n\t\t\t\t\t\t\t'if ( fogType == 1 ) {',\n\t\n\t\t\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\t\n\t\t\t\t\t\t\t'} else {',\n\t\n\t\t\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\t\n\t\t\t\t\t\t\t'}',\n\t\n\t\t\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\t\n\t\t\t\t\t\t'}',\n\t\n\t\t\t\t\t'}'\n\t\n\t\t\t\t].join( '\\n' ) );\n\t\n\t\t\t\tgl.compileShader( vertexShader );\n\t\t\t\tgl.compileShader( fragmentShader );\n\t\n\t\t\t\tgl.attachShader( program, vertexShader );\n\t\t\t\tgl.attachShader( program, fragmentShader );\n\t\n\t\t\t\tgl.linkProgram( program );\n\t\n\t\t\t\treturn program;\n\t\n\t\t\t}\n\t\n\t\t\tfunction painterSortStable( a, b ) {\n\t\n\t\t\t\tif ( a.renderOrder !== b.renderOrder ) {\n\t\n\t\t\t\t\treturn a.renderOrder - b.renderOrder;\n\t\n\t\t\t\t} else if ( a.z !== b.z ) {\n\t\n\t\t\t\t\treturn b.z - a.z;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn b.id - a.id;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Material() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: MaterialIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Material';\n\t\n\t\t\tthis.fog = true;\n\t\t\tthis.lights = true;\n\t\n\t\t\tthis.blending = NormalBlending;\n\t\t\tthis.side = FrontSide;\n\t\t\tthis.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n\t\t\tthis.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\t\n\t\t\tthis.opacity = 1;\n\t\t\tthis.transparent = false;\n\t\n\t\t\tthis.blendSrc = SrcAlphaFactor;\n\t\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\t\tthis.blendEquation = AddEquation;\n\t\t\tthis.blendSrcAlpha = null;\n\t\t\tthis.blendDstAlpha = null;\n\t\t\tthis.blendEquationAlpha = null;\n\t\n\t\t\tthis.depthFunc = LessEqualDepth;\n\t\t\tthis.depthTest = true;\n\t\t\tthis.depthWrite = true;\n\t\n\t\t\tthis.clippingPlanes = null;\n\t\t\tthis.clipIntersection = false;\n\t\t\tthis.clipShadows = false;\n\t\n\t\t\tthis.colorWrite = true;\n\t\n\t\t\tthis.precision = null; // override the renderer's default precision for this material\n\t\n\t\t\tthis.polygonOffset = false;\n\t\t\tthis.polygonOffsetFactor = 0;\n\t\t\tthis.polygonOffsetUnits = 0;\n\t\n\t\t\tthis.alphaTest = 0;\n\t\t\tthis.premultipliedAlpha = false;\n\t\n\t\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\t\n\t\t\tthis.visible = true;\n\t\n\t\t\tthis._needsUpdate = true;\n\t\n\t\t}\n\t\n\t\tMaterial.prototype = {\n\t\n\t\t\tconstructor: Material,\n\t\n\t\t\tisMaterial: true,\n\t\n\t\t\tget needsUpdate() {\n\t\n\t\t\t\treturn this._needsUpdate;\n\t\n\t\t\t},\n\t\n\t\t\tset needsUpdate( value ) {\n\t\n\t\t\t\tif ( value === true ) this.update();\n\t\t\t\tthis._needsUpdate = value;\n\t\n\t\t\t},\n\t\n\t\t\tsetValues: function ( values ) {\n\t\n\t\t\t\tif ( values === undefined ) return;\n\t\n\t\t\t\tfor ( var key in values ) {\n\t\n\t\t\t\t\tvar newValue = values[ key ];\n\t\n\t\t\t\t\tif ( newValue === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar currentValue = this[ key ];\n\t\n\t\t\t\t\tif ( currentValue === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( (currentValue && currentValue.isColor) ) {\n\t\n\t\t\t\t\t\tcurrentValue.set( newValue );\n\t\n\t\t\t\t\t} else if ( (currentValue && currentValue.isVector3) && (newValue && newValue.isVector3) ) {\n\t\n\t\t\t\t\t\tcurrentValue.copy( newValue );\n\t\n\t\t\t\t\t} else if ( key === 'overdraw' ) {\n\t\n\t\t\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\t\t\tthis[ key ] = Number( newValue );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis[ key ] = newValue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar isRoot = meta === undefined;\n\t\n\t\t\t\tif ( isRoot ) {\n\t\n\t\t\t\t\tmeta = {\n\t\t\t\t\t\ttextures: {},\n\t\t\t\t\t\timages: {}\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar data = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.4,\n\t\t\t\t\t\ttype: 'Material',\n\t\t\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\t// standard Material serialization\n\t\t\t\tdata.uuid = this.uuid;\n\t\t\t\tdata.type = this.type;\n\t\n\t\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\t\tif ( (this.color && this.color.isColor) ) data.color = this.color.getHex();\n\t\n\t\t\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\t\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\t\n\t\t\t\tif ( (this.emissive && this.emissive.isColor) ) data.emissive = this.emissive.getHex();\n\t\t\t\tif ( (this.specular && this.specular.isColor) ) data.specular = this.specular.getHex();\n\t\t\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\n\t\t\t\tif ( (this.map && this.map.isTexture) ) data.map = this.map.toJSON( meta ).uuid;\n\t\t\t\tif ( (this.alphaMap && this.alphaMap.isTexture) ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\t\t\tif ( (this.lightMap && this.lightMap.isTexture) ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\t\tif ( (this.bumpMap && this.bumpMap.isTexture) ) {\n\t\n\t\t\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\t\t\tdata.bumpScale = this.bumpScale;\n\t\n\t\t\t\t}\n\t\t\t\tif ( (this.normalMap && this.normalMap.isTexture) ) {\n\t\n\t\t\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\t\t\tdata.normalScale = this.normalScale.toArray();\n\t\n\t\t\t\t}\n\t\t\t\tif ( (this.displacementMap && this.displacementMap.isTexture) ) {\n\t\n\t\t\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\t\t\tdata.displacementBias = this.displacementBias;\n\t\n\t\t\t\t}\n\t\t\t\tif ( (this.roughnessMap && this.roughnessMap.isTexture) ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\t\t\tif ( (this.metalnessMap && this.metalnessMap.isTexture) ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\t\n\t\t\t\tif ( (this.emissiveMap && this.emissiveMap.isTexture) ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\t\t\tif ( (this.specularMap && this.specularMap.isTexture) ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\t\n\t\t\t\tif ( (this.envMap && this.envMap.isTexture) ) {\n\t\n\t\t\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\t\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\t\n\t\t\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\t\t\tif ( this.shading !== SmoothShading ) data.shading = this.shading;\n\t\t\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\t\t\tif ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\n\t\n\t\t\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\t\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\t\n\t\t\t\tdata.depthFunc = this.depthFunc;\n\t\t\t\tdata.depthTest = this.depthTest;\n\t\t\t\tdata.depthWrite = this.depthWrite;\n\t\n\t\t\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\t\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\t\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\t\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\t\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\t\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\t\n\t\t\t\tdata.skinning = this.skinning;\n\t\t\t\tdata.morphTargets = this.morphTargets;\n\t\n\t\t\t\t// TODO: Copied from Object3D.toJSON\n\t\n\t\t\t\tfunction extractFromCache( cache ) {\n\t\n\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\tfor ( var key in cache ) {\n\t\n\t\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\t\tvalues.push( data );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn values;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( isRoot ) {\n\t\n\t\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\t\tvar images = extractFromCache( meta.images );\n\t\n\t\t\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\t\t\tif ( images.length > 0 ) data.images = images;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.name = source.name;\n\t\n\t\t\t\tthis.fog = source.fog;\n\t\t\t\tthis.lights = source.lights;\n\t\n\t\t\t\tthis.blending = source.blending;\n\t\t\t\tthis.side = source.side;\n\t\t\t\tthis.shading = source.shading;\n\t\t\t\tthis.vertexColors = source.vertexColors;\n\t\n\t\t\t\tthis.opacity = source.opacity;\n\t\t\t\tthis.transparent = source.transparent;\n\t\n\t\t\t\tthis.blendSrc = source.blendSrc;\n\t\t\t\tthis.blendDst = source.blendDst;\n\t\t\t\tthis.blendEquation = source.blendEquation;\n\t\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\t\n\t\t\t\tthis.depthFunc = source.depthFunc;\n\t\t\t\tthis.depthTest = source.depthTest;\n\t\t\t\tthis.depthWrite = source.depthWrite;\n\t\n\t\t\t\tthis.colorWrite = source.colorWrite;\n\t\n\t\t\t\tthis.precision = source.precision;\n\t\n\t\t\t\tthis.polygonOffset = source.polygonOffset;\n\t\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\t\n\t\t\t\tthis.alphaTest = source.alphaTest;\n\t\n\t\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\t\n\t\t\t\tthis.overdraw = source.overdraw;\n\t\n\t\t\t\tthis.visible = source.visible;\n\t\t\t\tthis.clipShadows = source.clipShadows;\n\t\t\t\tthis.clipIntersection = source.clipIntersection;\n\t\n\t\t\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\t\t\tdstPlanes = null;\n\t\n\t\t\t\tif ( srcPlanes !== null ) {\n\t\n\t\t\t\t\tvar n = srcPlanes.length;\n\t\t\t\t\tdstPlanes = new Array( n );\n\t\n\t\t\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.clippingPlanes = dstPlanes;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tupdate: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'update' } );\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tObject.assign( Material.prototype, EventDispatcher.prototype );\n\t\n\t\tvar count$1 = 0;\n\t\tfunction MaterialIdCount() { return count$1++; }\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  defines: { \"label\" : \"value\" },\n\t\t *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n\t\t *\n\t\t *  fragmentShader: <string>,\n\t\t *  vertexShader: <string>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  lights: <bool>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction ShaderMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'ShaderMaterial';\n\t\n\t\t\tthis.defines = {};\n\t\t\tthis.uniforms = {};\n\t\n\t\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\t\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\t\n\t\t\tthis.linewidth = 1;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\n\t\t\tthis.fog = false; // set to use scene fog\n\t\t\tthis.lights = false; // set to use scene lights\n\t\t\tthis.clipping = false; // set to use user-defined clipping planes\n\t\n\t\t\tthis.skinning = false; // set to use skinning attribute streams\n\t\t\tthis.morphTargets = false; // set to use morph targets\n\t\t\tthis.morphNormals = false; // set to use morph normals\n\t\n\t\t\tthis.extensions = {\n\t\t\t\tderivatives: false, // set to use derivatives\n\t\t\t\tfragDepth: false, // set to use fragment depth values\n\t\t\t\tdrawBuffers: false, // set to use draw buffers\n\t\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t\t\t};\n\t\n\t\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\t\tthis.defaultAttributeValues = {\n\t\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t\t'uv': [ 0, 0 ],\n\t\t\t\t'uv2': [ 0, 0 ]\n\t\t\t};\n\t\n\t\t\tthis.index0AttributeName = undefined;\n\t\n\t\t\tif ( parameters !== undefined ) {\n\t\n\t\t\t\tif ( parameters.attributes !== undefined ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.setValues( parameters );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tShaderMaterial.prototype = Object.create( Material.prototype );\n\t\tShaderMaterial.prototype.constructor = ShaderMaterial;\n\t\n\t\tShaderMaterial.prototype.isShaderMaterial = true;\n\t\n\t\tShaderMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.fragmentShader = source.fragmentShader;\n\t\t\tthis.vertexShader = source.vertexShader;\n\t\n\t\t\tthis.uniforms = UniformsUtils.clone( source.uniforms );\n\t\n\t\t\tthis.defines = source.defines;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\t\tthis.lights = source.lights;\n\t\t\tthis.clipping = source.clipping;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\tthis.extensions = source.extensions;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tShaderMaterial.prototype.toJSON = function ( meta ) {\n\t\n\t\t\tvar data = Material.prototype.toJSON.call( this, meta );\n\t\n\t\t\tdata.uniforms = this.uniforms;\n\t\t\tdata.vertexShader = this.vertexShader;\n\t\t\tdata.fragmentShader = this.fragmentShader;\n\t\n\t\t\treturn data;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author bhouston / https://clara.io\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * parameters = {\n\t\t *\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  displacementMap: new THREE.Texture( <Image> ),\n\t\t *  displacementScale: <float>,\n\t\t *  displacementBias: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshDepthMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshDepthMaterial';\n\t\n\t\t\tthis.depthPacking = BasicDepthPacking;\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\n\t\t\tthis.fog = false;\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshDepthMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\n\t\n\t\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\t\n\t\tMeshDepthMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.depthPacking = source.depthPacking;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Box3( min, max ) {\n\t\n\t\t\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\n\t\t\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\n\t\n\t\t}\n\t\n\t\tBox3.prototype = {\n\t\n\t\t\tconstructor: Box3,\n\t\n\t\t\tisBox3: true,\n\t\n\t\t\tset: function ( min, max ) {\n\t\n\t\t\t\tthis.min.copy( min );\n\t\t\t\tthis.max.copy( max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromArray: function ( array ) {\n\t\n\t\t\t\tvar minX = + Infinity;\n\t\t\t\tvar minY = + Infinity;\n\t\t\t\tvar minZ = + Infinity;\n\t\n\t\t\t\tvar maxX = - Infinity;\n\t\t\t\tvar maxY = - Infinity;\n\t\t\t\tvar maxZ = - Infinity;\n\t\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\tvar x = array[ i ];\n\t\t\t\t\tvar y = array[ i + 1 ];\n\t\t\t\t\tvar z = array[ i + 2 ];\n\t\n\t\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\t\tif ( z < minZ ) minZ = z;\n\t\n\t\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\t\tif ( y > maxY ) maxY = y;\n\t\t\t\t\tif ( z > maxZ ) maxZ = z;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.min.set( minX, minY, minZ );\n\t\t\t\tthis.max.set( maxX, maxY, maxZ );\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPoints: function ( points ) {\n\t\n\t\t\t\tthis.makeEmpty();\n\t\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.expandByPoint( points[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCenterAndSize: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function setFromCenterAndSize( center, size ) {\n\t\n\t\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\n\t\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\t\tthis.max.copy( center ).add( halfSize );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tsetFromObject: function () {\n\t\n\t\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t\t\t// accounting for both the object's, and children's, world transforms\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function setFromObject( object ) {\n\t\n\t\t\t\t\tvar scope = this;\n\t\n\t\t\t\t\tobject.updateMatrixWorld( true );\n\t\n\t\t\t\t\tthis.makeEmpty();\n\t\n\t\t\t\t\tobject.traverse( function ( node ) {\n\t\n\t\t\t\t\t\tvar geometry = node.geometry;\n\t\n\t\t\t\t\t\tif ( geometry !== undefined ) {\n\t\n\t\t\t\t\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\t\n\t\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else if ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\t\t\t\tvar attribute = geometry.attributes.position;\n\t\n\t\t\t\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\t\t\t\tvar array, offset, stride;\n\t\n\t\t\t\t\t\t\t\t\tif ( (attribute && attribute.isInterleavedBufferAttribute) ) {\n\t\n\t\t\t\t\t\t\t\t\t\tarray = attribute.data.array;\n\t\t\t\t\t\t\t\t\t\toffset = attribute.offset;\n\t\t\t\t\t\t\t\t\t\tstride = attribute.data.stride;\n\t\n\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\tarray = attribute.array;\n\t\t\t\t\t\t\t\t\t\toffset = 0;\n\t\t\t\t\t\t\t\t\t\tstride = 3;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tfor ( var i = offset, il = array.length; i < il; i += stride ) {\n\t\n\t\t\t\t\t\t\t\t\t\tv1.fromArray( array, i );\n\t\t\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\t\n\t\t\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( box ) {\n\t\n\t\t\t\tthis.min.copy( box.min );\n\t\t\t\tthis.max.copy( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeEmpty: function () {\n\t\n\t\t\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tisEmpty: function () {\n\t\n\t\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\n\t\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\t\n\t\t\t},\n\t\n\t\t\tgetCenter: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\t\n\t\t\t},\n\t\n\t\t\tgetSize: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );\n\t\n\t\t\t},\n\t\n\t\t\texpandByPoint: function ( point ) {\n\t\n\t\t\t\tthis.min.min( point );\n\t\t\t\tthis.max.max( point );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByVector: function ( vector ) {\n\t\n\t\t\t\tthis.min.sub( vector );\n\t\t\t\tthis.max.add( vector );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.min.addScalar( - scalar );\n\t\t\t\tthis.max.addScalar( scalar );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tcontainsBox: function ( box ) {\n\t\n\t\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t},\n\t\n\t\t\tgetParameter: function ( point, optionalTarget ) {\n\t\n\t\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t\t// has a size dimension of 0.\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn result.set(\n\t\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t\t\t);\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\t// using 6 splitting planes to rule out intersections.\n\t\n\t\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tintersectsSphere: ( function () {\n\t\n\t\t\t\tvar closestPoint;\n\t\n\t\t\t\treturn function intersectsSphere( sphere ) {\n\t\n\t\t\t\t\tif ( closestPoint === undefined ) closestPoint = new Vector3();\n\t\n\t\t\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\t\n\t\t\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\t\n\t\t\t\tvar min, max;\n\t\n\t\t\t\tif ( plane.normal.x > 0 ) {\n\t\n\t\t\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\t\t\tmax = plane.normal.x * this.max.x;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\t\t\tmax = plane.normal.x * this.min.x;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( plane.normal.y > 0 ) {\n\t\n\t\t\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\t\t\tmax += plane.normal.y * this.max.y;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\t\t\tmax += plane.normal.y * this.min.y;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( plane.normal.z > 0 ) {\n\t\n\t\t\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\t\t\tmax += plane.normal.z * this.max.z;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\t\t\tmax += plane.normal.z * this.min.z;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn ( min <= plane.constant && max >= plane.constant );\n\t\n\t\t\t},\n\t\n\t\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function distanceToPoint( point ) {\n\t\n\t\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\t\treturn clampedPoint.sub( point ).length();\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tgetBoundingSphere: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function getBoundingSphere( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Sphere();\n\t\n\t\t\t\t\tthis.getCenter( result.center );\n\t\n\t\t\t\t\tresult.radius = this.getSize( v1 ).length() * 0.5;\n\t\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersect: function ( box ) {\n\t\n\t\t\t\tthis.min.max( box.min );\n\t\t\t\tthis.max.min( box.max );\n\t\n\t\t\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\t\t\tif( this.isEmpty() ) this.makeEmpty();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tunion: function ( box ) {\n\t\n\t\t\t\tthis.min.min( box.min );\n\t\t\t\tthis.max.max( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function () {\n\t\n\t\t\t\tvar points = [\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3()\n\t\t\t\t];\n\t\n\t\t\t\treturn function applyMatrix4( matrix ) {\n\t\n\t\t\t\t\t// transform of empty box is an empty box.\n\t\t\t\t\tif( this.isEmpty() ) return this;\n\t\n\t\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\t\n\t\t\t\t\tthis.setFromPoints( points );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslate: function ( offset ) {\n\t\n\t\t\t\tthis.min.add( offset );\n\t\t\t\tthis.max.add( offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( box ) {\n\t\n\t\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Sphere( center, radius ) {\n\t\n\t\t\tthis.center = ( center !== undefined ) ? center : new Vector3();\n\t\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\t\n\t\t}\n\t\n\t\tSphere.prototype = {\n\t\n\t\t\tconstructor: Sphere,\n\t\n\t\t\tset: function ( center, radius ) {\n\t\n\t\t\t\tthis.center.copy( center );\n\t\t\t\tthis.radius = radius;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPoints: function () {\n\t\n\t\t\t\tvar box = new Box3();\n\t\n\t\t\t\treturn function setFromPoints( points, optionalCenter ) {\n\t\n\t\t\t\t\tvar center = this.center;\n\t\n\t\t\t\t\tif ( optionalCenter !== undefined ) {\n\t\n\t\t\t\t\t\tcenter.copy( optionalCenter );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tbox.setFromPoints( points ).getCenter( center );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar maxRadiusSq = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( sphere ) {\n\t\n\t\t\t\tthis.center.copy( sphere.center );\n\t\t\t\tthis.radius = sphere.radius;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tempty: function () {\n\t\n\t\t\t\treturn ( this.radius <= 0 );\n\t\n\t\t\t},\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\t\tvar radiusSum = this.radius + sphere.radius;\n\t\n\t\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\treturn box.intersectsSphere( this );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t\t// We use the following equation to compute the signed distance from\n\t\t\t\t// the center of the sphere to the plane.\n\t\t\t\t//\n\t\t\t\t// distance = q * n - d\n\t\t\t\t//\n\t\t\t\t// If this distance is greater than the radius of the sphere,\n\t\t\t\t// then there is no intersection.\n\t\n\t\t\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\t\n\t\t\t},\n\t\n\t\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\tresult.copy( point );\n\t\n\t\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\t\n\t\t\t\t\tresult.sub( this.center ).normalize();\n\t\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t},\n\t\n\t\t\tgetBoundingBox: function ( optionalTarget ) {\n\t\n\t\t\t\tvar box = optionalTarget || new Box3();\n\t\n\t\t\t\tbox.set( this.center, this.center );\n\t\t\t\tbox.expandByScalar( this.radius );\n\t\n\t\t\t\treturn box;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function ( matrix ) {\n\t\n\t\t\t\tthis.center.applyMatrix4( matrix );\n\t\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttranslate: function ( offset ) {\n\t\n\t\t\t\tthis.center.add( offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( sphere ) {\n\t\n\t\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author bhouston / http://clara.io\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction Matrix3() {\n\t\n\t\t\tthis.elements = new Float32Array( [\n\t\n\t\t\t\t1, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 1\n\t\n\t\t\t] );\n\t\n\t\t\tif ( arguments.length > 0 ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tMatrix3.prototype = {\n\t\n\t\t\tconstructor: Matrix3,\n\t\n\t\t\tisMatrix3: true,\n\t\n\t\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tidentity: function () {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().fromArray( this.elements );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( m ) {\n\t\n\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\n\t\t\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\n\t\t\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrix4: function( m ) {\n\t\n\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\n\t\t\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\n\t\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyToVector3Array: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\t\tif ( length === undefined ) length = array.length;\n\t\n\t\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\t\n\t\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\t\tv1.applyMatrix3( this );\n\t\t\t\t\t\tv1.toArray( array, j );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn array;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyToBuffer: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\t\n\t\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\t\n\t\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\t\tv1.z = buffer.getZ( j );\n\t\n\t\t\t\t\t\tv1.applyMatrix3( this );\n\t\n\t\t\t\t\t\tbuffer.setXYZ( j, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn buffer;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdeterminant: function () {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\t\n\t\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\t\n\t\t\t},\n\t\n\t\t\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\t\n\t\t\t\tif ( (matrix && matrix.isMatrix4) ) {\n\t\n\t\t\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar me = matrix.elements,\n\t\t\t\t\tte = this.elements,\n\t\n\t\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\t\n\t\t\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\t\t\tt13 = n23 * n12 - n22 * n13,\n\t\n\t\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\t\n\t\t\t\tif ( det === 0 ) {\n\t\n\t\t\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\t\n\t\t\t\t\tif ( throwOnDegenerate === true ) {\n\t\n\t\t\t\t\t\tthrow new Error( msg );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tconsole.warn( msg );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this.identity();\n\t\t\t\t}\n\t\n\t\t\t\tvar detInv = 1 / det;\n\t\n\t\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\t\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\t\n\t\t\t\tte[ 3 ] = t12 * detInv;\n\t\t\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\t\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\t\n\t\t\t\tte[ 6 ] = t13 * detInv;\n\t\t\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\t\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttranspose: function () {\n\t\n\t\t\t\tvar tmp, m = this.elements;\n\t\n\t\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tflattenToArrayOffset: function ( array, offset ) {\n\t\n\t\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\t\"- just use .toArray instead.\" );\n\t\n\t\t\t\treturn this.toArray( array, offset );\n\t\n\t\t\t},\n\t\n\t\t\tgetNormalMatrix: function ( matrix4 ) {\n\t\n\t\t\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\t\n\t\t\t},\n\t\n\t\t\ttransposeIntoArray: function ( r ) {\n\t\n\t\t\t\tvar m = this.elements;\n\t\n\t\t\t\tr[ 0 ] = m[ 0 ];\n\t\t\t\tr[ 1 ] = m[ 3 ];\n\t\t\t\tr[ 2 ] = m[ 6 ];\n\t\t\t\tr[ 3 ] = m[ 1 ];\n\t\t\t\tr[ 4 ] = m[ 4 ];\n\t\t\t\tr[ 5 ] = m[ 7 ];\n\t\t\t\tr[ 6 ] = m[ 2 ];\n\t\t\t\tr[ 7 ] = m[ 5 ];\n\t\t\t\tr[ 8 ] = m[ 8 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tfor( var i = 0; i < 9; i ++ ) {\n\t\n\t\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\n\t\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\n\t\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Plane( normal, constant ) {\n\t\n\t\t\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\t\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\t\n\t\t}\n\t\n\t\tPlane.prototype = {\n\t\n\t\t\tconstructor: Plane,\n\t\n\t\t\tset: function ( normal, constant ) {\n\t\n\t\t\t\tthis.normal.copy( normal );\n\t\t\t\tthis.constant = constant;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetComponents: function ( x, y, z, w ) {\n\t\n\t\t\t\tthis.normal.set( x, y, z );\n\t\t\t\tthis.constant = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\t\n\t\t\t\tthis.normal.copy( normal );\n\t\t\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCoplanarPoints: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\t\t\tvar v2 = new Vector3();\n\t\n\t\t\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\t\n\t\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\t\n\t\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\t\n\t\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( plane ) {\n\t\n\t\t\t\tthis.normal.copy( plane.normal );\n\t\t\t\tthis.constant = plane.constant;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\t\n\t\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\t\t\tthis.constant *= inverseNormalLength;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnegate: function () {\n\t\n\t\t\t\tthis.constant *= - 1;\n\t\t\t\tthis.normal.negate();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\t\treturn this.normal.dot( point ) + this.constant;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToSphere: function ( sphere ) {\n\t\n\t\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\t\n\t\t\t},\n\t\n\t\t\tprojectPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\t\n\t\t\t},\n\t\n\t\t\torthoPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\t\n\t\t\t},\n\t\n\t\t\tintersectLine: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function intersectLine( line, optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t\tvar direction = line.delta( v1 );\n\t\n\t\t\t\t\tvar denominator = this.normal.dot( direction );\n\t\n\t\t\t\t\tif ( denominator === 0 ) {\n\t\n\t\t\t\t\t\t// line is coplanar, return origin\n\t\t\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\t\n\t\t\t\t\t\t\treturn result.copy( line.start );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\t\t\treturn undefined;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\t\n\t\t\t\t\tif ( t < 0 || t > 1 ) {\n\t\n\t\t\t\t\t\treturn undefined;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectsLine: function ( line ) {\n\t\n\t\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\t\n\t\t\t\tvar startSign = this.distanceToPoint( line.start );\n\t\t\t\tvar endSign = this.distanceToPoint( line.end );\n\t\n\t\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\treturn box.intersectsPlane( this );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\t\treturn sphere.intersectsPlane( this );\n\t\n\t\t\t},\n\t\n\t\t\tcoplanarPoint: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\t\t\tvar m1 = new Matrix3();\n\t\n\t\t\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\t\n\t\t\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\t\n\t\t\t\t\t// transform normal based on theory here:\n\t\t\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\t\t\tthis.constant = - referencePoint.dot( normal );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslate: function ( offset ) {\n\t\n\t\t\t\tthis.constant = this.constant - offset.dot( this.normal );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( plane ) {\n\t\n\t\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\n\t\n\t\t\tthis.planes = [\n\t\n\t\t\t\t( p0 !== undefined ) ? p0 : new Plane(),\n\t\t\t\t( p1 !== undefined ) ? p1 : new Plane(),\n\t\t\t\t( p2 !== undefined ) ? p2 : new Plane(),\n\t\t\t\t( p3 !== undefined ) ? p3 : new Plane(),\n\t\t\t\t( p4 !== undefined ) ? p4 : new Plane(),\n\t\t\t\t( p5 !== undefined ) ? p5 : new Plane()\n\t\n\t\t\t];\n\t\n\t\t}\n\t\n\t\tFrustum.prototype = {\n\t\n\t\t\tconstructor: Frustum,\n\t\n\t\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\tplanes[ 0 ].copy( p0 );\n\t\t\t\tplanes[ 1 ].copy( p1 );\n\t\t\t\tplanes[ 2 ].copy( p2 );\n\t\t\t\tplanes[ 3 ].copy( p3 );\n\t\t\t\tplanes[ 4 ].copy( p4 );\n\t\t\t\tplanes[ 5 ].copy( p5 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( frustum ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrix: function ( m ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\t\t\tvar me = m.elements;\n\t\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\t\n\t\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tintersectsObject: function () {\n\t\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\treturn function intersectsObject( object ) {\n\t\n\t\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t\t\t.applyMatrix4( object.matrixWorld );\n\t\n\t\t\t\t\treturn this.intersectsSphere( sphere );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectsSprite: function () {\n\t\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\treturn function intersectsSprite( sprite ) {\n\t\n\t\t\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\t\n\t\t\t\t\treturn this.intersectsSphere( sphere );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\t\t\tvar center = sphere.center;\n\t\t\t\tvar negRadius = - sphere.radius;\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\t\n\t\t\t\t\tif ( distance < negRadius ) {\n\t\n\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function () {\n\t\n\t\t\t\tvar p1 = new Vector3(),\n\t\t\t\t\tp2 = new Vector3();\n\t\n\t\t\t\treturn function intersectsBox( box ) {\n\t\n\t\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\t\n\t\t\t\t\t\tvar plane = planes[ i ];\n\t\n\t\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\t\n\t\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\t\n\t\t\t\t\t\t// if both outside plane, no intersection\n\t\n\t\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\t\n\t\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\t\n\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {\n\t\n\t\t\tvar _gl = _renderer.context,\n\t\t\t_state = _renderer.state,\n\t\t\t_frustum = new Frustum(),\n\t\t\t_projScreenMatrix = new Matrix4(),\n\t\n\t\t\t_lightShadows = _lights.shadows,\n\t\n\t\t\t_shadowMapSize = new Vector2(),\n\t\t\t_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),\n\t\n\t\t\t_lookTarget = new Vector3(),\n\t\t\t_lightPositionWorld = new Vector3(),\n\t\n\t\t\t_renderList = [],\n\t\n\t\t\t_MorphingFlag = 1,\n\t\t\t_SkinningFlag = 2,\n\t\n\t\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\t\n\t\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\t\n\t\t\t_materialCache = {};\n\t\n\t\t\tvar cubeDirections = [\n\t\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t\t];\n\t\n\t\t\tvar cubeUps = [\n\t\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t\t];\n\t\n\t\t\tvar cube2DViewPorts = [\n\t\t\t\tnew Vector4(), new Vector4(), new Vector4(),\n\t\t\t\tnew Vector4(), new Vector4(), new Vector4()\n\t\t\t];\n\t\n\t\t\t// init\n\t\n\t\t\tvar depthMaterialTemplate = new MeshDepthMaterial();\n\t\t\tdepthMaterialTemplate.depthPacking = RGBADepthPacking;\n\t\t\tdepthMaterialTemplate.clipping = true;\n\t\n\t\t\tvar distanceShader = ShaderLib[ \"distanceRGBA\" ];\n\t\t\tvar distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );\n\t\n\t\t\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\t\n\t\t\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\t\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\t\n\t\t\t\tvar depthMaterial = depthMaterialTemplate.clone();\n\t\t\t\tdepthMaterial.morphTargets = useMorphing;\n\t\t\t\tdepthMaterial.skinning = useSkinning;\n\t\n\t\t\t\t_depthMaterials[ i ] = depthMaterial;\n\t\n\t\t\t\tvar distanceMaterial = new ShaderMaterial( {\n\t\t\t\t\tdefines: {\n\t\t\t\t\t\t'USE_SHADOWMAP': ''\n\t\t\t\t\t},\n\t\t\t\t\tuniforms: distanceUniforms,\n\t\t\t\t\tvertexShader: distanceShader.vertexShader,\n\t\t\t\t\tfragmentShader: distanceShader.fragmentShader,\n\t\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\t\tskinning: useSkinning,\n\t\t\t\t\tclipping: true\n\t\t\t\t} );\n\t\n\t\t\t\t_distanceMaterials[ i ] = distanceMaterial;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tthis.enabled = false;\n\t\n\t\t\tthis.autoUpdate = true;\n\t\t\tthis.needsUpdate = false;\n\t\n\t\t\tthis.type = PCFShadowMap;\n\t\n\t\t\tthis.renderReverseSided = true;\n\t\t\tthis.renderSingleSided = true;\n\t\n\t\t\tthis.render = function ( scene, camera ) {\n\t\n\t\t\t\tif ( scope.enabled === false ) return;\n\t\t\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\t\n\t\t\t\tif ( _lightShadows.length === 0 ) return;\n\t\n\t\t\t\t// Set GL state for depth map.\n\t\t\t\t_state.clearColor( 1, 1, 1, 1 );\n\t\t\t\t_state.disable( _gl.BLEND );\n\t\t\t\t_state.setDepthTest( true );\n\t\t\t\t_state.setScissorTest( false );\n\t\n\t\t\t\t// render depth map\n\t\n\t\t\t\tvar faceCount, isPointLight;\n\t\n\t\t\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar light = _lightShadows[ i ];\n\t\t\t\t\tvar shadow = light.shadow;\n\t\n\t\t\t\t\tif ( shadow === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar shadowCamera = shadow.camera;\n\t\n\t\t\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t\t\t\t_shadowMapSize.min( _maxShadowMapSize );\n\t\n\t\t\t\t\tif ( (light && light.isPointLight) ) {\n\t\n\t\t\t\t\t\tfaceCount = 6;\n\t\t\t\t\t\tisPointLight = true;\n\t\n\t\t\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\t\n\t\t\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t\t\t// following orientation:\n\t\t\t\t\t\t//\n\t\t\t\t\t\t//  xzXZ\n\t\t\t\t\t\t//   y Y\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// X - Positive x direction\n\t\t\t\t\t\t// x - Negative x direction\n\t\t\t\t\t\t// Y - Positive y direction\n\t\t\t\t\t\t// y - Negative y direction\n\t\t\t\t\t\t// Z - Positive z direction\n\t\t\t\t\t\t// z - Negative z direction\n\t\n\t\t\t\t\t\t// positive X\n\t\t\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t\t// negative X\n\t\t\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t\t// positive Z\n\t\t\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t\t// negative Z\n\t\t\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t\t// positive Y\n\t\t\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t\t\t// negative Y\n\t\t\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\t\n\t\t\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t\t\t_shadowMapSize.y *= 2.0;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tfaceCount = 1;\n\t\t\t\t\t\tisPointLight = false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( shadow.map === null ) {\n\t\n\t\t\t\t\t\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\n\t\n\t\t\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\n\t\t\t\t\t\tshadowCamera.updateProjectionMatrix();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( (shadow && shadow.isSpotLightShadow) ) {\n\t\n\t\t\t\t\t\tshadow.update( light );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar shadowMap = shadow.map;\n\t\t\t\t\tvar shadowMatrix = shadow.matrix;\n\t\n\t\t\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\t\n\t\t\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t\t\t_renderer.clear();\n\t\n\t\t\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t\t\t// run a single pass if not\n\t\n\t\t\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\t\n\t\t\t\t\t\tif ( isPointLight ) {\n\t\n\t\t\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\n\t\t\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t\t\t_state.viewport( vpDimensions );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\t\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\t\n\t\t\t\t\t\t// compute shadow matrix\n\t\n\t\t\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\t\n\t\t\t\t\t\t// update camera matrices and frustum\n\t\n\t\t\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\t\n\t\t\t\t\t\t// set object matrices & frustum culling\n\t\n\t\t\t\t\t\t_renderList.length = 0;\n\t\n\t\t\t\t\t\tprojectObject( scene, camera, shadowCamera );\n\t\n\t\t\t\t\t\t// render shadow map\n\t\t\t\t\t\t// render regular objects\n\t\n\t\t\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar object = _renderList[ j ];\n\t\t\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\t\tif ( (material && material.isMultiMaterial) ) {\n\t\n\t\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\t\tvar materials = material.materials;\n\t\n\t\t\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\t\n\t\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\t\n\t\t\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Restore GL state.\n\t\t\t\tvar clearColor = _renderer.getClearColor(),\n\t\t\t\tclearAlpha = _renderer.getClearAlpha();\n\t\t\t\t_renderer.setClearColor( clearColor, clearAlpha );\n\t\n\t\t\t\tscope.needsUpdate = false;\n\t\n\t\t\t};\n\t\n\t\t\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tvar result = null;\n\t\n\t\t\t\tvar materialVariants = _depthMaterials;\n\t\t\t\tvar customMaterial = object.customDepthMaterial;\n\t\n\t\t\t\tif ( isPointLight ) {\n\t\n\t\t\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\t\t\tcustomMaterial = object.customDistanceMaterial;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ! customMaterial ) {\n\t\n\t\t\t\t\tvar useMorphing = false;\n\t\n\t\t\t\t\tif ( material.morphTargets ) {\n\t\n\t\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\t\n\t\t\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\t\t\t\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar useSkinning = object.isSkinnedMesh && material.skinning;\n\t\n\t\t\t\t\tvar variantIndex = 0;\n\t\n\t\t\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\t\n\t\t\t\t\tresult = materialVariants[ variantIndex ];\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tresult = customMaterial;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\t\t material.clipShadows === true &&\n\t\t\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\t\n\t\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t\t// appropriate state\n\t\n\t\t\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\t\n\t\t\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\t\n\t\t\t\t\tif ( materialsForVariant === undefined ) {\n\t\n\t\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\t\n\t\t\t\t\tif ( cachedMaterial === undefined ) {\n\t\n\t\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tresult = cachedMaterial;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tresult.visible = material.visible;\n\t\t\t\tresult.wireframe = material.wireframe;\n\t\n\t\t\t\tvar side = material.side;\n\t\n\t\t\t\tif ( scope.renderSingleSided && side == DoubleSide ) {\n\t\n\t\t\t\t\tside = FrontSide;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( scope.renderReverseSided ) {\n\t\n\t\t\t\t\tif ( side === FrontSide ) side = BackSide;\n\t\t\t\t\telse if ( side === BackSide ) side = FrontSide;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tresult.side = side;\n\t\n\t\t\t\tresult.clipShadows = material.clipShadows;\n\t\t\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\n\t\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\t\t\tresult.linewidth = material.linewidth;\n\t\n\t\t\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\t\n\t\t\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t\tfunction projectObject( object, camera, shadowCamera ) {\n\t\n\t\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\t\tvar visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\t\n\t\t\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\t\n\t\t\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\t\n\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\tif ( material.visible === true ) {\n\t\n\t\t\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\t\t\t_renderList.push( object );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar children = object.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tprojectObject( children[ i ], camera, shadowCamera );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Ray( origin, direction ) {\n\t\n\t\t\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\n\t\t\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\n\t\n\t\t}\n\t\n\t\tRay.prototype = {\n\t\n\t\t\tconstructor: Ray,\n\t\n\t\t\tset: function ( origin, direction ) {\n\t\n\t\t\t\tthis.origin.copy( origin );\n\t\t\t\tthis.direction.copy( direction );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( ray ) {\n\t\n\t\t\t\tthis.origin.copy( ray.origin );\n\t\t\t\tthis.direction.copy( ray.direction );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tat: function ( t, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\t\n\t\t\t},\n\t\n\t\t\tlookAt: function ( v ) {\n\t\n\t\t\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trecast: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function recast( t ) {\n\t\n\t\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclosestPointToPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\tresult.subVectors( point, this.origin );\n\t\t\t\tvar directionDistance = result.dot( this.direction );\n\t\n\t\t\t\tif ( directionDistance < 0 ) {\n\t\n\t\t\t\t\treturn result.copy( this.origin );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceSqToPoint: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function distanceSqToPoint( point ) {\n\t\n\t\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\t\n\t\t\t\t\t// point behind the ray\n\t\n\t\t\t\t\tif ( directionDistance < 0 ) {\n\t\n\t\t\t\t\t\treturn this.origin.distanceToSquared( point );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\t\n\t\t\t\t\treturn v1.distanceToSquared( point );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tdistanceSqToSegment: function () {\n\t\n\t\t\t\tvar segCenter = new Vector3();\n\t\t\t\tvar segDir = new Vector3();\n\t\t\t\tvar diff = new Vector3();\n\t\n\t\t\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\t\n\t\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t\t\t// defined by v0 and v1\n\t\t\t\t\t// It can also set two optional targets :\n\t\t\t\t\t// - The closest point on the ray\n\t\t\t\t\t// - The closest point on the segment\n\t\n\t\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\t\n\t\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\t\t\tvar c = diff.lengthSq();\n\t\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\t\t\tvar s0, s1, sqrDist, extDet;\n\t\n\t\t\t\t\tif ( det > 0 ) {\n\t\n\t\t\t\t\t\t// The ray and segment are not parallel.\n\t\n\t\t\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\t\t\textDet = segExtent * det;\n\t\n\t\t\t\t\t\tif ( s0 >= 0 ) {\n\t\n\t\t\t\t\t\t\tif ( s1 >= - extDet ) {\n\t\n\t\t\t\t\t\t\t\tif ( s1 <= extDet ) {\n\t\n\t\t\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\t\n\t\t\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t// region 1\n\t\n\t\t\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// region 5\n\t\n\t\t\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( s1 <= - extDet ) {\n\t\n\t\t\t\t\t\t\t\t// region 4\n\t\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t} else if ( s1 <= extDet ) {\n\t\n\t\t\t\t\t\t\t\t// region 3\n\t\n\t\t\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// region 2\n\t\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// Ray and segment are parallel.\n\t\n\t\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( optionalPointOnRay ) {\n\t\n\t\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( optionalPointOnSegment ) {\n\t\n\t\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn sqrDist;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectSphere: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\t\n\t\t\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\t\t\tvar tca = v1.dot( this.direction );\n\t\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\t\n\t\t\t\t\tif ( d2 > radius2 ) return null;\n\t\n\t\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\t\n\t\t\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\t\t\tvar t0 = tca - thc;\n\t\n\t\t\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\t\t\tvar t1 = tca + thc;\n\t\n\t\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\t\n\t\t\t\t\t// test to see if t0 is behind the ray:\n\t\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\t\n\t\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\t\t\treturn this.at( t0, optionalTarget );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPlane: function ( plane ) {\n\t\n\t\t\t\tvar denominator = plane.normal.dot( this.direction );\n\t\n\t\t\t\tif ( denominator === 0 ) {\n\t\n\t\t\t\t\t// line is coplanar, return origin\n\t\t\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\t\n\t\t\t\t\t\treturn 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\t\n\t\t\t\t// Return if the ray never intersects the plane\n\t\n\t\t\t\treturn t >= 0 ? t :  null;\n\t\n\t\t\t},\n\t\n\t\t\tintersectPlane: function ( plane, optionalTarget ) {\n\t\n\t\t\t\tvar t = this.distanceToPlane( plane );\n\t\n\t\t\t\tif ( t === null ) {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.at( t, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\n\t\n\t\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t\t// check if the ray lies on the plane first\n\t\n\t\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\t\n\t\t\t\tif ( distToPoint === 0 ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar denominator = plane.normal.dot( this.direction );\n\t\n\t\t\t\tif ( denominator * distToPoint < 0 ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// ray origin is behind the plane (and is pointing behind it)\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t},\n\t\n\t\t\tintersectBox: function ( box, optionalTarget ) {\n\t\n\t\t\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\t\n\t\t\t\tvar invdirx = 1 / this.direction.x,\n\t\t\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\t\t\tinvdirz = 1 / this.direction.z;\n\t\n\t\t\t\tvar origin = this.origin;\n\t\n\t\t\t\tif ( invdirx >= 0 ) {\n\t\n\t\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( invdiry >= 0 ) {\n\t\n\t\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\t\n\t\t\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\t\n\t\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\t\n\t\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\t\n\t\t\t\tif ( invdirz >= 0 ) {\n\t\n\t\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\t\n\t\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\t\n\t\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\t\n\t\t\t\t//return point closest to the ray (positive side)\n\t\n\t\t\t\tif ( tmax < 0 ) return null;\n\t\n\t\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: ( function () {\n\t\n\t\t\t\tvar v = new Vector3();\n\t\n\t\t\t\treturn function intersectsBox( box ) {\n\t\n\t\t\t\t\treturn this.intersectBox( box, v ) !== null;\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\tintersectTriangle: function () {\n\t\n\t\t\t\t// Compute the offset origin, edges, and normal.\n\t\t\t\tvar diff = new Vector3();\n\t\t\t\tvar edge1 = new Vector3();\n\t\t\t\tvar edge2 = new Vector3();\n\t\t\t\tvar normal = new Vector3();\n\t\n\t\t\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\t\n\t\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\t\n\t\t\t\t\tedge1.subVectors( b, a );\n\t\t\t\t\tedge2.subVectors( c, a );\n\t\t\t\t\tnormal.crossVectors( edge1, edge2 );\n\t\n\t\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\t\t\tvar sign;\n\t\n\t\t\t\t\tif ( DdN > 0 ) {\n\t\n\t\t\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\t\t\tsign = 1;\n\t\n\t\t\t\t\t} else if ( DdN < 0 ) {\n\t\n\t\t\t\t\t\tsign = - 1;\n\t\t\t\t\t\tDdN = - DdN;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdiff.subVectors( this.origin, a );\n\t\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\t\n\t\t\t\t\t// b1 < 0, no intersection\n\t\t\t\t\tif ( DdQxE2 < 0 ) {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\t\n\t\t\t\t\t// b2 < 0, no intersection\n\t\t\t\t\tif ( DdE1xQ < 0 ) {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// b1+b2 > 1, no intersection\n\t\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Line intersects triangle, check if ray does.\n\t\t\t\t\tvar QdN = - sign * diff.dot( normal );\n\t\n\t\t\t\t\t// t < 0, no intersection\n\t\t\t\t\tif ( QdN < 0 ) {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Ray intersects triangle.\n\t\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyMatrix4: function ( matrix4 ) {\n\t\n\t\t\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\t\t\tthis.origin.applyMatrix4( matrix4 );\n\t\t\t\tthis.direction.sub( this.origin );\n\t\t\t\tthis.direction.normalize();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( ray ) {\n\t\n\t\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Euler( x, y, z, order ) {\n\t\n\t\t\tthis._x = x || 0;\n\t\t\tthis._y = y || 0;\n\t\t\tthis._z = z || 0;\n\t\t\tthis._order = order || Euler.DefaultOrder;\n\t\n\t\t}\n\t\n\t\tEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\t\n\t\tEuler.DefaultOrder = 'XYZ';\n\t\n\t\tEuler.prototype = {\n\t\n\t\t\tconstructor: Euler,\n\t\n\t\t\tisEuler: true,\n\t\n\t\t\tget x () {\n\t\n\t\t\t\treturn this._x;\n\t\n\t\t\t},\n\t\n\t\t\tset x ( value ) {\n\t\n\t\t\t\tthis._x = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget y () {\n\t\n\t\t\t\treturn this._y;\n\t\n\t\t\t},\n\t\n\t\t\tset y ( value ) {\n\t\n\t\t\t\tthis._y = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget z () {\n\t\n\t\t\t\treturn this._z;\n\t\n\t\t\t},\n\t\n\t\t\tset z ( value ) {\n\t\n\t\t\t\tthis._z = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget order () {\n\t\n\t\t\t\treturn this._order;\n\t\n\t\t\t},\n\t\n\t\t\tset order ( value ) {\n\t\n\t\t\t\tthis._order = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( x, y, z, order ) {\n\t\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\t\t\t\tthis._order = order || this._order;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( euler ) {\n\t\n\t\t\t\tthis._x = euler._x;\n\t\t\t\tthis._y = euler._y;\n\t\t\t\tthis._z = euler._z;\n\t\t\t\tthis._order = euler._order;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromRotationMatrix: function ( m, order, update ) {\n\t\n\t\t\t\tvar clamp = _Math.clamp;\n\t\n\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\t\tvar te = m.elements;\n\t\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\t\n\t\t\t\torder = order || this._order;\n\t\n\t\t\t\tif ( order === 'XYZ' ) {\n\t\n\t\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\t\tthis._z = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'YXZ' ) {\n\t\n\t\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\t\tthis._z = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'ZXY' ) {\n\t\n\t\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._y = 0;\n\t\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'ZYX' ) {\n\t\n\t\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'YZX' ) {\n\t\n\t\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'XZY' ) {\n\t\n\t\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\t\tthis._y = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._order = order;\n\t\n\t\t\t\tif ( update !== false ) this.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromQuaternion: function () {\n\t\n\t\t\t\tvar matrix;\n\t\n\t\t\t\treturn function setFromQuaternion( q, order, update ) {\n\t\n\t\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\t\n\t\t\t\t\tmatrix.makeRotationFromQuaternion( q );\n\t\n\t\t\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tsetFromVector3: function ( v, order ) {\n\t\n\t\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\t\n\t\t\t},\n\t\n\t\t\treorder: function () {\n\t\n\t\t\t\t// WARNING: this discards revolution information -bhouston\n\t\n\t\t\t\tvar q = new Quaternion();\n\t\n\t\t\t\treturn function reorder( newOrder ) {\n\t\n\t\t\t\t\tq.setFromEuler( this );\n\t\n\t\t\t\t\treturn this.setFromQuaternion( q, newOrder );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tequals: function ( euler ) {\n\t\n\t\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array ) {\n\t\n\t\t\t\tthis._x = array[ 0 ];\n\t\t\t\tthis._y = array[ 1 ];\n\t\t\t\tthis._z = array[ 2 ];\n\t\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this._x;\n\t\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\t\tarray[ offset + 3 ] = this._order;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\ttoVector3: function ( optionalResult ) {\n\t\n\t\t\t\tif ( optionalResult ) {\n\t\n\t\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn new Vector3( this._x, this._y, this._z );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tonChange: function ( callback ) {\n\t\n\t\t\t\tthis.onChangeCallback = callback;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tonChangeCallback: function () {}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Layers() {\n\t\n\t\t\tthis.mask = 1;\n\t\n\t\t}\n\t\n\t\tLayers.prototype = {\n\t\n\t\t\tconstructor: Layers,\n\t\n\t\t\tset: function ( channel ) {\n\t\n\t\t\t\tthis.mask = 1 << channel;\n\t\n\t\t\t},\n\t\n\t\t\tenable: function ( channel ) {\n\t\n\t\t\t\tthis.mask |= 1 << channel;\n\t\n\t\t\t},\n\t\n\t\t\ttoggle: function ( channel ) {\n\t\n\t\t\t\tthis.mask ^= 1 << channel;\n\t\n\t\t\t},\n\t\n\t\t\tdisable: function ( channel ) {\n\t\n\t\t\t\tthis.mask &= ~ ( 1 << channel );\n\t\n\t\t\t},\n\t\n\t\t\ttest: function ( layers ) {\n\t\n\t\t\t\treturn ( this.mask & layers.mask ) !== 0;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author elephantatwork / www.elephantatwork.ch\n\t\t */\n\t\n\t\tfunction Object3D() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: Object3DIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Object3D';\n\t\n\t\t\tthis.parent = null;\n\t\t\tthis.children = [];\n\t\n\t\t\tthis.up = Object3D.DefaultUp.clone();\n\t\n\t\t\tvar position = new Vector3();\n\t\t\tvar rotation = new Euler();\n\t\t\tvar quaternion = new Quaternion();\n\t\t\tvar scale = new Vector3( 1, 1, 1 );\n\t\n\t\t\tfunction onRotationChange() {\n\t\n\t\t\t\tquaternion.setFromEuler( rotation, false );\n\t\n\t\t\t}\n\t\n\t\t\tfunction onQuaternionChange() {\n\t\n\t\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\t\n\t\t\t}\n\t\n\t\t\trotation.onChange( onRotationChange );\n\t\t\tquaternion.onChange( onQuaternionChange );\n\t\n\t\t\tObject.defineProperties( this, {\n\t\t\t\tposition: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: position\n\t\t\t\t},\n\t\t\t\trotation: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: rotation\n\t\t\t\t},\n\t\t\t\tquaternion: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: quaternion\n\t\t\t\t},\n\t\t\t\tscale: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: scale\n\t\t\t\t},\n\t\t\t\tmodelViewMatrix: {\n\t\t\t\t\tvalue: new Matrix4()\n\t\t\t\t},\n\t\t\t\tnormalMatrix: {\n\t\t\t\t\tvalue: new Matrix3()\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tthis.matrix = new Matrix4();\n\t\t\tthis.matrixWorld = new Matrix4();\n\t\n\t\t\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\t\n\t\t\tthis.layers = new Layers();\n\t\t\tthis.visible = true;\n\t\n\t\t\tthis.castShadow = false;\n\t\t\tthis.receiveShadow = false;\n\t\n\t\t\tthis.frustumCulled = true;\n\t\t\tthis.renderOrder = 0;\n\t\n\t\t\tthis.userData = {};\n\t\n\t\t\tthis.onBeforeRender = function(){}; \n\t\t\tthis.onAfterRender = function(){};\n\t\n\t\t}\n\t\n\t\tObject3D.DefaultUp = new Vector3( 0, 1, 0 );\n\t\tObject3D.DefaultMatrixAutoUpdate = true;\n\t\n\t\tObject.assign( Object3D.prototype, EventDispatcher.prototype, {\n\t\n\t\t\tisObject3D: true,\n\t\n\t\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\t\n\t\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\t\n\t\t\t},\n\t\n\t\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\t\n\t\t\t\t// assumes axis is normalized\n\t\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\t\n\t\t\t},\n\t\n\t\t\tsetRotationFromEuler: function ( euler ) {\n\t\n\t\t\t\tthis.quaternion.setFromEuler( euler, true );\n\t\n\t\t\t},\n\t\n\t\t\tsetRotationFromMatrix: function ( m ) {\n\t\n\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m );\n\t\n\t\t\t},\n\t\n\t\t\tsetRotationFromQuaternion: function ( q ) {\n\t\n\t\t\t\t// assumes q is normalized\n\t\n\t\t\t\tthis.quaternion.copy( q );\n\t\n\t\t\t},\n\t\n\t\t\trotateOnAxis: function () {\n\t\n\t\t\t\t// rotate object on axis in object space\n\t\t\t\t// axis is assumed to be normalized\n\t\n\t\t\t\tvar q1 = new Quaternion();\n\t\n\t\t\t\treturn function rotateOnAxis( axis, angle ) {\n\t\n\t\t\t\t\tq1.setFromAxisAngle( axis, angle );\n\t\n\t\t\t\t\tthis.quaternion.multiply( q1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateX: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\t\n\t\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateY: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\t\n\t\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateZ: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\t\n\t\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslateOnAxis: function () {\n\t\n\t\t\t\t// translate object by distance along axis in object space\n\t\t\t\t// axis is assumed to be normalized\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function translateOnAxis( axis, distance ) {\n\t\n\t\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\t\n\t\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslateX: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\t\n\t\t\t\treturn function translateX( distance ) {\n\t\n\t\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslateY: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\t\n\t\t\t\treturn function translateY( distance ) {\n\t\n\t\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslateZ: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\t\n\t\t\t\treturn function translateZ( distance ) {\n\t\n\t\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tlocalToWorld: function ( vector ) {\n\t\n\t\t\t\treturn vector.applyMatrix4( this.matrixWorld );\n\t\n\t\t\t},\n\t\n\t\t\tworldToLocal: function () {\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function worldToLocal( vector ) {\n\t\n\t\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tlookAt: function () {\n\t\n\t\t\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\t\tm1.lookAt( vector, this.position, this.up );\n\t\n\t\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tadd: function ( object ) {\n\t\n\t\t\t\tif ( arguments.length > 1 ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\t\n\t\t\t\t\t\tthis.add( arguments[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object === this ) {\n\t\n\t\t\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( (object && object.isObject3D) ) {\n\t\n\t\t\t\t\tif ( object.parent !== null ) {\n\t\n\t\t\t\t\t\tobject.parent.remove( object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.parent = this;\n\t\t\t\t\tobject.dispatchEvent( { type: 'added' } );\n\t\n\t\t\t\t\tthis.children.push( object );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tremove: function ( object ) {\n\t\n\t\t\t\tif ( arguments.length > 1 ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\t\n\t\t\t\t\t\tthis.remove( arguments[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar index = this.children.indexOf( object );\n\t\n\t\t\t\tif ( index !== - 1 ) {\n\t\n\t\t\t\t\tobject.parent = null;\n\t\n\t\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\t\n\t\t\t\t\tthis.children.splice( index, 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tgetObjectById: function ( id ) {\n\t\n\t\t\t\treturn this.getObjectByProperty( 'id', id );\n\t\n\t\t\t},\n\t\n\t\t\tgetObjectByName: function ( name ) {\n\t\n\t\t\t\treturn this.getObjectByProperty( 'name', name );\n\t\n\t\t\t},\n\t\n\t\t\tgetObjectByProperty: function ( name, value ) {\n\t\n\t\t\t\tif ( this[ name ] === value ) return this;\n\t\n\t\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar child = this.children[ i ];\n\t\t\t\t\tvar object = child.getObjectByProperty( name, value );\n\t\n\t\t\t\t\tif ( object !== undefined ) {\n\t\n\t\t\t\t\t\treturn object;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn undefined;\n\t\n\t\t\t},\n\t\n\t\t\tgetWorldPosition: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t},\n\t\n\t\t\tgetWorldQuaternion: function () {\n\t\n\t\t\t\tvar position = new Vector3();\n\t\t\t\tvar scale = new Vector3();\n\t\n\t\t\t\treturn function getWorldQuaternion( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Quaternion();\n\t\n\t\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\t\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tgetWorldRotation: function () {\n\t\n\t\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\t\treturn function getWorldRotation( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Euler();\n\t\n\t\t\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tgetWorldScale: function () {\n\t\n\t\t\t\tvar position = new Vector3();\n\t\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\t\treturn function getWorldScale( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\t\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tgetWorldDirection: function () {\n\t\n\t\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\t\treturn function getWorldDirection( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\traycast: function () {},\n\t\n\t\t\ttraverse: function ( callback ) {\n\t\n\t\t\t\tcallback( this );\n\t\n\t\t\t\tvar children = this.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tchildren[ i ].traverse( callback );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttraverseVisible: function ( callback ) {\n\t\n\t\t\t\tif ( this.visible === false ) return;\n\t\n\t\t\t\tcallback( this );\n\t\n\t\t\t\tvar children = this.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tchildren[ i ].traverseVisible( callback );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttraverseAncestors: function ( callback ) {\n\t\n\t\t\t\tvar parent = this.parent;\n\t\n\t\t\t\tif ( parent !== null ) {\n\t\n\t\t\t\t\tcallback( parent );\n\t\n\t\t\t\t\tparent.traverseAncestors( callback );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrix: function () {\n\t\n\t\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\t\n\t\t\t\tthis.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrixWorld: function ( force ) {\n\t\n\t\t\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\t\n\t\t\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\t\n\t\t\t\t\tif ( this.parent === null ) {\n\t\n\t\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\t\n\t\t\t\t\tforce = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// update children\n\t\n\t\t\t\tvar children = this.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tchildren[ i ].updateMatrixWorld( force );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\t// meta is '' when called from JSON.stringify\n\t\t\t\tvar isRootObject = ( meta === undefined || meta === '' );\n\t\n\t\t\t\tvar output = {};\n\t\n\t\t\t\t// meta is a hash used to collect geometries, materials.\n\t\t\t\t// not providing it implies that this is the root object\n\t\t\t\t// being serialized.\n\t\t\t\tif ( isRootObject ) {\n\t\n\t\t\t\t\t// initialize meta obj\n\t\t\t\t\tmeta = {\n\t\t\t\t\t\tgeometries: {},\n\t\t\t\t\t\tmaterials: {},\n\t\t\t\t\t\ttextures: {},\n\t\t\t\t\t\timages: {}\n\t\t\t\t\t};\n\t\n\t\t\t\t\toutput.metadata = {\n\t\t\t\t\t\tversion: 4.4,\n\t\t\t\t\t\ttype: 'Object',\n\t\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// standard Object3D serialization\n\t\n\t\t\t\tvar object = {};\n\t\n\t\t\t\tobject.uuid = this.uuid;\n\t\t\t\tobject.type = this.type;\n\t\n\t\t\t\tif ( this.name !== '' ) object.name = this.name;\n\t\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\t\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\t\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\t\t\tif ( this.visible === false ) object.visible = false;\n\t\n\t\t\t\tobject.matrix = this.matrix.toArray();\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( this.geometry !== undefined ) {\n\t\n\t\t\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\t\n\t\t\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.geometry = this.geometry.uuid;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.material !== undefined ) {\n\t\n\t\t\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\n\t\n\t\t\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.material = this.material.uuid;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( this.children.length > 0 ) {\n\t\n\t\t\t\t\tobject.children = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\t\n\t\t\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( isRootObject ) {\n\t\n\t\t\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\t\tvar images = extractFromCache( meta.images );\n\t\n\t\t\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\t\t\tif ( images.length > 0 ) output.images = images;\n\t\n\t\t\t\t}\n\t\n\t\t\t\toutput.object = object;\n\t\n\t\t\t\treturn output;\n\t\n\t\t\t\t// extract data from the cache hash\n\t\t\t\t// remove metadata on each item\n\t\t\t\t// and return as array\n\t\t\t\tfunction extractFromCache( cache ) {\n\t\n\t\t\t\t\tvar values = [];\n\t\t\t\t\tfor ( var key in cache ) {\n\t\n\t\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\t\tvalues.push( data );\n\t\n\t\t\t\t\t}\n\t\t\t\t\treturn values;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function ( recursive ) {\n\t\n\t\t\t\treturn new this.constructor().copy( this, recursive );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source, recursive ) {\n\t\n\t\t\t\tif ( recursive === undefined ) recursive = true;\n\t\n\t\t\t\tthis.name = source.name;\n\t\n\t\t\t\tthis.up.copy( source.up );\n\t\n\t\t\t\tthis.position.copy( source.position );\n\t\t\t\tthis.quaternion.copy( source.quaternion );\n\t\t\t\tthis.scale.copy( source.scale );\n\t\n\t\t\t\tthis.matrix.copy( source.matrix );\n\t\t\t\tthis.matrixWorld.copy( source.matrixWorld );\n\t\n\t\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\t\n\t\t\t\tthis.visible = source.visible;\n\t\n\t\t\t\tthis.castShadow = source.castShadow;\n\t\t\t\tthis.receiveShadow = source.receiveShadow;\n\t\n\t\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\t\tthis.renderOrder = source.renderOrder;\n\t\n\t\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\t\n\t\t\t\tif ( recursive === true ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar child = source.children[ i ];\n\t\t\t\t\t\tthis.add( child.clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar count$2 = 0;\n\t\tfunction Object3DIdCount() { return count$2++; }\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Line3( start, end ) {\n\t\n\t\t\tthis.start = ( start !== undefined ) ? start : new Vector3();\n\t\t\tthis.end = ( end !== undefined ) ? end : new Vector3();\n\t\n\t\t}\n\t\n\t\tLine3.prototype = {\n\t\n\t\t\tconstructor: Line3,\n\t\n\t\t\tset: function ( start, end ) {\n\t\n\t\t\t\tthis.start.copy( start );\n\t\t\t\tthis.end.copy( end );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( line ) {\n\t\n\t\t\t\tthis.start.copy( line.start );\n\t\t\t\tthis.end.copy( line.end );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetCenter: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\t\n\t\t\t},\n\t\n\t\t\tdelta: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.subVectors( this.end, this.start );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceSq: function () {\n\t\n\t\t\t\treturn this.start.distanceToSquared( this.end );\n\t\n\t\t\t},\n\t\n\t\t\tdistance: function () {\n\t\n\t\t\t\treturn this.start.distanceTo( this.end );\n\t\n\t\t\t},\n\t\n\t\t\tat: function ( t, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\t\n\t\t\t},\n\t\n\t\t\tclosestPointToPointParameter: function () {\n\t\n\t\t\t\tvar startP = new Vector3();\n\t\t\t\tvar startEnd = new Vector3();\n\t\n\t\t\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\t\n\t\t\t\t\tstartP.subVectors( point, this.start );\n\t\t\t\t\tstartEnd.subVectors( this.end, this.start );\n\t\n\t\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\t\n\t\t\t\t\tvar t = startEnd_startP / startEnd2;\n\t\n\t\t\t\t\tif ( clampToLine ) {\n\t\n\t\t\t\t\t\tt = _Math.clamp( t, 0, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn t;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\t\n\t\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function ( matrix ) {\n\t\n\t\t\t\tthis.start.applyMatrix4( matrix );\n\t\t\t\tthis.end.applyMatrix4( matrix );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( line ) {\n\t\n\t\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Triangle( a, b, c ) {\n\t\n\t\t\tthis.a = ( a !== undefined ) ? a : new Vector3();\n\t\t\tthis.b = ( b !== undefined ) ? b : new Vector3();\n\t\t\tthis.c = ( c !== undefined ) ? c : new Vector3();\n\t\n\t\t}\n\t\n\t\tTriangle.normal = function () {\n\t\n\t\t\tvar v0 = new Vector3();\n\t\n\t\t\treturn function normal( a, b, c, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\tresult.subVectors( c, b );\n\t\t\t\tv0.subVectors( a, b );\n\t\t\t\tresult.cross( v0 );\n\t\n\t\t\t\tvar resultLengthSq = result.lengthSq();\n\t\t\t\tif ( resultLengthSq > 0 ) {\n\t\n\t\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result.set( 0, 0, 0 );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t// static/instance method to calculate barycentric coordinates\n\t\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\t\tTriangle.barycoordFromPoint = function () {\n\t\n\t\t\tvar v0 = new Vector3();\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\t\n\t\t\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\t\n\t\t\t\tv0.subVectors( c, a );\n\t\t\t\tv1.subVectors( b, a );\n\t\t\t\tv2.subVectors( point, a );\n\t\n\t\t\t\tvar dot00 = v0.dot( v0 );\n\t\t\t\tvar dot01 = v0.dot( v1 );\n\t\t\t\tvar dot02 = v0.dot( v2 );\n\t\t\t\tvar dot11 = v1.dot( v1 );\n\t\t\t\tvar dot12 = v1.dot( v2 );\n\t\n\t\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t// collinear or singular triangle\n\t\t\t\tif ( denom === 0 ) {\n\t\n\t\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\t\treturn result.set( - 2, - 1, - 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar invDenom = 1 / denom;\n\t\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\t\n\t\t\t\t// barycentric coordinates must always sum to 1\n\t\t\t\treturn result.set( 1 - u - v, v, u );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\tTriangle.containsPoint = function () {\n\t\n\t\t\tvar v1 = new Vector3();\n\t\n\t\t\treturn function containsPoint( point, a, b, c ) {\n\t\n\t\t\t\tvar result = Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\t\n\t\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\tTriangle.prototype = {\n\t\n\t\t\tconstructor: Triangle,\n\t\n\t\t\tset: function ( a, b, c ) {\n\t\n\t\t\t\tthis.a.copy( a );\n\t\t\t\tthis.b.copy( b );\n\t\t\t\tthis.c.copy( c );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\t\n\t\t\t\tthis.a.copy( points[ i0 ] );\n\t\t\t\tthis.b.copy( points[ i1 ] );\n\t\t\t\tthis.c.copy( points[ i2 ] );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( triangle ) {\n\t\n\t\t\t\tthis.a.copy( triangle.a );\n\t\t\t\tthis.b.copy( triangle.b );\n\t\t\t\tthis.c.copy( triangle.c );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tarea: function () {\n\t\n\t\t\t\tvar v0 = new Vector3();\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function area() {\n\t\n\t\t\t\t\tv0.subVectors( this.c, this.b );\n\t\t\t\t\tv1.subVectors( this.a, this.b );\n\t\n\t\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmidpoint: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\t\n\t\t\t},\n\t\n\t\t\tnormal: function ( optionalTarget ) {\n\t\n\t\t\t\treturn Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\t\tplane: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Plane();\n\t\n\t\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\n\t\t\t},\n\t\n\t\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\treturn Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\t\n\t\t\t},\n\t\n\t\t\tclosestPointToPoint: function () {\n\t\n\t\t\t\tvar plane, edgeList, projectedPoint, closestPoint;\n\t\n\t\t\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\t\n\t\t\t\t\tif ( plane === undefined ) {\n\t\n\t\t\t\t\t\tplane = new Plane();\n\t\t\t\t\t\tedgeList = [ new Line3(), new Line3(), new Line3() ];\n\t\t\t\t\t\tprojectedPoint = new Vector3();\n\t\t\t\t\t\tclosestPoint = new Vector3();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\t\tvar minDistance = Infinity;\n\t\n\t\t\t\t\t// project the point onto the plane of the triangle\n\t\n\t\t\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\t\t\tplane.projectPoint( point, projectedPoint );\n\t\n\t\t\t\t\t// check if the projection lies within the triangle\n\t\n\t\t\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\n\t\n\t\t\t\t\t\t// if so, this is the closest point\n\t\n\t\t\t\t\t\tresult.copy( projectedPoint );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\t\n\t\t\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\t\n\t\t\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\t\n\t\t\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\t\n\t\t\t\t\t\t\tif( distance < minDistance ) {\n\t\n\t\t\t\t\t\t\t\tminDistance = distance;\n\t\n\t\t\t\t\t\t\t\tresult.copy( closestPoint );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tequals: function ( triangle ) {\n\t\n\t\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Face3( a, b, c, normal, color, materialIndex ) {\n\t\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\n\t\t\tthis.normal = (normal && normal.isVector3) ? normal : new Vector3();\n\t\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\t\n\t\t\tthis.color = (color && color.isColor) ? color : new Color();\n\t\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\t\n\t\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\t\n\t\t}\n\t\n\t\tFace3.prototype = {\n\t\n\t\t\tconstructor: Face3,\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.a = source.a;\n\t\t\t\tthis.b = source.b;\n\t\t\t\tthis.c = source.c;\n\t\n\t\t\t\tthis.normal.copy( source.normal );\n\t\t\t\tthis.color.copy( source.color );\n\t\n\t\t\t\tthis.materialIndex = source.materialIndex;\n\t\n\t\t\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  aoMap: new THREE.Texture( <Image> ),\n\t\t *  aoMapIntensity: <float>\n\t\t *\n\t\t *  specularMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t\t *  combine: THREE.Multiply,\n\t\t *  reflectivity: <float>,\n\t\t *  refractionRatio: <float>,\n\t\t *\n\t\t *  shading: THREE.SmoothShading,\n\t\t *  depthTest: <bool>,\n\t\t *  depthWrite: <bool>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshBasicMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshBasicMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff ); // emissive\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\t\tthis.specularMap = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshBasicMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\n\t\n\t\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\t\n\t\tMeshBasicMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\t\tthis.specularMap = source.specularMap;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction BufferAttribute( array, itemSize, normalized ) {\n\t\n\t\t\tif ( Array.isArray( array ) ) {\n\t\n\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\t\n\t\t\t}\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.array = array;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\t\tthis.normalized = normalized === true;\n\t\n\t\t\tthis.dynamic = false;\n\t\t\tthis.updateRange = { offset: 0, count: - 1 };\n\t\n\t\t\tthis.version = 0;\n\t\n\t\t}\n\t\n\t\tBufferAttribute.prototype = {\n\t\n\t\t\tconstructor: BufferAttribute,\n\t\n\t\t\tisBufferAttribute: true,\n\t\n\t\t\tset needsUpdate( value ) {\n\t\n\t\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t\t},\n\t\n\t\t\tsetArray: function ( array ) {\n\t\n\t\t\t\tif ( Array.isArray( array ) ) {\n\t\n\t\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\n\t\t\t\tthis.array = array;\n\t\n\t\t\t},\n\t\n\t\t\tsetDynamic: function ( value ) {\n\t\n\t\t\t\tthis.dynamic = value;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\t\tthis.itemSize = source.itemSize;\n\t\t\t\tthis.count = source.count;\n\t\t\t\tthis.normalized = source.normalized;\n\t\n\t\t\t\tthis.dynamic = source.dynamic;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyAt: function ( index1, attribute, index2 ) {\n\t\n\t\t\t\tindex1 *= this.itemSize;\n\t\t\t\tindex2 *= attribute.itemSize;\n\t\n\t\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyArray: function ( array ) {\n\t\n\t\t\t\tthis.array.set( array );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyColorsArray: function ( colors ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar color = colors[ i ];\n\t\n\t\t\t\t\tif ( color === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\t\t\tcolor = new Color();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tarray[ offset ++ ] = color.r;\n\t\t\t\t\tarray[ offset ++ ] = color.g;\n\t\t\t\t\tarray[ offset ++ ] = color.b;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyIndicesArray: function ( indices ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar index = indices[ i ];\n\t\n\t\t\t\t\tarray[ offset ++ ] = index.a;\n\t\t\t\t\tarray[ offset ++ ] = index.b;\n\t\t\t\t\tarray[ offset ++ ] = index.c;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyVector2sArray: function ( vectors ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\t\t\tvector = new Vector2();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyVector3sArray: function ( vectors ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\t\t\tvector = new Vector3();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyVector4sArray: function ( vectors ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\t\t\tvector = new Vector4();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\t\t\tarray[ offset ++ ] = vector.w;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( value, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.array.set( value, offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetX: function ( index ) {\n\t\n\t\t\t\treturn this.array[ index * this.itemSize ];\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( index, x ) {\n\t\n\t\t\t\tthis.array[ index * this.itemSize ] = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetY: function ( index ) {\n\t\n\t\t\t\treturn this.array[ index * this.itemSize + 1 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( index, y ) {\n\t\n\t\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetZ: function ( index ) {\n\t\n\t\t\t\treturn this.array[ index * this.itemSize + 2 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetZ: function ( index, z ) {\n\t\n\t\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetW: function ( index ) {\n\t\n\t\t\t\treturn this.array[ index * this.itemSize + 3 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetW: function ( index, w ) {\n\t\n\t\t\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXY: function ( index, x, y ) {\n\t\n\t\t\t\tindex *= this.itemSize;\n\t\n\t\t\t\tthis.array[ index + 0 ] = x;\n\t\t\t\tthis.array[ index + 1 ] = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXYZ: function ( index, x, y, z ) {\n\t\n\t\t\t\tindex *= this.itemSize;\n\t\n\t\t\t\tthis.array[ index + 0 ] = x;\n\t\t\t\tthis.array[ index + 1 ] = y;\n\t\t\t\tthis.array[ index + 2 ] = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXYZW: function ( index, x, y, z, w ) {\n\t\n\t\t\t\tindex *= this.itemSize;\n\t\n\t\t\t\tthis.array[ index + 0 ] = x;\n\t\t\t\tthis.array[ index + 1 ] = y;\n\t\t\t\tthis.array[ index + 2 ] = z;\n\t\t\t\tthis.array[ index + 3 ] = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tfunction Int8Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Int8Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Uint8Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Uint8Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Uint8ClampedAttribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Uint8ClampedArray( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Int16Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Int16Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Uint16Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Uint16Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Int32Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Int32Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Uint32Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Uint32Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Float32Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Float32Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Float64Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Float64Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\t// Deprecated\n\t\n\t\tfunction DynamicBufferAttribute( array, itemSize ) {\n\t\n\t\t\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\t\t\treturn new BufferAttribute( array, itemSize ).setDynamic( true );\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author kile / http://kile.stravaganza.org/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Geometry() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Geometry';\n\t\n\t\t\tthis.vertices = [];\n\t\t\tthis.colors = [];\n\t\t\tthis.faces = [];\n\t\t\tthis.faceVertexUvs = [ [] ];\n\t\n\t\t\tthis.morphTargets = [];\n\t\t\tthis.morphNormals = [];\n\t\n\t\t\tthis.skinWeights = [];\n\t\t\tthis.skinIndices = [];\n\t\n\t\t\tthis.lineDistances = [];\n\t\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\t\n\t\t\t// update flags\n\t\n\t\t\tthis.elementsNeedUpdate = false;\n\t\t\tthis.verticesNeedUpdate = false;\n\t\t\tthis.uvsNeedUpdate = false;\n\t\t\tthis.normalsNeedUpdate = false;\n\t\t\tthis.colorsNeedUpdate = false;\n\t\t\tthis.lineDistancesNeedUpdate = false;\n\t\t\tthis.groupsNeedUpdate = false;\n\t\n\t\t}\n\t\n\t\tObject.assign( Geometry.prototype, EventDispatcher.prototype, {\n\t\n\t\t\tisGeometry: true,\n\t\n\t\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\t\tvertex.applyMatrix4( matrix );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar face = this.faces[ i ];\n\t\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.verticesNeedUpdate = true;\n\t\t\t\tthis.normalsNeedUpdate = true;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trotateX: function () {\n\t\n\t\t\t\t// rotate geometry around world x-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationX( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateY: function () {\n\t\n\t\t\t\t// rotate geometry around world y-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationY( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateZ: function () {\n\t\n\t\t\t\t// rotate geometry around world z-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationZ( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslate: function () {\n\t\n\t\t\t\t// translate geometry\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function translate( x, y, z ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeTranslation( x, y, z );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tscale: function () {\n\t\n\t\t\t\t// scale geometry\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function scale( x, y, z ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeScale( x, y, z );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tlookAt: function () {\n\t\n\t\t\t\tvar obj;\n\t\n\t\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\t\tif ( obj === undefined ) obj = new Object3D();\n\t\n\t\t\t\t\tobj.lookAt( vector );\n\t\n\t\t\t\t\tobj.updateMatrix();\n\t\n\t\t\t\t\tthis.applyMatrix( obj.matrix );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tfromBufferGeometry: function ( geometry ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\n\t\t\t\tvar positions = attributes.position.array;\n\t\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\t\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\t\n\t\t\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\t\n\t\t\t\tvar tempNormals = [];\n\t\t\t\tvar tempUVs = [];\n\t\t\t\tvar tempUVs2 = [];\n\t\n\t\t\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\t\n\t\t\t\t\tscope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\t\n\t\t\t\t\tif ( normals !== undefined ) {\n\t\n\t\t\t\t\t\ttempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( colors !== undefined ) {\n\t\n\t\t\t\t\t\tscope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( uvs !== undefined ) {\n\t\n\t\t\t\t\t\ttempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( uvs2 !== undefined ) {\n\t\n\t\t\t\t\t\ttempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction addFace( a, b, c, materialIndex ) {\n\t\n\t\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\t\n\t\t\t\t\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\t\n\t\t\t\t\tscope.faces.push( face );\n\t\n\t\t\t\t\tif ( uvs !== undefined ) {\n\t\n\t\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( uvs2 !== undefined ) {\n\t\n\t\t\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( indices !== undefined ) {\n\t\n\t\t\t\t\tvar groups = geometry.groups;\n\t\n\t\t\t\t\tif ( groups.length > 0 ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\n\t\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\t\n\t\t\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\t\n\t\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\t\n\t\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.computeFaceNormals();\n\t\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcenter: function () {\n\t\n\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\t\n\t\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\t\n\t\t\t\treturn offset;\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\t\tvar center = this.boundingSphere.center;\n\t\t\t\tvar radius = this.boundingSphere.radius;\n\t\n\t\t\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\t\n\t\t\t\tvar matrix = new Matrix4();\n\t\t\t\tmatrix.set(\n\t\t\t\t\ts, 0, 0, - s * center.x,\n\t\t\t\t\t0, s, 0, - s * center.y,\n\t\t\t\t\t0, 0, s, - s * center.z,\n\t\t\t\t\t0, 0, 0, 1\n\t\t\t\t);\n\t\n\t\t\t\tthis.applyMatrix( matrix );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcomputeFaceNormals: function () {\n\t\n\t\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\t\n\t\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tvar face = this.faces[ f ];\n\t\n\t\t\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\t\t\tvar vC = this.vertices[ face.c ];\n\t\n\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\tcb.normalize();\n\t\n\t\t\t\t\tface.normal.copy( cb );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeVertexNormals: function ( areaWeighted ) {\n\t\n\t\t\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\t\n\t\t\t\tvar v, vl, f, fl, face, vertices;\n\t\n\t\t\t\tvertices = new Array( this.vertices.length );\n\t\n\t\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\t\tvertices[ v ] = new Vector3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( areaWeighted ) {\n\t\n\t\t\t\t\t// vertex normals weighted by triangle areas\n\t\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\t\n\t\t\t\t\tvar vA, vB, vC;\n\t\t\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\t\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\t\t\tvC = this.vertices[ face.c ];\n\t\n\t\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\t\t\tvertices[ face.c ].add( cb );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.computeFaceNormals();\n\t\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\t\t\tvertices[ face.c ].add( face.normal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\t\tvertices[ v ].normalize();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\tif ( vertexNormals.length === 3 ) {\n\t\n\t\t\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.faces.length > 0 ) {\n\t\n\t\t\t\t\tthis.normalsNeedUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeFlatVertexNormals: function () {\n\t\n\t\t\t\tvar f, fl, face;\n\t\n\t\t\t\tthis.computeFaceNormals();\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\tif ( vertexNormals.length === 3 ) {\n\t\n\t\t\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.faces.length > 0 ) {\n\t\n\t\t\t\t\tthis.normalsNeedUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeMorphNormals: function () {\n\t\n\t\t\t\tvar i, il, f, fl, face;\n\t\n\t\t\t\t// save original normals\n\t\t\t\t// - create temp variables on first access\n\t\t\t\t//   otherwise just copy (for faster repeated calls)\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tif ( ! face.__originalFaceNormal ) {\n\t\n\t\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\t\n\t\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\t\n\t\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// use temp geometry to compute face and vertex normals for each morph\n\t\n\t\t\t\tvar tmpGeo = new Geometry();\n\t\t\t\ttmpGeo.faces = this.faces;\n\t\n\t\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t// create on first access\n\t\n\t\t\t\t\tif ( ! this.morphNormals[ i ] ) {\n\t\n\t\t\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\t\n\t\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\t\n\t\t\t\t\t\tvar faceNormal, vertexNormals;\n\t\n\t\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\t\tfaceNormal = new Vector3();\n\t\t\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\t\n\t\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar morphNormals = this.morphNormals[ i ];\n\t\n\t\t\t\t\t// set vertices to morph target\n\t\n\t\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\t\n\t\t\t\t\t// compute morph normals\n\t\n\t\t\t\t\ttmpGeo.computeFaceNormals();\n\t\t\t\t\ttmpGeo.computeVertexNormals();\n\t\n\t\t\t\t\t// store morph normals\n\t\n\t\t\t\t\tvar faceNormal, vertexNormals;\n\t\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\t\n\t\t\t\t\t\tfaceNormal.copy( face.normal );\n\t\n\t\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// restore original normals\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeTangents: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeLineDistances: function () {\n\t\n\t\t\t\tvar d = 0;\n\t\t\t\tvar vertices = this.vertices;\n\t\n\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tif ( i > 0 ) {\n\t\n\t\t\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.lineDistances[ i ] = d;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeBoundingBox: function () {\n\t\n\t\t\t\tif ( this.boundingBox === null ) {\n\t\n\t\t\t\t\tthis.boundingBox = new Box3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.boundingBox.setFromPoints( this.vertices );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeBoundingSphere: function () {\n\t\n\t\t\t\tif ( this.boundingSphere === null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = new Sphere();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\t\n\t\t\t},\n\t\n\t\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\t\n\t\t\t\tif ( (geometry && geometry.isGeometry) === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar normalMatrix,\n\t\t\t\tvertexOffset = this.vertices.length,\n\t\t\t\tvertices1 = this.vertices,\n\t\t\t\tvertices2 = geometry.vertices,\n\t\t\t\tfaces1 = this.faces,\n\t\t\t\tfaces2 = geometry.faces,\n\t\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ],\n\t\t\t\tcolors1 = this.colors,\n\t\t\t\tcolors2 = geometry.colors;\n\t\n\t\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\t\n\t\t\t\tif ( matrix !== undefined ) {\n\t\n\t\t\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// vertices\n\t\n\t\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar vertex = vertices2[ i ];\n\t\n\t\t\t\t\tvar vertexCopy = vertex.clone();\n\t\n\t\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\t\n\t\t\t\t\tvertices1.push( vertexCopy );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// colors\n\t\n\t\t\t\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tcolors1.push( colors2[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// faces\n\t\n\t\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\t\t\tfaceVertexColors = face.vertexColors;\n\t\n\t\t\t\t\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\t\t\tfaceCopy.normal.copy( face.normal );\n\t\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\n\t\n\t\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\t\n\t\t\t\t\t\tif ( normalMatrix !== undefined ) {\n\t\n\t\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfaceCopy.color.copy( face.color );\n\t\n\t\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\t\n\t\t\t\t\tfaces1.push( faceCopy );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// uvs\n\t\n\t\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\t\n\t\t\t\t\tif ( uv === undefined ) {\n\t\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tuvs1.push( uvCopy );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tmergeMesh: function ( mesh ) {\n\t\n\t\t\t\tif ( (mesh && mesh.isMesh) === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\t\n\t\t\t\tthis.merge( mesh.geometry, mesh.matrix );\n\t\n\t\t\t},\n\t\n\t\t\t/*\n\t\t\t * Checks for duplicate vertices with hashmap.\n\t\t\t * Duplicated vertices are removed\n\t\t\t * and faces' vertices are updated.\n\t\t\t */\n\t\n\t\t\tmergeVertices: function () {\n\t\n\t\t\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\t\t\tvar unique = [], changes = [];\n\t\n\t\t\t\tvar v, key;\n\t\t\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\t\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\t\t\tvar i, il, face;\n\t\t\t\tvar indices, j, jl;\n\t\n\t\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tv = this.vertices[ i ];\n\t\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\t\n\t\t\t\t\tif ( verticesMap[ key ] === undefined ) {\n\t\n\t\t\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\t\t\tchanges[ i ] = unique.length - 1;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\t// if faces are completely degenerate after merging vertices, we\n\t\t\t\t// have to remove them from the geometry.\n\t\t\t\tvar faceIndicesToRemove = [];\n\t\n\t\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ i ];\n\t\n\t\t\t\t\tface.a = changes[ face.a ];\n\t\t\t\t\tface.b = changes[ face.b ];\n\t\t\t\t\tface.c = changes[ face.c ];\n\t\n\t\t\t\t\tindices = [ face.a, face.b, face.c ];\n\t\n\t\t\t\t\tvar dupIndex = - 1;\n\t\n\t\t\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t\t\t// we have to remove the face as nothing can be saved\n\t\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\t\n\t\t\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\t\n\t\t\t\t\t\t\tdupIndex = n;\n\t\t\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\t\n\t\t\t\t\tvar idx = faceIndicesToRemove[ i ];\n\t\n\t\t\t\t\tthis.faces.splice( idx, 1 );\n\t\n\t\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Use unique set of vertices\n\t\n\t\t\t\tvar diff = this.vertices.length - unique.length;\n\t\t\t\tthis.vertices = unique;\n\t\t\t\treturn diff;\n\t\n\t\t\t},\n\t\n\t\t\tsortFacesByMaterialIndex: function () {\n\t\n\t\t\t\tvar faces = this.faces;\n\t\t\t\tvar length = faces.length;\n\t\n\t\t\t\t// tag faces\n\t\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\tfaces[ i ]._id = i;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// sort faces\n\t\n\t\t\t\tfunction materialIndexSort( a, b ) {\n\t\n\t\t\t\t\treturn a.materialIndex - b.materialIndex;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfaces.sort( materialIndexSort );\n\t\n\t\t\t\t// sort uvs\n\t\n\t\t\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\t\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\t\n\t\t\t\tvar newUvs1, newUvs2;\n\t\n\t\t\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\t\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\t\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\tvar id = faces[ i ]._id;\n\t\n\t\t\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\t\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\tvar data = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.4,\n\t\t\t\t\t\ttype: 'Geometry',\n\t\t\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\t// standard Geometry serialization\n\t\n\t\t\t\tdata.uuid = this.uuid;\n\t\t\t\tdata.type = this.type;\n\t\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\t\tif ( this.parameters !== undefined ) {\n\t\n\t\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn data;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar vertices = [];\n\t\n\t\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\t\n\t\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar faces = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar normalsHash = {};\n\t\t\t\tvar colors = [];\n\t\t\t\tvar colorsHash = {};\n\t\t\t\tvar uvs = [];\n\t\t\t\tvar uvsHash = {};\n\t\n\t\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\t\n\t\t\t\t\tvar face = this.faces[ i ];\n\t\n\t\t\t\t\tvar hasMaterial = true;\n\t\t\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\t\n\t\t\t\t\tvar faceType = 0;\n\t\n\t\t\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\t\n\t\t\t\t\tfaces.push( faceType );\n\t\t\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\t\t\tfaces.push( face.materialIndex );\n\t\n\t\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\t\n\t\t\t\t\t\tfaces.push(\n\t\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\t\tfaces.push(\n\t\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\t\tvar vertexColors = face.vertexColors;\n\t\n\t\t\t\t\t\tfaces.push(\n\t\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction setBit( value, position, enabled ) {\n\t\n\t\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getNormalIndex( normal ) {\n\t\n\t\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\t\n\t\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn normalsHash[ hash ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\treturn normalsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getColorIndex( color ) {\n\t\n\t\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\t\n\t\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn colorsHash[ hash ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\t\t\tcolors.push( color.getHex() );\n\t\n\t\t\t\t\treturn colorsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getUvIndex( uv ) {\n\t\n\t\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\t\n\t\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn uvsHash[ hash ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\t\n\t\t\t\t\treturn uvsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdata.data = {};\n\t\n\t\t\t\tdata.data.vertices = vertices;\n\t\t\t\tdata.data.normals = normals;\n\t\t\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\t\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\t\t\tdata.data.faces = faces;\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\t/*\n\t\t\t\t// Handle primitives\n\t\n\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\tif ( parameters !== undefined ) {\n\t\n\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\t\tvalues.push( parameters[ key ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\t\treturn geometry;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\t\t\t*/\n\t\n\t\t\t\treturn new Geometry().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.vertices = [];\n\t\t\t\tthis.faces = [];\n\t\t\t\tthis.faceVertexUvs = [ [] ];\n\t\t\t\tthis.colors = [];\n\t\n\t\t\t\tvar vertices = source.vertices;\n\t\n\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar colors = source.colors;\n\t\n\t\t\t\tfor ( var i = 0, il = colors.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.colors.push( colors[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar faces = source.faces;\n\t\n\t\t\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.faces.push( faces[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\t\n\t\t\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\t\n\t\t\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\t\n\t\t\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\n\t\n\t\t\t\t\t\t\tvar uv = uvs[ k ];\n\t\n\t\t\t\t\t\t\tuvsCopy.push( uv.clone() );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar count$3 = 0;\n\t\tfunction GeometryIdCount() { return count$3++; }\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction DirectGeometry() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'DirectGeometry';\n\t\n\t\t\tthis.indices = [];\n\t\t\tthis.vertices = [];\n\t\t\tthis.normals = [];\n\t\t\tthis.colors = [];\n\t\t\tthis.uvs = [];\n\t\t\tthis.uvs2 = [];\n\t\n\t\t\tthis.groups = [];\n\t\n\t\t\tthis.morphTargets = {};\n\t\n\t\t\tthis.skinWeights = [];\n\t\t\tthis.skinIndices = [];\n\t\n\t\t\t// this.lineDistances = [];\n\t\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\t\n\t\t\t// update flags\n\t\n\t\t\tthis.verticesNeedUpdate = false;\n\t\t\tthis.normalsNeedUpdate = false;\n\t\t\tthis.colorsNeedUpdate = false;\n\t\t\tthis.uvsNeedUpdate = false;\n\t\t\tthis.groupsNeedUpdate = false;\n\t\n\t\t}\n\t\n\t\tObject.assign( DirectGeometry.prototype, EventDispatcher.prototype, {\n\t\n\t\t\tcomputeBoundingBox: Geometry.prototype.computeBoundingBox,\n\t\t\tcomputeBoundingSphere: Geometry.prototype.computeBoundingSphere,\n\t\n\t\t\tcomputeFaceNormals: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeVertexNormals: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeGroups: function ( geometry ) {\n\t\n\t\t\t\tvar group;\n\t\t\t\tvar groups = [];\n\t\t\t\tvar materialIndex;\n\t\n\t\t\t\tvar faces = geometry.faces;\n\t\n\t\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\t// materials\n\t\n\t\t\t\t\tif ( face.materialIndex !== materialIndex ) {\n\t\n\t\t\t\t\t\tmaterialIndex = face.materialIndex;\n\t\n\t\t\t\t\t\tif ( group !== undefined ) {\n\t\n\t\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\t\t\tgroups.push( group );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tgroup = {\n\t\t\t\t\t\t\tstart: i * 3,\n\t\t\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( group !== undefined ) {\n\t\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\tgroups.push( group );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.groups = groups;\n\t\n\t\t\t},\n\t\n\t\t\tfromGeometry: function ( geometry ) {\n\t\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\t\n\t\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\t\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\t\n\t\t\t\t// morphs\n\t\n\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\tvar morphTargetsLength = morphTargets.length;\n\t\n\t\t\t\tvar morphTargetsPosition;\n\t\n\t\t\t\tif ( morphTargetsLength > 0 ) {\n\t\n\t\t\t\t\tmorphTargetsPosition = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\t\n\t\t\t\t\t\tmorphTargetsPosition[ i ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar morphNormals = geometry.morphNormals;\n\t\t\t\tvar morphNormalsLength = morphNormals.length;\n\t\n\t\t\t\tvar morphTargetsNormal;\n\t\n\t\t\t\tif ( morphNormalsLength > 0 ) {\n\t\n\t\t\t\t\tmorphTargetsNormal = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\t\n\t\t\t\t\t\tmorphTargetsNormal[ i ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// skins\n\t\n\t\t\t\tvar skinIndices = geometry.skinIndices;\n\t\t\t\tvar skinWeights = geometry.skinWeights;\n\t\n\t\t\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\t\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\t\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\tif ( vertexNormals.length === 3 ) {\n\t\n\t\t\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar normal = face.normal;\n\t\n\t\t\t\t\t\tthis.normals.push( normal, normal, normal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar vertexColors = face.vertexColors;\n\t\n\t\t\t\t\tif ( vertexColors.length === 3 ) {\n\t\n\t\t\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar color = face.color;\n\t\n\t\t\t\t\t\tthis.colors.push( color, color, color );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceVertexUv === true ) {\n\t\n\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\t\n\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\t\n\t\t\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\t\n\t\t\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceVertexUv2 === true ) {\n\t\n\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\t\n\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\t\n\t\t\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\t\n\t\t\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// morphs\n\t\n\t\t\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\t\n\t\t\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\t\n\t\t\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\t\n\t\t\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\t\n\t\t\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// skins\n\t\n\t\t\t\t\tif ( hasSkinIndices ) {\n\t\n\t\t\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasSkinWeights ) {\n\t\n\t\t\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.computeGroups( geometry );\n\t\n\t\t\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction BufferGeometry() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'BufferGeometry';\n\t\n\t\t\tthis.index = null;\n\t\t\tthis.attributes = {};\n\t\n\t\t\tthis.morphAttributes = {};\n\t\n\t\t\tthis.groups = [];\n\t\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\t\n\t\t\tthis.drawRange = { start: 0, count: Infinity };\n\t\n\t\t}\n\t\n\t\tObject.assign( BufferGeometry.prototype, EventDispatcher.prototype, {\n\t\n\t\t\tisBufferGeometry: true,\n\t\n\t\t\tgetIndex: function () {\n\t\n\t\t\t\treturn this.index;\n\t\n\t\t\t},\n\t\n\t\t\tsetIndex: function ( index ) {\n\t\n\t\t\t\tthis.index = index;\n\t\n\t\t\t},\n\t\n\t\t\taddAttribute: function ( name, attribute ) {\n\t\n\t\t\t\tif ( (attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\t\n\t\t\t\t\tthis.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\t\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( name === 'index' ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\t\t\tthis.setIndex( attribute );\n\t\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.attributes[ name ] = attribute;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetAttribute: function ( name ) {\n\t\n\t\t\t\treturn this.attributes[ name ];\n\t\n\t\t\t},\n\t\n\t\t\tremoveAttribute: function ( name ) {\n\t\n\t\t\t\tdelete this.attributes[ name ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddGroup: function ( start, count, materialIndex ) {\n\t\n\t\t\t\tthis.groups.push( {\n\t\n\t\t\t\t\tstart: start,\n\t\t\t\t\tcount: count,\n\t\t\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\t\n\t\t\t\t} );\n\t\n\t\t\t},\n\t\n\t\t\tclearGroups: function () {\n\t\n\t\t\t\tthis.groups = [];\n\t\n\t\t\t},\n\t\n\t\t\tsetDrawRange: function ( start, count ) {\n\t\n\t\t\t\tthis.drawRange.start = start;\n\t\t\t\tthis.drawRange.count = count;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\t\tvar position = this.attributes.position;\n\t\n\t\t\t\tif ( position !== undefined ) {\n\t\n\t\t\t\t\tmatrix.applyToVector3Array( position.array );\n\t\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar normal = this.attributes.normal;\n\t\n\t\t\t\tif ( normal !== undefined ) {\n\t\n\t\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\t\t\tnormalMatrix.applyToVector3Array( normal.array );\n\t\t\t\t\tnormal.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trotateX: function () {\n\t\n\t\t\t\t// rotate geometry around world x-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationX( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateY: function () {\n\t\n\t\t\t\t// rotate geometry around world y-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationY( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateZ: function () {\n\t\n\t\t\t\t// rotate geometry around world z-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationZ( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslate: function () {\n\t\n\t\t\t\t// translate geometry\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function translate( x, y, z ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeTranslation( x, y, z );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tscale: function () {\n\t\n\t\t\t\t// scale geometry\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function scale( x, y, z ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeScale( x, y, z );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tlookAt: function () {\n\t\n\t\t\t\tvar obj;\n\t\n\t\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\t\tif ( obj === undefined ) obj = new Object3D();\n\t\n\t\t\t\t\tobj.lookAt( vector );\n\t\n\t\t\t\t\tobj.updateMatrix();\n\t\n\t\t\t\t\tthis.applyMatrix( obj.matrix );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tcenter: function () {\n\t\n\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\t\n\t\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\t\n\t\t\t\treturn offset;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromObject: function ( object ) {\n\t\n\t\t\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tif ( (object && object.isPoints) || (object && object.isLine) ) {\n\t\n\t\t\t\t\tvar positions = new Float32Attribute( geometry.vertices.length * 3, 3 );\n\t\t\t\t\tvar colors = new Float32Attribute( geometry.colors.length * 3, 3 );\n\t\n\t\t\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\t\n\t\t\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\t\n\t\t\t\t\t\tvar lineDistances = new Float32Attribute( geometry.lineDistances.length, 1 );\n\t\n\t\t\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( (object && object.isMesh) ) {\n\t\n\t\t\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\t\t\tthis.fromGeometry( geometry );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tupdateFromObject: function ( object ) {\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tif ( (object && object.isMesh) ) {\n\t\n\t\t\t\t\tvar direct = geometry.__directGeometry;\n\t\n\t\t\t\t\tif ( geometry.elementsNeedUpdate === true ) {\n\t\n\t\t\t\t\t\tdirect = undefined;\n\t\t\t\t\t\tgeometry.elementsNeedUpdate = false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( direct === undefined ) {\n\t\n\t\t\t\t\t\treturn this.fromGeometry( geometry );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\t\n\t\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\t\tgeometry.groupsNeedUpdate = false;\n\t\n\t\t\t\t\tgeometry = direct;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attribute;\n\t\n\t\t\t\tif ( geometry.verticesNeedUpdate === true ) {\n\t\n\t\t\t\t\tattribute = this.attributes.position;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.normalsNeedUpdate === true ) {\n\t\n\t\t\t\t\tattribute = this.attributes.normal;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.colorsNeedUpdate === true ) {\n\t\n\t\t\t\t\tattribute = this.attributes.color;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.uvsNeedUpdate ) {\n\t\n\t\t\t\t\tattribute = this.attributes.uv;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\t\n\t\t\t\t\tattribute = this.attributes.lineDistance;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.groupsNeedUpdate ) {\n\t\n\t\t\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\t\t\tthis.groups = geometry.groups;\n\t\n\t\t\t\t\tgeometry.groupsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tfromGeometry: function ( geometry ) {\n\t\n\t\t\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\n\t\n\t\t\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\t\n\t\t\t},\n\t\n\t\t\tfromDirectGeometry: function ( geometry ) {\n\t\n\t\t\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\t\n\t\t\t\tif ( geometry.normals.length > 0 ) {\n\t\n\t\t\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.colors.length > 0 ) {\n\t\n\t\t\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\t\t\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.uvs.length > 0 ) {\n\t\n\t\t\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.uvs2.length > 0 ) {\n\t\n\t\t\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\t\t\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.indices.length > 0 ) {\n\t\n\t\t\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n\t\t\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// groups\n\t\n\t\t\t\tthis.groups = geometry.groups;\n\t\n\t\t\t\t// morphs\n\t\n\t\t\t\tfor ( var name in geometry.morphTargets ) {\n\t\n\t\t\t\t\tvar array = [];\n\t\t\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\t\n\t\t\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\n\t\t\t\t\t\tvar attribute = new Float32Attribute( morphTarget.length * 3, 3 );\n\t\n\t\t\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.morphAttributes[ name ] = array;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// skinning\n\t\n\t\t\t\tif ( geometry.skinIndices.length > 0 ) {\n\t\n\t\t\t\t\tvar skinIndices = new Float32Attribute( geometry.skinIndices.length * 4, 4 );\n\t\t\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.skinWeights.length > 0 ) {\n\t\n\t\t\t\t\tvar skinWeights = new Float32Attribute( geometry.skinWeights.length * 4, 4 );\n\t\t\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcomputeBoundingBox: function () {\n\t\n\t\t\t\tif ( this.boundingBox === null ) {\n\t\n\t\t\t\t\tthis.boundingBox = new Box3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar positions = this.attributes.position.array;\n\t\n\t\t\t\tif ( positions !== undefined ) {\n\t\n\t\t\t\t\tthis.boundingBox.setFromArray( positions );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.boundingBox.makeEmpty();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeBoundingSphere: function () {\n\t\n\t\t\t\tvar box = new Box3();\n\t\t\t\tvar vector = new Vector3();\n\t\n\t\t\t\treturn function computeBoundingSphere() {\n\t\n\t\t\t\t\tif ( this.boundingSphere === null ) {\n\t\n\t\t\t\t\t\tthis.boundingSphere = new Sphere();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar positions = this.attributes.position;\n\t\n\t\t\t\t\tif ( positions ) {\n\t\n\t\t\t\t\t\tvar array = positions.array;\n\t\t\t\t\t\tvar center = this.boundingSphere.center;\n\t\n\t\t\t\t\t\tbox.setFromArray( array );\n\t\t\t\t\t\tbox.getCenter( center );\n\t\n\t\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\t\n\t\t\t\t\t\tvar maxRadiusSq = 0;\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\t\tvector.fromArray( array, i );\n\t\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\t\n\t\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tcomputeFaceNormals: function () {\n\t\n\t\t\t\t// backwards compatibility\n\t\n\t\t\t},\n\t\n\t\t\tcomputeVertexNormals: function () {\n\t\n\t\t\t\tvar index = this.index;\n\t\t\t\tvar attributes = this.attributes;\n\t\t\t\tvar groups = this.groups;\n\t\n\t\t\t\tif ( attributes.position ) {\n\t\n\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\tif ( attributes.normal === undefined ) {\n\t\n\t\t\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// reset existing normals to zero\n\t\n\t\t\t\t\t\tvar array = attributes.normal.array;\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tarray[ i ] = 0;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar normals = attributes.normal.array;\n\t\n\t\t\t\t\tvar vA, vB, vC,\n\t\n\t\t\t\t\tpA = new Vector3(),\n\t\t\t\t\tpB = new Vector3(),\n\t\t\t\t\tpC = new Vector3(),\n\t\n\t\t\t\t\tcb = new Vector3(),\n\t\t\t\t\tab = new Vector3();\n\t\n\t\t\t\t\t// indexed elements\n\t\n\t\t\t\t\tif ( index ) {\n\t\n\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\tif ( groups.length === 0 ) {\n\t\n\t\t\t\t\t\t\tthis.addGroup( 0, indices.length );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\t\n\t\t\t\t\t\t\tvar group = groups[ j ];\n\t\n\t\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\t\n\t\t\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\t\t\tpC.fromArray( positions, vC );\n\t\n\t\t\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\t\n\t\t\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\t\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\t\n\t\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\t\n\t\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.normalizeNormals();\n\t\n\t\t\t\t\tattributes.normal.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tmerge: function ( geometry, offset ) {\n\t\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tvar attributes = this.attributes;\n\t\n\t\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\t\n\t\t\t\t\tvar attribute1 = attributes[ key ];\n\t\t\t\t\tvar attributeArray1 = attribute1.array;\n\t\n\t\t\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\t\t\tvar attributeArray2 = attribute2.array;\n\t\n\t\t\t\t\tvar attributeSize = attribute2.itemSize;\n\t\n\t\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\t\n\t\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnormalizeNormals: function () {\n\t\n\t\t\t\tvar normals = this.attributes.normal.array;\n\t\n\t\t\t\tvar x, y, z, n;\n\t\n\t\t\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\t\n\t\t\t\t\tx = normals[ i ];\n\t\t\t\t\ty = normals[ i + 1 ];\n\t\t\t\t\tz = normals[ i + 2 ];\n\t\n\t\t\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\t\n\t\t\t\t\tnormals[ i ] *= n;\n\t\t\t\t\tnormals[ i + 1 ] *= n;\n\t\t\t\t\tnormals[ i + 2 ] *= n;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttoNonIndexed: function () {\n\t\n\t\t\t\tif ( this.index === null ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar geometry2 = new BufferGeometry();\n\t\n\t\t\t\tvar indices = this.index.array;\n\t\t\t\tvar attributes = this.attributes;\n\t\n\t\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\t\tvar attribute = attributes[ name ];\n\t\n\t\t\t\t\tvar array = attribute.array;\n\t\t\t\t\tvar itemSize = attribute.itemSize;\n\t\n\t\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\t\n\t\t\t\t\tvar index = 0, index2 = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tindex = indices[ i ] * itemSize;\n\t\n\t\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\t\n\t\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometry2;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\tvar data = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.4,\n\t\t\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\t// standard BufferGeometry serialization\n\t\n\t\t\t\tdata.uuid = this.uuid;\n\t\t\t\tdata.type = this.type;\n\t\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\t\tif ( this.parameters !== undefined ) {\n\t\n\t\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn data;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdata.data = { attributes: {} };\n\t\n\t\t\t\tvar index = this.index;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tvar array = Array.prototype.slice.call( index.array );\n\t\n\t\t\t\t\tdata.data.index = {\n\t\t\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\t\t\tarray: array\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attributes = this.attributes;\n\t\n\t\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\t\tvar attribute = attributes[ key ];\n\t\n\t\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\t\n\t\t\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\t\t\tarray: array,\n\t\t\t\t\t\tnormalized: attribute.normalized\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar groups = this.groups;\n\t\n\t\t\t\tif ( groups.length > 0 ) {\n\t\n\t\t\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar boundingSphere = this.boundingSphere;\n\t\n\t\t\t\tif ( boundingSphere !== null ) {\n\t\n\t\t\t\t\tdata.data.boundingSphere = {\n\t\t\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\t\t\tradius: boundingSphere.radius\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\t/*\n\t\t\t\t// Handle primitives\n\t\n\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\tif ( parameters !== undefined ) {\n\t\n\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\t\tvalues.push( parameters[ key ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\t\treturn geometry;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\t\t\t*/\n\t\n\t\t\t\treturn new BufferGeometry().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tvar index = source.index;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tthis.setIndex( index.clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attributes = source.attributes;\n\t\n\t\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\t\tvar attribute = attributes[ name ];\n\t\t\t\t\tthis.addAttribute( name, attribute.clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar groups = source.groups;\n\t\n\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tBufferGeometry.MaxIndex = 65535;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author jonobr1 / http://jonobr1.com/\n\t\t */\n\t\n\t\tfunction Mesh( geometry, material ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Mesh';\n\t\n\t\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\t\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t\t\tthis.drawMode = TrianglesDrawMode;\n\t\n\t\t\tthis.updateMorphTargets();\n\t\n\t\t}\n\t\n\t\tMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Mesh,\n\t\n\t\t\tisMesh: true,\n\t\n\t\t\tsetDrawMode: function ( value ) {\n\t\n\t\t\t\tthis.drawMode = value;\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.drawMode = source.drawMode;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tupdateMorphTargets: function () {\n\t\n\t\t\t\tvar morphTargets = this.geometry.morphTargets;\n\t\n\t\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\t\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\t\n\t\t\t\t\tfor ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {\n\t\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ morphTargets[ m ].name ] = m;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\t\tvar ray = new Ray();\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\tvar vA = new Vector3();\n\t\t\t\tvar vB = new Vector3();\n\t\t\t\tvar vC = new Vector3();\n\t\n\t\t\t\tvar tempA = new Vector3();\n\t\t\t\tvar tempB = new Vector3();\n\t\t\t\tvar tempC = new Vector3();\n\t\n\t\t\t\tvar uvA = new Vector2();\n\t\t\t\tvar uvB = new Vector2();\n\t\t\t\tvar uvC = new Vector2();\n\t\n\t\t\t\tvar barycoord = new Vector3();\n\t\n\t\t\t\tvar intersectionPoint = new Vector3();\n\t\t\t\tvar intersectionPointWorld = new Vector3();\n\t\n\t\t\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\t\n\t\t\t\t\tTriangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\t\n\t\t\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\t\t\tuv3.multiplyScalar( barycoord.z );\n\t\n\t\t\t\t\tuv1.add( uv2 ).add( uv3 );\n\t\n\t\t\t\t\treturn uv1.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\t\n\t\t\t\t\tvar intersect;\n\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\tif ( material.side === BackSide ) {\n\t\n\t\t\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( intersect === null ) return null;\n\t\n\t\t\t\t\tintersectionPointWorld.copy( point );\n\t\t\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\t\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\t\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\t\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\t\t\tobject: object\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\t\n\t\t\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\t\t\tvC.fromArray( positions, c * 3 );\n\t\n\t\t\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\t\n\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\tif ( uvs ) {\n\t\n\t\t\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\t\n\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tintersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );\n\t\t\t\t\t\tintersection.faceIndex = a;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn intersection;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tvar geometry = this.geometry;\n\t\t\t\t\tvar material = this.material;\n\t\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\n\t\t\t\t\tif ( material === undefined ) return;\n\t\n\t\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t\t//\n\t\n\t\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\t\t// Check boundingBox before continuing\n\t\n\t\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar uvs, intersection;\n\t\n\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\t\tvar a, b, c;\n\t\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\t\n\t\t\t\t\t\t\tuvs = attributes.uv.array;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\ta = indices[ i ];\n\t\t\t\t\t\t\t\tb = indices[ i + 1 ];\n\t\t\t\t\t\t\t\tc = indices[ i + 2 ];\n\t\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\t\n\t\t\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\n\t\n\t\t\t\t\t\t\t\ta = i / 3;\n\t\t\t\t\t\t\t\tb = a + 1;\n\t\t\t\t\t\t\t\tc = a + 2;\n\t\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\t\n\t\t\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\t\t\tvar isFaceMaterial = (material && material.isMultiMaterial);\n\t\t\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\t\n\t\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\t\n\t\t\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\t\n\t\t\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\t\t\tfvC = vertices[ face.c ];\n\t\n\t\t\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\t\n\t\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\t\n\t\t\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\t\n\t\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\t\n\t\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\t\n\t\t\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\t\n\t\t\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\t\t\tvC.add( fvC );\n\t\n\t\t\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\t\t\tfvC = vC;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\t\n\t\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\t\tif ( uvs ) {\n\t\n\t\t\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\t\n\t\t\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'BoxBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepth: depth,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tdepthSegments: depthSegments\n\t\t\t};\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\t// segments\n\t\t\twidthSegments = Math.floor( widthSegments ) || 1;\n\t\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\t\tdepthSegments = Math.floor( depthSegments ) || 1;\n\t\n\t\t\t// these are used to calculate buffer length\n\t\t\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\n\t\t\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\n\t\n\t\t\t// buffers\n\t\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\t\n\t\t\t// offset variables\n\t\t\tvar vertexBufferOffset = 0;\n\t\t\tvar uvBufferOffset = 0;\n\t\t\tvar indexBufferOffset = 0;\n\t\t\tvar numberOfVertices = 0;\n\t\n\t\t\t// group variables\n\t\t\tvar groupStart = 0;\n\t\n\t\t\t// build each side of the box geometry\n\t\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n\t\t\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n\t\t\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n\t\t\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n\t\t\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n\t\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\t\n\t\t\t// build geometry\n\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\t\n\t\t\t// helper functions\n\t\n\t\t\tfunction calculateVertexCount( w, h, d ) {\n\t\n\t\t\t\tvar vertices = 0;\n\t\n\t\t\t\t// calculate the amount of vertices for each side (plane)\n\t\t\t\tvertices += (w + 1) * (h + 1) * 2; // xy\n\t\t\t\tvertices += (w + 1) * (d + 1) * 2; // xz\n\t\t\t\tvertices += (d + 1) * (h + 1) * 2; // zy\n\t\n\t\t\t\treturn vertices;\n\t\n\t\t\t}\n\t\n\t\t\tfunction calculateIndexCount( w, h, d ) {\n\t\n\t\t\t\tvar index = 0;\n\t\n\t\t\t\t// calculate the amount of squares for each side\n\t\t\t\tindex += w * h * 2; // xy\n\t\t\t\tindex += w * d * 2; // xz\n\t\t\t\tindex += d * h * 2; // zy\n\t\n\t\t\t\treturn index * 6; // two triangles per square => six vertices per square\n\t\n\t\t\t}\n\t\n\t\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\t\n\t\t\t\tvar segmentWidth\t= width / gridX;\n\t\t\t\tvar segmentHeight = height / gridY;\n\t\n\t\t\t\tvar widthHalf = width / 2;\n\t\t\t\tvar heightHalf = height / 2;\n\t\t\t\tvar depthHalf = depth / 2;\n\t\n\t\t\t\tvar gridX1 = gridX + 1;\n\t\t\t\tvar gridY1 = gridY + 1;\n\t\n\t\t\t\tvar vertexCounter = 0;\n\t\t\t\tvar groupCount = 0;\n\t\n\t\t\t\tvar vector = new Vector3();\n\t\n\t\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\t\n\t\t\t\t\tvar y = iy * segmentHeight - heightHalf;\n\t\n\t\t\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\t\n\t\t\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\t\n\t\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\t\tvector[ w ] = depthHalf;\n\t\n\t\t\t\t\t\t// now apply vector to vertex buffer\n\t\t\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\n\t\n\t\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\t\n\t\t\t\t\t\t// now apply vector to normal buffer\n\t\t\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\n\t\n\t\t\t\t\t\t// uvs\n\t\t\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\n\t\t\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\n\t\n\t\t\t\t\t\t// update offsets and counters\n\t\t\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\t\t\tuvBufferOffset += 2;\n\t\t\t\t\t\tvertexCounter += 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// 1. you need three indices to draw a single face\n\t\t\t\t// 2. a single segment consists of two faces\n\t\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\t\n\t\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\t\n\t\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\t\n\t\t\t\t\t\t// indices\n\t\t\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\t\n\t\t\t\t\t\t// face one\n\t\t\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\t\n\t\t\t\t\t\t// face two\n\t\t\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\t\n\t\t\t\t\t\t// update offsets and counters\n\t\t\t\t\t\tindexBufferOffset += 6;\n\t\t\t\t\t\tgroupCount += 6;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\t\n\t\t\t\t// calculate new start value for groups\n\t\t\t\tgroupStart += groupCount;\n\t\n\t\t\t\t// update total number of vertices\n\t\t\t\tnumberOfVertices += vertexCounter;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t\t */\n\t\n\t\tfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'PlaneBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments\n\t\t\t};\n\t\n\t\t\tvar width_half = width / 2;\n\t\t\tvar height_half = height / 2;\n\t\n\t\t\tvar gridX = Math.floor( widthSegments ) || 1;\n\t\t\tvar gridY = Math.floor( heightSegments ) || 1;\n\t\n\t\t\tvar gridX1 = gridX + 1;\n\t\t\tvar gridY1 = gridY + 1;\n\t\n\t\t\tvar segment_width = width / gridX;\n\t\t\tvar segment_height = height / gridY;\n\t\n\t\t\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\n\t\t\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\n\t\t\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\n\t\n\t\t\tvar offset = 0;\n\t\t\tvar offset2 = 0;\n\t\n\t\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\t\n\t\t\t\tvar y = iy * segment_height - height_half;\n\t\n\t\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\t\n\t\t\t\t\tvar x = ix * segment_width - width_half;\n\t\n\t\t\t\t\tvertices[ offset ] = x;\n\t\t\t\t\tvertices[ offset + 1 ] = - y;\n\t\n\t\t\t\t\tnormals[ offset + 2 ] = 1;\n\t\n\t\t\t\t\tuvs[ offset2 ] = ix / gridX;\n\t\t\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\n\t\n\t\t\t\t\toffset += 3;\n\t\t\t\t\toffset2 += 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\toffset = 0;\n\t\n\t\t\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\n\t\n\t\t\tfor ( var iy = 0; iy < gridY; iy ++ ) {\n\t\n\t\t\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\n\t\n\t\t\t\t\tvar a = ix + gridX1 * iy;\n\t\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\t\n\t\t\t\t\tindices[ offset ] = a;\n\t\t\t\t\tindices[ offset + 1 ] = b;\n\t\t\t\t\tindices[ offset + 2 ] = d;\n\t\n\t\t\t\t\tindices[ offset + 3 ] = b;\n\t\t\t\t\tindices[ offset + 4 ] = c;\n\t\t\t\t\tindices[ offset + 5 ] = d;\n\t\n\t\t\t\t\toffset += 6;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\t\n\t\t}\n\t\n\t\tPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t*/\n\t\n\t\tfunction Camera() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Camera';\n\t\n\t\t\tthis.matrixWorldInverse = new Matrix4();\n\t\t\tthis.projectionMatrix = new Matrix4();\n\t\n\t\t}\n\t\n\t\tCamera.prototype = Object.create( Object3D.prototype );\n\t\tCamera.prototype.constructor = Camera;\n\t\n\t\tCamera.prototype.isCamera = true;\n\t\n\t\tCamera.prototype.getWorldDirection = function () {\n\t\n\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\treturn function getWorldDirection( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\tCamera.prototype.lookAt = function () {\n\t\n\t\t\t// This routine does not support cameras with rotated and/or translated parent(s)\n\t\n\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\tm1.lookAt( this.position, vector, this.up );\n\t\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\tCamera.prototype.clone = function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t};\n\t\n\t\tCamera.prototype.copy = function ( source ) {\n\t\n\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\t\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author greggman / http://games.greggman.com/\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction PerspectiveCamera( fov, aspect, near, far ) {\n\t\n\t\t\tCamera.call( this );\n\t\n\t\t\tthis.type = 'PerspectiveCamera';\n\t\n\t\t\tthis.fov = fov !== undefined ? fov : 50;\n\t\t\tthis.zoom = 1;\n\t\n\t\t\tthis.near = near !== undefined ? near : 0.1;\n\t\t\tthis.far = far !== undefined ? far : 2000;\n\t\t\tthis.focus = 10;\n\t\n\t\t\tthis.aspect = aspect !== undefined ? aspect : 1;\n\t\t\tthis.view = null;\n\t\n\t\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\t\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t}\n\t\n\t\tPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\t\n\t\t\tconstructor: PerspectiveCamera,\n\t\n\t\t\tisPerspectiveCamera: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tCamera.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.fov = source.fov;\n\t\t\t\tthis.zoom = source.zoom;\n\t\n\t\t\t\tthis.near = source.near;\n\t\t\t\tthis.far = source.far;\n\t\t\t\tthis.focus = source.focus;\n\t\n\t\t\t\tthis.aspect = source.aspect;\n\t\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\t\n\t\t\t\tthis.filmGauge = source.filmGauge;\n\t\t\t\tthis.filmOffset = source.filmOffset;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t\t\t *\n\t\t\t * The default film gauge is 35, so that the focal length can be specified for\n\t\t\t * a 35mm (full frame) camera.\n\t\t\t *\n\t\t\t * Values for focal length and film gauge must have the same unit.\n\t\t\t */\n\t\t\tsetFocalLength: function ( focalLength ) {\n\t\n\t\t\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\t\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\t\n\t\t\t\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Calculates the focal length from the current .fov and .filmGauge.\n\t\t\t */\n\t\t\tgetFocalLength: function () {\n\t\n\t\t\t\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\n\t\n\t\t\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\t\n\t\t\t},\n\t\n\t\t\tgetEffectiveFOV: function () {\n\t\n\t\t\t\treturn _Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\t\t\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\t\n\t\t\t},\n\t\n\t\t\tgetFilmWidth: function () {\n\t\n\t\t\t\t// film not completely covered in portrait format (aspect < 1)\n\t\t\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\t\n\t\t\t},\n\t\n\t\t\tgetFilmHeight: function () {\n\t\n\t\t\t\t// film not completely covered in landscape format (aspect > 1)\n\t\t\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\t\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t\t\t * multi-monitor/multi-machine setups.\n\t\t\t *\n\t\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t\t\t * the monitors are in grid like this\n\t\t\t *\n\t\t\t *   +---+---+---+\n\t\t\t *   | A | B | C |\n\t\t\t *   +---+---+---+\n\t\t\t *   | D | E | F |\n\t\t\t *   +---+---+---+\n\t\t\t *\n\t\t\t * then for each monitor you would call it like this\n\t\t\t *\n\t\t\t *   var w = 1920;\n\t\t\t *   var h = 1080;\n\t\t\t *   var fullWidth = w * 3;\n\t\t\t *   var fullHeight = h * 2;\n\t\t\t *\n\t\t\t *   --A--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t\t\t *   --B--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t\t\t *   --C--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t\t\t *   --D--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t\t\t *   --E--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t\t\t *   --F--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t\t\t *\n\t\t\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t\t\t */\n\t\t\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\t\n\t\t\t\tthis.aspect = fullWidth / fullHeight;\n\t\n\t\t\t\tthis.view = {\n\t\t\t\t\tfullWidth: fullWidth,\n\t\t\t\t\tfullHeight: fullHeight,\n\t\t\t\t\toffsetX: x,\n\t\t\t\t\toffsetY: y,\n\t\t\t\t\twidth: width,\n\t\t\t\t\theight: height\n\t\t\t\t};\n\t\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\tclearViewOffset: function() {\n\t\n\t\t\t\tthis.view = null;\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\tupdateProjectionMatrix: function () {\n\t\n\t\t\t\tvar near = this.near,\n\t\t\t\t\ttop = near * Math.tan(\n\t\t\t\t\t\t\t_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\t\t\theight = 2 * top,\n\t\t\t\t\twidth = this.aspect * height,\n\t\t\t\t\tleft = - 0.5 * width,\n\t\t\t\t\tview = this.view;\n\t\n\t\t\t\tif ( view !== null ) {\n\t\n\t\t\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\t\t\tfullHeight = view.fullHeight;\n\t\n\t\t\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\t\t\twidth *= view.width / fullWidth;\n\t\t\t\t\theight *= view.height / fullHeight;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar skew = this.filmOffset;\n\t\t\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\t\n\t\t\t\tthis.projectionMatrix.makeFrustum(\n\t\t\t\t\t\tleft, left + width, top - height, top, near, this.far );\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.fov = this.fov;\n\t\t\t\tdata.object.zoom = this.zoom;\n\t\n\t\t\t\tdata.object.near = this.near;\n\t\t\t\tdata.object.far = this.far;\n\t\t\t\tdata.object.focus = this.focus;\n\t\n\t\t\t\tdata.object.aspect = this.aspect;\n\t\n\t\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\t\n\t\t\t\tdata.object.filmGauge = this.filmGauge;\n\t\t\t\tdata.object.filmOffset = this.filmOffset;\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author arose / http://github.com/arose\n\t\t */\n\t\n\t\tfunction OrthographicCamera( left, right, top, bottom, near, far ) {\n\t\n\t\t\tCamera.call( this );\n\t\n\t\t\tthis.type = 'OrthographicCamera';\n\t\n\t\t\tthis.zoom = 1;\n\t\t\tthis.view = null;\n\t\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t\tthis.top = top;\n\t\t\tthis.bottom = bottom;\n\t\n\t\t\tthis.near = ( near !== undefined ) ? near : 0.1;\n\t\t\tthis.far = ( far !== undefined ) ? far : 2000;\n\t\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t}\n\t\n\t\tOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\t\n\t\t\tconstructor: OrthographicCamera,\n\t\n\t\t\tisOrthographicCamera: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tCamera.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.left = source.left;\n\t\t\t\tthis.right = source.right;\n\t\t\t\tthis.top = source.top;\n\t\t\t\tthis.bottom = source.bottom;\n\t\t\t\tthis.near = source.near;\n\t\t\t\tthis.far = source.far;\n\t\n\t\t\t\tthis.zoom = source.zoom;\n\t\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\t\n\t\t\t\tthis.view = {\n\t\t\t\t\tfullWidth: fullWidth,\n\t\t\t\t\tfullHeight: fullHeight,\n\t\t\t\t\toffsetX: x,\n\t\t\t\t\toffsetY: y,\n\t\t\t\t\twidth: width,\n\t\t\t\t\theight: height\n\t\t\t\t};\n\t\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\tclearViewOffset: function() {\n\t\n\t\t\t\tthis.view = null;\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\tupdateProjectionMatrix: function () {\n\t\n\t\t\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\t\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\t\t\tvar cx = ( this.right + this.left ) / 2;\n\t\t\t\tvar cy = ( this.top + this.bottom ) / 2;\n\t\n\t\t\t\tvar left = cx - dx;\n\t\t\t\tvar right = cx + dx;\n\t\t\t\tvar top = cy + dy;\n\t\t\t\tvar bottom = cy - dy;\n\t\n\t\t\t\tif ( this.view !== null ) {\n\t\n\t\t\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\t\n\t\t\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.zoom = this.zoom;\n\t\t\t\tdata.object.left = this.left;\n\t\t\t\tdata.object.right = this.right;\n\t\t\t\tdata.object.top = this.top;\n\t\t\t\tdata.object.bottom = this.bottom;\n\t\t\t\tdata.object.near = this.near;\n\t\t\t\tdata.object.far = this.far;\n\t\n\t\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {\n\t\n\t\t\tvar mode;\n\t\n\t\t\tfunction setMode( value ) {\n\t\n\t\t\t\tmode = value;\n\t\n\t\t\t}\n\t\n\t\t\tvar type, size;\n\t\n\t\t\tfunction setIndex( index ) {\n\t\n\t\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\t\n\t\t\t\t\ttype = gl.UNSIGNED_INT;\n\t\t\t\t\tsize = 4;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\t\t\t\t\tsize = 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction render( start, count ) {\n\t\n\t\t\t\tgl.drawElements( mode, count, type, start * size );\n\t\n\t\t\t\tinfoRender.calls ++;\n\t\t\t\tinfoRender.vertices += count;\n\t\n\t\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\t\n\t\t\t}\n\t\n\t\t\tfunction renderInstances( geometry, start, count ) {\n\t\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\t\n\t\t\t\tinfoRender.calls ++;\n\t\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\t\n\t\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tsetMode: setMode,\n\t\t\t\tsetIndex: setIndex,\n\t\t\t\trender: render,\n\t\t\t\trenderInstances: renderInstances\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLBufferRenderer( gl, extensions, infoRender ) {\n\t\n\t\t\tvar mode;\n\t\n\t\t\tfunction setMode( value ) {\n\t\n\t\t\t\tmode = value;\n\t\n\t\t\t}\n\t\n\t\t\tfunction render( start, count ) {\n\t\n\t\t\t\tgl.drawArrays( mode, start, count );\n\t\n\t\t\t\tinfoRender.calls ++;\n\t\t\t\tinfoRender.vertices += count;\n\t\n\t\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\t\n\t\t\t}\n\t\n\t\t\tfunction renderInstances( geometry ) {\n\t\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar position = geometry.attributes.position;\n\t\n\t\t\t\tvar count = 0;\n\t\n\t\t\t\tif ( (position && position.isInterleavedBufferAttribute) ) {\n\t\n\t\t\t\t\tcount = position.data.count;\n\t\n\t\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tcount = position.count;\n\t\n\t\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tinfoRender.calls ++;\n\t\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\t\n\t\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tsetMode: setMode,\n\t\t\t\trender: render,\n\t\t\t\trenderInstances: renderInstances\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLLights() {\n\t\n\t\t\tvar lights = {};\n\t\n\t\t\treturn {\n\t\n\t\t\t\tget: function ( light ) {\n\t\n\t\t\t\t\tif ( lights[ light.id ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn lights[ light.id ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar uniforms;\n\t\n\t\t\t\t\tswitch ( light.type ) {\n\t\n\t\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\t\tcolor: new Color(),\n\t\n\t\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\t\t\tdecay: 0,\n\t\n\t\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\t\tdecay: 0,\n\t\n\t\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tlights[ light.id ] = uniforms;\n\t\n\t\t\t\t\treturn uniforms;\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction addLineNumbers( string ) {\n\t\n\t\t\tvar lines = string.split( '\\n' );\n\t\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\t\n\t\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn lines.join( '\\n' );\n\t\n\t\t}\n\t\n\t\tfunction WebGLShader( gl, type, string ) {\n\t\n\t\t\tvar shader = gl.createShader( type );\n\t\n\t\t\tgl.shaderSource( shader, string );\n\t\t\tgl.compileShader( shader );\n\t\n\t\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\t\n\t\t\t}\n\t\n\t\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\t\n\t\t\t}\n\t\n\t\t\t// --enable-privileged-webgl-extension\n\t\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\t\n\t\t\treturn shader;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tvar programIdCount = 0;\n\t\n\t\tfunction getEncodingComponents( encoding ) {\n\t\n\t\t\tswitch ( encoding ) {\n\t\n\t\t\t\tcase LinearEncoding:\n\t\t\t\t\treturn [ 'Linear','( value )' ];\n\t\t\t\tcase sRGBEncoding:\n\t\t\t\t\treturn [ 'sRGB','( value )' ];\n\t\t\t\tcase RGBEEncoding:\n\t\t\t\t\treturn [ 'RGBE','( value )' ];\n\t\t\t\tcase RGBM7Encoding:\n\t\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\n\t\t\t\tcase RGBM16Encoding:\n\t\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\n\t\t\t\tcase RGBDEncoding:\n\t\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\n\t\t\t\tcase GammaEncoding:\n\t\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\t\n\t\t\tvar components = getEncodingComponents( encoding );\n\t\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\t\n\t\t}\n\t\n\t\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\t\n\t\t\tvar components = getEncodingComponents( encoding );\n\t\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\t\n\t\t}\n\t\n\t\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\t\n\t\t\tvar toneMappingName;\n\t\n\t\t\tswitch ( toneMapping ) {\n\t\n\t\t\t\tcase LinearToneMapping:\n\t\t\t\t\ttoneMappingName = \"Linear\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase ReinhardToneMapping:\n\t\t\t\t\ttoneMappingName = \"Reinhard\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase Uncharted2ToneMapping:\n\t\t\t\t\ttoneMappingName = \"Uncharted2\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase CineonToneMapping:\n\t\t\t\t\ttoneMappingName = \"OptimizedCineon\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\t\n\t\t\t}\n\t\n\t\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\t\n\t\t}\n\t\n\t\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\t\n\t\t\textensions = extensions || {};\n\t\n\t\t\tvar chunks = [\n\t\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\n\t\t\t];\n\t\n\t\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t}\n\t\n\t\tfunction generateDefines( defines ) {\n\t\n\t\t\tvar chunks = [];\n\t\n\t\t\tfor ( var name in defines ) {\n\t\n\t\t\t\tvar value = defines[ name ];\n\t\n\t\t\t\tif ( value === false ) continue;\n\t\n\t\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\t\n\t\t\t}\n\t\n\t\t\treturn chunks.join( '\\n' );\n\t\n\t\t}\n\t\n\t\tfunction fetchAttributeLocations( gl, program, identifiers ) {\n\t\n\t\t\tvar attributes = {};\n\t\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\t\n\t\t\tfor ( var i = 0; i < n; i ++ ) {\n\t\n\t\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\t\tvar name = info.name;\n\t\n\t\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\t\n\t\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\t\n\t\t\t}\n\t\n\t\t\treturn attributes;\n\t\n\t\t}\n\t\n\t\tfunction filterEmptyLine( string ) {\n\t\n\t\t\treturn string !== '';\n\t\n\t\t}\n\t\n\t\tfunction replaceLightNums( string, parameters ) {\n\t\n\t\t\treturn string\n\t\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\t\n\t\t}\n\t\n\t\tfunction parseIncludes( string ) {\n\t\n\t\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\n\t\n\t\t\tfunction replace( match, include ) {\n\t\n\t\t\t\tvar replace = ShaderChunk[ include ];\n\t\n\t\t\t\tif ( replace === undefined ) {\n\t\n\t\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn parseIncludes( replace );\n\t\n\t\t\t}\n\t\n\t\t\treturn string.replace( pattern, replace );\n\t\n\t\t}\n\t\n\t\tfunction unrollLoops( string ) {\n\t\n\t\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\t\n\t\t\tfunction replace( match, start, end, snippet ) {\n\t\n\t\t\t\tvar unroll = '';\n\t\n\t\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\t\n\t\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn unroll;\n\t\n\t\t\t}\n\t\n\t\t\treturn string.replace( pattern, replace );\n\t\n\t\t}\n\t\n\t\tfunction WebGLProgram( renderer, code, material, parameters ) {\n\t\n\t\t\tvar gl = renderer.context;\n\t\n\t\t\tvar extensions = material.extensions;\n\t\t\tvar defines = material.defines;\n\t\n\t\t\tvar vertexShader = material.__webglShader.vertexShader;\n\t\t\tvar fragmentShader = material.__webglShader.fragmentShader;\n\t\n\t\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\t\n\t\t\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\t\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\t\n\t\t\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\t\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\t\n\t\t\t}\n\t\n\t\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\n\t\t\tif ( parameters.envMap ) {\n\t\n\t\t\t\tswitch ( material.envMap.mapping ) {\n\t\n\t\t\t\t\tcase CubeReflectionMapping:\n\t\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase CubeUVReflectionMapping:\n\t\t\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase EquirectangularReflectionMapping:\n\t\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase SphericalReflectionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tswitch ( material.envMap.mapping ) {\n\t\n\t\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tswitch ( material.combine ) {\n\t\n\t\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase MixOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase AddOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\t\n\t\t\t// console.log( 'building new program ' );\n\t\n\t\t\t//\n\t\n\t\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\t\n\t\t\tvar customDefines = generateDefines( defines );\n\t\n\t\t\t//\n\t\n\t\t\tvar program = gl.createProgram();\n\t\n\t\t\tvar prefixVertex, prefixFragment;\n\t\n\t\t\tif ( material.isRawShaderMaterial ) {\n\t\n\t\t\t\tprefixVertex = [\n\t\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t\tprefixFragment = [\n\t\n\t\t\t\t\tcustomExtensions,\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tprefixVertex = [\n\t\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\n\t\n\t\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\t\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\t\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\t\n\t\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\t\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\t\n\t\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\t\n\t\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\t\n\t\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\t\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\t\n\t\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\t\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\t\n\t\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t\t'uniform vec3 cameraPosition;',\n\t\n\t\t\t\t\t'attribute vec3 position;',\n\t\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t\t'attribute vec2 uv;',\n\t\n\t\t\t\t\t'#ifdef USE_COLOR',\n\t\n\t\t\t\t\t'\tattribute vec3 color;',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\t\n\t\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t\t'\tattribute vec3 morphTarget3;',\n\t\n\t\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\t\n\t\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\t\n\t\t\t\t\t'\t#else',\n\t\n\t\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\t\n\t\t\t\t\t'\t#endif',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef USE_SKINNING',\n\t\n\t\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t\t'\tattribute vec4 skinWeight;',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t\tprefixFragment = [\n\t\n\t\t\t\t\tcustomExtensions,\n\t\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\n\t\n\t\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\t\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\t\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\t\n\t\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\t\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\t\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\t\n\t\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\t\t\t\t\t'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),\n\t\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\t\n\t\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\t\n\t\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\t\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\t\n\t\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\t\n\t\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t\t'uniform vec3 cameraPosition;',\n\t\n\t\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n\t\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\t\n\t\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\t\n\t\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t}\n\t\n\t\t\tvertexShader = parseIncludes( vertexShader, parameters );\n\t\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\t\n\t\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\n\t\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\t\n\t\t\tif ( ! material.isShaderMaterial ) {\n\t\n\t\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\t\n\t\t\t}\n\t\n\t\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\t\n\t\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\t\n\t\t\tvar glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\t\tvar glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\t\n\t\t\tgl.attachShader( program, glVertexShader );\n\t\t\tgl.attachShader( program, glFragmentShader );\n\t\n\t\t\t// Force a particular attribute to index 0.\n\t\n\t\t\tif ( material.index0AttributeName !== undefined ) {\n\t\n\t\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\t\n\t\t\t} else if ( parameters.morphTargets === true ) {\n\t\n\t\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\t\n\t\t\t}\n\t\n\t\t\tgl.linkProgram( program );\n\t\n\t\t\tvar programLog = gl.getProgramInfoLog( program );\n\t\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\n\t\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\t\n\t\t\tvar runnable = true;\n\t\t\tvar haveDiagnostics = true;\n\t\n\t\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\t\n\t\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\t\n\t\t\t\trunnable = false;\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\t\n\t\t\t} else if ( programLog !== '' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\t\n\t\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\t\n\t\t\t\thaveDiagnostics = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( haveDiagnostics ) {\n\t\n\t\t\t\tthis.diagnostics = {\n\t\n\t\t\t\t\trunnable: runnable,\n\t\t\t\t\tmaterial: material,\n\t\n\t\t\t\t\tprogramLog: programLog,\n\t\n\t\t\t\t\tvertexShader: {\n\t\n\t\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\t\tprefix: prefixVertex\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfragmentShader: {\n\t\n\t\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\t\tprefix: prefixFragment\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t// clean up\n\t\n\t\t\tgl.deleteShader( glVertexShader );\n\t\t\tgl.deleteShader( glFragmentShader );\n\t\n\t\t\t// set up caching for uniform locations\n\t\n\t\t\tvar cachedUniforms;\n\t\n\t\t\tthis.getUniforms = function() {\n\t\n\t\t\t\tif ( cachedUniforms === undefined ) {\n\t\n\t\t\t\t\tcachedUniforms =\n\t\t\t\t\t\t\tnew WebGLUniforms( gl, program, renderer );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn cachedUniforms;\n\t\n\t\t\t};\n\t\n\t\t\t// set up caching for attribute locations\n\t\n\t\t\tvar cachedAttributes;\n\t\n\t\t\tthis.getAttributes = function() {\n\t\n\t\t\t\tif ( cachedAttributes === undefined ) {\n\t\n\t\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn cachedAttributes;\n\t\n\t\t\t};\n\t\n\t\t\t// free resource\n\t\n\t\t\tthis.destroy = function() {\n\t\n\t\t\t\tgl.deleteProgram( program );\n\t\t\t\tthis.program = undefined;\n\t\n\t\t\t};\n\t\n\t\t\t// DEPRECATED\n\t\n\t\t\tObject.defineProperties( this, {\n\t\n\t\t\t\tuniforms: {\n\t\t\t\t\tget: function() {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\t\treturn this.getUniforms();\n\t\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\tattributes: {\n\t\t\t\t\tget: function() {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\t\treturn this.getAttributes();\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t} );\n\t\n\t\n\t\t\t//\n\t\n\t\t\tthis.id = programIdCount ++;\n\t\t\tthis.code = code;\n\t\t\tthis.usedTimes = 1;\n\t\t\tthis.program = program;\n\t\t\tthis.vertexShader = glVertexShader;\n\t\t\tthis.fragmentShader = glFragmentShader;\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLPrograms( renderer, capabilities ) {\n\t\n\t\t\tvar programs = [];\n\t\n\t\t\tvar shaderIDs = {\n\t\t\t\tMeshDepthMaterial: 'depth',\n\t\t\t\tMeshNormalMaterial: 'normal',\n\t\t\t\tMeshBasicMaterial: 'basic',\n\t\t\t\tMeshLambertMaterial: 'lambert',\n\t\t\t\tMeshPhongMaterial: 'phong',\n\t\t\t\tMeshStandardMaterial: 'physical',\n\t\t\t\tMeshPhysicalMaterial: 'physical',\n\t\t\t\tLineBasicMaterial: 'basic',\n\t\t\t\tLineDashedMaterial: 'dashed',\n\t\t\t\tPointsMaterial: 'points'\n\t\t\t};\n\t\n\t\t\tvar parameterNames = [\n\t\t\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\t\t\"roughnessMap\", \"metalnessMap\",\n\t\t\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\n\t\t\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"numClipIntersection\", \"depthPacking\"\n\t\t\t];\n\t\n\t\n\t\t\tfunction allocateBones( object ) {\n\t\n\t\t\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\t\n\t\t\t\t\treturn 1024;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// default for when object is not specified\n\t\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t\t\t//\n\t\t\t\t\t//  - leave some extra space for other uniforms\n\t\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t\t\t//    (up to 54 should be safe)\n\t\n\t\t\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\t\n\t\t\t\t\tvar maxBones = nVertexMatrices;\n\t\n\t\t\t\t\tif ( object !== undefined && (object && object.isSkinnedMesh) ) {\n\t\n\t\t\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\n\t\n\t\t\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn maxBones;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\t\n\t\t\t\tvar encoding;\n\t\n\t\t\t\tif ( ! map ) {\n\t\n\t\t\t\t\tencoding = LinearEncoding;\n\t\n\t\t\t\t} else if ( (map && map.isTexture) ) {\n\t\n\t\t\t\t\tencoding = map.encoding;\n\t\n\t\t\t\t} else if ( (map && map.isWebGLRenderTarget) ) {\n\t\n\t\t\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\tencoding = map.texture.encoding;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\t\t\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\n\t\n\t\t\t\t\tencoding = GammaEncoding;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn encoding;\n\t\n\t\t\t}\n\t\n\t\t\tthis.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {\n\t\n\t\t\t\tvar shaderID = shaderIDs[ material.type ];\n\t\n\t\t\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t\t\t// (not to blow over maxLights budget)\n\t\n\t\t\t\tvar maxBones = allocateBones( object );\n\t\t\t\tvar precision = renderer.getPrecision();\n\t\n\t\t\t\tif ( material.precision !== null ) {\n\t\n\t\t\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\t\n\t\t\t\t\tif ( precision !== material.precision ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\n\t\n\t\t\t\tvar parameters = {\n\t\n\t\t\t\t\tshaderID: shaderID,\n\t\n\t\t\t\t\tprecision: precision,\n\t\t\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\t\t\tmap: !! material.map,\n\t\t\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\t\t\tenvMap: !! material.envMap,\n\t\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\n\t\t\t\t\tlightMap: !! material.lightMap,\n\t\t\t\t\taoMap: !! material.aoMap,\n\t\t\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\t\t\tbumpMap: !! material.bumpMap,\n\t\t\t\t\tnormalMap: !! material.normalMap,\n\t\t\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\t\t\tspecularMap: !! material.specularMap,\n\t\t\t\t\talphaMap: !! material.alphaMap,\n\t\n\t\t\t\t\tcombine: material.combine,\n\t\n\t\t\t\t\tvertexColors: material.vertexColors,\n\t\n\t\t\t\t\tfog: !! fog,\n\t\t\t\t\tuseFog: material.fog,\n\t\t\t\t\tfogExp: (fog && fog.isFogExp2),\n\t\n\t\t\t\t\tflatShading: material.shading === FlatShading,\n\t\n\t\t\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\t\n\t\t\t\t\tskinning: material.skinning,\n\t\t\t\t\tmaxBones: maxBones,\n\t\t\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\t\n\t\t\t\t\tmorphTargets: material.morphTargets,\n\t\t\t\t\tmorphNormals: material.morphNormals,\n\t\t\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\t\n\t\t\t\t\tnumDirLights: lights.directional.length,\n\t\t\t\t\tnumPointLights: lights.point.length,\n\t\t\t\t\tnumSpotLights: lights.spot.length,\n\t\t\t\t\tnumHemiLights: lights.hemi.length,\n\t\n\t\t\t\t\tnumClippingPlanes: nClipPlanes,\n\t\t\t\t\tnumClipIntersection: nClipIntersection,\n\t\n\t\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n\t\t\t\t\tshadowMapType: renderer.shadowMap.type,\n\t\n\t\t\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\t\n\t\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\t\n\t\t\t\t\talphaTest: material.alphaTest,\n\t\t\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\t\t\tflipSided: material.side === BackSide,\n\t\n\t\t\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\t\n\t\t\t\t};\n\t\n\t\t\t\treturn parameters;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getProgramCode = function ( material, parameters ) {\n\t\n\t\t\t\tvar array = [];\n\t\n\t\t\t\tif ( parameters.shaderID ) {\n\t\n\t\t\t\t\tarray.push( parameters.shaderID );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tarray.push( material.fragmentShader );\n\t\t\t\t\tarray.push( material.vertexShader );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.defines !== undefined ) {\n\t\n\t\t\t\t\tfor ( var name in material.defines ) {\n\t\n\t\t\t\t\t\tarray.push( name );\n\t\t\t\t\t\tarray.push( material.defines[ name ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\t\n\t\t\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn array.join();\n\t\n\t\t\t};\n\t\n\t\t\tthis.acquireProgram = function ( material, parameters, code ) {\n\t\n\t\t\t\tvar program;\n\t\n\t\t\t\t// Check if code has been already compiled\n\t\t\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\t\n\t\t\t\t\tvar programInfo = programs[ p ];\n\t\n\t\t\t\t\tif ( programInfo.code === code ) {\n\t\n\t\t\t\t\t\tprogram = programInfo;\n\t\t\t\t\t\t++ program.usedTimes;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t\tprogram = new WebGLProgram( renderer, code, material, parameters );\n\t\t\t\t\tprograms.push( program );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn program;\n\t\n\t\t\t};\n\t\n\t\t\tthis.releaseProgram = function( program ) {\n\t\n\t\t\t\tif ( -- program.usedTimes === 0 ) {\n\t\n\t\t\t\t\t// Remove from unordered set\n\t\t\t\t\tvar i = programs.indexOf( program );\n\t\t\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\t\t\tprograms.pop();\n\t\n\t\t\t\t\t// Free WebGL resources\n\t\t\t\t\tprogram.destroy();\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\t\tthis.programs = programs;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLGeometries( gl, properties, info ) {\n\t\n\t\t\tvar geometries = {};\n\t\n\t\t\tfunction onGeometryDispose( event ) {\n\t\n\t\t\t\tvar geometry = event.target;\n\t\t\t\tvar buffergeometry = geometries[ geometry.id ];\n\t\n\t\t\t\tif ( buffergeometry.index !== null ) {\n\t\n\t\t\t\t\tdeleteAttribute( buffergeometry.index );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdeleteAttributes( buffergeometry.attributes );\n\t\n\t\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\t\n\t\t\t\tdelete geometries[ geometry.id ];\n\t\n\t\t\t\t// TODO\n\t\n\t\t\t\tvar property = properties.get( geometry );\n\t\n\t\t\t\tif ( property.wireframe ) {\n\t\n\t\t\t\t\tdeleteAttribute( property.wireframe );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tproperties.delete( geometry );\n\t\n\t\t\t\tvar bufferproperty = properties.get( buffergeometry );\n\t\n\t\t\t\tif ( bufferproperty.wireframe ) {\n\t\n\t\t\t\t\tdeleteAttribute( bufferproperty.wireframe );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tproperties.delete( buffergeometry );\n\t\n\t\t\t\t//\n\t\n\t\t\t\tinfo.memory.geometries --;\n\t\n\t\t\t}\n\t\n\t\t\tfunction getAttributeBuffer( attribute ) {\n\t\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\t\n\t\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn properties.get( attribute ).__webglBuffer;\n\t\n\t\t\t}\n\t\n\t\t\tfunction deleteAttribute( attribute ) {\n\t\n\t\t\t\tvar buffer = getAttributeBuffer( attribute );\n\t\n\t\t\t\tif ( buffer !== undefined ) {\n\t\n\t\t\t\t\tgl.deleteBuffer( buffer );\n\t\t\t\t\tremoveAttributeBuffer( attribute );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction deleteAttributes( attributes ) {\n\t\n\t\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\t\tdeleteAttribute( attributes[ name ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction removeAttributeBuffer( attribute ) {\n\t\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\t\n\t\t\t\t\tproperties.delete( attribute.data );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tproperties.delete( attribute );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tget: function ( object ) {\n\t\n\t\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\t\tif ( geometries[ geometry.id ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn geometries[ geometry.id ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\t\n\t\t\t\t\tvar buffergeometry;\n\t\n\t\t\t\t\tif ( geometry.isBufferGeometry ) {\n\t\n\t\t\t\t\t\tbuffergeometry = geometry;\n\t\n\t\t\t\t\t} else if ( geometry.isGeometry ) {\n\t\n\t\t\t\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\t\n\t\t\t\t\t\t\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbuffergeometry = geometry._bufferGeometry;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometries[ geometry.id ] = buffergeometry;\n\t\n\t\t\t\t\tinfo.memory.geometries ++;\n\t\n\t\t\t\t\treturn buffergeometry;\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLObjects( gl, properties, info ) {\n\t\n\t\t\tvar geometries = new WebGLGeometries( gl, properties, info );\n\t\n\t\t\t//\n\t\n\t\t\tfunction update( object ) {\n\t\n\t\t\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\t\n\t\t\t\tvar geometry = geometries.get( object );\n\t\n\t\t\t\tif ( object.geometry.isGeometry ) {\n\t\n\t\t\t\t\tgeometry.updateFromObject( object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// morph targets\n\t\n\t\t\t\tvar morphAttributes = geometry.morphAttributes;\n\t\n\t\t\t\tfor ( var name in morphAttributes ) {\n\t\n\t\t\t\t\tvar array = morphAttributes[ name ];\n\t\n\t\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometry;\n\t\n\t\t\t}\n\t\n\t\t\tfunction updateAttribute( attribute, bufferType ) {\n\t\n\t\t\t\tvar data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;\n\t\n\t\t\t\tvar attributeProperties = properties.get( data );\n\t\n\t\t\t\tif ( attributeProperties.__webglBuffer === undefined ) {\n\t\n\t\t\t\t\tcreateBuffer( attributeProperties, data, bufferType );\n\t\n\t\t\t\t} else if ( attributeProperties.version !== data.version ) {\n\t\n\t\t\t\t\tupdateBuffer( attributeProperties, data, bufferType );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction createBuffer( attributeProperties, data, bufferType ) {\n\t\n\t\t\t\tattributeProperties.__webglBuffer = gl.createBuffer();\n\t\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\t\n\t\t\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\t\n\t\t\t\tgl.bufferData( bufferType, data.array, usage );\n\t\n\t\t\t\tattributeProperties.version = data.version;\n\t\n\t\t\t}\n\t\n\t\t\tfunction updateBuffer( attributeProperties, data, bufferType ) {\n\t\n\t\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\t\n\t\t\t\tif ( data.dynamic === false ) {\n\t\n\t\t\t\t\tgl.bufferData( bufferType, data.array, gl.STATIC_DRAW );\n\t\n\t\t\t\t} else if ( data.updateRange.count === - 1 ) {\n\t\n\t\t\t\t\t// Not using update ranges\n\t\n\t\t\t\t\tgl.bufferSubData( bufferType, 0, data.array );\n\t\n\t\t\t\t} else if ( data.updateRange.count === 0 ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\t\n\t\t\t\t\tdata.updateRange.count = 0; // reset range\n\t\n\t\t\t\t}\n\t\n\t\t\t\tattributeProperties.version = data.version;\n\t\n\t\t\t}\n\t\n\t\t\tfunction getAttributeBuffer( attribute ) {\n\t\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\t\n\t\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn properties.get( attribute ).__webglBuffer;\n\t\n\t\t\t}\n\t\n\t\t\tfunction getWireframeAttribute( geometry ) {\n\t\n\t\t\t\tvar property = properties.get( geometry );\n\t\n\t\t\t\tif ( property.wireframe !== undefined ) {\n\t\n\t\t\t\t\treturn property.wireframe;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar indices = [];\n\t\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar position = attributes.position;\n\t\n\t\t\t\t// console.time( 'wireframe' );\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tvar edges = {};\n\t\t\t\t\tvar array = index.array;\n\t\n\t\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\t\t\tvar c = array[ i + 2 ];\n\t\n\t\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar array = attributes.position.array;\n\t\n\t\t\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\tvar a = i + 0;\n\t\t\t\t\t\tvar b = i + 1;\n\t\t\t\t\t\tvar c = i + 2;\n\t\n\t\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// console.timeEnd( 'wireframe' );\n\t\n\t\t\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n\t\t\t\tvar attribute = new BufferAttribute( new TypeArray( indices ), 1 );\n\t\n\t\t\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\t\n\t\t\t\tproperty.wireframe = attribute;\n\t\n\t\t\t\treturn attribute;\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tgetAttributeBuffer: getAttributeBuffer,\n\t\t\t\tgetWireframeAttribute: getWireframeAttribute,\n\t\n\t\t\t\tupdate: update\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\t\n\t\t\tvar _infoMemory = info.memory;\n\t\t\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\t\n\t\t\t//\n\t\n\t\t\tfunction clampToMaxSize( image, maxSize ) {\n\t\n\t\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\t\n\t\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t\t\t// premultiplied alpha.\n\t\n\t\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\t\n\t\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\t\t\tcanvas.height = Math.floor( image.height * scale );\n\t\n\t\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\t\n\t\t\t\t\treturn canvas;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn image;\n\t\n\t\t\t}\n\t\n\t\t\tfunction isPowerOfTwo( image ) {\n\t\n\t\t\t\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\n\t\n\t\t\t}\n\t\n\t\t\tfunction makePowerOfTwo( image ) {\n\t\n\t\t\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\t\n\t\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\tcanvas.width = _Math.nearestPowerOfTwo( image.width );\n\t\t\t\t\tcanvas.height = _Math.nearestPowerOfTwo( image.height );\n\t\n\t\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\t\n\t\t\t\t\treturn canvas;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn image;\n\t\n\t\t\t}\n\t\n\t\t\tfunction textureNeedsPowerOfTwo( texture ) {\n\t\n\t\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) return true;\n\t\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) return true;\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t}\n\t\n\t\t\t// Fallback filters for non-power-of-2 textures\n\t\n\t\t\tfunction filterFallback( f ) {\n\t\n\t\t\t\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\n\t\n\t\t\t\t\treturn _gl.NEAREST;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn _gl.LINEAR;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction onTextureDispose( event ) {\n\t\n\t\t\t\tvar texture = event.target;\n\t\n\t\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\t\tdeallocateTexture( texture );\n\t\n\t\t\t\t_infoMemory.textures --;\n\t\n\t\n\t\t\t}\n\t\n\t\t\tfunction onRenderTargetDispose( event ) {\n\t\n\t\t\t\tvar renderTarget = event.target;\n\t\n\t\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\t\n\t\t\t\tdeallocateRenderTarget( renderTarget );\n\t\n\t\t\t\t_infoMemory.textures --;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction deallocateTexture( texture ) {\n\t\n\t\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\t\n\t\t\t\t\t// cube texture\n\t\n\t\t\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// 2D texture\n\t\n\t\t\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\t\n\t\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// remove all webgl properties\n\t\t\t\tproperties.delete( texture );\n\t\n\t\t\t}\n\t\n\t\t\tfunction deallocateRenderTarget( renderTarget ) {\n\t\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\n\t\t\t\tif ( ! renderTarget ) return;\n\t\n\t\t\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\t\n\t\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( renderTarget.depthTexture ) {\n\t\n\t\t\t\t\trenderTarget.depthTexture.dispose();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( (renderTarget && renderTarget.isWebGLRenderTargetCube) ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tproperties.delete( renderTarget.texture );\n\t\t\t\tproperties.delete( renderTarget );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\n\t\n\t\t\tfunction setTexture2D( texture, slot ) {\n\t\n\t\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\t\n\t\t\t\t\tvar image = texture.image;\n\t\n\t\t\t\t\tif ( image === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\t\n\t\t\t\t\t} else if ( image.complete === false ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setTextureCube( texture, slot ) {\n\t\n\t\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\t\tif ( texture.image.length === 6 ) {\n\t\n\t\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\t\n\t\t\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\t\n\t\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\t\n\t\t\t\t\t\t\t_infoMemory.textures ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\t\n\t\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\n\t\t\t\t\t\tvar isCompressed = (texture && texture.isCompressedTexture);\n\t\t\t\t\t\tvar isDataTexture = (texture.image[ 0 ] && texture.image[ 0 ].isDataTexture);\n\t\n\t\t\t\t\t\tvar cubeImage = [];\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\t\n\t\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\t\t\tglType = paramThreeToGL( texture.type );\n\t\n\t\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( ! isCompressed ) {\n\t\n\t\t\t\t\t\t\t\tif ( isDataTexture ) {\n\t\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\t\n\t\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\t\n\t\t\t\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\t\n\t\t\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\t\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttextureProperties.__version = texture.version;\n\t\n\t\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction setTextureCubeDynamic( texture, slot ) {\n\t\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setTextureParameters( textureType, texture, isPowerOfTwoImage ) {\n\t\n\t\t\t\tvar extension;\n\t\n\t\t\t\tif ( isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\t\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\t\n\t\t\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\t\n\t\t\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\n\t\t\t\tif ( extension ) {\n\t\n\t\t\t\t\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\t\t\tif ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\t\n\t\t\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\t\n\t\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction uploadTexture( textureProperties, texture, slot ) {\n\t\n\t\t\t\tif ( textureProperties.__webglInit === undefined ) {\n\t\n\t\t\t\t\ttextureProperties.__webglInit = true;\n\t\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\n\t\t\t\t\t_infoMemory.textures ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\n\t\t\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\t\n\t\t\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\t\n\t\t\t\t\timage = makePowerOfTwo( image );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\tglType = paramThreeToGL( texture.type );\n\t\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\t\n\t\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\t\n\t\t\t\tif ( (texture && texture.isDepthTexture) ) {\n\t\n\t\t\t\t\t// populate depth texture with dummy data\n\t\n\t\t\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\t\n\t\t\t\t\tif ( texture.type === FloatType ) {\n\t\n\t\t\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n\t\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\t\n\t\t\t\t\t} else if ( _isWebGL2 ) {\n\t\n\t\t\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\tif ( texture.format === DepthStencilFormat ) {\n\t\n\t\t\t\t\t\tinternalFormat = _gl.DEPTH_STENCIL;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\t\n\t\t\t\t} else if ( (texture && texture.isDataTexture) ) {\n\t\n\t\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\n\t\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture.generateMipmaps = false;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( (texture && texture.isCompressedTexture) ) {\n\t\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\n\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\t\n\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\t\n\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// regular Texture (image, video, canvas)\n\t\n\t\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\n\t\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture.generateMipmaps = false;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\n\t\t\t\ttextureProperties.__version = texture.version;\n\t\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\t\n\t\t\t}\n\t\n\t\t\t// Render targets\n\t\n\t\t\t// Setup storage for target texture and bind it to correct framebuffer\n\t\t\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\n\t\n\t\t\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\n\t\t\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\n\t\t\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\n\t\t\t}\n\t\n\t\t\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\t\t\tfunction setupRenderBufferStorage( renderbuffer, renderTarget ) {\n\t\n\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\t\n\t\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\t\n\t\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\t\n\t\t\t}\n\t\n\t\t\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\t\t\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\t\n\t\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\t\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\t\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\n\t\t\t\tif ( !( (renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture) ) ) {\n\t\n\t\t\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// upload an empty depth texture with framebuffer size\n\t\t\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t\t\t}\n\t\n\t\t\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\t\n\t\t\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\t\n\t\t\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\t\n\t\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\t\n\t\t\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\t\n\t\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthrow new Error('Unknown depthTexture format')\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Setup GL resources for a non-texture depth buffer\n\t\t\tfunction setupDepthRenderbuffer( renderTarget ) {\n\t\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\n\t\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\n\t\t\t\tif ( renderTarget.depthTexture ) {\n\t\n\t\t\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\t\n\t\t\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\n\t\t\t}\n\t\n\t\t\t// Set up GL resources for the render target\n\t\t\tfunction setupRenderTarget( renderTarget ) {\n\t\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\n\t\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\t\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\n\t\t\t\t_infoMemory.textures ++;\n\t\n\t\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\t\n\t\t\t\t// Setup framebuffer\n\t\n\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Setup color buffer\n\t\n\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\t\n\t\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Setup depth and stencil buffers\n\t\n\t\t\t\tif ( renderTarget.depthBuffer ) {\n\t\n\t\t\t\t\tsetupDepthRenderbuffer( renderTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction updateRenderTargetMipmap( renderTarget ) {\n\t\n\t\t\t\tvar texture = renderTarget.texture;\n\t\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n\t\t\t\t\t\ttexture.minFilter !== NearestFilter &&\n\t\t\t\t\t\ttexture.minFilter !== LinearFilter ) {\n\t\n\t\t\t\t\tvar target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\t\n\t\t\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t\t\t_gl.generateMipmap( target );\n\t\t\t\t\tstate.bindTexture( target, null );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.setTexture2D = setTexture2D;\n\t\t\tthis.setTextureCube = setTextureCube;\n\t\t\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\t\t\tthis.setupRenderTarget = setupRenderTarget;\n\t\t\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author fordacious / fordacious.github.io\n\t\t */\n\t\n\t\tfunction WebGLProperties() {\n\t\n\t\t\tvar properties = {};\n\t\n\t\t\treturn {\n\t\n\t\t\t\tget: function ( object ) {\n\t\n\t\t\t\t\tvar uuid = object.uuid;\n\t\t\t\t\tvar map = properties[ uuid ];\n\t\n\t\t\t\t\tif ( map === undefined ) {\n\t\n\t\t\t\t\t\tmap = {};\n\t\t\t\t\t\tproperties[ uuid ] = map;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn map;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tdelete: function ( object ) {\n\t\n\t\t\t\t\tdelete properties[ object.uuid ];\n\t\n\t\t\t\t},\n\t\n\t\t\t\tclear: function () {\n\t\n\t\t\t\t\tproperties = {};\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLState( gl, extensions, paramThreeToGL ) {\n\t\n\t\t\tfunction ColorBuffer() {\n\t\n\t\t\t\tvar locked = false;\n\t\n\t\t\t\tvar color = new Vector4();\n\t\t\t\tvar currentColorMask = null;\n\t\t\t\tvar currentColorClear = new Vector4();\n\t\n\t\t\t\treturn {\n\t\n\t\t\t\t\tsetMask: function ( colorMask ) {\n\t\n\t\t\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\t\n\t\t\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\t\t\tcurrentColorMask = colorMask;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetLocked: function ( lock ) {\n\t\n\t\t\t\t\t\tlocked = lock;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetClear: function ( r, g, b, a ) {\n\t\n\t\t\t\t\t\tcolor.set( r, g, b, a );\n\t\n\t\t\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\t\n\t\t\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\t\t\tcurrentColorClear.copy( color );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\treset: function () {\n\t\n\t\t\t\t\t\tlocked = false;\n\t\n\t\t\t\t\t\tcurrentColorMask = null;\n\t\t\t\t\t\tcurrentColorClear.set( 0, 0, 0, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tfunction DepthBuffer() {\n\t\n\t\t\t\tvar locked = false;\n\t\n\t\t\t\tvar currentDepthMask = null;\n\t\t\t\tvar currentDepthFunc = null;\n\t\t\t\tvar currentDepthClear = null;\n\t\n\t\t\t\treturn {\n\t\n\t\t\t\t\tsetTest: function ( depthTest ) {\n\t\n\t\t\t\t\t\tif ( depthTest ) {\n\t\n\t\t\t\t\t\t\tenable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tdisable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetMask: function ( depthMask ) {\n\t\n\t\t\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\t\n\t\t\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\t\t\tcurrentDepthMask = depthMask;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetFunc: function ( depthFunc ) {\n\t\n\t\t\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\t\n\t\t\t\t\t\t\tif ( depthFunc ) {\n\t\n\t\t\t\t\t\t\t\tswitch ( depthFunc ) {\n\t\n\t\t\t\t\t\t\t\t\tcase NeverDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase AlwaysDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase LessDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase LessEqualDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase EqualDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase GreaterDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase NotEqualDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetLocked: function ( lock ) {\n\t\n\t\t\t\t\t\tlocked = lock;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetClear: function ( depth ) {\n\t\n\t\t\t\t\t\tif ( currentDepthClear !== depth ) {\n\t\n\t\t\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\t\t\tcurrentDepthClear = depth;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\treset: function () {\n\t\n\t\t\t\t\t\tlocked = false;\n\t\n\t\t\t\t\t\tcurrentDepthMask = null;\n\t\t\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\t\t\tcurrentDepthClear = null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tfunction StencilBuffer() {\n\t\n\t\t\t\tvar locked = false;\n\t\n\t\t\t\tvar currentStencilMask = null;\n\t\t\t\tvar currentStencilFunc = null;\n\t\t\t\tvar currentStencilRef = null;\n\t\t\t\tvar currentStencilFuncMask = null;\n\t\t\t\tvar currentStencilFail  = null;\n\t\t\t\tvar currentStencilZFail = null;\n\t\t\t\tvar currentStencilZPass = null;\n\t\t\t\tvar currentStencilClear = null;\n\t\n\t\t\t\treturn {\n\t\n\t\t\t\t\tsetTest: function ( stencilTest ) {\n\t\n\t\t\t\t\t\tif ( stencilTest ) {\n\t\n\t\t\t\t\t\t\tenable( gl.STENCIL_TEST );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tdisable( gl.STENCIL_TEST );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetMask: function ( stencilMask ) {\n\t\n\t\t\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\t\n\t\t\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\t\t\tcurrentStencilMask = stencilMask;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\t\n\t\t\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\t\n\t\t\t\t\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\n\t\n\t\t\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\t\t\tcurrentStencilRef  = stencilRef;\n\t\t\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\t\n\t\t\t\t\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\t\n\t\t\t\t\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\n\t\n\t\t\t\t\t\t\tcurrentStencilFail  = stencilFail;\n\t\t\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetLocked: function ( lock ) {\n\t\n\t\t\t\t\t\tlocked = lock;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetClear: function ( stencil ) {\n\t\n\t\t\t\t\t\tif ( currentStencilClear !== stencil ) {\n\t\n\t\t\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\t\t\tcurrentStencilClear = stencil;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\treset: function () {\n\t\n\t\t\t\t\t\tlocked = false;\n\t\n\t\t\t\t\t\tcurrentStencilMask = null;\n\t\t\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\t\t\tcurrentStencilRef = null;\n\t\t\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\t\t\tcurrentStencilFail = null;\n\t\t\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\t\t\tcurrentStencilClear = null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar colorBuffer = new ColorBuffer();\n\t\t\tvar depthBuffer = new DepthBuffer();\n\t\t\tvar stencilBuffer = new StencilBuffer();\n\t\n\t\t\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\t\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\t\t\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\t\t\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\t\n\t\t\tvar capabilities = {};\n\t\n\t\t\tvar compressedTextureFormats = null;\n\t\n\t\t\tvar currentBlending = null;\n\t\t\tvar currentBlendEquation = null;\n\t\t\tvar currentBlendSrc = null;\n\t\t\tvar currentBlendDst = null;\n\t\t\tvar currentBlendEquationAlpha = null;\n\t\t\tvar currentBlendSrcAlpha = null;\n\t\t\tvar currentBlendDstAlpha = null;\n\t\t\tvar currentPremultipledAlpha = false;\n\t\n\t\t\tvar currentFlipSided = null;\n\t\t\tvar currentCullFace = null;\n\t\n\t\t\tvar currentLineWidth = null;\n\t\n\t\t\tvar currentPolygonOffsetFactor = null;\n\t\t\tvar currentPolygonOffsetUnits = null;\n\t\n\t\t\tvar currentScissorTest = null;\n\t\n\t\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\n\t\t\tvar currentTextureSlot = null;\n\t\t\tvar currentBoundTextures = {};\n\t\n\t\t\tvar currentScissor = new Vector4();\n\t\t\tvar currentViewport = new Vector4();\n\t\n\t\t\tfunction createTexture( type, target, count ) {\n\t\n\t\t\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\t\t\tvar texture = gl.createTexture();\n\t\n\t\t\t\tgl.bindTexture( type, texture );\n\t\t\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\n\t\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\t\n\t\t\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t}\n\t\n\t\t\tvar emptyTextures = {};\n\t\t\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\t\t\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\t\n\t\t\t//\n\t\n\t\t\tfunction init() {\n\t\n\t\t\t\tclearColor( 0, 0, 0, 1 );\n\t\t\t\tclearDepth( 1 );\n\t\t\t\tclearStencil( 0 );\n\t\n\t\t\t\tenable( gl.DEPTH_TEST );\n\t\t\t\tsetDepthFunc( LessEqualDepth );\n\t\n\t\t\t\tsetFlipSided( false );\n\t\t\t\tsetCullFace( CullFaceBack );\n\t\t\t\tenable( gl.CULL_FACE );\n\t\n\t\t\t\tenable( gl.BLEND );\n\t\t\t\tsetBlending( NormalBlending );\n\t\n\t\t\t}\n\t\n\t\t\tfunction initAttributes() {\n\t\n\t\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tnewAttributes[ i ] = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction enableAttribute( attribute ) {\n\t\n\t\t\t\tnewAttributes[ attribute ] = 1;\n\t\n\t\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\t\n\t\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\t\tenabledAttributes[ attribute ] = 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\t\n\t\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\t\t\tattributeDivisors[ attribute ] = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {\n\t\n\t\t\t\tnewAttributes[ attribute ] = 1;\n\t\n\t\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\t\n\t\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\t\tenabledAttributes[ attribute ] = 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\t\n\t\t\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction disableUnusedAttributes() {\n\t\n\t\t\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\t\n\t\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\t\n\t\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\t\tenabledAttributes[ i ] = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction enable( id ) {\n\t\n\t\t\t\tif ( capabilities[ id ] !== true ) {\n\t\n\t\t\t\t\tgl.enable( id );\n\t\t\t\t\tcapabilities[ id ] = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction disable( id ) {\n\t\n\t\t\t\tif ( capabilities[ id ] !== false ) {\n\t\n\t\t\t\t\tgl.disable( id );\n\t\t\t\t\tcapabilities[ id ] = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction getCompressedTextureFormats() {\n\t\n\t\t\t\tif ( compressedTextureFormats === null ) {\n\t\n\t\t\t\t\tcompressedTextureFormats = [];\n\t\n\t\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\t\n\t\t\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn compressedTextureFormats;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\t\n\t\t\t\tif ( blending !== NoBlending ) {\n\t\n\t\t\t\t\tenable( gl.BLEND );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdisable( gl.BLEND );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\t\n\t\t\t\t\tif ( blending === AdditiveBlending ) {\n\t\n\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( blending === SubtractiveBlending ) {\n\t\n\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( blending === MultiplyBlending ) {\n\t\n\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcurrentBlending = blending;\n\t\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( blending === CustomBlending ) {\n\t\n\t\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\t\n\t\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\t\n\t\t\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\t\n\t\t\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\t\n\t\t\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\t\n\t\t\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tcurrentBlendEquation = null;\n\t\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\t\tcurrentBlendDst = null;\n\t\t\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\t\tcurrentBlendDstAlpha = null;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// TODO Deprecate\n\t\n\t\t\tfunction setColorWrite( colorWrite ) {\n\t\n\t\t\t\tcolorBuffer.setMask( colorWrite );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setDepthTest( depthTest ) {\n\t\n\t\t\t\tdepthBuffer.setTest( depthTest );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setDepthWrite( depthWrite ) {\n\t\n\t\t\t\tdepthBuffer.setMask( depthWrite );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setDepthFunc( depthFunc ) {\n\t\n\t\t\t\tdepthBuffer.setFunc( depthFunc );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setStencilTest( stencilTest ) {\n\t\n\t\t\t\tstencilBuffer.setTest( stencilTest );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setStencilWrite( stencilWrite ) {\n\t\n\t\t\t\tstencilBuffer.setMask( stencilWrite );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setStencilFunc( stencilFunc, stencilRef, stencilMask ) {\n\t\n\t\t\t\tstencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setStencilOp( stencilFail, stencilZFail, stencilZPass ) {\n\t\n\t\t\t\tstencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction setFlipSided( flipSided ) {\n\t\n\t\t\t\tif ( currentFlipSided !== flipSided ) {\n\t\n\t\t\t\t\tif ( flipSided ) {\n\t\n\t\t\t\t\t\tgl.frontFace( gl.CW );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.frontFace( gl.CCW );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcurrentFlipSided = flipSided;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction setCullFace( cullFace ) {\n\t\n\t\t\t\tif ( cullFace !== CullFaceNone ) {\n\t\n\t\t\t\t\tenable( gl.CULL_FACE );\n\t\n\t\t\t\t\tif ( cullFace !== currentCullFace ) {\n\t\n\t\t\t\t\t\tif ( cullFace === CullFaceBack ) {\n\t\n\t\t\t\t\t\t\tgl.cullFace( gl.BACK );\n\t\n\t\t\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\t\n\t\t\t\t\t\t\tgl.cullFace( gl.FRONT );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdisable( gl.CULL_FACE );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcurrentCullFace = cullFace;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setLineWidth( width ) {\n\t\n\t\t\t\tif ( width !== currentLineWidth ) {\n\t\n\t\t\t\t\tgl.lineWidth( width );\n\t\n\t\t\t\t\tcurrentLineWidth = width;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\t\n\t\t\t\tif ( polygonOffset ) {\n\t\n\t\t\t\t\tenable( gl.POLYGON_OFFSET_FILL );\n\t\n\t\t\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\t\n\t\t\t\t\t\tgl.polygonOffset( factor, units );\n\t\n\t\t\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\t\t\tcurrentPolygonOffsetUnits = units;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdisable( gl.POLYGON_OFFSET_FILL );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction getScissorTest() {\n\t\n\t\t\t\treturn currentScissorTest;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setScissorTest( scissorTest ) {\n\t\n\t\t\t\tcurrentScissorTest = scissorTest;\n\t\n\t\t\t\tif ( scissorTest ) {\n\t\n\t\t\t\t\tenable( gl.SCISSOR_TEST );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdisable( gl.SCISSOR_TEST );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// texture\n\t\n\t\t\tfunction activeTexture( webglSlot ) {\n\t\n\t\t\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\t\n\t\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\t\n\t\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\t\tcurrentTextureSlot = webglSlot;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction bindTexture( webglType, webglTexture ) {\n\t\n\t\t\t\tif ( currentTextureSlot === null ) {\n\t\n\t\t\t\t\tactiveTexture();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\t\n\t\t\t\tif ( boundTexture === undefined ) {\n\t\n\t\t\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\t\n\t\t\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\t\n\t\t\t\t\tboundTexture.type = webglType;\n\t\t\t\t\tboundTexture.texture = webglTexture;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction compressedTexImage2D() {\n\t\n\t\t\t\ttry {\n\t\n\t\t\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\t\n\t\t\t\t} catch ( error ) {\n\t\n\t\t\t\t\tconsole.error( error );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction texImage2D() {\n\t\n\t\t\t\ttry {\n\t\n\t\t\t\t\tgl.texImage2D.apply( gl, arguments );\n\t\n\t\t\t\t} catch ( error ) {\n\t\n\t\t\t\t\tconsole.error( error );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// TODO Deprecate\n\t\n\t\t\tfunction clearColor( r, g, b, a ) {\n\t\n\t\t\t\tcolorBuffer.setClear( r, g, b, a );\n\t\n\t\t\t}\n\t\n\t\t\tfunction clearDepth( depth ) {\n\t\n\t\t\t\tdepthBuffer.setClear( depth );\n\t\n\t\t\t}\n\t\n\t\t\tfunction clearStencil( stencil ) {\n\t\n\t\t\t\tstencilBuffer.setClear( stencil );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction scissor( scissor ) {\n\t\n\t\t\t\tif ( currentScissor.equals( scissor ) === false ) {\n\t\n\t\t\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\t\t\tcurrentScissor.copy( scissor );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction viewport( viewport ) {\n\t\n\t\t\t\tif ( currentViewport.equals( viewport ) === false ) {\n\t\n\t\t\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\t\t\tcurrentViewport.copy( viewport );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction reset() {\n\t\n\t\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\t\n\t\t\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\t\n\t\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\t\tenabledAttributes[ i ] = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcapabilities = {};\n\t\n\t\t\t\tcompressedTextureFormats = null;\n\t\n\t\t\t\tcurrentTextureSlot = null;\n\t\t\t\tcurrentBoundTextures = {};\n\t\n\t\t\t\tcurrentBlending = null;\n\t\n\t\t\t\tcurrentFlipSided = null;\n\t\t\t\tcurrentCullFace = null;\n\t\n\t\t\t\tcolorBuffer.reset();\n\t\t\t\tdepthBuffer.reset();\n\t\t\t\tstencilBuffer.reset();\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tbuffers: {\n\t\t\t\t\tcolor: colorBuffer,\n\t\t\t\t\tdepth: depthBuffer,\n\t\t\t\t\tstencil: stencilBuffer\n\t\t\t\t},\n\t\n\t\t\t\tinit: init,\n\t\t\t\tinitAttributes: initAttributes,\n\t\t\t\tenableAttribute: enableAttribute,\n\t\t\t\tenableAttributeAndDivisor: enableAttributeAndDivisor,\n\t\t\t\tdisableUnusedAttributes: disableUnusedAttributes,\n\t\t\t\tenable: enable,\n\t\t\t\tdisable: disable,\n\t\t\t\tgetCompressedTextureFormats: getCompressedTextureFormats,\n\t\n\t\t\t\tsetBlending: setBlending,\n\t\n\t\t\t\tsetColorWrite: setColorWrite,\n\t\t\t\tsetDepthTest: setDepthTest,\n\t\t\t\tsetDepthWrite: setDepthWrite,\n\t\t\t\tsetDepthFunc: setDepthFunc,\n\t\t\t\tsetStencilTest: setStencilTest,\n\t\t\t\tsetStencilWrite: setStencilWrite,\n\t\t\t\tsetStencilFunc: setStencilFunc,\n\t\t\t\tsetStencilOp: setStencilOp,\n\t\n\t\t\t\tsetFlipSided: setFlipSided,\n\t\t\t\tsetCullFace: setCullFace,\n\t\n\t\t\t\tsetLineWidth: setLineWidth,\n\t\t\t\tsetPolygonOffset: setPolygonOffset,\n\t\n\t\t\t\tgetScissorTest: getScissorTest,\n\t\t\t\tsetScissorTest: setScissorTest,\n\t\n\t\t\t\tactiveTexture: activeTexture,\n\t\t\t\tbindTexture: bindTexture,\n\t\t\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\t\t\ttexImage2D: texImage2D,\n\t\n\t\t\t\tclearColor: clearColor,\n\t\t\t\tclearDepth: clearDepth,\n\t\t\t\tclearStencil: clearStencil,\n\t\n\t\t\t\tscissor: scissor,\n\t\t\t\tviewport: viewport,\n\t\n\t\t\t\treset: reset\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLCapabilities( gl, extensions, parameters ) {\n\t\n\t\t\tvar maxAnisotropy;\n\t\n\t\t\tfunction getMaxAnisotropy() {\n\t\n\t\t\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\t\n\t\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\n\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmaxAnisotropy = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn maxAnisotropy;\n\t\n\t\t\t}\n\t\n\t\t\tfunction getMaxPrecision( precision ) {\n\t\n\t\t\t\tif ( precision === 'highp' ) {\n\t\n\t\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\t\n\t\t\t\t\t\treturn 'highp';\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tprecision = 'mediump';\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( precision === 'mediump' ) {\n\t\n\t\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\t\n\t\t\t\t\t\treturn 'mediump';\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn 'lowp';\n\t\n\t\t\t}\n\t\n\t\t\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\t\t\tvar maxPrecision = getMaxPrecision( precision );\n\t\n\t\t\tif ( maxPrecision !== precision ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\t\t\tprecision = maxPrecision;\n\t\n\t\t\t}\n\t\n\t\t\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );\n\t\n\t\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\t\tvar maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\t\t\tvar maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\t\t\tvar maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\t\n\t\t\tvar maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\t\tvar maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\t\tvar maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\t\t\tvar maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\t\n\t\t\tvar vertexTextures = maxVertexTextures > 0;\n\t\t\tvar floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\t\t\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\n\t\n\t\t\treturn {\n\t\n\t\t\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\t\t\tgetMaxPrecision: getMaxPrecision,\n\t\n\t\t\t\tprecision: precision,\n\t\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\t\n\t\t\t\tmaxTextures: maxTextures,\n\t\t\t\tmaxVertexTextures: maxVertexTextures,\n\t\t\t\tmaxTextureSize: maxTextureSize,\n\t\t\t\tmaxCubemapSize: maxCubemapSize,\n\t\n\t\t\t\tmaxAttributes: maxAttributes,\n\t\t\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\t\t\tmaxVaryings: maxVaryings,\n\t\t\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\t\n\t\t\t\tvertexTextures: vertexTextures,\n\t\t\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\t\t\tfloatVertexTextures: floatVertexTextures\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLExtensions( gl ) {\n\t\n\t\t\tvar extensions = {};\n\t\n\t\t\treturn {\n\t\n\t\t\t\tget: function ( name ) {\n\t\n\t\t\t\t\tif ( extensions[ name ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn extensions[ name ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar extension;\n\t\n\t\t\t\t\tswitch ( name ) {\n\t\n\t\t\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\textension = gl.getExtension( name );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\textensions[ name ] = extension;\n\t\n\t\t\t\t\treturn extension;\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction WebGLClipping() {\n\t\n\t\t\tvar scope = this,\n\t\n\t\t\t\tglobalState = null,\n\t\t\t\tnumGlobalPlanes = 0,\n\t\t\t\tlocalClippingEnabled = false,\n\t\t\t\trenderingShadows = false,\n\t\n\t\t\t\tplane = new Plane(),\n\t\t\t\tviewNormalMatrix = new Matrix3(),\n\t\n\t\t\t\tuniform = { value: null, needsUpdate: false };\n\t\n\t\t\tthis.uniform = uniform;\n\t\t\tthis.numPlanes = 0;\n\t\t\tthis.numIntersection = 0;\n\t\n\t\t\tthis.init = function( planes, enableLocalClipping, camera ) {\n\t\n\t\t\t\tvar enabled =\n\t\t\t\t\tplanes.length !== 0 ||\n\t\t\t\t\tenableLocalClipping ||\n\t\t\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t\t\t// run another frame in order to reset the state:\n\t\t\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\t\t\tlocalClippingEnabled;\n\t\n\t\t\t\tlocalClippingEnabled = enableLocalClipping;\n\t\n\t\t\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\t\t\tnumGlobalPlanes = planes.length;\n\t\n\t\t\t\treturn enabled;\n\t\n\t\t\t};\n\t\n\t\t\tthis.beginShadows = function() {\n\t\n\t\t\t\trenderingShadows = true;\n\t\t\t\tprojectPlanes( null );\n\t\n\t\t\t};\n\t\n\t\t\tthis.endShadows = function() {\n\t\n\t\t\t\trenderingShadows = false;\n\t\t\t\tresetGlobalState();\n\t\n\t\t\t};\n\t\n\t\t\tthis.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\n\t\n\t\t\t\tif ( ! localClippingEnabled ||\n\t\t\t\t\t\tplanes === null || planes.length === 0 ||\n\t\t\t\t\t\trenderingShadows && ! clipShadows ) {\n\t\t\t\t\t// there's no local clipping\n\t\n\t\t\t\t\tif ( renderingShadows ) {\n\t\t\t\t\t\t// there's no global clipping\n\t\n\t\t\t\t\t\tprojectPlanes( null );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tresetGlobalState();\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\t\t\tlGlobal = nGlobal * 4,\n\t\n\t\t\t\t\t\tdstArray = cache.clippingState || null;\n\t\n\t\t\t\t\tuniform.value = dstArray; // ensure unique state\n\t\n\t\t\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\t\n\t\t\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\t\n\t\t\t\t\t\tdstArray[ i ] = globalState[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcache.clippingState = dstArray;\n\t\t\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\t\t\tthis.numPlanes += nGlobal;\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t};\n\t\n\t\t\tfunction resetGlobalState() {\n\t\n\t\t\t\tif ( uniform.value !== globalState ) {\n\t\n\t\t\t\t\tuniform.value = globalState;\n\t\t\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.numPlanes = numGlobalPlanes;\n\t\t\t\tscope.numIntersection = 0;\n\t\n\t\t\t}\n\t\n\t\t\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\t\n\t\t\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\t\t\tdstArray = null;\n\t\n\t\t\t\tif ( nPlanes !== 0 ) {\n\t\n\t\t\t\t\tdstArray = uniform.value;\n\t\n\t\t\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\t\n\t\t\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\t\n\t\t\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\t\n\t\t\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\t\n\t\t\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( var i = 0, i4 = dstOffset;\n\t\t\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\n\t\n\t\t\t\t\t\t\tplane.copy( planes[ i ] ).\n\t\t\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\n\t\n\t\t\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tuniform.value = dstArray;\n\t\t\t\t\tuniform.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.numPlanes = nPlanes;\n\t\t\t\t\n\t\t\t\treturn dstArray;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author szimek / https://github.com/szimek/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction WebGLRenderer( parameters ) {\n\t\n\t\t\tconsole.log( 'THREE.WebGLRenderer', REVISION );\n\t\n\t\t\tparameters = parameters || {};\n\t\n\t\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\t\n\t\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\t\n\t\t\tvar lights = [];\n\t\n\t\t\tvar opaqueObjects = [];\n\t\t\tvar opaqueObjectsLastIndex = - 1;\n\t\t\tvar transparentObjects = [];\n\t\t\tvar transparentObjectsLastIndex = - 1;\n\t\n\t\t\tvar morphInfluences = new Float32Array( 8 );\n\t\n\t\t\tvar sprites = [];\n\t\t\tvar lensFlares = [];\n\t\n\t\t\t// public properties\n\t\n\t\t\tthis.domElement = _canvas;\n\t\t\tthis.context = null;\n\t\n\t\t\t// clearing\n\t\n\t\t\tthis.autoClear = true;\n\t\t\tthis.autoClearColor = true;\n\t\t\tthis.autoClearDepth = true;\n\t\t\tthis.autoClearStencil = true;\n\t\n\t\t\t// scene graph\n\t\n\t\t\tthis.sortObjects = true;\n\t\n\t\t\t// user-defined clipping\n\t\n\t\t\tthis.clippingPlanes = [];\n\t\t\tthis.localClippingEnabled = false;\n\t\n\t\t\t// physically based shading\n\t\n\t\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\t\t\tthis.gammaInput = false;\n\t\t\tthis.gammaOutput = false;\n\t\n\t\t\t// physical lights\n\t\n\t\t\tthis.physicallyCorrectLights = false;\n\t\n\t\t\t// tone mapping\n\t\n\t\t\tthis.toneMapping = LinearToneMapping;\n\t\t\tthis.toneMappingExposure = 1.0;\n\t\t\tthis.toneMappingWhitePoint = 1.0;\n\t\n\t\t\t// morphs\n\t\n\t\t\tthis.maxMorphTargets = 8;\n\t\t\tthis.maxMorphNormals = 4;\n\t\n\t\t\t// internal properties\n\t\n\t\t\tvar _this = this,\n\t\n\t\t\t// internal state cache\n\t\n\t\t\t_currentProgram = null,\n\t\t\t_currentRenderTarget = null,\n\t\t\t_currentFramebuffer = null,\n\t\t\t_currentMaterialId = - 1,\n\t\t\t_currentGeometryProgram = '',\n\t\t\t_currentCamera = null,\n\t\n\t\t\t_currentScissor = new Vector4(),\n\t\t\t_currentScissorTest = null,\n\t\n\t\t\t_currentViewport = new Vector4(),\n\t\n\t\t\t//\n\t\n\t\t\t_usedTextureUnits = 0,\n\t\n\t\t\t//\n\t\n\t\t\t_clearColor = new Color( 0x000000 ),\n\t\t\t_clearAlpha = 0,\n\t\n\t\t\t_width = _canvas.width,\n\t\t\t_height = _canvas.height,\n\t\n\t\t\t_pixelRatio = 1,\n\t\n\t\t\t_scissor = new Vector4( 0, 0, _width, _height ),\n\t\t\t_scissorTest = false,\n\t\n\t\t\t_viewport = new Vector4( 0, 0, _width, _height ),\n\t\n\t\t\t// frustum\n\t\n\t\t\t_frustum = new Frustum(),\n\t\n\t\t\t// clipping\n\t\n\t\t\t_clipping = new WebGLClipping(),\n\t\t\t_clippingEnabled = false,\n\t\t\t_localClippingEnabled = false,\n\t\n\t\t\t_sphere = new Sphere(),\n\t\n\t\t\t// camera matrices cache\n\t\n\t\t\t_projScreenMatrix = new Matrix4(),\n\t\n\t\t\t_vector3 = new Vector3(),\n\t\n\t\t\t// light arrays cache\n\t\n\t\t\t_lights = {\n\t\n\t\t\t\thash: '',\n\t\n\t\t\t\tambient: [ 0, 0, 0 ],\n\t\t\t\tdirectional: [],\n\t\t\t\tdirectionalShadowMap: [],\n\t\t\t\tdirectionalShadowMatrix: [],\n\t\t\t\tspot: [],\n\t\t\t\tspotShadowMap: [],\n\t\t\t\tspotShadowMatrix: [],\n\t\t\t\tpoint: [],\n\t\t\t\tpointShadowMap: [],\n\t\t\t\tpointShadowMatrix: [],\n\t\t\t\themi: [],\n\t\n\t\t\t\tshadows: []\n\t\n\t\t\t},\n\t\n\t\t\t// info\n\t\n\t\t\t_infoRender = {\n\t\n\t\t\t\tcalls: 0,\n\t\t\t\tvertices: 0,\n\t\t\t\tfaces: 0,\n\t\t\t\tpoints: 0\n\t\n\t\t\t};\n\t\n\t\t\tthis.info = {\n\t\n\t\t\t\trender: _infoRender,\n\t\t\t\tmemory: {\n\t\n\t\t\t\t\tgeometries: 0,\n\t\t\t\t\ttextures: 0\n\t\n\t\t\t\t},\n\t\t\t\tprograms: null\n\t\n\t\t\t};\n\t\n\t\n\t\t\t// initialize\n\t\n\t\t\tvar _gl;\n\t\n\t\t\ttry {\n\t\n\t\t\t\tvar attributes = {\n\t\t\t\t\talpha: _alpha,\n\t\t\t\t\tdepth: _depth,\n\t\t\t\t\tstencil: _stencil,\n\t\t\t\t\tantialias: _antialias,\n\t\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t\t\t};\n\t\n\t\t\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\t\n\t\t\t\tif ( _gl === null ) {\n\t\n\t\t\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\t\n\t\t\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthrow 'Error creating WebGL context.';\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\t\n\t\t\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\t\n\t\t\t\t\t_gl.getShaderPrecisionFormat = function () {\n\t\n\t\t\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\t\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\n\t\t\t} catch ( error ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\n\t\n\t\t\t}\n\t\n\t\t\tvar extensions = new WebGLExtensions( _gl );\n\t\n\t\t\textensions.get( 'WEBGL_depth_texture' );\n\t\t\textensions.get( 'OES_texture_float' );\n\t\t\textensions.get( 'OES_texture_float_linear' );\n\t\t\textensions.get( 'OES_texture_half_float' );\n\t\t\textensions.get( 'OES_texture_half_float_linear' );\n\t\t\textensions.get( 'OES_standard_derivatives' );\n\t\t\textensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\tif ( extensions.get( 'OES_element_index_uint' ) ) {\n\t\n\t\t\t\tBufferGeometry.MaxIndex = 4294967296;\n\t\n\t\t\t}\n\t\n\t\t\tvar capabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\t\n\t\t\tvar state = new WebGLState( _gl, extensions, paramThreeToGL );\n\t\t\tvar properties = new WebGLProperties();\n\t\t\tvar textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n\t\t\tvar objects = new WebGLObjects( _gl, properties, this.info );\n\t\t\tvar programCache = new WebGLPrograms( this, capabilities );\n\t\t\tvar lightCache = new WebGLLights();\n\t\n\t\t\tthis.info.programs = programCache.programs;\n\t\n\t\t\tvar bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );\n\t\t\tvar indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\t\n\t\t\t//\n\t\n\t\t\tvar backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\t\tvar backgroundCamera2 = new PerspectiveCamera();\n\t\t\tvar backgroundPlaneMesh = new Mesh(\n\t\t\t\tnew PlaneBufferGeometry( 2, 2 ),\n\t\t\t\tnew MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\n\t\t\t);\n\t\t\tvar backgroundBoxShader = ShaderLib[ 'cube' ];\n\t\t\tvar backgroundBoxMesh = new Mesh(\n\t\t\t\tnew BoxBufferGeometry( 5, 5, 5 ),\n\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\tuniforms: backgroundBoxShader.uniforms,\n\t\t\t\t\tvertexShader: backgroundBoxShader.vertexShader,\n\t\t\t\t\tfragmentShader: backgroundBoxShader.fragmentShader,\n\t\t\t\t\tside: BackSide,\n\t\t\t\t\tdepthTest: false,\n\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\tfog: false\n\t\t\t\t} )\n\t\t\t);\n\t\n\t\t\t//\n\t\n\t\t\tfunction getTargetPixelRatio() {\n\t\n\t\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\t\n\t\t\t}\n\t\n\t\t\tfunction glClearColor( r, g, b, a ) {\n\t\n\t\t\t\tif ( _premultipliedAlpha === true ) {\n\t\n\t\t\t\t\tr *= a; g *= a; b *= a;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.clearColor( r, g, b, a );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setDefaultGLState() {\n\t\n\t\t\t\tstate.init();\n\t\n\t\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\t\n\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t\t}\n\t\n\t\t\tfunction resetGLState() {\n\t\n\t\t\t\t_currentProgram = null;\n\t\t\t\t_currentCamera = null;\n\t\n\t\t\t\t_currentGeometryProgram = '';\n\t\t\t\t_currentMaterialId = - 1;\n\t\n\t\t\t\tstate.reset();\n\t\n\t\t\t}\n\t\n\t\t\tsetDefaultGLState();\n\t\n\t\t\tthis.context = _gl;\n\t\t\tthis.capabilities = capabilities;\n\t\t\tthis.extensions = extensions;\n\t\t\tthis.properties = properties;\n\t\t\tthis.state = state;\n\t\n\t\t\t// shadow map\n\t\n\t\t\tvar shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );\n\t\n\t\t\tthis.shadowMap = shadowMap;\n\t\n\t\n\t\t\t// Plugins\n\t\n\t\t\tvar spritePlugin = new SpritePlugin( this, sprites );\n\t\t\tvar lensFlarePlugin = new LensFlarePlugin( this, lensFlares );\n\t\n\t\t\t// API\n\t\n\t\t\tthis.getContext = function () {\n\t\n\t\t\t\treturn _gl;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getContextAttributes = function () {\n\t\n\t\t\t\treturn _gl.getContextAttributes();\n\t\n\t\t\t};\n\t\n\t\t\tthis.forceContextLoss = function () {\n\t\n\t\t\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\n\t\n\t\t\t};\n\t\n\t\t\tthis.getMaxAnisotropy = function () {\n\t\n\t\t\t\treturn capabilities.getMaxAnisotropy();\n\t\n\t\t\t};\n\t\n\t\t\tthis.getPrecision = function () {\n\t\n\t\t\t\treturn capabilities.precision;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getPixelRatio = function () {\n\t\n\t\t\t\treturn _pixelRatio;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setPixelRatio = function ( value ) {\n\t\n\t\t\t\tif ( value === undefined ) return;\n\t\n\t\t\t\t_pixelRatio = value;\n\t\n\t\t\t\tthis.setSize( _viewport.z, _viewport.w, false );\n\t\n\t\t\t};\n\t\n\t\t\tthis.getSize = function () {\n\t\n\t\t\t\treturn {\n\t\t\t\t\twidth: _width,\n\t\t\t\t\theight: _height\n\t\t\t\t};\n\t\n\t\t\t};\n\t\n\t\t\tthis.setSize = function ( width, height, updateStyle ) {\n\t\n\t\t\t\t_width = width;\n\t\t\t\t_height = height;\n\t\n\t\t\t\t_canvas.width = width * _pixelRatio;\n\t\t\t\t_canvas.height = height * _pixelRatio;\n\t\n\t\t\t\tif ( updateStyle !== false ) {\n\t\n\t\t\t\t\t_canvas.style.width = width + 'px';\n\t\t\t\t\t_canvas.style.height = height + 'px';\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.setViewport( 0, 0, width, height );\n\t\n\t\t\t};\n\t\n\t\t\tthis.setViewport = function ( x, y, width, height ) {\n\t\n\t\t\t\tstate.viewport( _viewport.set( x, y, width, height ) );\n\t\n\t\t\t};\n\t\n\t\t\tthis.setScissor = function ( x, y, width, height ) {\n\t\n\t\t\t\tstate.scissor( _scissor.set( x, y, width, height ) );\n\t\n\t\t\t};\n\t\n\t\t\tthis.setScissorTest = function ( boolean ) {\n\t\n\t\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\t\n\t\t\t};\n\t\n\t\t\t// Clearing\n\t\n\t\t\tthis.getClearColor = function () {\n\t\n\t\t\t\treturn _clearColor;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setClearColor = function ( color, alpha ) {\n\t\n\t\t\t\t_clearColor.set( color );\n\t\n\t\t\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\t\n\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t\t};\n\t\n\t\t\tthis.getClearAlpha = function () {\n\t\n\t\t\t\treturn _clearAlpha;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setClearAlpha = function ( alpha ) {\n\t\n\t\t\t\t_clearAlpha = alpha;\n\t\n\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clear = function ( color, depth, stencil ) {\n\t\n\t\t\t\tvar bits = 0;\n\t\n\t\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\t\n\t\t\t\t_gl.clear( bits );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clearColor = function () {\n\t\n\t\t\t\tthis.clear( true, false, false );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clearDepth = function () {\n\t\n\t\t\t\tthis.clear( false, true, false );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clearStencil = function () {\n\t\n\t\t\t\tthis.clear( false, false, true );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\t\n\t\t\t\tthis.setRenderTarget( renderTarget );\n\t\t\t\tthis.clear( color, depth, stencil );\n\t\n\t\t\t};\n\t\n\t\t\t// Reset\n\t\n\t\t\tthis.resetGLState = resetGLState;\n\t\n\t\t\tthis.dispose = function() {\n\t\n\t\t\t\ttransparentObjects = [];\n\t\t\t\ttransparentObjectsLastIndex = -1;\n\t\t\t\topaqueObjects = [];\n\t\t\t\topaqueObjectsLastIndex = -1;\n\t\n\t\t\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\n\t\t\t};\n\t\n\t\t\t// Events\n\t\n\t\t\tfunction onContextLost( event ) {\n\t\n\t\t\t\tevent.preventDefault();\n\t\n\t\t\t\tresetGLState();\n\t\t\t\tsetDefaultGLState();\n\t\n\t\t\t\tproperties.clear();\n\t\n\t\t\t}\n\t\n\t\t\tfunction onMaterialDispose( event ) {\n\t\n\t\t\t\tvar material = event.target;\n\t\n\t\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\t\n\t\t\t\tdeallocateMaterial( material );\n\t\n\t\t\t}\n\t\n\t\t\t// Buffer deallocation\n\t\n\t\t\tfunction deallocateMaterial( material ) {\n\t\n\t\t\t\treleaseMaterialProgramReference( material );\n\t\n\t\t\t\tproperties.delete( material );\n\t\n\t\t\t}\n\t\n\t\n\t\t\tfunction releaseMaterialProgramReference( material ) {\n\t\n\t\t\t\tvar programInfo = properties.get( material ).program;\n\t\n\t\t\t\tmaterial.program = undefined;\n\t\n\t\t\t\tif ( programInfo !== undefined ) {\n\t\n\t\t\t\t\tprogramCache.releaseProgram( programInfo );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Buffer rendering\n\t\n\t\t\tthis.renderBufferImmediate = function ( object, program, material ) {\n\t\n\t\t\t\tstate.initAttributes();\n\t\n\t\t\t\tvar buffers = properties.get( object );\n\t\n\t\t\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\t\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\t\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\t\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\t\n\t\t\t\tvar attributes = program.getAttributes();\n\t\n\t\t\t\tif ( object.hasPositions ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object.hasNormals ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\t\n\t\t\t\t\tif ( ! material.isMeshPhongMaterial &&\n\t\t\t\t\t     ! material.isMeshStandardMaterial &&\n\t\t\t\t\t       material.shading === FlatShading ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\t\n\t\t\t\t\t\t\tvar array = object.normalArray;\n\t\n\t\t\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\t\n\t\t\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\t\t\tarray[ i + 2 ] = nz;\n\t\n\t\t\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\t\t\tarray[ i + 5 ] = nz;\n\t\n\t\t\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\t\t\tarray[ i + 8 ] = nz;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\t\tstate.enableAttribute( attributes.normal );\n\t\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object.hasUvs && material.map ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\t\tstate.enableAttribute( attributes.uv );\n\t\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object.hasColors && material.vertexColors !== NoColors ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\t\tstate.enableAttribute( attributes.color );\n\t\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\t\n\t\t\t\tobject.count = 0;\n\t\n\t\t\t};\n\t\n\t\t\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\t\n\t\t\t\tsetMaterial( material );\n\t\n\t\t\t\tvar program = setProgram( camera, fog, material, object );\n\t\n\t\t\t\tvar updateBuffers = false;\n\t\t\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\t\n\t\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\t\n\t\t\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\t\t\tupdateBuffers = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// morph targets\n\t\n\t\t\t\tvar morphTargetInfluences = object.morphTargetInfluences;\n\t\n\t\t\t\tif ( morphTargetInfluences !== undefined ) {\n\t\n\t\t\t\t\tvar activeInfluences = [];\n\t\n\t\t\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar influence = morphTargetInfluences[ i ];\n\t\t\t\t\t\tactiveInfluences.push( [ influence, i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tactiveInfluences.sort( absNumericalSort );\n\t\n\t\t\t\t\tif ( activeInfluences.length > 8 ) {\n\t\n\t\t\t\t\t\tactiveInfluences.length = 8;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar morphAttributes = geometry.morphAttributes;\n\t\n\t\t\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar influence = activeInfluences[ i ];\n\t\t\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\n\t\n\t\t\t\t\t\tif ( influence[ 0 ] !== 0 ) {\n\t\n\t\t\t\t\t\t\tvar index = influence[ 1 ];\n\t\n\t\t\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n\t\t\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tmorphInfluences[ i ] = 0.0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tprogram.getUniforms().setValue(\n\t\t\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\n\t\n\t\t\t\t\tupdateBuffers = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar position = geometry.attributes.position;\n\t\t\t\tvar rangeFactor = 1;\n\t\n\t\t\t\tif ( material.wireframe === true ) {\n\t\n\t\t\t\t\tindex = objects.getWireframeAttribute( geometry );\n\t\t\t\t\trangeFactor = 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar renderer;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\t\trenderer.setIndex( index );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderer = bufferRenderer;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( updateBuffers ) {\n\t\n\t\t\t\t\tsetupVertexAttributes( material, program, geometry );\n\t\n\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar dataCount = 0;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tdataCount = index.count;\n\t\n\t\t\t\t} else if ( position !== undefined ) {\n\t\n\t\t\t\t\tdataCount = position.count;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar rangeStart = geometry.drawRange.start * rangeFactor;\n\t\t\t\tvar rangeCount = geometry.drawRange.count * rangeFactor;\n\t\n\t\t\t\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\t\t\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\t\n\t\t\t\tvar drawStart = Math.max( rangeStart, groupStart );\n\t\t\t\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\t\n\t\t\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\t\n\t\t\t\tif ( drawCount === 0 ) return;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( object.isMesh ) {\n\t\n\t\t\t\t\tif ( material.wireframe === true ) {\n\t\n\t\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\t\trenderer.setMode( _gl.LINES );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tswitch ( object.drawMode ) {\n\t\n\t\t\t\t\t\t\tcase TrianglesDrawMode:\n\t\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase TriangleStripDrawMode:\n\t\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase TriangleFanDrawMode:\n\t\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\n\t\t\t\t} else if ( object.isLine ) {\n\t\n\t\t\t\t\tvar lineWidth = material.linewidth;\n\t\n\t\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\t\n\t\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\t\n\t\t\t\t\tif ( object.isLineSegments ) {\n\t\n\t\t\t\t\t\trenderer.setMode( _gl.LINES );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( object.isPoints ) {\n\t\n\t\t\t\t\trenderer.setMode( _gl.POINTS );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\t\n\t\t\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\t\n\t\t\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderer.render( drawStart, drawCount );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\t\n\t\t\t\tvar extension;\n\t\n\t\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\t\n\t\t\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( startIndex === undefined ) startIndex = 0;\n\t\n\t\t\t\tstate.initAttributes();\n\t\n\t\t\t\tvar geometryAttributes = geometry.attributes;\n\t\n\t\t\t\tvar programAttributes = program.getAttributes();\n\t\n\t\t\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\t\n\t\t\t\tfor ( var name in programAttributes ) {\n\t\n\t\t\t\t\tvar programAttribute = programAttributes[ name ];\n\t\n\t\t\t\t\tif ( programAttribute >= 0 ) {\n\t\n\t\t\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\t\n\t\t\t\t\t\tif ( geometryAttribute !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar type = _gl.FLOAT;\n\t\t\t\t\t\t\tvar array = geometryAttribute.array;\n\t\t\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\t\n\t\t\t\t\t\t\tif ( array instanceof Float32Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.FLOAT;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Float64Array ) {\n\t\n\t\t\t\t\t\t\t\tconsole.warn( \"Unsupported data buffer format: Float64Array\" );\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Int16Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.SHORT;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Int32Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.INT;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Int8Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.BYTE;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\t\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\n\t\n\t\t\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\t\n\t\t\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\t\n\t\t\t\t\t\t\t\tif ( data && data.isInstancedInterleavedBuffer ) {\n\t\n\t\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\t\n\t\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\t\n\t\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\t\n\t\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\t\n\t\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tswitch ( value.length ) {\n\t\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t}\n\t\n\t\t\t// Sorting\n\t\n\t\t\tfunction absNumericalSort( a, b ) {\n\t\n\t\t\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\t\n\t\t\t}\n\t\n\t\t\tfunction painterSortStable( a, b ) {\n\t\n\t\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\t\n\t\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\t\n\t\t\t\t} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {\n\t\n\t\t\t\t\treturn a.material.program.id - b.material.program.id;\n\t\n\t\t\t\t} else if ( a.material.id !== b.material.id ) {\n\t\n\t\t\t\t\treturn a.material.id - b.material.id;\n\t\n\t\t\t\t} else if ( a.z !== b.z ) {\n\t\n\t\t\t\t\treturn a.z - b.z;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn a.id - b.id;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction reversePainterSortStable( a, b ) {\n\t\n\t\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\t\n\t\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\t\n\t\t\t\t} if ( a.z !== b.z ) {\n\t\n\t\t\t\t\treturn b.z - a.z;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn a.id - b.id;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Rendering\n\t\n\t\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\t\n\t\t\t\tif ( camera !== undefined && camera.isCamera !== true ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// reset caching for this frame\n\t\n\t\t\t\t_currentGeometryProgram = '';\n\t\t\t\t_currentMaterialId = - 1;\n\t\t\t\t_currentCamera = null;\n\t\n\t\t\t\t// update scene graph\n\t\n\t\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\t\n\t\t\t\t// update camera matrices and frustum\n\t\n\t\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\t\n\t\t\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\t\n\t\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\t\n\t\t\t\tlights.length = 0;\n\t\n\t\t\t\topaqueObjectsLastIndex = - 1;\n\t\t\t\ttransparentObjectsLastIndex = - 1;\n\t\n\t\t\t\tsprites.length = 0;\n\t\t\t\tlensFlares.length = 0;\n\t\n\t\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\t\n\t\t\t\tprojectObject( scene, camera );\n\t\n\t\t\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\n\t\t\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\n\t\n\t\t\t\tif ( _this.sortObjects === true ) {\n\t\n\t\t\t\t\topaqueObjects.sort( painterSortStable );\n\t\t\t\t\ttransparentObjects.sort( reversePainterSortStable );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\t\n\t\t\t\tsetupShadows( lights );\n\t\n\t\t\t\tshadowMap.render( scene, camera );\n\t\n\t\t\t\tsetupLights( lights, camera );\n\t\n\t\t\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\t\n\t\t\t\t//\n\t\n\t\t\t\t_infoRender.calls = 0;\n\t\t\t\t_infoRender.vertices = 0;\n\t\t\t\t_infoRender.faces = 0;\n\t\t\t\t_infoRender.points = 0;\n\t\n\t\t\t\tif ( renderTarget === undefined ) {\n\t\n\t\t\t\t\trenderTarget = null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.setRenderTarget( renderTarget );\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar background = scene.background;\n\t\n\t\t\t\tif ( background === null ) {\n\t\n\t\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t\t\t} else if ( background && background.isColor ) {\n\t\n\t\t\t\t\tglClearColor( background.r, background.g, background.b, 1 );\n\t\t\t\t\tforceClear = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.autoClear || forceClear ) {\n\t\n\t\t\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( background && background.isCubeTexture ) {\n\t\n\t\t\t\t\tbackgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );\n\t\n\t\t\t\t\tbackgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );\n\t\t\t\t\tbackgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );\n\t\n\t\t\t\t\tbackgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n\t\t\t\t\tbackgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\t\n\t\t\t\t\tobjects.update( backgroundBoxMesh );\n\t\n\t\t\t\t\t_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\t\n\t\t\t\t} else if ( background && background.isTexture ) {\n\t\n\t\t\t\t\tbackgroundPlaneMesh.material.map = background;\n\t\n\t\t\t\t\tobjects.update( backgroundPlaneMesh );\n\t\n\t\t\t\t\t_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( scene.overrideMaterial ) {\n\t\n\t\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\t\n\t\t\t\t\trenderObjects( opaqueObjects, scene, camera, overrideMaterial );\n\t\t\t\t\trenderObjects( transparentObjects, scene, camera, overrideMaterial );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// opaque pass (front-to-back order)\n\t\n\t\t\t\t\tstate.setBlending( NoBlending );\n\t\t\t\t\trenderObjects( opaqueObjects, scene, camera );\n\t\n\t\t\t\t\t// transparent pass (back-to-front order)\n\t\n\t\t\t\t\trenderObjects( transparentObjects, scene, camera );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// custom render plugins (post pass)\n\t\n\t\t\t\tspritePlugin.render( scene, camera );\n\t\t\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\n\t\n\t\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\t\n\t\t\t\tif ( renderTarget ) {\n\t\n\t\t\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\t\n\t\t\t\tstate.setDepthTest( true );\n\t\t\t\tstate.setDepthWrite( true );\n\t\t\t\tstate.setColorWrite( true );\n\t\n\t\t\t\t// _gl.finish();\n\t\n\t\t\t};\n\t\n\t\t\tfunction pushRenderItem( object, geometry, material, z, group ) {\n\t\n\t\t\t\tvar array, index;\n\t\n\t\t\t\t// allocate the next position in the appropriate array\n\t\n\t\t\t\tif ( material.transparent ) {\n\t\n\t\t\t\t\tarray = transparentObjects;\n\t\t\t\t\tindex = ++ transparentObjectsLastIndex;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tarray = opaqueObjects;\n\t\t\t\t\tindex = ++ opaqueObjectsLastIndex;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// recycle existing render item or grow the array\n\t\n\t\t\t\tvar renderItem = array[ index ];\n\t\n\t\t\t\tif ( renderItem !== undefined ) {\n\t\n\t\t\t\t\trenderItem.id = object.id;\n\t\t\t\t\trenderItem.object = object;\n\t\t\t\t\trenderItem.geometry = geometry;\n\t\t\t\t\trenderItem.material = material;\n\t\t\t\t\trenderItem.z = _vector3.z;\n\t\t\t\t\trenderItem.group = group;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderItem = {\n\t\t\t\t\t\tid: object.id,\n\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tz: _vector3.z,\n\t\t\t\t\t\tgroup: group\n\t\t\t\t\t};\n\t\n\t\t\t\t\t// assert( index === array.length );\n\t\t\t\t\tarray.push( renderItem );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// TODO Duplicated code (Frustum)\n\t\n\t\t\tfunction isObjectViewable( object ) {\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\t\t\tapplyMatrix4( object.matrixWorld );\n\t\n\t\t\t\treturn isSphereViewable( _sphere );\n\t\n\t\t\t}\n\t\n\t\t\tfunction isSpriteViewable( sprite ) {\n\t\n\t\t\t\t_sphere.center.set( 0, 0, 0 );\n\t\t\t\t_sphere.radius = 0.7071067811865476;\n\t\t\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\t\n\t\t\t\treturn isSphereViewable( _sphere );\n\t\n\t\t\t}\n\t\n\t\t\tfunction isSphereViewable( sphere ) {\n\t\n\t\t\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\t\n\t\t\t\tvar numPlanes = _clipping.numPlanes;\n\t\n\t\t\t\tif ( numPlanes === 0 ) return true;\n\t\n\t\t\t\tvar planes = _this.clippingPlanes,\n\t\n\t\t\t\t\tcenter = sphere.center,\n\t\t\t\t\tnegRad = - sphere.radius,\n\t\t\t\t\ti = 0;\n\t\n\t\t\t\tdo {\n\t\n\t\t\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\t\n\t\t\t\t} while ( ++ i !== numPlanes );\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\tfunction projectObject( object, camera ) {\n\t\n\t\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\t\tvar visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\t\n\t\t\t\tif ( visible ) {\n\t\n\t\t\t\t\tif ( object.isLight ) {\n\t\n\t\t\t\t\t\tlights.push( object );\n\t\n\t\t\t\t\t} else if ( object.isSprite ) {\n\t\n\t\t\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\t\n\t\t\t\t\t\t\tsprites.push( object );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( object.isLensFlare ) {\n\t\n\t\t\t\t\t\tlensFlares.push( object );\n\t\n\t\t\t\t\t} else if ( object.isImmediateRenderObject ) {\n\t\n\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\t\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\n\t\n\t\t\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\t\n\t\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\t\n\t\t\t\t\t\t\tobject.skeleton.update();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\t\n\t\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\t\tif ( material.visible === true ) {\n\t\n\t\t\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\t\n\t\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tvar geometry = objects.update( object );\n\t\n\t\t\t\t\t\t\t\tif ( material.isMultiMaterial ) {\n\t\n\t\t\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\t\t\tvar materials = material.materials;\n\t\n\t\t\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\t\n\t\t\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar children = object.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tprojectObject( children[ i ], camera );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\n\t\n\t\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar renderItem = renderList[ i ];\n\t\n\t\t\t\t\tvar object = renderItem.object;\n\t\t\t\t\tvar geometry = renderItem.geometry;\n\t\t\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\t\t\tvar group = renderItem.group;\n\t\n\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\t\n\t\t\t\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\t\n\t\t\t\t\tif ( object.isImmediateRenderObject ) {\n\t\n\t\t\t\t\t\tsetMaterial( material );\n\t\n\t\t\t\t\t\tvar program = setProgram( camera, scene.fog, material, object );\n\t\n\t\t\t\t\t\t_currentGeometryProgram = '';\n\t\n\t\t\t\t\t\tobject.render( function ( object ) {\n\t\n\t\t\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\t\n\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\t\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction initMaterial( material, fog, object ) {\n\t\n\t\t\t\tvar materialProperties = properties.get( material );\n\t\n\t\t\t\tvar parameters = programCache.getParameters(\n\t\t\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );\n\t\n\t\t\t\tvar code = programCache.getProgramCode( material, parameters );\n\t\n\t\t\t\tvar program = materialProperties.program;\n\t\t\t\tvar programChange = true;\n\t\n\t\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t\t// new material\n\t\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\t\n\t\t\t\t} else if ( program.code !== code ) {\n\t\n\t\t\t\t\t// changed glsl or parameters\n\t\t\t\t\treleaseMaterialProgramReference( material );\n\t\n\t\t\t\t} else if ( parameters.shaderID !== undefined ) {\n\t\n\t\t\t\t\t// same glsl and uniform list\n\t\t\t\t\treturn;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// only rebuild uniform list\n\t\t\t\t\tprogramChange = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( programChange ) {\n\t\n\t\t\t\t\tif ( parameters.shaderID ) {\n\t\n\t\t\t\t\t\tvar shader = ShaderLib[ parameters.shaderID ];\n\t\n\t\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\n\t\n\t\t\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\n\t\n\t\t\t\t\tmaterialProperties.program = program;\n\t\t\t\t\tmaterial.program = program;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attributes = program.getAttributes();\n\t\n\t\t\t\tif ( material.morphTargets ) {\n\t\n\t\t\t\t\tmaterial.numSupportedMorphTargets = 0;\n\t\n\t\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\t\n\t\t\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\t\n\t\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.morphNormals ) {\n\t\n\t\t\t\t\tmaterial.numSupportedMorphNormals = 0;\n\t\n\t\t\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\t\n\t\t\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\t\n\t\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar uniforms = materialProperties.__webglShader.uniforms;\n\t\n\t\t\t\tif ( ! material.isShaderMaterial &&\n\t\t\t\t     ! material.isRawShaderMaterial ||\n\t\t\t\t       material.clipping === true ) {\n\t\n\t\t\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\t\t\tmaterialProperties.numIntersection = _clipping.numIntersection;\n\t\t\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmaterialProperties.fog = fog;\n\t\n\t\t\t\t// store the light setup it was created for\n\t\n\t\t\t\tmaterialProperties.lightsHash = _lights.hash;\n\t\n\t\t\t\tif ( material.lights ) {\n\t\n\t\t\t\t\t// wire up the material to this renderer's lighting state\n\t\n\t\t\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\n\t\t\t\t\tuniforms.directionalLights.value = _lights.directional;\n\t\t\t\t\tuniforms.spotLights.value = _lights.spot;\n\t\t\t\t\tuniforms.pointLights.value = _lights.point;\n\t\t\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\n\t\n\t\t\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n\t\t\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n\t\t\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\n\t\t\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n\t\t\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\n\t\t\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\t\t\tuniformsList =\n\t\t\t\t\t\t\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\t\n\t\t\t\tmaterialProperties.uniformsList = uniformsList;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setMaterial( material ) {\n\t\n\t\t\t\tmaterial.side === DoubleSide\n\t\t\t\t\t? state.disable( _gl.CULL_FACE )\n\t\t\t\t\t: state.enable( _gl.CULL_FACE );\n\t\n\t\t\t\tstate.setFlipSided( material.side === BackSide );\n\t\n\t\t\t\tmaterial.transparent === true\n\t\t\t\t\t? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )\n\t\t\t\t\t: state.setBlending( NoBlending );\n\t\n\t\t\t\tstate.setDepthFunc( material.depthFunc );\n\t\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\t\tstate.setDepthWrite( material.depthWrite );\n\t\t\t\tstate.setColorWrite( material.colorWrite );\n\t\t\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setProgram( camera, fog, material, object ) {\n\t\n\t\t\t\t_usedTextureUnits = 0;\n\t\n\t\t\t\tvar materialProperties = properties.get( material );\n\t\n\t\t\t\tif ( _clippingEnabled ) {\n\t\n\t\t\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\t\n\t\t\t\t\t\tvar useCache =\n\t\t\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\t\n\t\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\t\t_clipping.setState(\n\t\t\t\t\t\t\t\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\n\t\t\t\t\t\t\t\tcamera, materialProperties, useCache );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.needsUpdate === false ) {\n\t\n\t\t\t\t\tif ( materialProperties.program === undefined ) {\n\t\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t\t} else if ( material.fog && materialProperties.fog !== fog ) {\n\t\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t\t} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {\n\t\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\t\t( materialProperties.numClippingPlanes !== _clipping.numPlanes || \n\t\t \t\t\t\t  materialProperties.numIntersection  !== _clipping.numIntersection ) ) {\n\t\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.needsUpdate ) {\n\t\n\t\t\t\t\tinitMaterial( material, fog, object );\n\t\t\t\t\tmaterial.needsUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar refreshProgram = false;\n\t\t\t\tvar refreshMaterial = false;\n\t\t\t\tvar refreshLights = false;\n\t\n\t\t\t\tvar program = materialProperties.program,\n\t\t\t\t\tp_uniforms = program.getUniforms(),\n\t\t\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\n\t\n\t\t\t\tif ( program.id !== _currentProgram ) {\n\t\n\t\t\t\t\t_gl.useProgram( program.program );\n\t\t\t\t\t_currentProgram = program.id;\n\t\n\t\t\t\t\trefreshProgram = true;\n\t\t\t\t\trefreshMaterial = true;\n\t\t\t\t\trefreshLights = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.id !== _currentMaterialId ) {\n\t\n\t\t\t\t\t_currentMaterialId = material.id;\n\t\n\t\t\t\t\trefreshMaterial = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\t\n\t\t\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\n\t\n\t\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\t\n\t\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\t\n\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\tif ( camera !== _currentCamera ) {\n\t\n\t\t\t\t\t\t_currentCamera = camera;\n\t\n\t\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t\t// the next material that does gets activated:\n\t\n\t\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// load material specific uniforms\n\t\t\t\t\t// (shader material also gets them for the sake of genericity)\n\t\n\t\t\t\t\tif ( material.isShaderMaterial ||\n\t\t\t\t\t     material.isMeshPhongMaterial ||\n\t\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t\t     material.envMap ) {\n\t\n\t\t\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\t\n\t\t\t\t\t\tif ( uCamPos !== undefined ) {\n\t\n\t\t\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\t\t     material.isMeshLambertMaterial ||\n\t\t\t\t\t     material.isMeshBasicMaterial ||\n\t\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t\t     material.isShaderMaterial ||\n\t\t\t\t\t     material.skinning ) {\n\t\n\t\t\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\n\t\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// skinning uniforms must be set even if material didn't change\n\t\t\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t\t\t// not sure why, but otherwise weird things happen\n\t\n\t\t\t\tif ( material.skinning ) {\n\t\n\t\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\t\n\t\t\t\t\tvar skeleton = object.skeleton;\n\t\n\t\t\t\t\tif ( skeleton ) {\n\t\n\t\t\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\t\n\t\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\n\t\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n\t\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( refreshMaterial ) {\n\t\n\t\t\t\t\tif ( material.lights ) {\n\t\n\t\t\t\t\t\t// the current material requires lighting info\n\t\n\t\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t\t// values\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t\t// the GL state when required\n\t\n\t\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// refresh uniforms common to several materials\n\t\n\t\t\t\t\tif ( fog && material.fog ) {\n\t\n\t\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( material.isMeshBasicMaterial ||\n\t\t\t\t\t     material.isMeshLambertMaterial ||\n\t\t\t\t\t     material.isMeshPhongMaterial ||\n\t\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t\t     material.isMeshDepthMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// refresh single material specific uniforms\n\t\n\t\t\t\t\tif ( material.isLineBasicMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isLineDashedMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isPointsMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshLambertMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshPhongMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshPhysicalMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshStandardMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshDepthMaterial ) {\n\t\n\t\t\t\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( material.isMeshNormalMaterial ) {\n\t\n\t\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tWebGLUniforms.upload(\n\t\t\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\t// common matrices\n\t\n\t\t\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\n\t\t\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\n\t\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\t\n\t\t\t\treturn program;\n\t\n\t\t\t}\n\t\n\t\t\t// Uniforms (refresh uniforms objects)\n\t\n\t\t\tfunction refreshUniformsCommon( uniforms, material ) {\n\t\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\t\n\t\t\t\tuniforms.diffuse.value = material.color;\n\t\n\t\t\t\tif ( material.emissive ) {\n\t\n\t\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\t\n\t\t\t\tif ( material.aoMap ) {\n\t\n\t\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// uv repeat and offset setting priorities\n\t\t\t\t// 1. color map\n\t\t\t\t// 2. specular map\n\t\t\t\t// 3. normal map\n\t\t\t\t// 4. bump map\n\t\t\t\t// 5. alpha map\n\t\t\t\t// 6. emissive map\n\t\n\t\t\t\tvar uvScaleMap;\n\t\n\t\t\t\tif ( material.map ) {\n\t\n\t\t\t\t\tuvScaleMap = material.map;\n\t\n\t\t\t\t} else if ( material.specularMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.specularMap;\n\t\n\t\t\t\t} else if ( material.displacementMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.displacementMap;\n\t\n\t\t\t\t} else if ( material.normalMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.normalMap;\n\t\n\t\t\t\t} else if ( material.bumpMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.bumpMap;\n\t\n\t\t\t\t} else if ( material.roughnessMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.roughnessMap;\n\t\n\t\t\t\t} else if ( material.metalnessMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.metalnessMap;\n\t\n\t\t\t\t} else if ( material.alphaMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.alphaMap;\n\t\n\t\t\t\t} else if ( material.emissiveMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.emissiveMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( uvScaleMap !== undefined ) {\n\t\n\t\t\t\t\t// backwards compatibility\n\t\t\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\t\n\t\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar offset = uvScaleMap.offset;\n\t\t\t\t\tvar repeat = uvScaleMap.repeat;\n\t\n\t\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tuniforms.envMap.value = material.envMap;\n\t\n\t\t\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\t\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;\n\t\n\t\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsLine( uniforms, material ) {\n\t\n\t\t\t\tuniforms.diffuse.value = material.color;\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsDash( uniforms, material ) {\n\t\n\t\t\t\tuniforms.dashSize.value = material.dashSize;\n\t\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\t\t\tuniforms.scale.value = material.scale;\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsPoints( uniforms, material ) {\n\t\n\t\t\t\tuniforms.diffuse.value = material.color;\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\t\t\tuniforms.scale.value = _height * 0.5;\n\t\n\t\t\t\tuniforms.map.value = material.map;\n\t\n\t\t\t\tif ( material.map !== null ) {\n\t\n\t\t\t\t\tvar offset = material.map.offset;\n\t\t\t\t\tvar repeat = material.map.repeat;\n\t\n\t\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsFog( uniforms, fog ) {\n\t\n\t\t\t\tuniforms.fogColor.value = fog.color;\n\t\n\t\t\t\tif ( fog.isFog ) {\n\t\n\t\t\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\t\t\tuniforms.fogFar.value = fog.far;\n\t\n\t\t\t\t} else if ( fog.isFogExp2 ) {\n\t\n\t\t\t\t\tuniforms.fogDensity.value = fog.density;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsLambert( uniforms, material ) {\n\t\n\t\t\t\tif ( material.lightMap ) {\n\t\n\t\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsPhong( uniforms, material ) {\n\t\n\t\t\t\tuniforms.specular.value = material.specular;\n\t\t\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\t\n\t\t\t\tif ( material.lightMap ) {\n\t\n\t\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.bumpMap ) {\n\t\n\t\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.normalMap ) {\n\t\n\t\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsStandard( uniforms, material ) {\n\t\n\t\t\t\tuniforms.roughness.value = material.roughness;\n\t\t\t\tuniforms.metalness.value = material.metalness;\n\t\n\t\t\t\tif ( material.roughnessMap ) {\n\t\n\t\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.metalnessMap ) {\n\t\n\t\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.lightMap ) {\n\t\n\t\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.bumpMap ) {\n\t\n\t\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.normalMap ) {\n\t\n\t\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.envMap ) {\n\t\n\t\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsPhysical( uniforms, material ) {\n\t\n\t\t\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\t\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\t\n\t\t\t\trefreshUniformsStandard( uniforms, material );\n\t\n\t\t\t}\n\t\n\t\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\t\n\t\t\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\t\n\t\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\n\t\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\t\n\t\t\t}\n\t\n\t\t\t// Lighting\n\t\n\t\t\tfunction setupShadows( lights ) {\n\t\n\t\t\t\tvar lightShadowsLength = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar light = lights[ i ];\n\t\n\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_lights.shadows.length = lightShadowsLength;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setupLights( lights, camera ) {\n\t\n\t\t\t\tvar l, ll, light,\n\t\t\t\tr = 0, g = 0, b = 0,\n\t\t\t\tcolor,\n\t\t\t\tintensity,\n\t\t\t\tdistance,\n\t\t\t\tshadowMap,\n\t\n\t\t\t\tviewMatrix = camera.matrixWorldInverse,\n\t\n\t\t\t\tdirectionalLength = 0,\n\t\t\t\tpointLength = 0,\n\t\t\t\tspotLength = 0,\n\t\t\t\themiLength = 0;\n\t\n\t\t\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\t\n\t\t\t\t\tlight = lights[ l ];\n\t\n\t\t\t\t\tcolor = light.color;\n\t\t\t\t\tintensity = light.intensity;\n\t\t\t\t\tdistance = light.distance;\n\t\n\t\t\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\t\n\t\t\t\t\tif ( light.isAmbientLight ) {\n\t\n\t\t\t\t\t\tr += color.r * intensity;\n\t\t\t\t\t\tg += color.g * intensity;\n\t\t\t\t\t\tb += color.b * intensity;\n\t\n\t\t\t\t\t} else if ( light.isDirectionalLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\n\t\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\n\t\n\t\t\t\t\t} else if ( light.isSpotLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\t\n\t\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\t\t\tuniforms.distance = distance;\n\t\n\t\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\n\t\t\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\t\n\t\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\n\t\n\t\t\t\t\t} else if ( light.isPointLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\t\n\t\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\t\n\t\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\n\t\n\t\t\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\t\n\t\t\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new Matrix4();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t\t\t// equal to inverse of the light's position\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n\t\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\t\n\t\t\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\n\t\n\t\t\t\t\t} else if ( light.isHemisphereLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\t\t\tuniforms.direction.normalize();\n\t\n\t\t\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\t\n\t\t\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_lights.ambient[ 0 ] = r;\n\t\t\t\t_lights.ambient[ 1 ] = g;\n\t\t\t\t_lights.ambient[ 2 ] = b;\n\t\n\t\t\t\t_lights.directional.length = directionalLength;\n\t\t\t\t_lights.spot.length = spotLength;\n\t\t\t\t_lights.point.length = pointLength;\n\t\t\t\t_lights.hemi.length = hemiLength;\n\t\n\t\t\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\t\n\t\t\t}\n\t\n\t\t\t// GL state setting\n\t\n\t\t\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\t\n\t\t\t\tstate.setCullFace( cullFace );\n\t\t\t\tstate.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );\n\t\n\t\t\t};\n\t\n\t\t\t// Textures\n\t\n\t\t\tfunction allocTextureUnit() {\n\t\n\t\t\t\tvar textureUnit = _usedTextureUnits;\n\t\n\t\t\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\t\n\t\t\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_usedTextureUnits += 1;\n\t\n\t\t\t\treturn textureUnit;\n\t\n\t\t\t}\n\t\n\t\t\tthis.allocTextureUnit = allocTextureUnit;\n\t\n\t\t\t// this.setTexture2D = setTexture2D;\n\t\t\tthis.setTexture2D = ( function() {\n\t\n\t\t\t\tvar warned = false;\n\t\n\t\t\t\t// backwards compatibility: peel texture.texture\n\t\t\t\treturn function setTexture2D( texture, slot ) {\n\t\n\t\t\t\t\tif ( texture && texture.isWebGLRenderTarget ) {\n\t\n\t\t\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\t\twarned = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture = texture.texture;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttextures.setTexture2D( texture, slot );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() );\n\t\n\t\t\tthis.setTexture = ( function() {\n\t\n\t\t\t\tvar warned = false;\n\t\n\t\t\t\treturn function setTexture( texture, slot ) {\n\t\n\t\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\t\t\twarned = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttextures.setTexture2D( texture, slot );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() );\n\t\n\t\t\tthis.setTextureCube = ( function() {\n\t\n\t\t\t\tvar warned = false;\n\t\n\t\t\t\treturn function setTextureCube( texture, slot ) {\n\t\n\t\t\t\t\t// backwards compatibility: peel texture.texture\n\t\t\t\t\tif ( texture && texture.isWebGLRenderTargetCube ) {\n\t\n\t\t\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\t\twarned = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture = texture.texture;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t\t\t// TODO: unify these code paths\n\t\t\t\t\tif ( ( texture && texture.isCubeTexture ) ||\n\t\t\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\t\n\t\t\t\t\t\t// CompressedTexture can have Array in image :/\n\t\n\t\t\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\t\t\ttextures.setTextureCube( texture, slot );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\t\n\t\t\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}() );\n\t\n\t\t\tthis.getCurrentRenderTarget = function() {\n\t\n\t\t\t\treturn _currentRenderTarget;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setRenderTarget = function ( renderTarget ) {\n\t\n\t\t\t\t_currentRenderTarget = renderTarget;\n\t\n\t\t\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\t\n\t\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\n\t\t\t\tvar framebuffer;\n\t\n\t\t\t\tif ( renderTarget ) {\n\t\n\t\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\n\t\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\t\n\t\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tframebuffer = null;\n\t\n\t\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t\t\t_currentScissorTest = _scissorTest;\n\t\n\t\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( _currentFramebuffer !== framebuffer ) {\n\t\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t\t\t_currentFramebuffer = framebuffer;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.scissor( _currentScissor );\n\t\t\t\tstate.setScissorTest( _currentScissorTest );\n\t\n\t\t\t\tstate.viewport( _currentViewport );\n\t\n\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\t\n\t\t\t\tif ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\t\n\t\t\t\tif ( framebuffer ) {\n\t\n\t\t\t\t\tvar restore = false;\n\t\n\t\t\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\t\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\n\t\t\t\t\t\trestore = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\tvar texture = renderTarget.texture;\n\t\t\t\t\t\tvar textureFormat = texture.format;\n\t\t\t\t\t\tvar textureType = texture.type;\n\t\n\t\t\t\t\t\tif ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t\t     ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t\t     ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\t\n\t\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\t\n\t\t\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\t\n\t\t\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} finally {\n\t\n\t\t\t\t\t\tif ( restore ) {\n\t\n\t\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\t// Map three.js constants to WebGL constants\n\t\n\t\t\tfunction paramThreeToGL( p ) {\n\t\n\t\t\t\tvar extension;\n\t\n\t\t\t\tif ( p === RepeatWrapping ) return _gl.REPEAT;\n\t\t\t\tif ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\t\t\tif ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\t\n\t\t\t\tif ( p === NearestFilter ) return _gl.NEAREST;\n\t\t\t\tif ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\t\t\tif ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\t\n\t\t\t\tif ( p === LinearFilter ) return _gl.LINEAR;\n\t\t\t\tif ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\t\t\tif ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\t\n\t\t\t\tif ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\t\t\tif ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\t\tif ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\t\tif ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\t\n\t\t\t\tif ( p === ByteType ) return _gl.BYTE;\n\t\t\t\tif ( p === ShortType ) return _gl.SHORT;\n\t\t\t\tif ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\t\t\tif ( p === IntType ) return _gl.INT;\n\t\t\t\tif ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\t\t\tif ( p === FloatType ) return _gl.FLOAT;\n\t\n\t\t\t\tif ( p === HalfFloatType ) {\n\t\n\t\t\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\t\n\t\t\t\t\tif ( extension !== null ) return extension.HALF_FLOAT_OES;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === AlphaFormat ) return _gl.ALPHA;\n\t\t\t\tif ( p === RGBFormat ) return _gl.RGB;\n\t\t\t\tif ( p === RGBAFormat ) return _gl.RGBA;\n\t\t\t\tif ( p === LuminanceFormat ) return _gl.LUMINANCE;\n\t\t\t\tif ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\t\t\t\tif ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;\n\t\t\t\tif ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;\n\t\n\t\t\t\tif ( p === AddEquation ) return _gl.FUNC_ADD;\n\t\t\t\tif ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\t\t\tif ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\t\n\t\t\t\tif ( p === ZeroFactor ) return _gl.ZERO;\n\t\t\t\tif ( p === OneFactor ) return _gl.ONE;\n\t\t\t\tif ( p === SrcColorFactor ) return _gl.SRC_COLOR;\n\t\t\t\tif ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\t\t\tif ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\t\t\tif ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\t\t\tif ( p === DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\t\t\tif ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\t\n\t\t\t\tif ( p === DstColorFactor ) return _gl.DST_COLOR;\n\t\t\t\tif ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\t\t\tif ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\t\n\t\t\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\n\t\t\t\t\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\n\t\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\n\t\t\t\t\t p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\n\t\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === RGB_ETC1_Format ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\t\n\t\t\t\t\tif ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === MinEquation || p === MaxEquation ) {\n\t\n\t\t\t\t\textension = extensions.get( 'EXT_blend_minmax' );\n\t\n\t\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\t\tif ( p === MinEquation ) return extension.MIN_EXT;\n\t\t\t\t\t\tif ( p === MaxEquation ) return extension.MAX_EXT;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === UnsignedInt248Type ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_depth_texture' );\n\t\n\t\t\t\t\tif ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn 0;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction FogExp2 ( color, density ) {\n\t\n\t\t\tthis.name = '';\n\t\n\t\t\tthis.color = new Color( color );\n\t\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\t\n\t\t}\n\t\n\t\tFogExp2.prototype.isFogExp2 = true;\n\t\n\t\tFogExp2.prototype.clone = function () {\n\t\n\t\t\treturn new FogExp2( this.color.getHex(), this.density );\n\t\n\t\t};\n\t\n\t\tFogExp2.prototype.toJSON = function ( meta ) {\n\t\n\t\t\treturn {\n\t\t\t\ttype: 'FogExp2',\n\t\t\t\tcolor: this.color.getHex(),\n\t\t\t\tdensity: this.density\n\t\t\t};\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Fog ( color, near, far ) {\n\t\n\t\t\tthis.name = '';\n\t\n\t\t\tthis.color = new Color( color );\n\t\n\t\t\tthis.near = ( near !== undefined ) ? near : 1;\n\t\t\tthis.far = ( far !== undefined ) ? far : 1000;\n\t\n\t\t}\n\t\n\t\tFog.prototype.isFog = true;\n\t\n\t\tFog.prototype.clone = function () {\n\t\n\t\t\treturn new Fog( this.color.getHex(), this.near, this.far );\n\t\n\t\t};\n\t\n\t\tFog.prototype.toJSON = function ( meta ) {\n\t\n\t\t\treturn {\n\t\t\t\ttype: 'Fog',\n\t\t\t\tcolor: this.color.getHex(),\n\t\t\t\tnear: this.near,\n\t\t\t\tfar: this.far\n\t\t\t};\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Scene () {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Scene';\n\t\n\t\t\tthis.background = null;\n\t\t\tthis.fog = null;\n\t\t\tthis.overrideMaterial = null;\n\t\n\t\t\tthis.autoUpdate = true; // checked by the renderer\n\t\n\t\t}\n\t\n\t\tScene.prototype = Object.create( Object3D.prototype );\n\t\n\t\tScene.prototype.constructor = Scene;\n\t\n\t\tScene.prototype.copy = function ( source, recursive ) {\n\t\n\t\t\tObject3D.prototype.copy.call( this, source, recursive );\n\t\n\t\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\t\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\t\n\t\t\tthis.autoUpdate = source.autoUpdate;\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tScene.prototype.toJSON = function ( meta ) {\n\t\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\n\t\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\t\n\t\t\treturn data;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction LensFlare( texture, size, distance, blending, color ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.lensFlares = [];\n\t\n\t\t\tthis.positionScreen = new Vector3();\n\t\t\tthis.customUpdateCallback = undefined;\n\t\n\t\t\tif ( texture !== undefined ) {\n\t\n\t\t\t\tthis.add( texture, size, distance, blending, color );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tLensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: LensFlare,\n\t\n\t\t\tisLensFlare: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.positionScreen.copy( source.positionScreen );\n\t\t\t\tthis.customUpdateCallback = source.customUpdateCallback;\n\t\n\t\t\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( texture, size, distance, blending, color, opacity ) {\n\t\n\t\t\t\tif ( size === undefined ) size = - 1;\n\t\t\t\tif ( distance === undefined ) distance = 0;\n\t\t\t\tif ( opacity === undefined ) opacity = 1;\n\t\t\t\tif ( color === undefined ) color = new Color( 0xffffff );\n\t\t\t\tif ( blending === undefined ) blending = NormalBlending;\n\t\n\t\t\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\t\n\t\t\t\tthis.lensFlares.push( {\n\t\t\t\t\ttexture: texture,\t// THREE.Texture\n\t\t\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\n\t\t\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\n\t\t\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\n\t\t\t\t\tscale: 1, \t\t// scale\n\t\t\t\t\trotation: 0, \t\t// rotation\n\t\t\t\t\topacity: opacity,\t// opacity\n\t\t\t\t\tcolor: color,\t\t// color\n\t\t\t\t\tblending: blending\t// blending\n\t\t\t\t} );\n\t\n\t\t\t},\n\t\n\t\t\t/*\n\t\t\t * Update lens flares update positions on all flares based on the screen position\n\t\t\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t\t\t */\n\t\n\t\t\tupdateLensFlares: function () {\n\t\n\t\t\t\tvar f, fl = this.lensFlares.length;\n\t\t\t\tvar flare;\n\t\t\t\tvar vecX = - this.positionScreen.x * 2;\n\t\t\t\tvar vecY = - this.positionScreen.y * 2;\n\t\n\t\t\t\tfor ( f = 0; f < fl; f ++ ) {\n\t\n\t\t\t\t\tflare = this.lensFlares[ f ];\n\t\n\t\t\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\t\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\t\n\t\t\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\t\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *\tuvOffset: new THREE.Vector2(),\n\t\t *\tuvScale: new THREE.Vector2()\n\t\t * }\n\t\t */\n\t\n\t\tfunction SpriteMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'SpriteMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff );\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.rotation = 0;\n\t\n\t\t\tthis.fog = false;\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tSpriteMaterial.prototype = Object.create( Material.prototype );\n\t\tSpriteMaterial.prototype.constructor = SpriteMaterial;\n\t\n\t\tSpriteMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.rotation = source.rotation;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Sprite( material ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Sprite';\n\t\n\t\t\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\n\t\n\t\t}\n\t\n\t\tSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Sprite,\n\t\n\t\t\tisSprite: true,\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar matrixPosition = new Vector3();\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n\t\t\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\n\t\n\t\t\t\t\tif ( distanceSq > guessSizeSq ) {\n\t\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\tdistance: Math.sqrt( distanceSq ),\n\t\t\t\t\t\tpoint: this.position,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.material ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction LOD() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'LOD';\n\t\n\t\t\tObject.defineProperties( this, {\n\t\t\t\tlevels: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: []\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t}\n\t\n\t\n\t\tLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: LOD,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source, false );\n\t\n\t\t\t\tvar levels = source.levels;\n\t\n\t\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar level = levels[ i ];\n\t\n\t\t\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddLevel: function ( object, distance ) {\n\t\n\t\t\t\tif ( distance === undefined ) distance = 0;\n\t\n\t\t\t\tdistance = Math.abs( distance );\n\t\n\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\t\n\t\t\t\t\tif ( distance < levels[ l ].distance ) {\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\t\n\t\t\t\tthis.add( object );\n\t\n\t\t\t},\n\t\n\t\t\tgetObjectForDistance: function ( distance ) {\n\t\n\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tif ( distance < levels[ i ].distance ) {\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn levels[ i - 1 ].object;\n\t\n\t\t\t},\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar matrixPosition = new Vector3();\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\t\n\t\t\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tupdate: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\t\t\tvar v2 = new Vector3();\n\t\n\t\t\t\treturn function update( camera ) {\n\t\n\t\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\t\tif ( levels.length > 1 ) {\n\t\n\t\t\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\t\tvar distance = v1.distanceTo( v2 );\n\t\n\t\t\t\t\t\tlevels[ 0 ].object.visible = true;\n\t\n\t\t\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\t\n\t\t\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( ; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tlevels[ i ].object.visible = false;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.levels = [];\n\t\n\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar level = levels[ i ];\n\t\n\t\t\t\t\tdata.object.levels.push( {\n\t\t\t\t\t\tobject: level.object.uuid,\n\t\t\t\t\t\tdistance: level.distance\n\t\t\t\t\t} );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\t\n\t\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\t\tthis.image = { data: data, width: width, height: height };\n\t\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\t\n\t\t\tthis.generateMipmaps  = false;\n\t\t\tthis.flipY = false;\n\t\t\tthis.unpackAlignment = 1;\n\t\n\t\t}\n\t\n\t\tDataTexture.prototype = Object.create( Texture.prototype );\n\t\tDataTexture.prototype.constructor = DataTexture;\n\t\n\t\tDataTexture.prototype.isDataTexture = true;\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author michael guerrero / http://realitymeltdown.com\n\t\t * @author ikerr / http://verold.com\n\t\t */\n\t\n\t\tfunction Skeleton( bones, boneInverses, useVertexTexture ) {\n\t\n\t\t\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\t\n\t\t\tthis.identityMatrix = new Matrix4();\n\t\n\t\t\t// copy the bone array\n\t\n\t\t\tbones = bones || [];\n\t\n\t\t\tthis.bones = bones.slice( 0 );\n\t\n\t\t\t// create a bone texture or an array of floats\n\t\n\t\t\tif ( this.useVertexTexture ) {\n\t\n\t\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\t\n\t\n\t\t\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\t\t\tsize = _Math.nextPowerOfTwo( Math.ceil( size ) );\n\t\t\t\tsize = Math.max( size, 4 );\n\t\n\t\t\t\tthis.boneTextureWidth = size;\n\t\t\t\tthis.boneTextureHeight = size;\n\t\n\t\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\t\t\tthis.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\n\t\n\t\t\t}\n\t\n\t\t\t// use the supplied bone inverses or calculate the inverses\n\t\n\t\t\tif ( boneInverses === undefined ) {\n\t\n\t\t\t\tthis.calculateInverses();\n\t\n\t\t\t} else {\n\t\n\t\t\t\tif ( this.bones.length === boneInverses.length ) {\n\t\n\t\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\t\n\t\t\t\t\tthis.boneInverses = [];\n\t\n\t\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tObject.assign( Skeleton.prototype, {\n\t\n\t\t\tcalculateInverses: function () {\n\t\n\t\t\t\tthis.boneInverses = [];\n\t\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\tvar inverse = new Matrix4();\n\t\n\t\t\t\t\tif ( this.bones[ b ] ) {\n\t\n\t\t\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.boneInverses.push( inverse );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tpose: function () {\n\t\n\t\t\t\tvar bone;\n\t\n\t\t\t\t// recover the bind-time world matrices\n\t\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\tbone = this.bones[ b ];\n\t\n\t\t\t\t\tif ( bone ) {\n\t\n\t\t\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// compute the local matrices, positions, rotations and scales\n\t\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\tbone = this.bones[ b ];\n\t\n\t\t\t\t\tif ( bone ) {\n\t\n\t\t\t\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\t\n\t\t\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tupdate: ( function () {\n\t\n\t\t\t\tvar offsetMatrix = new Matrix4();\n\t\n\t\t\t\treturn function update() {\n\t\n\t\t\t\t\t// flatten bone matrices to array\n\t\n\t\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\t\t// compute the offset between the current and the original transform\n\t\n\t\t\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\t\n\t\t\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n\t\t\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( this.useVertexTexture ) {\n\t\n\t\t\t\t\t\tthis.boneTexture.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author ikerr / http://verold.com\n\t\t */\n\t\n\t\tfunction Bone( skin ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Bone';\n\t\n\t\t\tthis.skin = skin;\n\t\n\t\t}\n\t\n\t\tBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Bone,\n\t\n\t\t\tisBone: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.skin = source.skin;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author ikerr / http://verold.com\n\t\t */\n\t\n\t\tfunction SkinnedMesh( geometry, material, useVertexTexture ) {\n\t\n\t\t\tMesh.call( this, geometry, material );\n\t\n\t\t\tthis.type = 'SkinnedMesh';\n\t\n\t\t\tthis.bindMode = \"attached\";\n\t\t\tthis.bindMatrix = new Matrix4();\n\t\t\tthis.bindMatrixInverse = new Matrix4();\n\t\n\t\t\t// init bones\n\t\n\t\t\t// TODO: remove bone creation as there is no reason (other than\n\t\t\t// convenience) for THREE.SkinnedMesh to do this.\n\t\n\t\t\tvar bones = [];\n\t\n\t\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\t\n\t\t\t\tvar bone, gbone;\n\t\n\t\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\t\n\t\t\t\t\tgbone = this.geometry.bones[ b ];\n\t\n\t\t\t\t\tbone = new Bone( this );\n\t\t\t\t\tbones.push( bone );\n\t\n\t\t\t\t\tbone.name = gbone.name;\n\t\t\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\t\n\t\t\t\t\tgbone = this.geometry.bones[ b ];\n\t\n\t\t\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\n\t\t\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\n\t\n\t\t\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis.add( bones[ b ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.normalizeSkinWeights();\n\t\n\t\t\tthis.updateMatrixWorld( true );\n\t\t\tthis.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\t\n\t\t}\n\t\n\t\n\t\tSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\t\n\t\t\tconstructor: SkinnedMesh,\n\t\n\t\t\tisSkinnedMesh: true,\n\t\n\t\t\tbind: function( skeleton, bindMatrix ) {\n\t\n\t\t\t\tthis.skeleton = skeleton;\n\t\n\t\t\t\tif ( bindMatrix === undefined ) {\n\t\n\t\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\t\tthis.skeleton.calculateInverses();\n\t\n\t\t\t\t\tbindMatrix = this.matrixWorld;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.bindMatrix.copy( bindMatrix );\n\t\t\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\t\n\t\t\t},\n\t\n\t\t\tpose: function () {\n\t\n\t\t\t\tthis.skeleton.pose();\n\t\n\t\t\t},\n\t\n\t\t\tnormalizeSkinWeights: function () {\n\t\n\t\t\t\tif ( (this.geometry && this.geometry.isGeometry) ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\t\n\t\t\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\t\n\t\t\t\t\t\tif ( scale !== Infinity ) {\n\t\n\t\t\t\t\t\t\tsw.multiplyScalar( scale );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( (this.geometry && this.geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\tvar vec = new Vector4();\n\t\n\t\t\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\t\n\t\t\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\n\t\n\t\t\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\t\t\tvec.w = skinWeight.getW( i );\n\t\n\t\t\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\n\t\n\t\t\t\t\t\tif ( scale !== Infinity ) {\n\t\n\t\t\t\t\t\t\tvec.multiplyScalar( scale );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrixWorld: function( force ) {\n\t\n\t\t\t\tMesh.prototype.updateMatrixWorld.call( this, true );\n\t\n\t\t\t\tif ( this.bindMode === \"attached\" ) {\n\t\n\t\t\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\t\n\t\t\t\t} else if ( this.bindMode === \"detached\" ) {\n\t\n\t\t\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function() {\n\t\n\t\t\t\treturn new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  linewidth: <float>,\n\t\t *  linecap: \"round\",\n\t\t *  linejoin: \"round\"\n\t\t * }\n\t\t */\n\t\n\t\tfunction LineBasicMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'LineBasicMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff );\n\t\n\t\t\tthis.linewidth = 1;\n\t\t\tthis.linecap = 'round';\n\t\t\tthis.linejoin = 'round';\n\t\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tLineBasicMaterial.prototype = Object.create( Material.prototype );\n\t\tLineBasicMaterial.prototype.constructor = LineBasicMaterial;\n\t\n\t\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\t\n\t\tLineBasicMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.linewidth = source.linewidth;\n\t\t\tthis.linecap = source.linecap;\n\t\t\tthis.linejoin = source.linejoin;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Line( geometry, material, mode ) {\n\t\n\t\t\tif ( mode === 1 ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\t\t\treturn new LineSegments( geometry, material );\n\t\n\t\t\t}\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Line';\n\t\n\t\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\t\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t\t}\n\t\n\t\tLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Line,\n\t\n\t\t\tisLine: true,\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\t\tvar ray = new Ray();\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tvar precision = raycaster.linePrecision;\n\t\t\t\t\tvar precisionSq = precision * precision;\n\t\n\t\t\t\t\tvar geometry = this.geometry;\n\t\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\n\t\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t\t//\n\t\n\t\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\t\tvar vStart = new Vector3();\n\t\t\t\t\tvar vEnd = new Vector3();\n\t\t\t\t\tvar interSegment = new Vector3();\n\t\t\t\t\tvar interRay = new Vector3();\n\t\t\t\t\tvar step = (this && this.isLineSegments) ? 2 : 1;\n\t\n\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\t\n\t\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\t\n\t\t\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\t\n\t\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\t\n\t\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\t\n\t\t\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\t\n\t\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\t\n\t\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\t\tvar nbVertices = vertices.length;\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\t\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\t\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction LineSegments( geometry, material ) {\n\t\n\t\t\tLine.call( this, geometry, material );\n\t\n\t\t\tthis.type = 'LineSegments';\n\t\n\t\t}\n\t\n\t\tLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\n\t\n\t\t\tconstructor: LineSegments,\n\t\n\t\t\tisLineSegments: true\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  size: <float>,\n\t\t *  sizeAttenuation: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction PointsMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'PointsMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff );\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.size = 1;\n\t\t\tthis.sizeAttenuation = true;\n\t\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tPointsMaterial.prototype = Object.create( Material.prototype );\n\t\tPointsMaterial.prototype.constructor = PointsMaterial;\n\t\n\t\tPointsMaterial.prototype.isPointsMaterial = true;\n\t\n\t\tPointsMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.size = source.size;\n\t\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Points( geometry, material ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Points';\n\t\n\t\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\t\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t\t}\n\t\n\t\tPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Points,\n\t\n\t\t\tisPoints: true,\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\t\tvar ray = new Ray();\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tvar object = this;\n\t\t\t\t\tvar geometry = this.geometry;\n\t\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\t\t\tvar threshold = raycaster.params.Points.threshold;\n\t\n\t\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t\t//\n\t\n\t\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\t\t\tvar position = new Vector3();\n\t\n\t\t\t\t\tfunction testPoint( point, index ) {\n\t\n\t\t\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\t\n\t\t\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\t\n\t\t\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\t\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\t\n\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tobject: object\n\t\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\n\t\t\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\t\n\t\t\t\t\t\t\t\ttestPoint( position, a );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\t\n\t\t\t\t\t\t\t\ttestPoint( position, i );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\ttestPoint( vertices[ i ], i );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Group() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Group';\n\t\n\t\t}\n\t\n\t\tGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Group\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\t\n\t\t\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\t\n\t\t\tthis.generateMipmaps = false;\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tfunction update() {\n\t\n\t\t\t\trequestAnimationFrame( update );\n\t\n\t\t\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\t\n\t\t\t\t\tscope.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tupdate();\n\t\n\t\t}\n\t\n\t\tVideoTexture.prototype = Object.create( Texture.prototype );\n\t\tVideoTexture.prototype.constructor = VideoTexture;\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\t\n\t\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\t\tthis.image = { width: width, height: height };\n\t\t\tthis.mipmaps = mipmaps;\n\t\n\t\t\t// no flipping for cube textures\n\t\t\t// (also flipping doesn't work for compressed textures )\n\t\n\t\t\tthis.flipY = false;\n\t\n\t\t\t// can't generate mipmaps for compressed textures\n\t\t\t// mips must be embedded in DDS files\n\t\n\t\t\tthis.generateMipmaps = false;\n\t\n\t\t}\n\t\n\t\tCompressedTexture.prototype = Object.create( Texture.prototype );\n\t\tCompressedTexture.prototype.constructor = CompressedTexture;\n\t\n\t\tCompressedTexture.prototype.isCompressedTexture = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\t\n\t\t\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\t\n\t\t\tthis.needsUpdate = true;\n\t\n\t\t}\n\t\n\t\tCanvasTexture.prototype = Object.create( Texture.prototype );\n\t\tCanvasTexture.prototype.constructor = CanvasTexture;\n\t\n\t\t/**\n\t\t * @author Matt DesLauriers / @mattdesl\n\t\t * @author atix / arthursilber.de\n\t\t */\n\t\n\t\tfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\t\n\t\t\tformat = format !== undefined ? format : DepthFormat;\n\t\n\t\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\t\n\t\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )\n\t\n\t\t\t}\n\t\n\t\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\t\n\t\t\tthis.image = { width: width, height: height };\n\t\n\t\t\tthis.type = type !== undefined ? type : UnsignedShortType;\n\t\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\t\n\t\t\tthis.flipY = false;\n\t\t\tthis.generateMipmaps\t= false;\n\t\n\t\t}\n\t\n\t\tDepthTexture.prototype = Object.create( Texture.prototype );\n\t\tDepthTexture.prototype.constructor = DepthTexture;\n\t\tDepthTexture.prototype.isDepthTexture = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WireframeGeometry( geometry ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tvar edge = [ 0, 0 ], hash = {};\n\t\n\t\t\tfunction sortFunction( a, b ) {\n\t\n\t\t\t\treturn a - b;\n\t\n\t\t\t}\n\t\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\t\n\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar numEdges = 0;\n\t\n\t\t\t\t// allocate maximal size\n\t\t\t\tvar edges = new Uint32Array( 6 * faces.length );\n\t\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\t\tedge.sort( sortFunction );\n\t\n\t\t\t\t\t\tvar key = edge.toString();\n\t\n\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\t\n\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\tnumEdges ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\t\n\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\t\n\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\t\n\t\t\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\n\t\n\t\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\t\n\t\t\t} else if ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\tif ( geometry.index !== null ) {\n\t\n\t\t\t\t\t// Indexed BufferGeometry\n\t\n\t\t\t\t\tvar indices = geometry.index.array;\n\t\t\t\t\tvar vertices = geometry.attributes.position;\n\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\tvar numEdges = 0;\n\t\n\t\t\t\t\tif ( groups.length === 0 ) {\n\t\n\t\t\t\t\t\tgeometry.addGroup( 0, indices.length );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// allocate maximal size\n\t\t\t\t\tvar edges = new Uint32Array( 2 * indices.length );\n\t\n\t\t\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\n\t\n\t\t\t\t\t\tvar group = groups[ o ];\n\t\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\n\t\t\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\t\t\t\tedge.sort( sortFunction );\n\t\n\t\t\t\t\t\t\t\tvar key = edge.toString();\n\t\n\t\t\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\t\t\tnumEdges ++;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\t\n\t\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\n\t\n\t\t\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\n\t\t\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\n\t\t\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// non-indexed BufferGeometry\n\t\n\t\t\t\t\tvar vertices = geometry.attributes.position.array;\n\t\t\t\t\tvar numEdges = vertices.length / 3;\n\t\t\t\t\tvar numTris = numEdges / 3;\n\t\n\t\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\t\n\t\t\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar index = 18 * i + 6 * j;\n\t\n\t\t\t\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\t\n\t\t\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tWireframeGeometry.prototype.constructor = WireframeGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t *\n\t\t * Parametric Surfaces Geometry\n\t\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t\t */\n\t\n\t\tfunction ParametricBufferGeometry( func, slices, stacks ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'ParametricBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tfunc: func,\n\t\t\t\tslices: slices,\n\t\t\t\tstacks: stacks\n\t\t\t};\n\t\n\t\t\t// generate vertices and uvs\n\t\n\t\t\tvar vertices = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\tvar i, j, p;\n\t\t\tvar u, v;\n\t\n\t\t\tvar sliceCount = slices + 1;\n\t\n\t\t\tfor ( i = 0; i <= stacks; i ++ ) {\n\t\n\t\t\t\tv = i / stacks;\n\t\n\t\t\t\tfor ( j = 0; j <= slices; j ++ ) {\n\t\n\t\t\t\t\tu = j / slices;\n\t\n\t\t\t\t\tp = func( u, v );\n\t\t\t\t\tvertices.push( p.x, p.y, p.z );\n\t\n\t\t\t\t\tuvs.push( u, v );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tvar indices = [];\n\t\t\tvar a, b, c, d;\n\t\n\t\t\tfor ( i = 0; i < stacks; i ++ ) {\n\t\n\t\t\t\tfor ( j = 0; j < slices; j ++ ) {\n\t\n\t\t\t\t\ta = i * sliceCount + j;\n\t\t\t\t\tb = i * sliceCount + j + 1;\n\t\t\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\n\t\t\t\t\td = ( i + 1 ) * sliceCount + j;\n\t\n\t\t\t\t\t// faces one and two\n\t\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', Float32Attribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );\n\t\n\t\t\t// generate normals\n\t\n\t\t\tthis.computeVertexNormals();\n\t\n\t\t}\n\t\n\t\tParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\n\t\n\t\t/**\n\t\t * @author zz85 / https://github.com/zz85\n\t\t *\n\t\t * Parametric Surfaces Geometry\n\t\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t\t */\n\t\n\t\tfunction ParametricGeometry( func, slices, stacks ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'ParametricGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tfunc: func,\n\t\t\t\tslices: slices,\n\t\t\t\tstacks: stacks\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tParametricGeometry.prototype = Object.create( Geometry.prototype );\n\t\tParametricGeometry.prototype.constructor = ParametricGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'PolyhedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tvertices: vertices,\n\t\t\t\tindices: indices,\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tradius = radius || 1;\n\t\t\tdetail = detail || 0;\n\t\n\t\t\t// default buffer data\n\t\n\t\t\tvar vertexBuffer = [];\n\t\t\tvar uvBuffer = [];\n\t\n\t\t\t// the subdivision creates the vertex buffer data\n\t\n\t\t\tsubdivide( detail );\n\t\n\t\t\t// all vertices should lie on a conceptual sphere with a given radius\n\t\n\t\t\tappplyRadius( radius );\n\t\n\t\t\t// finally, create the uv data\n\t\n\t\t\tgenerateUVs();\n\t\n\t\t\t// build non-indexed geometry\n\t\n\t\t\tthis.addAttribute( 'position', Float32Attribute( vertexBuffer, 3 ) );\n\t\t\tthis.addAttribute( 'normal', Float32Attribute( vertexBuffer.slice(), 3 ) );\n\t\t\tthis.addAttribute( 'uv', Float32Attribute( uvBuffer, 2 ) );\n\t\t\tthis.normalizeNormals();\n\t\n\t\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\t\n\t\t\t// helper functions\n\t\n\t\t\tfunction subdivide( detail ) {\n\t\n\t\t\t\tvar a = new Vector3();\n\t\t\t\tvar b = new Vector3();\n\t\t\t\tvar c = new Vector3();\n\t\n\t\t\t\t// iterate over all faces and apply a subdivison with the given detail value\n\t\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\t\n\t\t\t\t\t// get the vertices of the face\n\t\n\t\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\t\n\t\t\t\t\t// perform subdivision\n\t\n\t\t\t\t\tsubdivideFace( a, b, c, detail );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction subdivideFace( a, b, c, detail ) {\n\t\n\t\t\t\tvar cols = Math.pow( 2, detail );\n\t\n\t\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\t\n\t\t\t\tvar v = [];\n\t\n\t\t\t\tvar i, j;\n\t\n\t\t\t\t// construct all of the vertices for this subdivision\n\t\n\t\t\t\tfor ( i = 0 ; i <= cols; i ++ ) {\n\t\n\t\t\t\t\tv[ i ] = [];\n\t\n\t\t\t\t\tvar aj = a.clone().lerp( c, i / cols );\n\t\t\t\t\tvar bj = b.clone().lerp( c, i / cols );\n\t\n\t\t\t\t\tvar rows = cols - i;\n\t\n\t\t\t\t\tfor ( j = 0; j <= rows; j ++ ) {\n\t\n\t\t\t\t\t\tif ( j === 0 && i === cols ) {\n\t\n\t\t\t\t\t\t\tv[ i ][ j ] = aj;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// construct all of the faces\n\t\n\t\t\t\tfor ( i = 0; i < cols ; i ++ ) {\n\t\n\t\t\t\t\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\t\n\t\t\t\t\t\tvar k = Math.floor( j / 2 );\n\t\n\t\t\t\t\t\tif ( j % 2 === 0 ) {\n\t\n\t\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction appplyRadius( radius ) {\n\t\n\t\t\t\tvar vertex = new Vector3();\n\t\n\t\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\t\n\t\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\t\n\t\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\t\n\t\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\t\n\t\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateUVs() {\n\t\n\t\t\t\tvar vertex = new Vector3();\n\t\n\t\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\t\n\t\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\t\n\t\t\t\t\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\t\tvar v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\t\tuvBuffer.push( u, 1 - v );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcorrectUVs();\n\t\n\t\t\t\tcorrectSeam();\n\t\n\t\t\t}\n\t\n\t\t\tfunction correctSeam() {\n\t\n\t\t\t\t// handle case when face straddles the seam, see #3269\n\t\n\t\t\t\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\n\t\n\t\t\t\t\t// uv data of a single face\n\t\n\t\t\t\t\tvar x0 = uvBuffer[ i + 0 ];\n\t\t\t\t\tvar x1 = uvBuffer[ i + 2 ];\n\t\t\t\t\tvar x2 = uvBuffer[ i + 4 ];\n\t\n\t\t\t\t\tvar max = Math.max( x0, x1, x2 );\n\t\t\t\t\tvar min = Math.min( x0, x1, x2 );\n\t\n\t\t\t\t\t// 0.9 is somewhat arbitrary\n\t\n\t\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\t\n\t\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction pushVertex( vertex ) {\n\t\n\t\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t}\n\t\n\t\t\tfunction getVertexByIndex( index, vertex ) {\n\t\n\t\t\t\tvar stride = index * 3;\n\t\n\t\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\t\tvertex.z = vertices[ stride + 2 ];\n\t\n\t\t\t}\n\t\n\t\t\tfunction correctUVs() {\n\t\n\t\t\t\tvar a = new Vector3();\n\t\t\t\tvar b = new Vector3();\n\t\t\t\tvar c = new Vector3();\n\t\n\t\t\t\tvar centroid = new Vector3();\n\t\n\t\t\t\tvar uvA = new Vector2();\n\t\t\t\tvar uvB = new Vector2();\n\t\t\t\tvar uvC = new Vector2();\n\t\n\t\t\t\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\t\n\t\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\t\n\t\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\t\n\t\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\t\n\t\t\t\t\tvar azi = azimuth( centroid );\n\t\n\t\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction correctUV( uv, stride, vector, azimuth  ) {\n\t\n\t\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\t\n\t\t\t\t\tuvBuffer[ stride ] =  uv.x - 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\t\n\t\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\t\n\t\t\tfunction azimuth( vector ) {\n\t\n\t\t\t\treturn Math.atan2( vector.z, - vector.x );\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// Angle above the XZ plane.\n\t\n\t\t\tfunction inclination( vector ) {\n\t\n\t\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction TetrahedronBufferGeometry( radius, detail ) {\n\t\n\t\t\tvar vertices = [\n\t\t\t\t1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n\t\t\t];\n\t\n\t\t\tvar indices = [\n\t\t\t\t2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n\t\t\t];\n\t\n\t\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\t\tthis.type = 'TetrahedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\t\tTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author timothypratley / https://github.com/timothypratley\n\t\t */\n\t\n\t\tfunction TetrahedronGeometry( radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TetrahedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction OctahedronBufferGeometry( radius,detail ) {\n\t\n\t\t\tvar vertices = [\n\t\t\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n\t\t\t];\n\t\n\t\t\tvar indices = [\n\t\t\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n\t\t\t];\n\t\n\t\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\t\tthis.type = 'OctahedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\t\tOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author timothypratley / https://github.com/timothypratley\n\t\t */\n\t\n\t\tfunction OctahedronGeometry( radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'OctahedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tOctahedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tOctahedronGeometry.prototype.constructor = OctahedronGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction IcosahedronBufferGeometry( radius, detail ) {\n\t\n\t\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\n\t\t\tvar vertices = [\n\t\t\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n\t\t\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n\t\t\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n\t\t\t];\n\t\n\t\t\tvar indices = [\n\t\t\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n\t\t\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n\t\t\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n\t\t\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n\t\t\t];\n\t\n\t\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\t\tthis.type = 'IcosahedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\t\tIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author timothypratley / https://github.com/timothypratley\n\t\t */\n\t\n\t\tfunction IcosahedronGeometry( radius, detail ) {\n\t\n\t\t \tGeometry.call( this );\n\t\n\t\t\tthis.type = 'IcosahedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction DodecahedronBufferGeometry( radius, detail ) {\n\t\n\t\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\t\tvar r = 1 / t;\n\t\n\t\t\tvar vertices = [\n\t\n\t\t\t\t// (±1, ±1, ±1)\n\t\t\t\t- 1, - 1, - 1,    - 1, - 1,  1,\n\t\t\t\t- 1,  1, - 1,    - 1,  1,  1,\n\t\t\t\t 1, - 1, - 1,     1, - 1,  1,\n\t\t\t\t 1,  1, - 1,     1,  1,  1,\n\t\n\t\t\t\t// (0, ±1/φ, ±φ)\n\t\t\t\t 0, - r, - t,     0, - r,  t,\n\t\t\t\t 0,  r, - t,     0,  r,  t,\n\t\n\t\t\t\t// (±1/φ, ±φ, 0)\n\t\t\t\t- r, - t,  0,    - r,  t,  0,\n\t\t\t\t r, - t,  0,     r,  t,  0,\n\t\n\t\t\t\t// (±φ, 0, ±1/φ)\n\t\t\t\t- t,  0, - r,     t,  0, - r,\n\t\t\t\t- t,  0,  r,     t,  0,  r\n\t\t\t];\n\t\n\t\t\tvar indices = [\n\t\t\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\n\t\t\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\n\t\t\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\n\t\t\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\n\t\t\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\n\t\t\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\n\t\t\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\n\t\t\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\n\t\t\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\n\t\t\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\n\t\t\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\n\t\t\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\n\t\t\t];\n\t\n\t\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\t\tthis.type = 'DodecahedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\t\tDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author Abe Pazos / https://hamoid.com\n\t\t */\n\t\n\t\tfunction DodecahedronGeometry( radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'DodecahedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\n\t\n\t\t/**\n\t\t * @author clockworkgeek / https://github.com/clockworkgeek\n\t\t * @author timothypratley / https://github.com/timothypratley\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t*/\n\t\n\t\tfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'PolyhedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tvertices: vertices,\n\t\t\t\tindices: indices,\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t *\n\t\t * Creates a tube which extrudes along a 3d spline.\n\t\t *\n\t\t */\n\t\n\t\tfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'TubeBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tpath: path,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradius: radius,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tclosed: closed\n\t\t\t};\n\t\n\t\t\ttubularSegments = tubularSegments || 64;\n\t\t\tradius = radius || 1;\n\t\t\tradialSegments = radialSegments || 8;\n\t\t\tclosed = closed || false;\n\t\n\t\t\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\n\t\n\t\t\t// expose internals\n\t\n\t\t\tthis.tangents = frames.tangents;\n\t\t\tthis.normals = frames.normals;\n\t\t\tthis.binormals = frames.binormals;\n\t\n\t\t\t// helper variables\n\t\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar normal = new Vector3();\n\t\t\tvar uv = new Vector2();\n\t\n\t\t\tvar i, j;\n\t\n\t\t\t// buffer\n\t\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\t\tvar indices = [];\n\t\n\t\t\t// create buffer data\n\t\n\t\t\tgenerateBufferData();\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', Float32Attribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', Float32Attribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );\n\t\n\t\t\t// functions\n\t\n\t\t\tfunction generateBufferData() {\n\t\n\t\t\t\tfor ( i = 0; i < tubularSegments; i ++ ) {\n\t\n\t\t\t\t\tgenerateSegment( i );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t\t// at the regular position on the given path\n\t\t\t\t//\n\t\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\t\n\t\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\t\n\t\t\t\t// uvs are generated in a separate function.\n\t\t\t\t// this makes it easy compute correct values for closed geometries\n\t\n\t\t\t\tgenerateUVs();\n\t\n\t\t\t\t// finally create faces\n\t\n\t\t\t\tgenerateIndices();\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateSegment( i ) {\n\t\n\t\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\t\n\t\t\t\tvar P = path.getPointAt( i / tubularSegments );\n\t\n\t\t\t\t// retrieve corresponding normal and binormal\n\t\n\t\t\t\tvar N = frames.normals[ i ];\n\t\t\t\tvar B = frames.binormals[ i ];\n\t\n\t\t\t\t// generate normals and vertices for the current segment\n\t\n\t\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\t\n\t\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\n\t\t\t\t\tvar sin =   Math.sin( v );\n\t\t\t\t\tvar cos = - Math.cos( v );\n\t\n\t\t\t\t\t// normal\n\t\n\t\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\t\tnormal.normalize();\n\t\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t// vertex\n\t\n\t\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\t\tvertex.z = P.z + radius * normal.z;\n\t\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateIndices() {\n\t\n\t\t\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\t\n\t\t\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\t\n\t\t\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\t\n\t\t\t\t\t\t// faces\n\t\n\t\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\t\tindices.push( b, c, d );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateUVs() {\n\t\n\t\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\t\n\t\t\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\t\n\t\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\t\tuv.y = j / radialSegments;\n\t\n\t\t\t\t\t\tuvs.push( uv.x, uv.y );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\n\t\n\t\t/**\n\t\t * @author oosmoxiecode / https://github.com/oosmoxiecode\n\t\t * @author WestLangley / https://github.com/WestLangley\n\t\t * @author zz85 / https://github.com/zz85\n\t\t * @author miningold / https://github.com/miningold\n\t\t * @author jonobr1 / https://github.com/jonobr1\n\t\t *\n\t\t * Creates a tube which extrudes along a 3d spline.\n\t\t */\n\t\n\t\tfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TubeGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tpath: path,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradius: radius,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tclosed: closed\n\t\t\t};\n\t\n\t\t\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\n\t\n\t\t\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\n\t\n\t\t\t// expose internals\n\t\n\t\t\tthis.tangents = bufferGeometry.tangents;\n\t\t\tthis.normals = bufferGeometry.normals;\n\t\t\tthis.binormals = bufferGeometry.binormals;\n\t\n\t\t\t// create geometry\n\t\n\t\t\tthis.fromBufferGeometry( bufferGeometry );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tTubeGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTubeGeometry.prototype.constructor = TubeGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t *\n\t\t * see: http://www.blackpawn.com/texts/pqtorus/\n\t\t */\n\t\tfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'TorusKnotBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tp: p,\n\t\t\t\tq: q\n\t\t\t};\n\t\n\t\t\tradius = radius || 100;\n\t\t\ttube = tube || 40;\n\t\t\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\t\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\t\tp = p || 2;\n\t\t\tq = q || 3;\n\t\n\t\t\t// used to calculate buffer length\n\t\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\t\n\t\t\t// buffers\n\t\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t\t// helper variables\n\t\t\tvar i, j, index = 0, indexOffset = 0;\n\t\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar normal = new Vector3();\n\t\t\tvar uv = new Vector2();\n\t\n\t\t\tvar P1 = new Vector3();\n\t\t\tvar P2 = new Vector3();\n\t\n\t\t\tvar B = new Vector3();\n\t\t\tvar T = new Vector3();\n\t\t\tvar N = new Vector3();\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\t\n\t\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\t\n\t\t\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\t\n\t\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\t\n\t\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\t\n\t\t\t\t// calculate orthonormal basis\n\t\n\t\t\t\tT.subVectors( P2, P1 );\n\t\t\t\tN.addVectors( P2, P1 );\n\t\t\t\tB.crossVectors( T, N );\n\t\t\t\tN.crossVectors( B, T );\n\t\n\t\t\t\t// normalize B, N. T can be ignored, we don't use it\n\t\n\t\t\t\tB.normalize();\n\t\t\t\tN.normalize();\n\t\n\t\t\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\t\n\t\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\t\n\t\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\t\t\tvar cy = tube * Math.sin( v );\n\t\n\t\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\t\n\t\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\t\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\t\n\t\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\t\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\t\n\t\t\t\t\t// face one\n\t\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t\t// face two\n\t\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', vertices );\n\t\t\tthis.addAttribute( 'normal', normals );\n\t\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t\t// this function calculates the current position on the torus curve\n\t\n\t\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\t\n\t\t\t\tvar cu = Math.cos( u );\n\t\t\t\tvar su = Math.sin( u );\n\t\t\t\tvar quOverP = q / p * u;\n\t\t\t\tvar cs = Math.cos( quOverP );\n\t\n\t\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\n\t\n\t\t/**\n\t\t * @author oosmoxiecode\n\t\t */\n\t\n\t\tfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TorusKnotGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tp: p,\n\t\t\t\tq: q\n\t\t\t};\n\t\n\t\t\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\t\n\t\t\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'TorusBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tarc: arc\n\t\t\t};\n\t\n\t\t\tradius = radius || 100;\n\t\t\ttube = tube || 40;\n\t\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\t\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\t\t\tarc = arc || Math.PI * 2;\n\t\n\t\t\t// used to calculate buffer length\n\t\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\t\n\t\t\t// buffers\n\t\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\t\n\t\t\t// offset variables\n\t\t\tvar vertexBufferOffset = 0;\n\t\t\tvar uvBufferOffset = 0;\n\t\t\tvar indexBufferOffset = 0;\n\t\n\t\t\t// helper variables\n\t\t\tvar center = new Vector3();\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar normal = new Vector3();\n\t\n\t\t\tvar j, i;\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\t\n\t\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\t\n\t\t\t\t\tvar u = i / tubularSegments * arc;\n\t\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\t\tvertex.z = tube * Math.sin( v );\n\t\n\t\t\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\n\t\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\n\t\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\n\t\n\t\t\t\t\t// this vector is used to calculate the normal\n\t\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\t\tcenter.y = radius * Math.sin( u );\n\t\n\t\t\t\t\t// normal\n\t\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\t\n\t\t\t\t\tnormals[ vertexBufferOffset ] = normal.x;\n\t\t\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\n\t\t\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\n\t\t\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\n\t\n\t\t\t\t\t// update offsets\n\t\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\t\tuvBufferOffset += 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\t\n\t\t\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\t\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\t\n\t\t\t\t\t// face one\n\t\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\t\n\t\t\t\t\t// face two\n\t\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\t\n\t\t\t\t\t// update offset\n\t\t\t\t\tindexBufferOffset += 6;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\t\n\t\t}\n\t\n\t\tTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\n\t\n\t\t/**\n\t\t * @author oosmoxiecode\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n\t\t */\n\t\n\t\tfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TorusGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tarc: arc\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\t\n\t\t}\n\t\n\t\tTorusGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTorusGeometry.prototype.constructor = TorusGeometry;\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t */\n\t\n\t\tvar ShapeUtils = {\n\t\n\t\t\t// calculate area of the contour polygon\n\t\n\t\t\tarea: function ( contour ) {\n\t\n\t\t\t\tvar n = contour.length;\n\t\t\t\tvar a = 0.0;\n\t\n\t\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\t\n\t\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn a * 0.5;\n\t\n\t\t\t},\n\t\n\t\t\ttriangulate: ( function () {\n\t\n\t\t\t\t/**\n\t\t\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t\t\t * See original code and more information here:\n\t\t\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t\t\t *\n\t\t\t\t * ported to actionscript by Zevan Rosser\n\t\t\t\t * www.actionsnippet.com\n\t\t\t\t *\n\t\t\t\t * ported to javascript by Joshua Koo\n\t\t\t\t * http://www.lab4games.net/zz85/blog\n\t\t\t\t *\n\t\t\t\t */\n\t\n\t\t\t\tfunction snip( contour, u, v, w, n, verts ) {\n\t\n\t\t\t\t\tvar p;\n\t\t\t\t\tvar ax, ay, bx, by;\n\t\t\t\t\tvar cx, cy, px, py;\n\t\n\t\t\t\t\tax = contour[ verts[ u ] ].x;\n\t\t\t\t\tay = contour[ verts[ u ] ].y;\n\t\n\t\t\t\t\tbx = contour[ verts[ v ] ].x;\n\t\t\t\t\tby = contour[ verts[ v ] ].y;\n\t\n\t\t\t\t\tcx = contour[ verts[ w ] ].x;\n\t\t\t\t\tcy = contour[ verts[ w ] ].y;\n\t\n\t\t\t\t\tif ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;\n\t\n\t\t\t\t\tvar aX, aY, bX, bY, cX, cY;\n\t\t\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\t\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\t\n\t\t\t\t\taX = cx - bx;  aY = cy - by;\n\t\t\t\t\tbX = ax - cx;  bY = ay - cy;\n\t\t\t\t\tcX = bx - ax;  cY = by - ay;\n\t\n\t\t\t\t\tfor ( p = 0; p < n; p ++ ) {\n\t\n\t\t\t\t\t\tpx = contour[ verts[ p ] ].x;\n\t\t\t\t\t\tpy = contour[ verts[ p ] ].y;\n\t\n\t\t\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\n\t\t\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\n\t\t\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\n\t\n\t\t\t\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\t\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\t\t\t\tcpx = px - cx;  cpy = py - cy;\n\t\n\t\t\t\t\t\t// see if p is inside triangle abc\n\t\n\t\t\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\n\t\t\t\t\t\tcCROSSap = cX * apy - cY * apx;\n\t\t\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\n\t\n\t\t\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// takes in an contour array and returns\n\t\n\t\t\t\treturn function triangulate( contour, indices ) {\n\t\n\t\t\t\t\tvar n = contour.length;\n\t\n\t\t\t\t\tif ( n < 3 ) return null;\n\t\n\t\t\t\t\tvar result = [],\n\t\t\t\t\t\tverts = [],\n\t\t\t\t\t\tvertIndices = [];\n\t\n\t\t\t\t\t/* we want a counter-clockwise polygon in verts */\n\t\n\t\t\t\t\tvar u, v, w;\n\t\n\t\t\t\t\tif ( ShapeUtils.area( contour ) > 0.0 ) {\n\t\n\t\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar nv = n;\n\t\n\t\t\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\t\n\t\t\t\t\tvar count = 2 * nv;   /* error detection */\n\t\n\t\t\t\t\tfor ( v = nv - 1; nv > 2; ) {\n\t\n\t\t\t\t\t\t/* if we loop, it is probably a non-simple polygon */\n\t\n\t\t\t\t\t\tif ( ( count -- ) <= 0 ) {\n\t\n\t\t\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\t\n\t\t\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t\t\t\t//return null;\n\t\t\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\t\n\t\t\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\t\t\treturn result;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\t\n\t\t\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\t\n\t\t\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\t\n\t\t\t\t\t\t\tvar a, b, c, s, t;\n\t\n\t\t\t\t\t\t\t/* true names of the vertices */\n\t\n\t\t\t\t\t\t\ta = verts[ u ];\n\t\t\t\t\t\t\tb = verts[ v ];\n\t\t\t\t\t\t\tc = verts[ w ];\n\t\n\t\t\t\t\t\t\t/* output Triangle */\n\t\n\t\t\t\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\t\t\t\tcontour[ b ],\n\t\t\t\t\t\t\t\tcontour[ c ] ] );\n\t\n\t\n\t\t\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\t\n\t\t\t\t\t\t\t/* remove v from the remaining polygon */\n\t\n\t\t\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\t\n\t\t\t\t\t\t\t\tverts[ s ] = verts[ t ];\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tnv --;\n\t\n\t\t\t\t\t\t\t/* reset error detection counter */\n\t\n\t\t\t\t\t\t\tcount = 2 * nv;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t}\n\t\n\t\t\t} )(),\n\t\n\t\t\ttriangulateShape: function ( contour, holes ) {\n\t\n\t\t\t\tfunction removeDupEndPts(points) {\n\t\n\t\t\t\t\tvar l = points.length;\n\t\n\t\t\t\t\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\t\n\t\t\t\t\t\tpoints.pop();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tremoveDupEndPts( contour );\n\t\t\t\tholes.forEach( removeDupEndPts );\n\t\n\t\t\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\t\n\t\t\t\t\t// inOtherPt needs to be collinear to the inSegment\n\t\t\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\n\t\n\t\t\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\n\t\n\t\t\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\n\t\n\t\t\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\t\n\t\t\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n\t\t\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\t\n\t\t\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n\t\t\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\t\n\t\t\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\n\t\t\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\t\n\t\t\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t\t// not parallel\n\t\n\t\t\t\t\t\tvar perpSeg2;\n\t\t\t\t\t\tif ( limit > 0 ) {\n\t\n\t\t\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\n\t\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\n\t\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// i.e. to reduce rounding errors\n\t\t\t\t\t\t// intersection at endpoint of segment#1?\n\t\t\t\t\t\tif ( perpSeg2 === 0 ) {\n\t\n\t\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( perpSeg2 === limit ) {\n\t\n\t\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\t\treturn [ inSeg1Pt2 ];\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// intersection at endpoint of segment#2?\n\t\t\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\n\t\t\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\n\t\n\t\t\t\t\t\t// return real intersection point\n\t\t\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\n\t\t\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n\t\t\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\n\t\t\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\n\t\n\t\t\t\t\t\t// they are collinear or degenerate\n\t\t\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\n\t\t\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\n\t\t\t\t\t\t// both segments are points\n\t\t\t\t\t\tif ( seg1Pt && seg2Pt ) {\n\t\n\t\t\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n\t\t\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\n\t\t\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// segment#1  is a single point\n\t\t\t\t\t\tif ( seg1Pt ) {\n\t\n\t\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\n\t\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// segment#2  is a single point\n\t\t\t\t\t\tif ( seg2Pt ) {\n\t\n\t\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\n\t\t\t\t\t\t\treturn [ inSeg2Pt1 ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// they are collinear segments, which might overlap\n\t\t\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\n\t\t\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\n\t\t\t\t\t\tif ( seg1dx !== 0 ) {\n\t\n\t\t\t\t\t\t\t// the segments are NOT on a vertical line\n\t\t\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\t\n\t\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n\t\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n\t\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\t\n\t\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n\t\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n\t\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// the segments are on a vertical line\n\t\t\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\t\n\t\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n\t\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n\t\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\t\n\t\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n\t\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n\t\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1minVal <= seg2minVal ) {\n\t\n\t\t\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\n\t\t\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\n\t\n\t\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\t\treturn [ seg2min ];\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\n\t\t\t\t\t\t\treturn\t[ seg2min, seg2max ];\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\n\t\t\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\n\t\n\t\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\t\treturn [ seg1min ];\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\n\t\t\t\t\t\t\treturn\t[ seg1min, seg2max ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\t\n\t\t\t\t\t// The order of legs is important\n\t\n\t\t\t\t\t// translation of all points, so that Vertex is at (0,0)\n\t\t\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\n\t\t\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\n\t\t\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\n\t\n\t\t\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\t\t\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\n\t\t\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\n\t\n\t\t\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t\t// angle != 180 deg.\n\t\n\t\t\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\n\t\t\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\t\n\t\t\t\t\t\tif ( from2toAngle > 0 ) {\n\t\n\t\t\t\t\t\t\t// main angle < 180 deg.\n\t\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// main angle > 180 deg.\n\t\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// angle == 180 deg.\n\t\t\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n\t\t\t\t\t\treturn\t( from2otherAngle > 0 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\tfunction removeHoles( contour, holes ) {\n\t\n\t\t\t\t\tvar shape = contour.concat(); // work on this shape\n\t\t\t\t\tvar hole;\n\t\n\t\t\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\t\n\t\t\t\t\t\t// Check if hole point lies within angle around shape point\n\t\t\t\t\t\tvar lastShapeIdx = shape.length - 1;\n\t\n\t\t\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\n\t\t\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\n\t\n\t\t\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\n\t\t\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\n\t\n\t\t\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n\t\t\t\t\t\tif ( ! insideAngle ) {\n\t\n\t\t\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n\t\t\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Check if shape point lies within angle around hole point\n\t\t\t\t\t\tvar lastHoleIdx = hole.length - 1;\n\t\n\t\t\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\n\t\t\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\n\t\n\t\t\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\n\t\t\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\n\t\n\t\t\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n\t\t\t\t\t\tif ( ! insideAngle ) {\n\t\n\t\t\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n\t\t\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn\ttrue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\n\t\n\t\t\t\t\t\t// checks for intersections with shape edges\n\t\t\t\t\t\tvar sIdx, nextIdx, intersection;\n\t\t\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\t\n\t\t\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\n\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar indepHoles = [];\n\t\n\t\t\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\n\t\n\t\t\t\t\t\t// checks for intersections with hole edges\n\t\t\t\t\t\tvar ihIdx, chkHole,\n\t\t\t\t\t\t\thIdx, nextIdx, intersection;\n\t\t\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\t\n\t\t\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\n\t\t\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\t\n\t\t\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\n\t\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n\t\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar holeIndex, shapeIndex,\n\t\t\t\t\t\tshapePt, holePt,\n\t\t\t\t\t\tholeIdx, cutKey, failedCuts = [],\n\t\t\t\t\t\ttmpShape1, tmpShape2,\n\t\t\t\t\t\ttmpHole1, tmpHole2;\n\t\n\t\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\t\tindepHoles.push( h );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar minShapeIndex = 0;\n\t\t\t\t\tvar counter = indepHoles.length * 2;\n\t\t\t\t\twhile ( indepHoles.length > 0 ) {\n\t\n\t\t\t\t\t\tcounter --;\n\t\t\t\t\t\tif ( counter < 0 ) {\n\t\n\t\t\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// search for shape-vertex and hole-vertex,\n\t\t\t\t\t\t// which can be connected without intersections\n\t\t\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\t\n\t\t\t\t\t\t\tshapePt = shape[ shapeIndex ];\n\t\t\t\t\t\t\tholeIndex\t= - 1;\n\t\n\t\t\t\t\t\t\t// search for hole which can be reached without intersections\n\t\t\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\n\t\n\t\t\t\t\t\t\t\tholeIdx = indepHoles[ h ];\n\t\n\t\t\t\t\t\t\t\t// prevent multiple checks\n\t\t\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n\t\t\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\n\t\n\t\t\t\t\t\t\t\thole = holes[ holeIdx ];\n\t\t\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tholePt = hole[ h2 ];\n\t\t\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\n\t\t\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\n\t\t\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\n\t\n\t\t\t\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\n\t\n\t\t\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\n\t\t\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\n\t\n\t\t\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\t\n\t\t\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\n\t\n\t\t\t\t\t\t\t\t\t// Debug only, to show the selected cuts\n\t\t\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\n\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\t\n\t\t\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn shape; \t\t\t/* shape with no holes */\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\tvar i, il, f, face,\n\t\t\t\t\tkey, index,\n\t\t\t\t\tallPointsMap = {};\n\t\n\t\t\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\t\n\t\t\t\tvar allpoints = contour.concat();\n\t\n\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\t\n\t\t\t\t// prepare all points map\n\t\n\t\t\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\t\n\t\t\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.ShapeUtils: Duplicate point\", key, i );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tallPointsMap[ key ] = i;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// remove holes by cutting paths to holes and adding them to the shape\n\t\t\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\n\t\n\t\t\t\tvar triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n\t\t\t\t//console.log( \"triangles\",triangles, triangles.length );\n\t\n\t\t\t\t// check all face vertices against all points map\n\t\n\t\t\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tface = triangles[ i ];\n\t\n\t\t\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\t\n\t\t\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\t\n\t\t\t\t\t\tindex = allPointsMap[ key ];\n\t\n\t\t\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\t\t\tface[ f ] = index;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn triangles.concat();\n\t\n\t\t\t},\n\t\n\t\t\tisClockWise: function ( pts ) {\n\t\n\t\t\t\treturn ShapeUtils.area( pts ) < 0;\n\t\n\t\t\t},\n\t\n\t\t\t// Bezier Curves formulas obtained from\n\t\t\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\t\n\t\t\t// Quad Bezier Functions\n\t\n\t\t\tb2: ( function () {\n\t\n\t\t\t\tfunction b2p0( t, p ) {\n\t\n\t\t\t\t\tvar k = 1 - t;\n\t\t\t\t\treturn k * k * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction b2p1( t, p ) {\n\t\n\t\t\t\t\treturn 2 * ( 1 - t ) * t * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction b2p2( t, p ) {\n\t\n\t\t\t\t\treturn t * t * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function b2( t, p0, p1, p2 ) {\n\t\n\t\t\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\t// Cubic Bezier Functions\n\t\n\t\t\tb3: ( function () {\n\t\n\t\t\t\tfunction b3p0( t, p ) {\n\t\n\t\t\t\t\tvar k = 1 - t;\n\t\t\t\t\treturn k * k * k * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction b3p1( t, p ) {\n\t\n\t\t\t\t\tvar k = 1 - t;\n\t\t\t\t\treturn 3 * k * k * t * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction b3p2( t, p ) {\n\t\n\t\t\t\t\tvar k = 1 - t;\n\t\t\t\t\treturn 3 * k * t * t * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction b3p3( t, p ) {\n\t\n\t\t\t\t\treturn t * t * t * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function b3( t, p0, p1, p2, p3 ) {\n\t\n\t\t\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t *\n\t\t * Creates extruded geometry from a path shape.\n\t\t *\n\t\t * parameters = {\n\t\t *\n\t\t *  curveSegments: <int>, // number of points on the curves\n\t\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n\t\t *  amount: <int>, // Depth to extrude the shape\n\t\t *\n\t\t *  bevelEnabled: <bool>, // turn on bevel\n\t\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\n\t\t *  bevelSize: <float>, // how far from shape outline is bevel\n\t\t *  bevelSegments: <int>, // number of bevel layers\n\t\t *\n\t\t *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n\t\t *  frames: <Object> // containing arrays of tangents, normals, binormals\n\t\t *\n\t\t *  uvGenerator: <Object> // object that provides UV generator functions\n\t\t *\n\t\t * }\n\t\t **/\n\t\n\t\tfunction ExtrudeGeometry( shapes, options ) {\n\t\n\t\t\tif ( typeof( shapes ) === \"undefined\" ) {\n\t\n\t\t\t\tshapes = [];\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'ExtrudeGeometry';\n\t\n\t\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\t\n\t\t\tthis.addShapeList( shapes, options );\n\t\n\t\t\tthis.computeFaceNormals();\n\t\n\t\t\t// can't really use automatic vertex normals\n\t\t\t// as then front and back sides get smoothed too\n\t\t\t// should do separate smoothing just for sides\n\t\n\t\t\t//this.computeVertexNormals();\n\t\n\t\t\t//console.log( \"took\", ( Date.now() - startTime ) );\n\t\n\t\t}\n\t\n\t\tExtrudeGeometry.prototype = Object.create( Geometry.prototype );\n\t\tExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\n\t\n\t\tExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\t\n\t\t\tvar sl = shapes.length;\n\t\n\t\t\tfor ( var s = 0; s < sl; s ++ ) {\n\t\n\t\t\t\tvar shape = shapes[ s ];\n\t\t\t\tthis.addShape( shape, options );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\t\n\t\t\tvar amount = options.amount !== undefined ? options.amount : 100;\n\t\n\t\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\t\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\t\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\t\n\t\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\t\n\t\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\n\t\t\tvar steps = options.steps !== undefined ? options.steps : 1;\n\t\n\t\t\tvar extrudePath = options.extrudePath;\n\t\t\tvar extrudePts, extrudeByPath = false;\n\t\n\t\t\t// Use default WorldUVGenerator if no UV generators are specified.\n\t\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;\n\t\n\t\t\tvar splineTube, binormal, normal, position2;\n\t\t\tif ( extrudePath ) {\n\t\n\t\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\t\n\t\t\t\textrudeByPath = true;\n\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\t\n\t\t\t\t// SETUP TNB variables\n\t\n\t\t\t\t// TODO1 - have a .isClosed in spline?\n\t\n\t\t\t\tsplineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );\n\t\n\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\t\n\t\t\t\tbinormal = new Vector3();\n\t\t\t\tnormal = new Vector3();\n\t\t\t\tposition2 = new Vector3();\n\t\n\t\t\t}\n\t\n\t\t\t// Safeguards if bevels are not enabled\n\t\n\t\t\tif ( ! bevelEnabled ) {\n\t\n\t\t\t\tbevelSegments = 0;\n\t\t\t\tbevelThickness = 0;\n\t\t\t\tbevelSize = 0;\n\t\n\t\t\t}\n\t\n\t\t\t// Variables initialization\n\t\n\t\t\tvar ahole, h, hl; // looping of holes\n\t\t\tvar scope = this;\n\t\n\t\t\tvar shapesOffset = this.vertices.length;\n\t\n\t\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\t\n\t\t\tvar vertices = shapePoints.shape;\n\t\t\tvar holes = shapePoints.holes;\n\t\n\t\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\t\n\t\t\tif ( reverse ) {\n\t\n\t\t\t\tvertices = vertices.reverse();\n\t\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\t\n\t\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tahole = holes[ h ];\n\t\n\t\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\t\n\t\t\t\t\t\tholes[ h ] = ahole.reverse();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\t\n\t\t\t}\n\t\n\t\n\t\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\t\n\t\t\t/* Vertices */\n\t\n\t\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\t\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tahole = holes[ h ];\n\t\n\t\t\t\tvertices = vertices.concat( ahole );\n\t\n\t\t\t}\n\t\n\t\n\t\t\tfunction scalePt2( pt, vec, size ) {\n\t\n\t\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\t\n\t\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\t\n\t\t\t}\n\t\n\t\t\tvar b, bs, t, z,\n\t\t\t\tvert, vlen = vertices.length,\n\t\t\t\tface, flen = faces.length;\n\t\n\t\n\t\t\t// Find directions for point movement\n\t\n\t\n\t\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\t\n\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t//\n\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\t\n\t\t\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\n\t\n\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\t\n\t\t\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n\t\t\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\t\n\t\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\t\n\t\t\t\t// check for collinear edges\n\t\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\t\n\t\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t// not collinear\n\t\n\t\t\t\t\t// length of vectors for normalizing\n\t\n\t\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\t\n\t\t\t\t\t// shift adjacent points by unit vectors to the left\n\t\n\t\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\t\n\t\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\t\n\t\t\t\t\t// scaling factor for v_prev to intersection point\n\t\n\t\t\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n\t\t\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\t\n\t\t\t\t\t// vector from inPt to intersection point\n\t\n\t\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\t\n\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t//  but prevent crazy spikes\n\t\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\t\n\t\t\t\t\t\treturn\tnew Vector2( v_trans_x, v_trans_y );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// handle special case of collinear edges\n\t\n\t\t\t\t\tvar direction_eq = false;\t\t// assumes: opposite\n\t\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\t\n\t\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\t\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( direction_eq ) {\n\t\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\t\tv_trans_y =  v_prev_x;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn\tnew Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\t\n\t\t\t}\n\t\n\t\n\t\t\tvar contourMovements = [];\n\t\n\t\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\t\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\t\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t// console.log('i,j,k', i, j , k)\n\t\n\t\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\t\n\t\t\t}\n\t\n\t\t\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\t\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tahole = holes[ h ];\n\t\n\t\t\t\toneHoleMovements = [];\n\t\n\t\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\t\n\t\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\t\tif ( k === il ) k = 0;\n\t\n\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\t\n\t\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\t\n\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\t\n\t\t\t\tt = b / bevelSegments;\n\t\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\t\n\t\t\t\t// contract shape\n\t\n\t\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\n\t\t\t\t\tv( vert.x, vert.y,  - z );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// expand holes\n\t\n\t\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\t\n\t\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\t\n\t\t\t\t\t\tv( vert.x, vert.y,  - z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tbs = bevelSize;\n\t\n\t\t\t// Back facing vertices\n\t\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\t\n\t\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\t\tv( vert.x, vert.y, 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\t\n\t\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\t\n\t\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\t\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Add stepped vertices...\n\t\t\t// Including front facing vertices\n\t\n\t\t\tvar s;\n\t\n\t\t\tfor ( s = 1; s <= steps; s ++ ) {\n\t\n\t\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\t\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\t\n\t\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\t\n\t\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\t\n\t\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// Add bevel segments planes\n\t\n\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\t\n\t\t\t\tt = b / bevelSegments;\n\t\t\t\tz = bevelThickness * Math.cos ( t * Math.PI / 2 );\n\t\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\t\n\t\t\t\t// contract shape\n\t\n\t\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// expand holes\n\t\n\t\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\t\n\t\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\t\n\t\t\t\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t/* Faces */\n\t\n\t\t\t// Top and bottom faces\n\t\n\t\t\tbuildLidFaces();\n\t\n\t\t\t// Sides faces\n\t\n\t\t\tbuildSideFaces();\n\t\n\t\n\t\t\t/////  Internal functions\n\t\n\t\t\tfunction buildLidFaces() {\n\t\n\t\t\t\tif ( bevelEnabled ) {\n\t\n\t\t\t\t\tvar layer = 0; // steps + 1\n\t\t\t\t\tvar offset = vlen * layer;\n\t\n\t\t\t\t\t// Bottom faces\n\t\n\t\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\toffset = vlen * layer;\n\t\n\t\t\t\t\t// Top faces\n\t\n\t\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Bottom faces\n\t\n\t\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Top faces\n\t\n\t\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Create faces for the z-sides of the shape\n\t\n\t\t\tfunction buildSideFaces() {\n\t\n\t\t\t\tvar layeroffset = 0;\n\t\t\t\tsidewalls( contour, layeroffset );\n\t\t\t\tlayeroffset += contour.length;\n\t\n\t\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tahole = holes[ h ];\n\t\t\t\t\tsidewalls( ahole, layeroffset );\n\t\n\t\t\t\t\t//, true\n\t\t\t\t\tlayeroffset += ahole.length;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction sidewalls( contour, layeroffset ) {\n\t\n\t\t\t\tvar j, k;\n\t\t\t\ti = contour.length;\n\t\n\t\t\t\twhile ( -- i >= 0 ) {\n\t\n\t\t\t\t\tj = i;\n\t\t\t\t\tk = i - 1;\n\t\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\t\n\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\t\n\t\t\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\t\n\t\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\t\n\t\t\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\t\n\t\t\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\t\n\t\t\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\n\t\t\tfunction v( x, y, z ) {\n\t\n\t\t\t\tscope.vertices.push( new Vector3( x, y, z ) );\n\t\n\t\t\t}\n\t\n\t\t\tfunction f3( a, b, c ) {\n\t\n\t\t\t\ta += shapesOffset;\n\t\t\t\tb += shapesOffset;\n\t\t\t\tc += shapesOffset;\n\t\n\t\t\t\tscope.faces.push( new Face3( a, b, c, null, null, 0 ) );\n\t\n\t\t\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\n\t\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\t\n\t\t\t}\n\t\n\t\t\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\t\n\t\t\t\ta += shapesOffset;\n\t\t\t\tb += shapesOffset;\n\t\t\t\tc += shapesOffset;\n\t\t\t\td += shapesOffset;\n\t\n\t\t\t\tscope.faces.push( new Face3( a, b, d, null, null, 1 ) );\n\t\t\t\tscope.faces.push( new Face3( b, c, d, null, null, 1 ) );\n\t\n\t\t\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\t\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tExtrudeGeometry.WorldUVGenerator = {\n\t\n\t\t\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\t\n\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\tvar a = vertices[ indexA ];\n\t\t\t\tvar b = vertices[ indexB ];\n\t\t\t\tvar c = vertices[ indexC ];\n\t\n\t\t\t\treturn [\n\t\t\t\t\tnew Vector2( a.x, a.y ),\n\t\t\t\t\tnew Vector2( b.x, b.y ),\n\t\t\t\t\tnew Vector2( c.x, c.y )\n\t\t\t\t];\n\t\n\t\t\t},\n\t\n\t\t\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\t\n\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\tvar a = vertices[ indexA ];\n\t\t\t\tvar b = vertices[ indexB ];\n\t\t\t\tvar c = vertices[ indexC ];\n\t\t\t\tvar d = vertices[ indexD ];\n\t\n\t\t\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\n\t\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew Vector2( a.x, 1 - a.z ),\n\t\t\t\t\t\tnew Vector2( b.x, 1 - b.z ),\n\t\t\t\t\t\tnew Vector2( c.x, 1 - c.z ),\n\t\t\t\t\t\tnew Vector2( d.x, 1 - d.z )\n\t\t\t\t\t];\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew Vector2( a.y, 1 - a.z ),\n\t\t\t\t\t\tnew Vector2( b.y, 1 - b.z ),\n\t\t\t\t\t\tnew Vector2( c.y, 1 - c.z ),\n\t\t\t\t\t\tnew Vector2( d.y, 1 - d.z )\n\t\t\t\t\t];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * Text = 3D Text\n\t\t *\n\t\t * parameters = {\n\t\t *  font: <THREE.Font>, // font\n\t\t *\n\t\t *  size: <float>, // size of the text\n\t\t *  height: <float>, // thickness to extrude text\n\t\t *  curveSegments: <int>, // number of points on the curves\n\t\t *\n\t\t *  bevelEnabled: <bool>, // turn on bevel\n\t\t *  bevelThickness: <float>, // how deep into text bevel goes\n\t\t *  bevelSize: <float> // how far from text outline is bevel\n\t\t * }\n\t\t */\n\t\n\t\tfunction TextGeometry( text, parameters ) {\n\t\n\t\t\tparameters = parameters || {};\n\t\n\t\t\tvar font = parameters.font;\n\t\n\t\t\tif ( (font && font.isFont) === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\t\t\treturn new Geometry();\n\t\n\t\t\t}\n\t\n\t\t\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\t\n\t\t\t// translate parameters to ExtrudeGeometry API\n\t\n\t\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\t\n\t\t\t// defaults\n\t\n\t\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\t\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\t\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\t\n\t\t\tExtrudeGeometry.call( this, shapes, parameters );\n\t\n\t\t\tthis.type = 'TextGeometry';\n\t\n\t\t}\n\t\n\t\tTextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );\n\t\tTextGeometry.prototype.constructor = TextGeometry;\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t * based on THREE.SphereGeometry\n\t\t */\n\t\n\t\tfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'SphereBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tradius = radius || 50;\n\t\n\t\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\t\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\t\n\t\t\tphiStart = phiStart !== undefined ? phiStart : 0;\n\t\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\t\n\t\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\t\n\t\t\tvar thetaEnd = thetaStart + thetaLength;\n\t\n\t\t\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\n\t\n\t\t\tvar positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t\tvar index = 0, vertices = [], normal = new Vector3();\n\t\n\t\t\tfor ( var y = 0; y <= heightSegments; y ++ ) {\n\t\n\t\t\t\tvar verticesRow = [];\n\t\n\t\t\t\tvar v = y / heightSegments;\n\t\n\t\t\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\n\t\n\t\t\t\t\tvar u = x / widthSegments;\n\t\n\t\t\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\n\t\t\t\t\tnormal.set( px, py, pz ).normalize();\n\t\n\t\t\t\t\tpositions.setXYZ( index, px, py, pz );\n\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\t\t\t\tuvs.setXY( index, u, 1 - v );\n\t\n\t\t\t\t\tverticesRow.push( index );\n\t\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvertices.push( verticesRow );\n\t\n\t\t\t}\n\t\n\t\t\tvar indices = [];\n\t\n\t\t\tfor ( var y = 0; y < heightSegments; y ++ ) {\n\t\n\t\t\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\n\t\n\t\t\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\t\n\t\t\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\n\t\t\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.setIndex( new ( positions.count > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', positions );\n\t\t\tthis.addAttribute( 'normal', normals );\n\t\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\t\n\t\t}\n\t\n\t\tSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'SphereGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\t\n\t\t}\n\t\n\t\tSphereGeometry.prototype = Object.create( Geometry.prototype );\n\t\tSphereGeometry.prototype.constructor = SphereGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'RingBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\touterRadius: outerRadius,\n\t\t\t\tthetaSegments: thetaSegments,\n\t\t\t\tphiSegments: phiSegments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tinnerRadius = innerRadius || 20;\n\t\t\touterRadius = outerRadius || 50;\n\t\n\t\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\t\n\t\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\t\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\t\n\t\t\t// these are used to calculate buffer length\n\t\t\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\n\t\t\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\n\t\n\t\t\t// buffers\n\t\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t\t// some helper variables\n\t\t\tvar index = 0, indexOffset = 0, segment;\n\t\t\tvar radius = innerRadius;\n\t\t\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar uv = new Vector2();\n\t\t\tvar j, i;\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\t// values are generate from the inside of the ring to the outside\n\t\n\t\t\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\t\n\t\t\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\t\n\t\t\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\t\tvertex.y = radius * Math.sin( segment );\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// normal\n\t\t\t\t\tnormals.setXYZ( index, 0, 0, 1 );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// increase the radius for next row of vertices\n\t\t\t\tradius += radiusStep;\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( j = 0; j < phiSegments; j ++ ) {\n\t\n\t\t\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\t\n\t\t\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\t\n\t\t\t\t\tsegment = i + thetaSegmentLevel;\n\t\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = segment;\n\t\t\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\t\t\tvar d = segment + 1;\n\t\n\t\t\t\t\t// face one\n\t\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\n\t\t\t\t\t// face two\n\t\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', vertices );\n\t\t\tthis.addAttribute( 'normal', normals );\n\t\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t}\n\t\n\t\tRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tRingBufferGeometry.prototype.constructor = RingBufferGeometry;\n\t\n\t\t/**\n\t\t * @author Kaleb Murphy\n\t\t */\n\t\n\t\tfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'RingGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\touterRadius: outerRadius,\n\t\t\t\tthetaSegments: thetaSegments,\n\t\t\t\tphiSegments: phiSegments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\t\n\t\t}\n\t\n\t\tRingGeometry.prototype = Object.create( Geometry.prototype );\n\t\tRingGeometry.prototype.constructor = RingGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t\t */\n\t\n\t\tfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'PlaneGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\t\n\t\t}\n\t\n\t\tPlaneGeometry.prototype = Object.create( Geometry.prototype );\n\t\tPlaneGeometry.prototype.constructor = PlaneGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\t // points - to create a closed torus, one must use a set of points\n\t\t //    like so: [ a, b, c, d, a ], see first is the same as last.\n\t\t // segments - the number of circumference segments to create\n\t\t // phiStart - the starting radian\n\t\t // phiLength - the radian (0 to 2PI) range of the lathed section\n\t\t //    2PI is a closed lathe, less than 2PI is a portion.\n\t\n\t\tfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'LatheBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tpoints: points,\n\t\t\t\tsegments: segments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength\n\t\t\t};\n\t\n\t\t\tsegments = Math.floor( segments ) || 12;\n\t\t\tphiStart = phiStart || 0;\n\t\t\tphiLength = phiLength || Math.PI * 2;\n\t\n\t\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\t\t\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\n\t\n\t\t\t// these are used to calculate buffer length\n\t\t\tvar vertexCount = ( segments + 1 ) * points.length;\n\t\t\tvar indexCount = segments * points.length * 2 * 3;\n\t\n\t\t\t// buffers\n\t\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t\t// helper variables\n\t\t\tvar index = 0, indexOffset = 0, base;\n\t\t\tvar inverseSegments = 1.0 / segments;\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar uv = new Vector2();\n\t\t\tvar i, j;\n\t\n\t\t\t// generate vertices and uvs\n\t\n\t\t\tfor ( i = 0; i <= segments; i ++ ) {\n\t\n\t\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\t\n\t\t\t\tvar sin = Math.sin( phi );\n\t\t\t\tvar cos = Math.cos( phi );\n\t\n\t\t\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\t\tvertex.z = points[ j ].x * cos;\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuv.x = i / segments;\n\t\t\t\t\tuv.y = j / ( points.length - 1 );\n\t\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( i = 0; i < segments; i ++ ) {\n\t\n\t\t\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\t\n\t\t\t\t\tbase = j + i * points.length;\n\t\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = base;\n\t\t\t\t\tvar b = base + points.length;\n\t\t\t\t\tvar c = base + points.length + 1;\n\t\t\t\t\tvar d = base + 1;\n\t\n\t\t\t\t\t// face one\n\t\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t\t// face two\n\t\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', vertices );\n\t\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t\t// generate normals\n\t\n\t\t\tthis.computeVertexNormals();\n\t\n\t\t\t// if the geometry is closed, we need to average the normals along the seam.\n\t\t\t// because the corresponding vertices are identical (but still have different UVs).\n\t\n\t\t\tif( phiLength === Math.PI * 2 ) {\n\t\n\t\t\t\tvar normals = this.attributes.normal.array;\n\t\t\t\tvar n1 = new Vector3();\n\t\t\t\tvar n2 = new Vector3();\n\t\t\t\tvar n = new Vector3();\n\t\n\t\t\t\t// this is the buffer offset for the last line of vertices\n\t\t\t\tbase = segments * points.length * 3;\n\t\n\t\t\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\t\n\t\t\t\t\t// select the normal of the vertex in the first line\n\t\t\t\t\tn1.x = normals[ j + 0 ];\n\t\t\t\t\tn1.y = normals[ j + 1 ];\n\t\t\t\t\tn1.z = normals[ j + 2 ];\n\t\n\t\t\t\t\t// select the normal of the vertex in the last line\n\t\t\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\t\t\tn2.z = normals[ base + j + 2 ];\n\t\n\t\t\t\t\t// average normals\n\t\t\t\t\tn.addVectors( n1, n2 ).normalize();\n\t\n\t\t\t\t\t// assign the new values to both normals\n\t\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\t\n\t\t\t\t} // next row\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\n\t\n\t\t/**\n\t\t * @author astrodud / http://astrodud.isgreat.org/\n\t\t * @author zz85 / https://github.com/zz85\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\t// points - to create a closed torus, one must use a set of points\n\t\t//    like so: [ a, b, c, d, a ], see first is the same as last.\n\t\t// segments - the number of circumference segments to create\n\t\t// phiStart - the starting radian\n\t\t// phiLength - the radian (0 to 2PI) range of the lathed section\n\t\t//    2PI is a closed lathe, less than 2PI is a portion.\n\t\n\t\tfunction LatheGeometry( points, segments, phiStart, phiLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'LatheGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tpoints: points,\n\t\t\t\tsegments: segments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tLatheGeometry.prototype = Object.create( Geometry.prototype );\n\t\tLatheGeometry.prototype.constructor = LatheGeometry;\n\t\n\t\t/**\n\t\t * @author jonobr1 / http://jonobr1.com\n\t\t *\n\t\t * Creates a one-sided polygonal geometry from a path shape. Similar to\n\t\t * ExtrudeGeometry.\n\t\t *\n\t\t * parameters = {\n\t\t *\n\t\t *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n\t\t *\n\t\t *\tmaterial: <int> // material index for front and back faces\n\t\t *\tuvGenerator: <Object> // object that provides UV generator functions\n\t\t *\n\t\t * }\n\t\t **/\n\t\n\t\tfunction ShapeGeometry( shapes, options ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'ShapeGeometry';\n\t\n\t\t\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\n\t\n\t\t\tthis.addShapeList( shapes, options );\n\t\n\t\t\tthis.computeFaceNormals();\n\t\n\t\t}\n\t\n\t\tShapeGeometry.prototype = Object.create( Geometry.prototype );\n\t\tShapeGeometry.prototype.constructor = ShapeGeometry;\n\t\n\t\t/**\n\t\t * Add an array of shapes to THREE.ShapeGeometry.\n\t\t */\n\t\tShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\t\n\t\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\t\n\t\t\t\tthis.addShape( shapes[ i ], options );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n\t\t */\n\t\tShapeGeometry.prototype.addShape = function ( shape, options ) {\n\t\n\t\t\tif ( options === undefined ) options = {};\n\t\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\n\t\t\tvar material = options.material;\n\t\t\tvar uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\t\n\t\t\t//\n\t\n\t\t\tvar i, l, hole;\n\t\n\t\t\tvar shapesOffset = this.vertices.length;\n\t\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\t\n\t\t\tvar vertices = shapePoints.shape;\n\t\t\tvar holes = shapePoints.holes;\n\t\n\t\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\t\n\t\t\tif ( reverse ) {\n\t\n\t\t\t\tvertices = vertices.reverse();\n\t\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\t\n\t\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\thole = holes[ i ];\n\t\n\t\t\t\t\tif ( ShapeUtils.isClockWise( hole ) ) {\n\t\n\t\t\t\t\t\tholes[ i ] = hole.reverse();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treverse = false;\n\t\n\t\t\t}\n\t\n\t\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\t\n\t\t\t// Vertices\n\t\n\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\t\n\t\t\t\thole = holes[ i ];\n\t\t\t\tvertices = vertices.concat( hole );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar vert, vlen = vertices.length;\n\t\t\tvar face, flen = faces.length;\n\t\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\t\tvert = vertices[ i ];\n\t\n\t\t\t\tthis.vertices.push( new Vector3( vert.x, vert.y, 0 ) );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\tface = faces[ i ];\n\t\n\t\t\t\tvar a = face[ 0 ] + shapesOffset;\n\t\t\t\tvar b = face[ 1 ] + shapesOffset;\n\t\t\t\tvar c = face[ 2 ] + shapesOffset;\n\t\n\t\t\t\tthis.faces.push( new Face3( a, b, c, null, null, material ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction EdgesGeometry( geometry, thresholdAngle ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\t\n\t\t\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\n\t\n\t\t\tvar edge = [ 0, 0 ], hash = {};\n\t\n\t\t\tfunction sortFunction( a, b ) {\n\t\n\t\t\t\treturn a - b;\n\t\n\t\t\t}\n\t\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\t\n\t\t\tvar geometry2;\n\t\n\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\tgeometry2 = new Geometry();\n\t\t\t\tgeometry2.fromBufferGeometry( geometry );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tgeometry2 = geometry.clone();\n\t\n\t\t\t}\n\t\n\t\t\tgeometry2.mergeVertices();\n\t\t\tgeometry2.computeFaceNormals();\n\t\n\t\t\tvar vertices = geometry2.vertices;\n\t\t\tvar faces = geometry2.faces;\n\t\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\tedge.sort( sortFunction );\n\t\n\t\t\t\t\tvar key = edge.toString();\n\t\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\t\n\t\t\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\thash[ key ].face2 = i;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar coords = [];\n\t\n\t\t\tfor ( var key in hash ) {\n\t\n\t\t\t\tvar h = hash[ key ];\n\t\n\t\t\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\n\t\n\t\t\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\t\t\tcoords.push( vertex.x );\n\t\t\t\t\tcoords.push( vertex.y );\n\t\t\t\t\tcoords.push( vertex.z );\n\t\n\t\t\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\t\t\tcoords.push( vertex.x );\n\t\t\t\t\tcoords.push( vertex.y );\n\t\t\t\t\tcoords.push( vertex.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( new Float32Array( coords ), 3 ) );\n\t\n\t\t}\n\t\n\t\tEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tEdgesGeometry.prototype.constructor = EdgesGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'CylinderBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradiusTop: radiusTop,\n\t\t\t\tradiusBottom: radiusBottom,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\t\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\t\t\theight = height !== undefined ? height : 100;\n\t\n\t\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\n\t\t\topenEnded = openEnded !== undefined ? openEnded : false;\n\t\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\t\t\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\t\n\t\t\t// used to calculate buffer length\n\t\n\t\t\tvar nbCap = 0;\n\t\n\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\tif ( radiusTop > 0 ) nbCap ++;\n\t\t\t\tif ( radiusBottom > 0 ) nbCap ++;\n\t\n\t\t\t}\n\t\n\t\t\tvar vertexCount = calculateVertexCount();\n\t\t\tvar indexCount = calculateIndexCount();\n\t\n\t\t\t// buffers\n\t\n\t\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\n\t\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t\t// helper variables\n\t\n\t\t\tvar index = 0,\n\t\t\t    indexOffset = 0,\n\t\t\t    indexArray = [],\n\t\t\t    halfHeight = height / 2;\n\t\n\t\t\t// group variables\n\t\t\tvar groupStart = 0;\n\t\n\t\t\t// generate geometry\n\t\n\t\t\tgenerateTorso();\n\t\n\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', vertices );\n\t\t\tthis.addAttribute( 'normal', normals );\n\t\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t\t// helper functions\n\t\n\t\t\tfunction calculateVertexCount() {\n\t\n\t\t\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\n\t\n\t\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn count;\n\t\n\t\t\t}\n\t\n\t\t\tfunction calculateIndexCount() {\n\t\n\t\t\t\tvar count = radialSegments * heightSegments * 2 * 3;\n\t\n\t\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\t\tcount += radialSegments * nbCap * 3;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn count;\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateTorso() {\n\t\n\t\t\t\tvar x, y;\n\t\t\t\tvar normal = new Vector3();\n\t\t\t\tvar vertex = new Vector3();\n\t\n\t\t\t\tvar groupCount = 0;\n\t\n\t\t\t\t// this will be used to calculate the normal\n\t\t\t\tvar slope = ( radiusBottom - radiusTop ) / height;\n\t\n\t\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\t\n\t\t\t\t\tvar indexRow = [];\n\t\n\t\t\t\t\tvar v = y / heightSegments;\n\t\n\t\t\t\t\t// calculate the radius of the current row\n\t\t\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\t\n\t\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\t\t\tvar u = x / radialSegments;\n\t\n\t\t\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\t\n\t\t\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\t\t\t\t\tvar cosTheta = Math.cos( theta );\n\t\n\t\t\t\t\t\t// vertex\n\t\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t\t// normal\n\t\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t\t// uv\n\t\t\t\t\t\tuvs.setXY( index, u, 1 - v );\n\t\n\t\t\t\t\t\t// save index of vertex in respective row\n\t\t\t\t\t\tindexRow.push( index );\n\t\n\t\t\t\t\t\t// increase index\n\t\t\t\t\t\tindex ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// now save vertices of the row in our index array\n\t\t\t\t\tindexArray.push( indexRow );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// generate indices\n\t\n\t\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\t\n\t\t\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\t\n\t\t\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\t\t\tvar i1 = indexArray[ y ][ x ];\n\t\t\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\n\t\t\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\n\t\n\t\t\t\t\t\t// face one\n\t\t\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\t\n\t\t\t\t\t\t// face two\n\t\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\t\n\t\t\t\t\t\t// update counters\n\t\t\t\t\t\tgroupCount += 6;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\t\n\t\t\t\t// calculate new start value for groups\n\t\t\t\tgroupStart += groupCount;\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateCap( top ) {\n\t\n\t\t\t\tvar x, centerIndexStart, centerIndexEnd;\n\t\n\t\t\t\tvar uv = new Vector2();\n\t\t\t\tvar vertex = new Vector3();\n\t\n\t\t\t\tvar groupCount = 0;\n\t\n\t\t\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\t\tvar sign = ( top === true ) ? 1 : - 1;\n\t\n\t\t\t\t// save the index of the first center vertex\n\t\t\t\tcenterIndexStart = index;\n\t\n\t\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t\t// we must generate a center vertex per face/segment\n\t\n\t\t\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\n\t\n\t\t\t\t\t// normal\n\t\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuv.x = 0.5;\n\t\t\t\t\tuv.y = 0.5;\n\t\n\t\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// save the index of the last center vertex\n\t\t\t\tcenterIndexEnd = index;\n\t\n\t\t\t\t// now we generate the surrounding vertices, normals and uvs\n\t\n\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\t\tvar u = x / radialSegments;\n\t\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\t\n\t\t\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// normal\n\t\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// generate indices\n\t\n\t\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\t\n\t\t\t\t\tvar c = centerIndexStart + x;\n\t\t\t\t\tvar i = centerIndexEnd + x;\n\t\n\t\t\t\t\tif ( top === true ) {\n\t\n\t\t\t\t\t\t// face top\n\t\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// face bottom\n\t\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// update counters\n\t\t\t\t\tgroupCount += 3;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\t\n\t\t\t\t// calculate new start value for groups\n\t\t\t\tgroupStart += groupCount;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'CylinderGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradiusTop: radiusTop,\n\t\t\t\tradiusBottom: radiusBottom,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tCylinderGeometry.prototype = Object.create( Geometry.prototype );\n\t\tCylinderGeometry.prototype.constructor = CylinderGeometry;\n\t\n\t\t/**\n\t\t * @author abelnation / http://github.com/abelnation\n\t\t */\n\t\n\t\tfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\t\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\t\n\t\t\tthis.type = 'ConeGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\n\t\tConeGeometry.prototype.constructor = ConeGeometry;\n\t\n\t\t/**\n\t\t * @author: abelnation / http://github.com/abelnation\n\t\t */\n\t\n\t\tfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\t\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\t\n\t\t\tthis.type = 'ConeBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\n\t\tConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'CircleBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tsegments: segments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tradius = radius || 50;\n\t\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\t\n\t\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\t\n\t\t\tvar vertices = segments + 2;\n\t\n\t\t\tvar positions = new Float32Array( vertices * 3 );\n\t\t\tvar normals = new Float32Array( vertices * 3 );\n\t\t\tvar uvs = new Float32Array( vertices * 2 );\n\t\n\t\t\t// center data is already zero, but need to set a few extras\n\t\t\tnormals[ 2 ] = 1.0;\n\t\t\tuvs[ 0 ] = 0.5;\n\t\t\tuvs[ 1 ] = 0.5;\n\t\n\t\t\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\n\t\n\t\t\t\tvar segment = thetaStart + s / segments * thetaLength;\n\t\n\t\t\t\tpositions[ i ] = radius * Math.cos( segment );\n\t\t\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\n\t\n\t\t\t\tnormals[ i + 2 ] = 1; // normal z\n\t\n\t\t\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\n\t\t\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\n\t\n\t\t\t}\n\t\n\t\t\tvar indices = [];\n\t\n\t\t\tfor ( var i = 1; i <= segments; i ++ ) {\n\t\n\t\t\t\tindices.push( i, i + 1, 0 );\n\t\n\t\t\t}\n\t\n\t\t\tthis.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\t\n\t\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\t\n\t\t}\n\t\n\t\tCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\n\t\n\t\t/**\n\t\t * @author hughes\n\t\t */\n\t\n\t\tfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'CircleGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tsegments: segments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\t\n\t\t}\n\t\n\t\tCircleGeometry.prototype = Object.create( Geometry.prototype );\n\t\tCircleGeometry.prototype.constructor = CircleGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n\t\t */\n\t\n\t\tfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'BoxGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepth: depth,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tdepthSegments: depthSegments\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tBoxGeometry.prototype = Object.create( Geometry.prototype );\n\t\tBoxGeometry.prototype.constructor = BoxGeometry;\n\t\n\t\n\t\n\t\tvar Geometries = Object.freeze({\n\t\t\tWireframeGeometry: WireframeGeometry,\n\t\t\tParametricGeometry: ParametricGeometry,\n\t\t\tParametricBufferGeometry: ParametricBufferGeometry,\n\t\t\tTetrahedronGeometry: TetrahedronGeometry,\n\t\t\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\n\t\t\tOctahedronGeometry: OctahedronGeometry,\n\t\t\tOctahedronBufferGeometry: OctahedronBufferGeometry,\n\t\t\tIcosahedronGeometry: IcosahedronGeometry,\n\t\t\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\n\t\t\tDodecahedronGeometry: DodecahedronGeometry,\n\t\t\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\n\t\t\tPolyhedronGeometry: PolyhedronGeometry,\n\t\t\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\n\t\t\tTubeGeometry: TubeGeometry,\n\t\t\tTubeBufferGeometry: TubeBufferGeometry,\n\t\t\tTorusKnotGeometry: TorusKnotGeometry,\n\t\t\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\n\t\t\tTorusGeometry: TorusGeometry,\n\t\t\tTorusBufferGeometry: TorusBufferGeometry,\n\t\t\tTextGeometry: TextGeometry,\n\t\t\tSphereBufferGeometry: SphereBufferGeometry,\n\t\t\tSphereGeometry: SphereGeometry,\n\t\t\tRingGeometry: RingGeometry,\n\t\t\tRingBufferGeometry: RingBufferGeometry,\n\t\t\tPlaneBufferGeometry: PlaneBufferGeometry,\n\t\t\tPlaneGeometry: PlaneGeometry,\n\t\t\tLatheGeometry: LatheGeometry,\n\t\t\tLatheBufferGeometry: LatheBufferGeometry,\n\t\t\tShapeGeometry: ShapeGeometry,\n\t\t\tExtrudeGeometry: ExtrudeGeometry,\n\t\t\tEdgesGeometry: EdgesGeometry,\n\t\t\tConeGeometry: ConeGeometry,\n\t\t\tConeBufferGeometry: ConeBufferGeometry,\n\t\t\tCylinderGeometry: CylinderGeometry,\n\t\t\tCylinderBufferGeometry: CylinderBufferGeometry,\n\t\t\tCircleBufferGeometry: CircleBufferGeometry,\n\t\t\tCircleGeometry: CircleGeometry,\n\t\t\tBoxBufferGeometry: BoxBufferGeometry,\n\t\t\tBoxGeometry: BoxGeometry\n\t\t});\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction ShadowMaterial() {\n\t\n\t\t\tShaderMaterial.call( this, {\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib[ \"lights\" ],\n\t\t\t\t\t{\n\t\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t\t}\n\t\t\t\t] ),\n\t\t\t\tvertexShader: ShaderChunk[ 'shadow_vert' ],\n\t\t\t\tfragmentShader: ShaderChunk[ 'shadow_frag' ]\n\t\t\t} );\n\t\n\t\t\tthis.lights = true;\n\t\t\tthis.transparent = true;\n\t\n\t\t\tObject.defineProperties( this, {\n\t\t\t\topacity: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn this.uniforms.opacity.value;\n\t\t\t\t\t},\n\t\t\t\t\tset: function ( value ) {\n\t\t\t\t\t\tthis.uniforms.opacity.value = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t}\n\t\n\t\tShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\t\tShadowMaterial.prototype.constructor = ShadowMaterial;\n\t\n\t\tShadowMaterial.prototype.isShadowMaterial = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction RawShaderMaterial( parameters ) {\n\t\n\t\t\tShaderMaterial.call( this, parameters );\n\t\n\t\t\tthis.type = 'RawShaderMaterial';\n\t\n\t\t}\n\t\n\t\tRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\t\tRawShaderMaterial.prototype.constructor = RawShaderMaterial;\n\t\n\t\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction MultiMaterial( materials ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.type = 'MultiMaterial';\n\t\n\t\t\tthis.materials = materials instanceof Array ? materials : [];\n\t\n\t\t\tthis.visible = true;\n\t\n\t\t}\n\t\n\t\tMultiMaterial.prototype = {\n\t\n\t\t\tconstructor: MultiMaterial,\n\t\n\t\t\tisMultiMaterial: true,\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar output = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.2,\n\t\t\t\t\t\ttype: 'material',\n\t\t\t\t\t\tgenerator: 'MaterialExporter'\n\t\t\t\t\t},\n\t\t\t\t\tuuid: this.uuid,\n\t\t\t\t\ttype: this.type,\n\t\t\t\t\tmaterials: []\n\t\t\t\t};\n\t\n\t\t\t\tvar materials = this.materials;\n\t\n\t\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar material = materials[ i ].toJSON( meta );\n\t\t\t\t\tdelete material.metadata;\n\t\n\t\t\t\t\toutput.materials.push( material );\n\t\n\t\t\t\t}\n\t\n\t\t\t\toutput.visible = this.visible;\n\t\n\t\t\t\treturn output;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\tvar material = new this.constructor();\n\t\n\t\t\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\t\n\t\t\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmaterial.visible = this.visible;\n\t\n\t\t\t\treturn material;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  roughness: <float>,\n\t\t *  metalness: <float>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  lightMap: new THREE.Texture( <Image> ),\n\t\t *  lightMapIntensity: <float>\n\t\t *\n\t\t *  aoMap: new THREE.Texture( <Image> ),\n\t\t *  aoMapIntensity: <float>\n\t\t *\n\t\t *  emissive: <hex>,\n\t\t *  emissiveIntensity: <float>\n\t\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  bumpMap: new THREE.Texture( <Image> ),\n\t\t *  bumpScale: <float>,\n\t\t *\n\t\t *  normalMap: new THREE.Texture( <Image> ),\n\t\t *  normalScale: <Vector2>,\n\t\t *\n\t\t *  displacementMap: new THREE.Texture( <Image> ),\n\t\t *  displacementScale: <float>,\n\t\t *  displacementBias: <float>,\n\t\t *\n\t\t *  roughnessMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  metalnessMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t\t *  envMapIntensity: <float>\n\t\t *\n\t\t *  refractionRatio: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshStandardMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.defines = { 'STANDARD': '' };\n\t\n\t\t\tthis.type = 'MeshStandardMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\t\tthis.roughness = 0.5;\n\t\t\tthis.metalness = 0.5;\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\t\tthis.emissive = new Color( 0x000000 );\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalScale = new Vector2( 1, 1 );\n\t\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\n\t\t\tthis.roughnessMap = null;\n\t\n\t\t\tthis.metalnessMap = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.envMap = null;\n\t\t\tthis.envMapIntensity = 1.0;\n\t\n\t\t\tthis.refractionRatio = 0.98;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshStandardMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\n\t\n\t\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\t\n\t\tMeshStandardMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.defines = { 'STANDARD': '' };\n\t\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.roughness = source.roughness;\n\t\t\tthis.metalness = source.metalness;\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\t\tthis.emissive.copy( source.emissive );\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalScale.copy( source.normalScale );\n\t\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\t\tthis.roughnessMap = source.roughnessMap;\n\t\n\t\t\tthis.metalnessMap = source.metalnessMap;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.envMapIntensity = source.envMapIntensity;\n\t\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * parameters = {\n\t\t *  reflectivity: <float>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshPhysicalMaterial( parameters ) {\n\t\n\t\t\tMeshStandardMaterial.call( this );\n\t\n\t\t\tthis.defines = { 'PHYSICAL': '' };\n\t\n\t\t\tthis.type = 'MeshPhysicalMaterial';\n\t\n\t\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\t\n\t\t\tthis.clearCoat = 0.0;\n\t\t\tthis.clearCoatRoughness = 0.0;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\n\t\tMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\n\t\n\t\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\t\n\t\tMeshPhysicalMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMeshStandardMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.defines = { 'PHYSICAL': '' };\n\t\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\n\t\t\tthis.clearCoat = source.clearCoat;\n\t\t\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  specular: <hex>,\n\t\t *  shininess: <float>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  lightMap: new THREE.Texture( <Image> ),\n\t\t *  lightMapIntensity: <float>\n\t\t *\n\t\t *  aoMap: new THREE.Texture( <Image> ),\n\t\t *  aoMapIntensity: <float>\n\t\t *\n\t\t *  emissive: <hex>,\n\t\t *  emissiveIntensity: <float>\n\t\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  bumpMap: new THREE.Texture( <Image> ),\n\t\t *  bumpScale: <float>,\n\t\t *\n\t\t *  normalMap: new THREE.Texture( <Image> ),\n\t\t *  normalScale: <Vector2>,\n\t\t *\n\t\t *  displacementMap: new THREE.Texture( <Image> ),\n\t\t *  displacementScale: <float>,\n\t\t *  displacementBias: <float>,\n\t\t *\n\t\t *  specularMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t\t *  combine: THREE.Multiply,\n\t\t *  reflectivity: <float>,\n\t\t *  refractionRatio: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshPhongMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshPhongMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\t\tthis.specular = new Color( 0x111111 );\n\t\t\tthis.shininess = 30;\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\t\tthis.emissive = new Color( 0x000000 );\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalScale = new Vector2( 1, 1 );\n\t\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\n\t\t\tthis.specularMap = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshPhongMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\n\t\n\t\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\t\n\t\tMeshPhongMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.specular.copy( source.specular );\n\t\t\tthis.shininess = source.shininess;\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\t\tthis.emissive.copy( source.emissive );\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalScale.copy( source.normalScale );\n\t\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\t\tthis.specularMap = source.specularMap;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshNormalMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this, parameters );\n\t\n\t\t\tthis.type = 'MeshNormalMaterial';\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\n\t\t\tthis.fog = false;\n\t\t\tthis.lights = false;\n\t\t\tthis.morphTargets = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshNormalMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\n\t\n\t\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\t\n\t\tMeshNormalMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  lightMap: new THREE.Texture( <Image> ),\n\t\t *  lightMapIntensity: <float>\n\t\t *\n\t\t *  aoMap: new THREE.Texture( <Image> ),\n\t\t *  aoMapIntensity: <float>\n\t\t *\n\t\t *  emissive: <hex>,\n\t\t *  emissiveIntensity: <float>\n\t\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  specularMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t\t *  combine: THREE.Multiply,\n\t\t *  reflectivity: <float>,\n\t\t *  refractionRatio: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshLambertMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshLambertMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\t\tthis.emissive = new Color( 0x000000 );\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\n\t\t\tthis.specularMap = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshLambertMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\n\t\n\t\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\t\n\t\tMeshLambertMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\t\tthis.emissive.copy( source.emissive );\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\t\tthis.specularMap = source.specularMap;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  linewidth: <float>,\n\t\t *\n\t\t *  scale: <float>,\n\t\t *  dashSize: <float>,\n\t\t *  gapSize: <float>\n\t\t * }\n\t\t */\n\t\n\t\tfunction LineDashedMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'LineDashedMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff );\n\t\n\t\t\tthis.linewidth = 1;\n\t\n\t\t\tthis.scale = 1;\n\t\t\tthis.dashSize = 3;\n\t\t\tthis.gapSize = 1;\n\t\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tLineDashedMaterial.prototype = Object.create( Material.prototype );\n\t\tLineDashedMaterial.prototype.constructor = LineDashedMaterial;\n\t\n\t\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\t\n\t\tLineDashedMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.linewidth = source.linewidth;\n\t\n\t\t\tthis.scale = source.scale;\n\t\t\tthis.dashSize = source.dashSize;\n\t\t\tthis.gapSize = source.gapSize;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\n\t\n\t\tvar Materials = Object.freeze({\n\t\t\tShadowMaterial: ShadowMaterial,\n\t\t\tSpriteMaterial: SpriteMaterial,\n\t\t\tRawShaderMaterial: RawShaderMaterial,\n\t\t\tShaderMaterial: ShaderMaterial,\n\t\t\tPointsMaterial: PointsMaterial,\n\t\t\tMultiMaterial: MultiMaterial,\n\t\t\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\t\t\tMeshStandardMaterial: MeshStandardMaterial,\n\t\t\tMeshPhongMaterial: MeshPhongMaterial,\n\t\t\tMeshNormalMaterial: MeshNormalMaterial,\n\t\t\tMeshLambertMaterial: MeshLambertMaterial,\n\t\t\tMeshDepthMaterial: MeshDepthMaterial,\n\t\t\tMeshBasicMaterial: MeshBasicMaterial,\n\t\t\tLineDashedMaterial: LineDashedMaterial,\n\t\t\tLineBasicMaterial: LineBasicMaterial,\n\t\t\tMaterial: Material\n\t\t});\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tvar Cache = {\n\t\n\t\t\tenabled: false,\n\t\n\t\t\tfiles: {},\n\t\n\t\t\tadd: function ( key, file ) {\n\t\n\t\t\t\tif ( this.enabled === false ) return;\n\t\n\t\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\t\n\t\t\t\tthis.files[ key ] = file;\n\t\n\t\t\t},\n\t\n\t\t\tget: function ( key ) {\n\t\n\t\t\t\tif ( this.enabled === false ) return;\n\t\n\t\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\t\n\t\t\t\treturn this.files[ key ];\n\t\n\t\t\t},\n\t\n\t\t\tremove: function ( key ) {\n\t\n\t\t\t\tdelete this.files[ key ];\n\t\n\t\t\t},\n\t\n\t\t\tclear: function () {\n\t\n\t\t\t\tthis.files = {};\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction LoadingManager( onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\t\n\t\t\tthis.onStart = undefined;\n\t\t\tthis.onLoad = onLoad;\n\t\t\tthis.onProgress = onProgress;\n\t\t\tthis.onError = onError;\n\t\n\t\t\tthis.itemStart = function ( url ) {\n\t\n\t\t\t\titemsTotal ++;\n\t\n\t\t\t\tif ( isLoading === false ) {\n\t\n\t\t\t\t\tif ( scope.onStart !== undefined ) {\n\t\n\t\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tisLoading = true;\n\t\n\t\t\t};\n\t\n\t\t\tthis.itemEnd = function ( url ) {\n\t\n\t\t\t\titemsLoaded ++;\n\t\n\t\t\t\tif ( scope.onProgress !== undefined ) {\n\t\n\t\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( itemsLoaded === itemsTotal ) {\n\t\n\t\t\t\t\tisLoading = false;\n\t\n\t\t\t\t\tif ( scope.onLoad !== undefined ) {\n\t\n\t\t\t\t\t\tscope.onLoad();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.itemError = function ( url ) {\n\t\n\t\t\t\tif ( scope.onError !== undefined ) {\n\t\n\t\t\t\t\tscope.onError( url );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tvar DefaultLoadingManager = new LoadingManager();\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction XHRLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( XHRLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tif ( url === undefined ) url = '';\n\t\n\t\t\t\tif ( this.path !== undefined ) url = this.path + url;\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar cached = Cache.get( url );\n\t\n\t\t\t\tif ( cached !== undefined ) {\n\t\n\t\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\t\tsetTimeout( function () {\n\t\n\t\t\t\t\t\tif ( onLoad ) onLoad( cached );\n\t\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t}, 0 );\n\t\n\t\t\t\t\treturn cached;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Check for data: URI\n\t\t\t\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\t\t\tvar dataUriRegexResult = url.match( dataUriRegex );\n\t\n\t\t\t\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\n\t\t\t\tif ( dataUriRegexResult ) {\n\t\n\t\t\t\t\tvar mimeType = dataUriRegexResult[1];\n\t\t\t\t\tvar isBase64 = !!dataUriRegexResult[2];\n\t\t\t\t\tvar data = dataUriRegexResult[3];\n\t\n\t\t\t\t\tdata = window.decodeURIComponent(data);\n\t\n\t\t\t\t\tif( isBase64 ) {\n\t\t\t\t\t\tdata = window.atob(data);\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\tvar response;\n\t\t\t\t\t\tvar responseType = ( this.responseType || '' ).toLowerCase();\n\t\n\t\t\t\t\t\tswitch ( responseType ) {\n\t\n\t\t\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\t\t\tcase 'blob':\n\t\n\t\t\t\t\t\t\t \tresponse = new ArrayBuffer( data.length );\n\t\t\t\t\t\t\t\tvar view = new Uint8Array( response );\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tview[ i ] = data.charCodeAt( i );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tif ( responseType === 'blob' ) {\n\t\n\t\t\t\t\t\t\t\t\tresponse = new Blob( [ response ], { \"type\" : mimeType } );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'document':\n\t\n\t\t\t\t\t\t\t\tvar parser = new DOMParser();\n\t\t\t\t\t\t\t\tresponse = parser.parseFromString( data, mimeType );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'json':\n\t\n\t\t\t\t\t\t\t\tresponse = JSON.parse( data );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tdefault: // 'text' or other\n\t\n\t\t\t\t\t\t\t\tresponse = data;\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Wait for next browser tick\n\t\t\t\t\t\twindow.setTimeout( function() {\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\t\n\t\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t\t}, 0);\n\t\n\t\t\t\t\t} catch ( error ) {\n\t\n\t\t\t\t\t\t// Wait for next browser tick\n\t\t\t\t\t\twindow.setTimeout( function() {\n\t\n\t\t\t\t\t\t\tif ( onError ) onError( error );\n\t\n\t\t\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t\t\t}, 0);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar request = new XMLHttpRequest();\n\t\t\t\t\trequest.open( 'GET', url, true );\n\t\n\t\t\t\t\trequest.addEventListener( 'load', function ( event ) {\n\t\n\t\t\t\t\t\tvar response = event.target.response;\n\t\n\t\t\t\t\t\tCache.add( url, response );\n\t\n\t\t\t\t\t\tif ( this.status === 200 ) {\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\t\n\t\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t\t} else if ( this.status === 0 ) {\n\t\n\t\t\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\t\n\t\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( onError ) onError( event );\n\t\n\t\t\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}, false );\n\t\n\t\t\t\t\tif ( onProgress !== undefined ) {\n\t\n\t\t\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\t\n\t\t\t\t\t\t\tonProgress( event );\n\t\n\t\t\t\t\t\t}, false );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\trequest.addEventListener( 'error', function ( event ) {\n\t\n\t\t\t\t\t\tif ( onError ) onError( event );\n\t\n\t\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t\t}, false );\n\t\n\t\t\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\t\n\t\t\t\t\tif ( request.overrideMimeType ) request.overrideMimeType( 'text/plain' );\n\t\n\t\t\t\t\trequest.send( null );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\treturn request;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetResponseType: function ( value ) {\n\t\n\t\t\t\tthis.responseType = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetWithCredentials: function ( value ) {\n\t\n\t\t\t\tthis.withCredentials = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t *\n\t\t * Abstract Base class to block based textures loader (dds, pvr, ...)\n\t\t */\n\t\n\t\tfunction CompressedTextureLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t\t// override in sub classes\n\t\t\tthis._parser = null;\n\t\n\t\t}\n\t\n\t\tObject.assign( CompressedTextureLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar images = [];\n\t\n\t\t\t\tvar texture = new CompressedTexture();\n\t\t\t\ttexture.image = images;\n\t\n\t\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\n\t\t\t\tfunction loadTexture( i ) {\n\t\n\t\t\t\t\tloader.load( url[ i ], function ( buffer ) {\n\t\n\t\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\t\n\t\t\t\t\t\timages[ i ] = {\n\t\t\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\tloaded += 1;\n\t\n\t\t\t\t\t\tif ( loaded === 6 ) {\n\t\n\t\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\n\t\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( Array.isArray( url ) ) {\n\t\n\t\t\t\t\tvar loaded = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\t\n\t\t\t\t\t\tloadTexture( i );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// compressed cubemap texture stored in a single DDS file\n\t\n\t\t\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\t\n\t\t\t\t\t\tif ( texDatas.isCubemap ) {\n\t\n\t\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\t\n\t\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\t\n\t\t\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\t\n\t\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author Nikos M. / https://github.com/foo123/\n\t\t *\n\t\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n\t\t */\n\t\n\t\tvar DataTextureLoader = BinaryTextureLoader;\n\t\tfunction BinaryTextureLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t\t// override in sub classes\n\t\t\tthis._parser = null;\n\t\n\t\t}\n\t\n\t\tObject.assign( BinaryTextureLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar texture = new DataTexture();\n\t\n\t\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\n\t\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\t\tvar texData = scope._parser( buffer );\n\t\n\t\t\t\t\tif ( ! texData ) return;\n\t\n\t\t\t\t\tif ( undefined !== texData.image ) {\n\t\n\t\t\t\t\t\ttexture.image = texData.image;\n\t\n\t\t\t\t\t} else if ( undefined !== texData.data ) {\n\t\n\t\t\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\t\t\ttexture.image.data = texData.data;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;\n\t\n\t\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;\n\t\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;\n\t\n\t\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\t\n\t\t\t\t\tif ( undefined !== texData.format ) {\n\t\n\t\t\t\t\t\ttexture.format = texData.format;\n\t\n\t\t\t\t\t}\n\t\t\t\t\tif ( undefined !== texData.type ) {\n\t\n\t\t\t\t\t\ttexture.type = texData.type;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( undefined !== texData.mipmaps ) {\n\t\n\t\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( 1 === texData.mipmapCount ) {\n\t\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( texture, texData );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction ImageLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( ImageLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\t\t\timage.onload = function () {\n\t\n\t\t\t\t\timage.onload = null;\n\t\n\t\t\t\t\tURL.revokeObjectURL( image.src );\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( image );\n\t\n\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t};\n\t\t\t\timage.onerror = onError;\n\t\n\t\t\t\tif ( url.indexOf( 'data:' ) === 0 ) {\n\t\n\t\t\t\t\timage.src = url;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar loader = new XHRLoader();\n\t\t\t\t\tloader.setPath( this.path );\n\t\t\t\t\tloader.setResponseType( 'blob' );\n\t\t\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\t\t\tloader.load( url, function ( blob ) {\n\t\n\t\t\t\t\t\timage.src = URL.createObjectURL( blob );\n\t\n\t\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\treturn image;\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\t\tthis.crossOrigin = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetWithCredentials: function ( value ) {\n\t\n\t\t\t\tthis.withCredentials = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction CubeTextureLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( CubeTextureLoader.prototype, {\n\t\n\t\t\tload: function ( urls, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar texture = new CubeTexture();\n\t\n\t\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\t\tloader.setPath( this.path );\n\t\n\t\t\t\tvar loaded = 0;\n\t\n\t\t\t\tfunction loadTexture( i ) {\n\t\n\t\t\t\t\tloader.load( urls[ i ], function ( image ) {\n\t\n\t\t\t\t\t\ttexture.images[ i ] = image;\n\t\n\t\t\t\t\t\tloaded ++;\n\t\n\t\t\t\t\t\tif ( loaded === 6 ) {\n\t\n\t\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}, undefined, onError );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\t\n\t\t\t\t\tloadTexture( i );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\t\tthis.crossOrigin = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction TextureLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( TextureLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar texture = new Texture();\n\t\n\t\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.load( url, function ( image ) {\n\t\n\t\t\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\t\t\tvar isJPEG = url.search( /\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\t\n\t\t\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\t\t\ttexture.image = image;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\tif ( onLoad !== undefined ) {\n\t\n\t\t\t\t\t\tonLoad( texture );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\t\tthis.crossOrigin = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetWithCredentials: function ( value ) {\n\t\n\t\t\t\tthis.withCredentials = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Light( color, intensity ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Light';\n\t\n\t\t\tthis.color = new Color( color );\n\t\t\tthis.intensity = intensity !== undefined ? intensity : 1;\n\t\n\t\t\tthis.receiveShadow = undefined;\n\t\n\t\t}\n\t\n\t\tLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Light,\n\t\n\t\t\tisLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.color.copy( source.color );\n\t\t\t\tthis.intensity = source.intensity;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.color = this.color.getHex();\n\t\t\t\tdata.object.intensity = this.intensity;\n\t\n\t\t\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\t\n\t\t\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\t\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\t\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\t\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\t\n\t\t\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction HemisphereLight( skyColor, groundColor, intensity ) {\n\t\n\t\t\tLight.call( this, skyColor, intensity );\n\t\n\t\t\tthis.type = 'HemisphereLight';\n\t\n\t\t\tthis.castShadow = undefined;\n\t\n\t\t\tthis.position.copy( Object3D.DefaultUp );\n\t\t\tthis.updateMatrix();\n\t\n\t\t\tthis.groundColor = new Color( groundColor );\n\t\n\t\t}\n\t\n\t\tHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: HemisphereLight,\n\t\n\t\t\tisHemisphereLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.groundColor.copy( source.groundColor );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction LightShadow( camera ) {\n\t\n\t\t\tthis.camera = camera;\n\t\n\t\t\tthis.bias = 0;\n\t\t\tthis.radius = 1;\n\t\n\t\t\tthis.mapSize = new Vector2( 512, 512 );\n\t\n\t\t\tthis.map = null;\n\t\t\tthis.matrix = new Matrix4();\n\t\n\t\t}\n\t\n\t\tObject.assign( LightShadow.prototype, {\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.camera = source.camera.clone();\n\t\n\t\t\t\tthis.bias = source.bias;\n\t\t\t\tthis.radius = source.radius;\n\t\n\t\t\t\tthis.mapSize.copy( source.mapSize );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\tvar object = {};\n\t\n\t\t\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\t\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\t\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\t\n\t\t\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\t\t\tdelete object.camera.matrix;\n\t\n\t\t\t\treturn object;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction SpotLightShadow() {\n\t\n\t\t\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\t\n\t\t}\n\t\n\t\tSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\t\n\t\t\tconstructor: SpotLightShadow,\n\t\n\t\t\tisSpotLightShadow: true,\n\t\n\t\t\tupdate: function ( light ) {\n\t\n\t\t\t\tvar fov = _Math.RAD2DEG * 2 * light.angle;\n\t\t\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\t\t\tvar far = light.distance || 500;\n\t\n\t\t\t\tvar camera = this.camera;\n\t\n\t\t\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\t\n\t\t\t\t\tcamera.fov = fov;\n\t\t\t\t\tcamera.aspect = aspect;\n\t\t\t\t\tcamera.far = far;\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'SpotLight';\n\t\n\t\t\tthis.position.copy( Object3D.DefaultUp );\n\t\t\tthis.updateMatrix();\n\t\n\t\t\tthis.target = new Object3D();\n\t\n\t\t\tObject.defineProperty( this, 'power', {\n\t\t\t\tget: function () {\n\t\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\t\treturn this.intensity * Math.PI;\n\t\t\t\t},\n\t\t\t\tset: function ( power ) {\n\t\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\t\tthis.intensity = power / Math.PI;\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\t\t\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\t\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\t\n\t\t\tthis.shadow = new SpotLightShadow();\n\t\n\t\t}\n\t\n\t\tSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: SpotLight,\n\t\n\t\t\tisSpotLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.distance = source.distance;\n\t\t\t\tthis.angle = source.angle;\n\t\t\t\tthis.penumbra = source.penumbra;\n\t\t\t\tthis.decay = source.decay;\n\t\n\t\t\t\tthis.target = source.target.clone();\n\t\n\t\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\n\t\tfunction PointLight( color, intensity, distance, decay ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'PointLight';\n\t\n\t\t\tObject.defineProperty( this, 'power', {\n\t\t\t\tget: function () {\n\t\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\t\treturn this.intensity * 4 * Math.PI;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( power ) {\n\t\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\t\n\t\t\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\t\n\t\t}\n\t\n\t\tPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: PointLight,\n\t\n\t\t\tisPointLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.distance = source.distance;\n\t\t\t\tthis.decay = source.decay;\n\t\n\t\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction DirectionalLightShadow( light ) {\n\t\n\t\t\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\t\n\t\t}\n\t\n\t\tDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\t\n\t\t\tconstructor: DirectionalLightShadow\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction DirectionalLight( color, intensity ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'DirectionalLight';\n\t\n\t\t\tthis.position.copy( Object3D.DefaultUp );\n\t\t\tthis.updateMatrix();\n\t\n\t\t\tthis.target = new Object3D();\n\t\n\t\t\tthis.shadow = new DirectionalLightShadow();\n\t\n\t\t}\n\t\n\t\tDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: DirectionalLight,\n\t\n\t\t\tisDirectionalLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.target = source.target.clone();\n\t\n\t\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction AmbientLight( color, intensity ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'AmbientLight';\n\t\n\t\t\tthis.castShadow = undefined;\n\t\n\t\t}\n\t\n\t\tAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: AmbientLight,\n\t\n\t\t\tisAmbientLight: true,\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author tschw\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t */\n\t\n\t\tvar AnimationUtils = {\n\t\n\t\t\t// same as Array.prototype.slice, but also works on typed arrays\n\t\t\tarraySlice: function( array, from, to ) {\n\t\n\t\t\t\tif ( AnimationUtils.isTypedArray( array ) ) {\n\t\n\t\t\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn array.slice( from, to );\n\t\n\t\t\t},\n\t\n\t\t\t// converts an array to a specific type\n\t\t\tconvertArray: function( array, type, forceClone ) {\n\t\n\t\t\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t\t\t! forceClone && array.constructor === type ) return array;\n\t\n\t\t\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\t\n\t\t\t\t\treturn new type( array ); // create typed array\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn Array.prototype.slice.call( array ); // create Array\n\t\n\t\t\t},\n\t\n\t\t\tisTypedArray: function( object ) {\n\t\n\t\t\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t\t\t! ( object instanceof DataView );\n\t\n\t\t\t},\n\t\n\t\t\t// returns an array by which times and values can be sorted\n\t\t\tgetKeyframeOrder: function( times ) {\n\t\n\t\t\t\tfunction compareTime( i, j ) {\n\t\n\t\t\t\t\treturn times[ i ] - times[ j ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar n = times.length;\n\t\t\t\tvar result = new Array( n );\n\t\t\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\t\n\t\t\t\tresult.sort( compareTime );\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t},\n\t\n\t\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\t\t\tsortedArray: function( values, stride, order ) {\n\t\n\t\t\t\tvar nValues = values.length;\n\t\t\t\tvar result = new values.constructor( nValues );\n\t\n\t\t\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\t\n\t\t\t\t\tvar srcOffset = order[ i ] * stride;\n\t\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\t\n\t\t\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t},\n\t\n\t\t\t// function for parsing AOS keyframe formats\n\t\t\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\t\n\t\t\t\tvar i = 1, key = jsonKeys[ 0 ];\n\t\n\t\t\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\t\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( key === undefined ) return; // no data\n\t\n\t\t\t\tvar value = key[ valuePropertyName ];\n\t\t\t\tif ( value === undefined ) return; // no data\n\t\n\t\t\t\tif ( Array.isArray( value ) ) {\n\t\n\t\t\t\t\tdo {\n\t\n\t\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t\t} else if ( value.toArray !== undefined ) {\n\t\t\t\t\t// ...assume THREE.Math-ish\n\t\n\t\t\t\t\tdo {\n\t\n\t\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\t\tvalue.toArray( values, values.length );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t\t} else {\n\t\t\t\t\t// otherwise push as-is\n\t\n\t\t\t\t\tdo {\n\t\n\t\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\t\tvalues.push( value );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * Abstract base class of interpolants over parametric samples.\n\t\t *\n\t\t * The parameter domain is one dimensional, typically the time or a path\n\t\t * along a curve defined by the data.\n\t\t *\n\t\t * The sample values can have any dimensionality and derived classes may\n\t\t * apply special interpretations to the data.\n\t\t *\n\t\t * This class provides the interval seek in a Template Method, deferring\n\t\t * the actual interpolation to derived classes.\n\t\t *\n\t\t * Time complexity is O(1) for linear access crossing at most two points\n\t\t * and O(log N) for random access, where N is the number of positions.\n\t\t *\n\t\t * References:\n\t\t *\n\t\t * \t\thttp://www.oodesign.com/template-method-pattern.html\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction Interpolant(\n\t\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tthis.parameterPositions = parameterPositions;\n\t\t\tthis._cachedIndex = 0;\n\t\n\t\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\t\tthis.sampleValues = sampleValues;\n\t\t\tthis.valueSize = sampleSize;\n\t\n\t\t}\n\t\n\t\tInterpolant.prototype = {\n\t\n\t\t\tconstructor: Interpolant,\n\t\n\t\t\tevaluate: function( t ) {\n\t\n\t\t\t\tvar pp = this.parameterPositions,\n\t\t\t\t\ti1 = this._cachedIndex,\n\t\n\t\t\t\t\tt1 = pp[   i1   ],\n\t\t\t\t\tt0 = pp[ i1 - 1 ];\n\t\n\t\t\t\tvalidate_interval: {\n\t\n\t\t\t\t\tseek: {\n\t\n\t\t\t\t\t\tvar right;\n\t\n\t\t\t\t\t\tlinear_scan: {\n\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t//- slower code:\n\t\t//-\n\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\t\n\t\t\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\n\t\n\t\t\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\t\n\t\t\t\t\t\t\t\t\t\t// after end\n\t\n\t\t\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\t\n\t\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\t\n\t\t\t\t\t\t\t\t\tif ( t < t1 ) {\n\t\n\t\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\t\tbreak seek;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\t\t\tbreak linear_scan;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t//- slower code:\n\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\t\n\t\t\t\t\t\t\t\t// looping?\n\t\n\t\t\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\t\n\t\t\t\t\t\t\t\tif ( t < t1global ) {\n\t\n\t\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\t\t\tt0 = t1global;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// linear reverse scan\n\t\n\t\t\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\n\t\n\t\t\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t\t// before start\n\t\n\t\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\t\n\t\t\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\t\n\t\t\t\t\t\t\t\t\tif ( t >= t0 ) {\n\t\n\t\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\t\tbreak seek;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\t\t\tbreak linear_scan;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// the interval is valid\n\t\n\t\t\t\t\t\t\tbreak validate_interval;\n\t\n\t\t\t\t\t\t} // linear scan\n\t\n\t\t\t\t\t\t// binary search\n\t\n\t\t\t\t\t\twhile ( i1 < right ) {\n\t\n\t\t\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\t\n\t\t\t\t\t\t\tif ( t < pp[ mid ] ) {\n\t\n\t\t\t\t\t\t\t\tright = mid;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\ti1 = mid + 1;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tt1 = pp[   i1   ];\n\t\t\t\t\t\tt0 = pp[ i1 - 1 ];\n\t\n\t\t\t\t\t\t// check boundary cases, again\n\t\n\t\t\t\t\t\tif ( t0 === undefined ) {\n\t\n\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( t1 === undefined ) {\n\t\n\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} // seek\n\t\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\n\t\t\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\t\n\t\t\t\t} // validate_interval\n\t\n\t\t\t\treturn this.interpolate_( i1, t0, t, t1 );\n\t\n\t\t\t},\n\t\n\t\t\tsettings: null, // optional, subclass-specific settings structure\n\t\t\t// Note: The indirection allows central control of many interpolants.\n\t\n\t\t\t// --- Protected interface\n\t\n\t\t\tDefaultSettings_: {},\n\t\n\t\t\tgetSettings_: function() {\n\t\n\t\t\t\treturn this.settings || this.DefaultSettings_;\n\t\n\t\t\t},\n\t\n\t\t\tcopySampleValue_: function( index ) {\n\t\n\t\t\t\t// copies a sample value to the result buffer\n\t\n\t\t\t\tvar result = this.resultBuffer,\n\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\toffset = index * stride;\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tresult[ i ] = values[ offset + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t},\n\t\n\t\t\t// Template methods for derived classes:\n\t\n\t\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\t\tthrow new Error( \"call to abstract method\" );\n\t\t\t\t// implementations shall return this.resultBuffer\n\t\n\t\t\t},\n\t\n\t\t\tintervalChanged_: function( i1, t0, t1 ) {\n\t\n\t\t\t\t// empty\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tObject.assign( Interpolant.prototype, {\n\t\n\t\t\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\n\t\t\t\tInterpolant.prototype.copySampleValue_,\n\t\n\t\t\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\n\t\t\t\tInterpolant.prototype.copySampleValue_\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * Fast and simple cubic spline interpolant.\n\t\t *\n\t\t * It was derived from a Hermitian construction setting the first derivative\n\t\t * at each sample position to the linear slope between neighboring positions\n\t\t * over their parameter interval.\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction CubicInterpolant(\n\t\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tInterpolant.call(\n\t\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\t\tthis._weightPrev = -0;\n\t\t\tthis._offsetPrev = -0;\n\t\t\tthis._weightNext = -0;\n\t\t\tthis._offsetNext = -0;\n\t\n\t\t}\n\t\n\t\tCubicInterpolant.prototype =\n\t\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\t\n\t\t\tconstructor: CubicInterpolant,\n\t\n\t\t\tDefaultSettings_: {\n\t\n\t\t\t\tendingStart: \tZeroCurvatureEnding,\n\t\t\t\tendingEnd:\t\tZeroCurvatureEnding\n\t\n\t\t\t},\n\t\n\t\t\tintervalChanged_: function( i1, t0, t1 ) {\n\t\n\t\t\t\tvar pp = this.parameterPositions,\n\t\t\t\t\tiPrev = i1 - 2,\n\t\t\t\t\tiNext = i1 + 1,\n\t\n\t\t\t\t\ttPrev = pp[ iPrev ],\n\t\t\t\t\ttNext = pp[ iNext ];\n\t\n\t\t\t\tif ( tPrev === undefined ) {\n\t\n\t\t\t\t\tswitch ( this.getSettings_().endingStart ) {\n\t\n\t\t\t\t\t\tcase ZeroSlopeEnding:\n\t\n\t\t\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\t\ttPrev = 2 * t0 - t1;\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase WrapAroundEnding:\n\t\n\t\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\t\n\t\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\t\ttPrev = t1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( tNext === undefined ) {\n\t\n\t\t\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\t\n\t\t\t\t\t\tcase ZeroSlopeEnding:\n\t\n\t\t\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\t\t\tiNext = i1;\n\t\t\t\t\t\t\ttNext = 2 * t1 - t0;\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase WrapAroundEnding:\n\t\n\t\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\t\tiNext = 1;\n\t\t\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\t\n\t\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\t\t\ttNext = t0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\t\t\tstride = this.valueSize;\n\t\n\t\t\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\t\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\t\t\tthis._offsetPrev = iPrev * stride;\n\t\t\t\tthis._offsetNext = iNext * stride;\n\t\n\t\t\t},\n\t\n\t\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\t\tvar result = this.resultBuffer,\n\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\t\n\t\t\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\t\tpp = p * p,\n\t\t\t\t\tppp = pp * p;\n\t\n\t\t\t\t// evaluate polynomials\n\t\n\t\t\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n\t\t\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n\t\t\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n\t\t\t\tvar sN =       wN   * ppp   -           wN      * pp;\n\t\n\t\t\t\t// combine data linearly\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tresult[ i ] =\n\t\t\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\t\t\tsN * values[ oN + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction LinearInterpolant(\n\t\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tInterpolant.call(\n\t\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\t}\n\t\n\t\tLinearInterpolant.prototype =\n\t\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\t\n\t\t\tconstructor: LinearInterpolant,\n\t\n\t\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\t\tvar result = this.resultBuffer,\n\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\t\toffset1 = i1 * stride,\n\t\t\t\t\toffset0 = offset1 - stride,\n\t\n\t\t\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\t\tweight0 = 1 - weight1;\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tresult[ i ] =\n\t\t\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * Interpolant that evaluates to the sample value at the position preceeding\n\t\t * the parameter.\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction DiscreteInterpolant(\n\t\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tInterpolant.call(\n\t\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\t}\n\t\n\t\tDiscreteInterpolant.prototype =\n\t\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\t\n\t\t\tconstructor: DiscreteInterpolant,\n\t\n\t\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar KeyframeTrackPrototype;\n\t\n\t\tKeyframeTrackPrototype = {\n\t\n\t\t\tTimeBufferType: Float32Array,\n\t\t\tValueBufferType: Float32Array,\n\t\n\t\t\tDefaultInterpolation: InterpolateLinear,\n\t\n\t\t\tInterpolantFactoryMethodDiscrete: function( result ) {\n\t\n\t\t\t\treturn new DiscreteInterpolant(\n\t\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t\t},\n\t\n\t\t\tInterpolantFactoryMethodLinear: function( result ) {\n\t\n\t\t\t\treturn new LinearInterpolant(\n\t\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t\t},\n\t\n\t\t\tInterpolantFactoryMethodSmooth: function( result ) {\n\t\n\t\t\t\treturn new CubicInterpolant(\n\t\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t\t},\n\t\n\t\t\tsetInterpolation: function( interpolation ) {\n\t\n\t\t\t\tvar factoryMethod;\n\t\n\t\t\t\tswitch ( interpolation ) {\n\t\n\t\t\t\t\tcase InterpolateDiscrete:\n\t\n\t\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase InterpolateLinear:\n\t\n\t\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase InterpolateSmooth:\n\t\n\t\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( factoryMethod === undefined ) {\n\t\n\t\t\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\t\n\t\t\t\t\tif ( this.createInterpolant === undefined ) {\n\t\n\t\t\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\t\n\t\t\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tconsole.warn( message );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.createInterpolant = factoryMethod;\n\t\n\t\t\t},\n\t\n\t\t\tgetInterpolation: function() {\n\t\n\t\t\t\tswitch ( this.createInterpolant ) {\n\t\n\t\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\t\n\t\t\t\t\t\treturn InterpolateDiscrete;\n\t\n\t\t\t\t\tcase this.InterpolantFactoryMethodLinear:\n\t\n\t\t\t\t\t\treturn InterpolateLinear;\n\t\n\t\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\t\n\t\t\t\t\t\treturn InterpolateSmooth;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tgetValueSize: function() {\n\t\n\t\t\t\treturn this.values.length / this.times.length;\n\t\n\t\t\t},\n\t\n\t\t\t// move all keyframes either forwards or backwards in time\n\t\t\tshift: function( timeOffset ) {\n\t\n\t\t\t\tif( timeOffset !== 0.0 ) {\n\t\n\t\t\t\t\tvar times = this.times;\n\t\n\t\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\ttimes[ i ] += timeOffset;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\t\t\tscale: function( timeScale ) {\n\t\n\t\t\t\tif( timeScale !== 1.0 ) {\n\t\n\t\t\t\t\tvar times = this.times;\n\t\n\t\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\ttimes[ i ] *= timeScale;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\t\t\ttrim: function( startTime, endTime ) {\n\t\n\t\t\t\tvar times = this.times,\n\t\t\t\t\tnKeys = times.length,\n\t\t\t\t\tfrom = 0,\n\t\t\t\t\tto = nKeys - 1;\n\t\n\t\t\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\n\t\t\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\n\t\n\t\t\t\t++ to; // inclusive -> exclusive bound\n\t\n\t\t\t\tif( from !== 0 || to !== nKeys ) {\n\t\n\t\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\n\t\n\t\t\t\t\tvar stride = this.getValueSize();\n\t\t\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\t\t\tthis.values = AnimationUtils.\n\t\t\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\t\t\tvalidate: function() {\n\t\n\t\t\t\tvar valid = true;\n\t\n\t\t\t\tvar valueSize = this.getValueSize();\n\t\t\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\t\n\t\t\t\t\tconsole.error( \"invalid value size in track\", this );\n\t\t\t\t\tvalid = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar times = this.times,\n\t\t\t\t\tvalues = this.values,\n\t\n\t\t\t\t\tnKeys = times.length;\n\t\n\t\t\t\tif( nKeys === 0 ) {\n\t\n\t\t\t\t\tconsole.error( \"track is empty\", this );\n\t\t\t\t\tvalid = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar prevTime = null;\n\t\n\t\t\t\tfor( var i = 0; i !== nKeys; i ++ ) {\n\t\n\t\t\t\t\tvar currTime = times[ i ];\n\t\n\t\t\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\t\n\t\t\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif( prevTime !== null && prevTime > currTime ) {\n\t\n\t\t\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tprevTime = currTime;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( values !== undefined ) {\n\t\n\t\t\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\t\tvar value = values[ i ];\n\t\n\t\t\t\t\t\t\tif ( isNaN( value ) ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\n\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn valid;\n\t\n\t\t\t},\n\t\n\t\t\t// removes equivalent sequential keys as common in morph target sequences\n\t\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\t\t\toptimize: function() {\n\t\n\t\t\t\tvar times = this.times,\n\t\t\t\t\tvalues = this.values,\n\t\t\t\t\tstride = this.getValueSize(),\n\t\n\t\t\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\t\n\t\t\t\t\twriteIndex = 1,\n\t\t\t\t\tlastIndex = times.length - 1;\n\t\n\t\t\t\tfor( var i = 1; i < lastIndex; ++ i ) {\n\t\n\t\t\t\t\tvar keep = false;\n\t\n\t\t\t\t\tvar time = times[ i ];\n\t\t\t\t\tvar timeNext = times[ i + 1 ];\n\t\n\t\t\t\t\t// remove adjacent keyframes scheduled at the same time\n\t\n\t\t\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\t\n\t\t\t\t\t\tif ( ! smoothInterpolation ) {\n\t\n\t\t\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\t\n\t\t\t\t\t\t\tvar offset = i * stride,\n\t\t\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\t\t\toffsetN = offset + stride;\n\t\n\t\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\t\n\t\t\t\t\t\t\t\tvar value = values[ offset + j ];\n\t\n\t\t\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\t\n\t\t\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else keep = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// in-place compaction\n\t\n\t\t\t\t\tif ( keep ) {\n\t\n\t\t\t\t\t\tif ( i !== writeIndex ) {\n\t\n\t\t\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\t\n\t\t\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\t\n\t\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j )\n\t\n\t\t\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t++ writeIndex;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// flush last keyframe (compaction looks ahead)\n\t\n\t\t\t\tif ( lastIndex > 0 ) {\n\t\n\t\t\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\t\n\t\t\t\t\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )\n\t\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\t\n\t\t\t\t\t++ writeIndex;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( writeIndex !== times.length ) {\n\t\n\t\t\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tfunction KeyframeTrackConstructor( name, times, values, interpolation ) {\n\t\n\t\t\tif( name === undefined ) throw new Error( \"track name is undefined\" );\n\t\n\t\t\tif( times === undefined || times.length === 0 ) {\n\t\n\t\t\t\tthrow new Error( \"no keyframes in track named \" + name );\n\t\n\t\t\t}\n\t\n\t\t\tthis.name = name;\n\t\n\t\t\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\t\t\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\t\n\t\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\t\n\t\t\tthis.validate();\n\t\t\tthis.optimize();\n\t\n\t\t}\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of vectored keyframe values.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction VectorKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tVectorKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: VectorKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'vector'\n\t\n\t\t\t// ValueBufferType is inherited\n\t\n\t\t\t// DefaultInterpolation is inherited\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * Spherical linear unit quaternion interpolant.\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction QuaternionLinearInterpolant(\n\t\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tInterpolant.call(\n\t\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\t}\n\t\n\t\tQuaternionLinearInterpolant.prototype =\n\t\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\t\n\t\t\tconstructor: QuaternionLinearInterpolant,\n\t\n\t\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\t\tvar result = this.resultBuffer,\n\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\t\toffset = i1 * stride,\n\t\n\t\t\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\t\n\t\t\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\t\n\t\t\t\t\tQuaternion.slerpFlat( result, 0,\n\t\t\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of quaternion keyframe values.\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tQuaternionKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: QuaternionKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'quaternion',\n\t\n\t\t\t// ValueBufferType is inherited\n\t\n\t\t\tDefaultInterpolation: InterpolateLinear,\n\t\n\t\t\tInterpolantFactoryMethodLinear: function( result ) {\n\t\n\t\t\t\treturn new QuaternionLinearInterpolant(\n\t\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t\t},\n\t\n\t\t\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of numeric keyframe values.\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction NumberKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tNumberKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: NumberKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'number',\n\t\n\t\t\t// ValueBufferType is inherited\n\t\n\t\t\t// DefaultInterpolation is inherited\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track that interpolates Strings\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction StringKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tStringKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: StringKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'string',\n\t\t\tValueBufferType: Array,\n\t\n\t\t\tDefaultInterpolation: InterpolateDiscrete,\n\t\n\t\t\tInterpolantFactoryMethodLinear: undefined,\n\t\n\t\t\tInterpolantFactoryMethodSmooth: undefined\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of Boolean keyframe values.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction BooleanKeyframeTrack( name, times, values ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values );\n\t\n\t\t}\n\t\n\t\tBooleanKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: BooleanKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'bool',\n\t\t\tValueBufferType: Array,\n\t\n\t\t\tDefaultInterpolation: InterpolateDiscrete,\n\t\n\t\t\tInterpolantFactoryMethodLinear: undefined,\n\t\t\tInterpolantFactoryMethodSmooth: undefined\n\t\n\t\t\t// Note: Actually this track could have a optimized / compressed\n\t\t\t// representation of a single value and a custom interpolant that\n\t\t\t// computes \"firstValue ^ isOdd( index )\".\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of keyframe values that represent color.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction ColorKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tColorKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: ColorKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'color'\n\t\n\t\t\t// ValueBufferType is inherited\n\t\n\t\t\t// DefaultInterpolation is inherited\n\t\n\t\n\t\t\t// Note: Very basic implementation and nothing special yet.\n\t\t\t// However, this is the place for color space parameterization.\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A timed sequence of keyframes for a specific property.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction KeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.apply( this, arguments );\n\t\n\t\t}\n\t\n\t\tKeyframeTrack.prototype = KeyframeTrackPrototype;\n\t\tKeyframeTrackPrototype.constructor = KeyframeTrack;\n\t\n\t\t// Static methods:\n\t\n\t\tObject.assign( KeyframeTrack, {\n\t\n\t\t\t// Serialization (in static context, because of constructor invocation\n\t\t\t// and automatic invocation of .toJSON):\n\t\n\t\t\tparse: function( json ) {\n\t\n\t\t\t\tif( json.type === undefined ) {\n\t\n\t\t\t\t\tthrow new Error( \"track type undefined, can not parse\" );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\t\n\t\t\t\tif ( json.times === undefined ) {\n\t\n\t\t\t\t\tvar times = [], values = [];\n\t\n\t\t\t\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\t\n\t\t\t\t\tjson.times = times;\n\t\t\t\t\tjson.values = values;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// derived classes can define a static parse method\n\t\t\t\tif ( trackType.parse !== undefined ) {\n\t\n\t\t\t\t\treturn trackType.parse( json );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// by default, we asssume a constructor compatible with the base\n\t\t\t\t\treturn new trackType(\n\t\t\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function( track ) {\n\t\n\t\t\t\tvar trackType = track.constructor;\n\t\n\t\t\t\tvar json;\n\t\n\t\t\t\t// derived classes can define a static toJSON method\n\t\t\t\tif ( trackType.toJSON !== undefined ) {\n\t\n\t\t\t\t\tjson = trackType.toJSON( track );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\t\t\tjson = {\n\t\n\t\t\t\t\t\t'name': track.name,\n\t\t\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\t\n\t\t\t\t\t};\n\t\n\t\t\t\t\tvar interpolation = track.getInterpolation();\n\t\n\t\t\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\t\n\t\t\t\t\t\tjson.interpolation = interpolation;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tjson.type = track.ValueTypeName; // mandatory\n\t\n\t\t\t\treturn json;\n\t\n\t\t\t},\n\t\n\t\t\t_getTrackTypeForValueTypeName: function( typeName ) {\n\t\n\t\t\t\tswitch( typeName.toLowerCase() ) {\n\t\n\t\t\t\t\tcase \"scalar\":\n\t\t\t\t\tcase \"double\":\n\t\t\t\t\tcase \"float\":\n\t\t\t\t\tcase \"number\":\n\t\t\t\t\tcase \"integer\":\n\t\n\t\t\t\t\t\treturn NumberKeyframeTrack;\n\t\n\t\t\t\t\tcase \"vector\":\n\t\t\t\t\tcase \"vector2\":\n\t\t\t\t\tcase \"vector3\":\n\t\t\t\t\tcase \"vector4\":\n\t\n\t\t\t\t\t\treturn VectorKeyframeTrack;\n\t\n\t\t\t\t\tcase \"color\":\n\t\n\t\t\t\t\t\treturn ColorKeyframeTrack;\n\t\n\t\t\t\t\tcase \"quaternion\":\n\t\n\t\t\t\t\t\treturn QuaternionKeyframeTrack;\n\t\n\t\t\t\t\tcase \"bool\":\n\t\t\t\t\tcase \"boolean\":\n\t\n\t\t\t\t\t\treturn BooleanKeyframeTrack;\n\t\n\t\t\t\t\tcase \"string\":\n\t\n\t\t\t\t\t\treturn StringKeyframeTrack;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * Reusable set of Tracks that represent an animation.\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t */\n\t\n\t\tfunction AnimationClip( name, duration, tracks ) {\n\t\n\t\t\tthis.name = name;\n\t\t\tthis.tracks = tracks;\n\t\t\tthis.duration = ( duration !== undefined ) ? duration : -1;\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\t// this means it should figure out its duration by scanning the tracks\n\t\t\tif ( this.duration < 0 ) {\n\t\n\t\t\t\tthis.resetDuration();\n\t\n\t\t\t}\n\t\n\t\t\tthis.optimize();\n\t\n\t\t}\n\t\n\t\tAnimationClip.prototype = {\n\t\n\t\t\tconstructor: AnimationClip,\n\t\n\t\t\tresetDuration: function() {\n\t\n\t\t\t\tvar tracks = this.tracks,\n\t\t\t\t\tduration = 0;\n\t\n\t\t\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar track = this.tracks[ i ];\n\t\n\t\t\t\t\tduration = Math.max(\n\t\t\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.duration = duration;\n\t\n\t\t\t},\n\t\n\t\t\ttrim: function() {\n\t\n\t\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\t\n\t\t\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\toptimize: function() {\n\t\n\t\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\t\n\t\t\t\t\tthis.tracks[ i ].optimize();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// Static methods:\n\t\n\t\tObject.assign( AnimationClip, {\n\t\n\t\t\tparse: function( json ) {\n\t\n\t\t\t\tvar tracks = [],\n\t\t\t\t\tjsonTracks = json.tracks,\n\t\t\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\t\n\t\t\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\ttracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn new AnimationClip( json.name, json.duration, tracks );\n\t\n\t\t\t},\n\t\n\t\n\t\t\ttoJSON: function( clip ) {\n\t\n\t\t\t\tvar tracks = [],\n\t\t\t\t\tclipTracks = clip.tracks;\n\t\n\t\t\t\tvar json = {\n\t\n\t\t\t\t\t'name': clip.name,\n\t\t\t\t\t'duration': clip.duration,\n\t\t\t\t\t'tracks': tracks\n\t\n\t\t\t\t};\n\t\n\t\t\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn json;\n\t\n\t\t\t},\n\t\n\t\n\t\t\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\n\t\n\t\t\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\t\t\tvar tracks = [];\n\t\n\t\t\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\t\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\ttimes.push(\n\t\t\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\t\n\t\t\t\t\tvalues.push( 0, 1, 0 );\n\t\n\t\t\t\t\tvar order = AnimationUtils.getKeyframeOrder( times );\n\t\t\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\t\n\t\t\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t\t\t// last frame as well for perfect loop.\n\t\t\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\t\n\t\t\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\t\t\tvalues.push( values[ 0 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttracks.push(\n\t\t\t\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\t\t\ttimes, values\n\t\t\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\t\t\t}\n\t\n\t\t\t\treturn new AnimationClip( name, -1, tracks );\n\t\n\t\t\t},\n\t\n\t\t\tfindByName: function( objectOrClipArray, name ) {\n\t\n\t\t\t\tvar clipArray = objectOrClipArray;\n\t\n\t\t\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\t\n\t\t\t\t\tvar o = objectOrClipArray;\n\t\t\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\t\n\t\t\t\t\tif ( clipArray[ i ].name === name ) {\n\t\n\t\t\t\t\t\treturn clipArray[ i ];\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t},\n\t\n\t\t\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\n\t\n\t\t\t\tvar animationToMorphTargets = {};\n\t\n\t\t\t\t// tested with https://regex101.com/ on trick sequences\n\t\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\t\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\t\n\t\t\t\t// sort morph target names into animation groups based\n\t\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\t\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\t\t\tvar parts = morphTarget.name.match( pattern );\n\t\n\t\t\t\t\tif ( parts && parts.length > 1 ) {\n\t\n\t\t\t\t\t\tvar name = parts[ 1 ];\n\t\n\t\t\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\t\t\tif ( ! animationMorphTargets ) {\n\t\n\t\t\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tanimationMorphTargets.push( morphTarget );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar clips = [];\n\t\n\t\t\t\tfor ( var name in animationToMorphTargets ) {\n\t\n\t\t\t\t\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn clips;\n\t\n\t\t\t},\n\t\n\t\t\t// parse the animation.hierarchy format\n\t\t\tparseAnimation: function( animation, bones ) {\n\t\n\t\t\t\tif ( ! animation ) {\n\t\n\t\t\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar addNonemptyTrack = function(\n\t\t\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\n\t\n\t\t\t\t\t// only return track if there are actually keys.\n\t\t\t\t\tif ( animationKeys.length !== 0 ) {\n\t\n\t\t\t\t\t\tvar times = [];\n\t\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\t\tAnimationUtils.flattenJSON(\n\t\t\t\t\t\t\t\tanimationKeys, times, values, propertyName );\n\t\n\t\t\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\t\t\tif ( times.length !== 0 ) {\n\t\n\t\t\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t\tvar tracks = [];\n\t\n\t\t\t\tvar clipName = animation.name || 'default';\n\t\t\t\t// automatic length determination in AnimationClip.\n\t\t\t\tvar duration = animation.length || -1;\n\t\t\t\tvar fps = animation.fps || 30;\n\t\n\t\t\t\tvar hierarchyTracks = animation.hierarchy || [];\n\t\n\t\t\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\t\n\t\t\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\t\n\t\t\t\t\t// skip empty tracks\n\t\t\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\t\n\t\t\t\t\t// process morph targets in a way exactly compatible\n\t\t\t\t\t// with AnimationHandler.init( animation )\n\t\t\t\t\tif ( animationKeys[0].morphTargets ) {\n\t\n\t\t\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\t\t\tvar morphTargetNames = {};\n\t\t\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\t\n\t\t\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\n\t\n\t\t\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t\t\t// the morphTarget is named.\n\t\t\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\t\n\t\t\t\t\t\t\tvar times = [];\n\t\t\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\t\t\tfor ( var m = 0;\n\t\t\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\n\t\n\t\t\t\t\t\t\t\tvar animationKey = animationKeys[k];\n\t\n\t\t\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\ttracks.push( new NumberKeyframeTrack(\n\t\t\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// ...assume skeletal animation\n\t\n\t\t\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\t\n\t\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\t\n\t\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\t\n\t\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( tracks.length === 0 ) {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar clip = new AnimationClip( clipName, duration, tracks );\n\t\n\t\t\t\treturn clip;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction MaterialLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\t\tthis.textures = {};\n\t\n\t\t}\n\t\n\t\tObject.assign( MaterialLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tsetTextures: function ( value ) {\n\t\n\t\t\t\tthis.textures = value;\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json ) {\n\t\n\t\t\t\tvar textures = this.textures;\n\t\n\t\t\t\tfunction getTexture( name ) {\n\t\n\t\t\t\t\tif ( textures[ name ] === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn textures[ name ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar material = new Materials[ json.type ]();\n\t\n\t\t\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\t\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\t\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\t\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\t\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\t\t\tif ( json.shading !== undefined ) material.shading = json.shading;\n\t\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\t\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\t\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\t\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\t\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\t\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\t\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\t\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\t\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\t\t\t\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\n\t\t\t\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\n\t\n\t\t\t\t// for PointsMaterial\n\t\n\t\t\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\t\n\t\t\t\t// maps\n\t\n\t\t\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\t\n\t\t\t\tif ( json.alphaMap !== undefined ) {\n\t\n\t\t\t\t\tmaterial.alphaMap = getTexture( json.alphaMap );\n\t\t\t\t\tmaterial.transparent = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\t\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\t\n\t\t\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\t\t\tif ( json.normalScale !== undefined ) {\n\t\n\t\t\t\t\tvar normalScale = json.normalScale;\n\t\n\t\t\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\t\n\t\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\t\n\t\t\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\t\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\t\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\t\n\t\t\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\t\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\t\n\t\t\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\t\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\t\n\t\t\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\t\n\t\t\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\t\n\t\t\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\t\n\t\t\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\t\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\t\n\t\t\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\t\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\t\n\t\t\t\t// MultiMaterial\n\t\n\t\t\t\tif ( json.materials !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn material;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction BufferGeometryLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( BufferGeometryLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json ) {\n\t\n\t\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\t\tvar index = json.data.index;\n\t\n\t\t\t\tvar TYPED_ARRAYS = {\n\t\t\t\t\t'Int8Array': Int8Array,\n\t\t\t\t\t'Uint8Array': Uint8Array,\n\t\t\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\n\t\t\t\t\t'Int16Array': Int16Array,\n\t\t\t\t\t'Uint16Array': Uint16Array,\n\t\t\t\t\t'Int32Array': Int32Array,\n\t\t\t\t\t'Uint32Array': Uint32Array,\n\t\t\t\t\t'Float32Array': Float32Array,\n\t\t\t\t\t'Float64Array': Float64Array\n\t\t\t\t};\n\t\n\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attributes = json.data.attributes;\n\t\n\t\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\t\tvar attribute = attributes[ key ];\n\t\t\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\t\n\t\t\t\t\tgeometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\t\n\t\t\t\tif ( groups !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar group = groups[ i ];\n\t\n\t\t\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar boundingSphere = json.data.boundingSphere;\n\t\n\t\t\t\tif ( boundingSphere !== undefined ) {\n\t\n\t\t\t\t\tvar center = new Vector3();\n\t\n\t\t\t\t\tif ( boundingSphere.center !== undefined ) {\n\t\n\t\t\t\t\t\tcenter.fromArray( boundingSphere.center );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometry;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Loader() {\n\t\n\t\t\tthis.onLoadStart = function () {};\n\t\t\tthis.onLoadProgress = function () {};\n\t\t\tthis.onLoadComplete = function () {};\n\t\n\t\t}\n\t\n\t\tLoader.prototype = {\n\t\n\t\t\tconstructor: Loader,\n\t\n\t\t\tcrossOrigin: undefined,\n\t\n\t\t\textractUrlBase: function ( url ) {\n\t\n\t\t\t\tvar parts = url.split( '/' );\n\t\n\t\t\t\tif ( parts.length === 1 ) return './';\n\t\n\t\t\t\tparts.pop();\n\t\n\t\t\t\treturn parts.join( '/' ) + '/';\n\t\n\t\t\t},\n\t\n\t\t\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\t\n\t\t\t\tvar array = [];\n\t\n\t\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\t\n\t\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tcreateMaterial: ( function () {\n\t\n\t\t\t\tvar color, textureLoader, materialLoader;\n\t\n\t\t\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\t\n\t\t\t\t\tif ( color === undefined ) color = new Color();\n\t\t\t\t\tif ( textureLoader === undefined ) textureLoader = new TextureLoader();\n\t\t\t\t\tif ( materialLoader === undefined ) materialLoader = new MaterialLoader();\n\t\n\t\t\t\t\t// convert from old material format\n\t\n\t\t\t\t\tvar textures = {};\n\t\n\t\t\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\t\n\t\t\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\t\t\tvar loader = Loader.Handlers.get( fullPath );\n\t\n\t\t\t\t\t\tvar texture;\n\t\n\t\t\t\t\t\tif ( loader !== null ) {\n\t\n\t\t\t\t\t\t\ttexture = loader.load( fullPath );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( repeat !== undefined ) {\n\t\n\t\t\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\t\n\t\t\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( offset !== undefined ) {\n\t\n\t\t\t\t\t\t\ttexture.offset.fromArray( offset );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( wrap !== undefined ) {\n\t\n\t\t\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\n\t\n\t\t\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\n\t\t\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( anisotropy !== undefined ) {\n\t\n\t\t\t\t\t\t\ttexture.anisotropy = anisotropy;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar uuid = _Math.generateUUID();\n\t\n\t\t\t\t\t\ttextures[ uuid ] = texture;\n\t\n\t\t\t\t\t\treturn uuid;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//\n\t\n\t\t\t\t\tvar json = {\n\t\t\t\t\t\tuuid: _Math.generateUUID(),\n\t\t\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t\t\t};\n\t\n\t\t\t\t\tfor ( var name in m ) {\n\t\n\t\t\t\t\t\tvar value = m[ name ];\n\t\n\t\t\t\t\t\tswitch ( name ) {\n\t\t\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\t\t\tjson.blending = BlendingMode[ value ];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\t\t\tjson.side = BackSide;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\t\t\tjson.side = DoubleSide;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\t\t\tcase 'opacity':\n\t\t\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\t\tcase 'visible':\n\t\t\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\t\t\tif ( value === true ) json.vertexColors = VertexColors;\n\t\t\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = FaceColors;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\t\n\t\t\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\t\n\t\t\t\t\tmaterialLoader.setTextures( textures );\n\t\n\t\t\t\t\treturn materialLoader.parse( json );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\t};\n\t\n\t\tLoader.Handlers = {\n\t\n\t\t\thandlers: [],\n\t\n\t\t\tadd: function ( regex, loader ) {\n\t\n\t\t\t\tthis.handlers.push( regex, loader );\n\t\n\t\t\t},\n\t\n\t\t\tget: function ( file ) {\n\t\n\t\t\t\tvar handlers = this.handlers;\n\t\n\t\t\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\t\n\t\t\t\t\tvar regex = handlers[ i ];\n\t\t\t\t\tvar loader  = handlers[ i + 1 ];\n\t\n\t\t\t\t\tif ( regex.test( file ) ) {\n\t\n\t\t\t\t\t\treturn loader;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction JSONLoader( manager ) {\n\t\n\t\t\tif ( typeof manager === 'boolean' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\t\t\tmanager = undefined;\n\t\n\t\t\t}\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t\tthis.withCredentials = false;\n\t\n\t\t}\n\t\n\t\tObject.assign( JSONLoader.prototype, {\n\t\n\t\t\tload: function( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );\n\t\n\t\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tvar json = JSON.parse( text );\n\t\t\t\t\tvar metadata = json.metadata;\n\t\n\t\t\t\t\tif ( metadata !== undefined ) {\n\t\n\t\t\t\t\t\tvar type = metadata.type;\n\t\n\t\t\t\t\t\tif ( type !== undefined ) {\n\t\n\t\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\t\t\tonLoad( object.geometry, object.materials );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tsetTexturePath: function ( value ) {\n\t\n\t\t\t\tthis.texturePath = value;\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json, texturePath ) {\n\t\n\t\t\t\tvar geometry = new Geometry(),\n\t\t\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\t\n\t\t\t\tparseModel( scale );\n\t\n\t\t\t\tparseSkin();\n\t\t\t\tparseMorphing( scale );\n\t\t\t\tparseAnimations();\n\t\n\t\t\t\tgeometry.computeFaceNormals();\n\t\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\t\tfunction parseModel( scale ) {\n\t\n\t\t\t\t\tfunction isBitSet( value, position ) {\n\t\n\t\t\t\t\t\treturn value & ( 1 << position );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar i, j, fi,\n\t\n\t\t\t\t\toffset, zLength,\n\t\n\t\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\t\n\t\t\t\t\ttype,\n\t\t\t\t\tisQuad,\n\t\t\t\t\thasMaterial,\n\t\t\t\t\thasFaceVertexUv,\n\t\t\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\t\t\thasFaceColor, hasFaceVertexColor,\n\t\n\t\t\t\tvertex, face, faceA, faceB, hex, normal,\n\t\n\t\t\t\t\tuvLayer, uv, u, v,\n\t\n\t\t\t\t\tfaces = json.faces,\n\t\t\t\t\tvertices = json.vertices,\n\t\t\t\t\tnormals = json.normals,\n\t\t\t\t\tcolors = json.colors,\n\t\n\t\t\t\t\tnUvLayers = 0;\n\t\n\t\t\t\t\tif ( json.uvs !== undefined ) {\n\t\n\t\t\t\t\t\t// disregard empty arrays\n\t\n\t\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\toffset = 0;\n\t\t\t\t\tzLength = vertices.length;\n\t\n\t\t\t\t\twhile ( offset < zLength ) {\n\t\n\t\t\t\t\t\tvertex = new Vector3();\n\t\n\t\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\t\n\t\t\t\t\t\tgeometry.vertices.push( vertex );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\toffset = 0;\n\t\t\t\t\tzLength = faces.length;\n\t\n\t\t\t\t\twhile ( offset < zLength ) {\n\t\n\t\t\t\t\t\ttype = faces[ offset ++ ];\n\t\n\t\n\t\t\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\t\n\t\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\t\n\t\t\t\t\t\tif ( isQuad ) {\n\t\n\t\t\t\t\t\t\tfaceA = new Face3();\n\t\t\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\t\n\t\t\t\t\t\t\tfaceB = new Face3();\n\t\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\t\n\t\t\t\t\t\t\toffset += 4;\n\t\n\t\t\t\t\t\t\tif ( hasMaterial ) {\n\t\n\t\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// to get face <=> uv index correspondence\n\t\n\t\t\t\t\t\t\tfi = geometry.faces.length;\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\t\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\t\n\t\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\t\n\t\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\t\n\t\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\t\n\t\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t\t);\n\t\n\t\n\t\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\t\n\t\t\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\t\t\tfaceB.color.setHex( hex );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\t\n\t\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );\n\t\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\t\t\tgeometry.faces.push( faceB );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tface = new Face3();\n\t\t\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.c = faces[ offset ++ ];\n\t\n\t\t\t\t\t\t\tif ( hasMaterial ) {\n\t\n\t\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.materialIndex = materialIndex;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// to get face <=> uv index correspondence\n\t\n\t\t\t\t\t\t\tfi = geometry.faces.length;\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\t\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\n\t\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\t\n\t\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\t\n\t\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\t\n\t\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\t\tface.vertexColors.push( new Color( colors[ colorIndex ] ) );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tgeometry.faces.push( face );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction parseSkin() {\n\t\n\t\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\t\n\t\t\t\t\tif ( json.skinWeights ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\t\n\t\t\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\t\n\t\t\t\t\t\t\tgeometry.skinWeights.push( new Vector4( x, y, z, w ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.skinIndices ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\t\n\t\t\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\t\n\t\t\t\t\t\t\tgeometry.skinIndices.push( new Vector4( a, b, c, d ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.bones = json.bones;\n\t\n\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction parseMorphing( scale ) {\n\t\n\t\t\t\t\tif ( json.morphTargets !== undefined ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\t\n\t\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\t\n\t\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\t\n\t\t\t\t\t\t\t\tvar vertex = new Vector3();\n\t\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\t\n\t\t\t\t\t\t\t\tdstVertices.push( vertex );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\t\n\t\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction parseAnimations() {\n\t\n\t\t\t\t\tvar outputAnimations = [];\n\t\n\t\t\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\t\t\tvar animations = [];\n\t\n\t\t\t\t\tif ( json.animation !== undefined ) {\n\t\n\t\t\t\t\t\tanimations.push( json.animation );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.animations !== undefined ) {\n\t\n\t\t\t\t\t\tif ( json.animations.length ) {\n\t\n\t\t\t\t\t\t\tanimations = animations.concat( json.animations );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tanimations.push( json.animations );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// parse implicit morph animations\n\t\t\t\t\tif ( geometry.morphTargets ) {\n\t\n\t\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\t\t\tvar morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\t\n\t\t\t\t\treturn { geometry: geometry };\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\t\n\t\t\t\t\treturn { geometry: geometry, materials: materials };\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction ObjectLoader ( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\t\tthis.texturePath = '';\n\t\n\t\t}\n\t\n\t\tObject.assign( ObjectLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tif ( this.texturePath === '' ) {\n\t\n\t\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tscope.parse( JSON.parse( text ), onLoad );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tsetTexturePath: function ( value ) {\n\t\n\t\t\t\tthis.texturePath = value;\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\t\tthis.crossOrigin = value;\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json, onLoad ) {\n\t\n\t\t\t\tvar geometries = this.parseGeometries( json.geometries );\n\t\n\t\t\t\tvar images = this.parseImages( json.images, function () {\n\t\n\t\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\t\n\t\t\t\t} );\n\t\n\t\t\t\tvar textures  = this.parseTextures( json.textures, images );\n\t\t\t\tvar materials = this.parseMaterials( json.materials, textures );\n\t\n\t\t\t\tvar object = this.parseObject( json.object, geometries, materials );\n\t\n\t\t\t\tif ( json.animations ) {\n\t\n\t\t\t\t\tobject.animations = this.parseAnimations( json.animations );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\t\n\t\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn object;\n\t\n\t\t\t},\n\t\n\t\t\tparseGeometries: function ( json ) {\n\t\n\t\t\t\tvar geometries = {};\n\t\n\t\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\t\tvar geometryLoader = new JSONLoader();\n\t\t\t\t\tvar bufferGeometryLoader = new BufferGeometryLoader();\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar geometry;\n\t\t\t\t\t\tvar data = json[ i ];\n\t\n\t\t\t\t\t\tswitch ( data.type ) {\n\t\n\t\t\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\t\t\tcase 'PlaneBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\t\t\tcase 'CircleBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\t\t\tcase 'CylinderBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\t\t\tcase 'ConeBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\t\t\tcase 'SphereBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\t\t\tcase 'TetrahedronGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\t\t\tcase 'RingBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\t\t\tcase 'TorusBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\t\t\tcase 'LatheBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'BufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'Geometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\t\n\t\t\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tgeometry.uuid = data.uuid;\n\t\n\t\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\n\t\t\t\t\t\tgeometries[ data.uuid ] = geometry;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometries;\n\t\n\t\t\t},\n\t\n\t\t\tparseMaterials: function ( json, textures ) {\n\t\n\t\t\t\tvar materials = {};\n\t\n\t\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\t\tvar loader = new MaterialLoader();\n\t\t\t\t\tloader.setTextures( textures );\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar material = loader.parse( json[ i ] );\n\t\t\t\t\t\tmaterials[ material.uuid ] = material;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn materials;\n\t\n\t\t\t},\n\t\n\t\t\tparseAnimations: function ( json ) {\n\t\n\t\t\t\tvar animations = [];\n\t\n\t\t\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\t\n\t\t\t\t\tvar clip = AnimationClip.parse( json[ i ] );\n\t\n\t\t\t\t\tanimations.push( clip );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn animations;\n\t\n\t\t\t},\n\t\n\t\t\tparseImages: function ( json, onLoad ) {\n\t\n\t\t\t\tvar scope = this;\n\t\t\t\tvar images = {};\n\t\n\t\t\t\tfunction loadImage( url ) {\n\t\n\t\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\t\treturn loader.load( url, function () {\n\t\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t}, undefined, function () {\n\t\n\t\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json !== undefined && json.length > 0 ) {\n\t\n\t\t\t\t\tvar manager = new LoadingManager( onLoad );\n\t\n\t\t\t\t\tvar loader = new ImageLoader( manager );\n\t\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar image = json[ i ];\n\t\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\t\n\t\t\t\t\t\timages[ image.uuid ] = loadImage( path );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn images;\n\t\n\t\t\t},\n\t\n\t\t\tparseTextures: function ( json, images ) {\n\t\n\t\t\t\tfunction parseConstant( value, type ) {\n\t\n\t\t\t\t\tif ( typeof( value ) === 'number' ) return value;\n\t\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\t\n\t\t\t\t\treturn type[ value ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar textures = {};\n\t\n\t\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar data = json[ i ];\n\t\n\t\t\t\t\t\tif ( data.image === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( images[ data.image ] === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar texture = new Texture( images[ data.image ] );\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\ttexture.uuid = data.uuid;\n\t\n\t\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\t\n\t\t\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );\n\t\n\t\t\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\t\t\tif ( data.wrap !== undefined ) {\n\t\n\t\t\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );\n\t\t\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );\n\t\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );\n\t\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\t\n\t\t\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\t\n\t\t\t\t\t\ttextures[ data.uuid ] = texture;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn textures;\n\t\n\t\t\t},\n\t\n\t\t\tparseObject: function () {\n\t\n\t\t\t\tvar matrix = new Matrix4();\n\t\n\t\t\t\treturn function parseObject( data, geometries, materials ) {\n\t\n\t\t\t\t\tvar object;\n\t\n\t\t\t\t\tfunction getGeometry( name ) {\n\t\n\t\t\t\t\t\tif ( geometries[ name ] === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn geometries[ name ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfunction getMaterial( name ) {\n\t\n\t\t\t\t\t\tif ( name === undefined ) return undefined;\n\t\n\t\t\t\t\t\tif ( materials[ name ] === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn materials[ name ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tswitch ( data.type ) {\n\t\n\t\t\t\t\t\tcase 'Scene':\n\t\n\t\t\t\t\t\t\tobject = new Scene();\n\t\n\t\t\t\t\t\t\tif ( data.background !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\t\n\t\t\t\t\t\t\t\t\tobject.background = new Color( data.background );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( data.fog !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\t\n\t\t\t\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\t\n\t\t\t\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\t\n\t\t\t\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'PerspectiveCamera':\n\t\n\t\t\t\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\t\n\t\t\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'OrthographicCamera':\n\t\n\t\t\t\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'AmbientLight':\n\t\n\t\t\t\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'DirectionalLight':\n\t\n\t\t\t\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'PointLight':\n\t\n\t\t\t\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'SpotLight':\n\t\n\t\t\t\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'HemisphereLight':\n\t\n\t\t\t\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'Mesh':\n\t\n\t\t\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\t\t\tvar material = getMaterial( data.material );\n\t\n\t\t\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\t\n\t\t\t\t\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tobject = new Mesh( geometry, material );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'LOD':\n\t\n\t\t\t\t\t\t\tobject = new LOD();\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'Line':\n\t\n\t\t\t\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'LineSegments':\n\t\n\t\t\t\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'PointCloud':\n\t\t\t\t\t\tcase 'Points':\n\t\n\t\t\t\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'Sprite':\n\t\n\t\t\t\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'Group':\n\t\n\t\t\t\t\t\t\tobject = new Group();\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\tobject = new Object3D();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.uuid = data.uuid;\n\t\n\t\t\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\t\t\tif ( data.matrix !== undefined ) {\n\t\n\t\t\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\t\n\t\t\t\t\tif ( data.shadow ) {\n\t\n\t\t\t\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\t\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\t\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\t\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\n\t\t\t\t\tif ( data.children !== undefined ) {\n\t\n\t\t\t\t\t\tfor ( var child in data.children ) {\n\t\n\t\t\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( data.type === 'LOD' ) {\n\t\n\t\t\t\t\t\tvar levels = data.levels;\n\t\n\t\t\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\t\n\t\t\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\t\n\t\t\t\t\t\t\tif ( child !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn object;\n\t\n\t\t\t\t};\n\t\n\t\t\t}()\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * Extensible curve object\n\t\t *\n\t\t * Some common of Curve methods\n\t\t * .getPoint(t), getTangent(t)\n\t\t * .getPointAt(u), getTangentAt(u)\n\t\t * .getPoints(), .getSpacedPoints()\n\t\t * .getLength()\n\t\t * .updateArcLengths()\n\t\t *\n\t\t * This following classes subclasses THREE.Curve:\n\t\t *\n\t\t * -- 2d classes --\n\t\t * THREE.LineCurve\n\t\t * THREE.QuadraticBezierCurve\n\t\t * THREE.CubicBezierCurve\n\t\t * THREE.SplineCurve\n\t\t * THREE.ArcCurve\n\t\t * THREE.EllipseCurve\n\t\t *\n\t\t * -- 3d classes --\n\t\t * THREE.LineCurve3\n\t\t * THREE.QuadraticBezierCurve3\n\t\t * THREE.CubicBezierCurve3\n\t\t * THREE.SplineCurve3\n\t\t *\n\t\t * A series of curves can be represented as a THREE.CurvePath\n\t\t *\n\t\t **/\n\t\n\t\t/**************************************************************\n\t\t *\tAbstract Curve base class\n\t\t **************************************************************/\n\t\n\t\tfunction Curve() {}\n\t\n\t\tCurve.prototype = {\n\t\n\t\t\tconstructor: Curve,\n\t\n\t\t\t// Virtual base class method to overwrite and implement in subclasses\n\t\t\t//\t- t [0 .. 1]\n\t\n\t\t\tgetPoint: function ( t ) {\n\t\n\t\t\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n\t\t\t\treturn null;\n\t\n\t\t\t},\n\t\n\t\t\t// Get point at relative position in curve according to arc length\n\t\t\t// - u [0 .. 1]\n\t\n\t\t\tgetPointAt: function ( u ) {\n\t\n\t\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\t\treturn this.getPoint( t );\n\t\n\t\t\t},\n\t\n\t\t\t// Get sequence of points using getPoint( t )\n\t\n\t\t\tgetPoints: function ( divisions ) {\n\t\n\t\t\t\tif ( ! divisions ) divisions = 5;\n\t\n\t\t\t\tvar points = [];\n\t\n\t\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\t\n\t\t\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn points;\n\t\n\t\t\t},\n\t\n\t\t\t// Get sequence of points using getPointAt( u )\n\t\n\t\t\tgetSpacedPoints: function ( divisions ) {\n\t\n\t\t\t\tif ( ! divisions ) divisions = 5;\n\t\n\t\t\t\tvar points = [];\n\t\n\t\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\t\n\t\t\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn points;\n\t\n\t\t\t},\n\t\n\t\t\t// Get total curve arc length\n\t\n\t\t\tgetLength: function () {\n\t\n\t\t\t\tvar lengths = this.getLengths();\n\t\t\t\treturn lengths[ lengths.length - 1 ];\n\t\n\t\t\t},\n\t\n\t\t\t// Get list of cumulative segment lengths\n\t\n\t\t\tgetLengths: function ( divisions ) {\n\t\n\t\t\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\t\n\t\t\t\tif ( this.cacheArcLengths\n\t\t\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\n\t\t\t\t\t&& ! this.needsUpdate ) {\n\t\n\t\t\t\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\t\t\t\treturn this.cacheArcLengths;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.needsUpdate = false;\n\t\n\t\t\t\tvar cache = [];\n\t\t\t\tvar current, last = this.getPoint( 0 );\n\t\t\t\tvar p, sum = 0;\n\t\n\t\t\t\tcache.push( 0 );\n\t\n\t\t\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\t\n\t\t\t\t\tcurrent = this.getPoint ( p / divisions );\n\t\t\t\t\tsum += current.distanceTo( last );\n\t\t\t\t\tcache.push( sum );\n\t\t\t\t\tlast = current;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cacheArcLengths = cache;\n\t\n\t\t\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\t\n\t\t\t},\n\t\n\t\t\tupdateArcLengths: function() {\n\t\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\tthis.getLengths();\n\t\n\t\t\t},\n\t\n\t\t\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\t\n\t\t\tgetUtoTmapping: function ( u, distance ) {\n\t\n\t\t\t\tvar arcLengths = this.getLengths();\n\t\n\t\t\t\tvar i = 0, il = arcLengths.length;\n\t\n\t\t\t\tvar targetArcLength; // The targeted u distance value to get\n\t\n\t\t\t\tif ( distance ) {\n\t\n\t\t\t\t\ttargetArcLength = distance;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//var time = Date.now();\n\t\n\t\t\t\t// binary search for the index with largest value smaller than target u distance\n\t\n\t\t\t\tvar low = 0, high = il - 1, comparison;\n\t\n\t\t\t\twhile ( low <= high ) {\n\t\n\t\t\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\t\n\t\t\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\t\n\t\t\t\t\tif ( comparison < 0 ) {\n\t\n\t\t\t\t\t\tlow = i + 1;\n\t\n\t\t\t\t\t} else if ( comparison > 0 ) {\n\t\n\t\t\t\t\t\thigh = i - 1;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\thigh = i;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t// DONE\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\ti = high;\n\t\n\t\t\t\t//console.log('b' , i, low, high, Date.now()- time);\n\t\n\t\t\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\t\n\t\t\t\t\tvar t = i / ( il - 1 );\n\t\t\t\t\treturn t;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\t\n\t\t\t\tvar lengthBefore = arcLengths[ i ];\n\t\t\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\t\n\t\t\t\tvar segmentLength = lengthAfter - lengthBefore;\n\t\n\t\t\t\t// determine where we are between the 'before' and 'after' points\n\t\n\t\t\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\t\n\t\t\t\t// add that fractional amount to t\n\t\n\t\t\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\t\n\t\t\t\treturn t;\n\t\n\t\t\t},\n\t\n\t\t\t// Returns a unit vector tangent at t\n\t\t\t// In case any sub curve does not implement its tangent derivation,\n\t\t\t// 2 points a small delta apart will be used to find its gradient\n\t\t\t// which seems to give a reasonable approximation\n\t\n\t\t\tgetTangent: function( t ) {\n\t\n\t\t\t\tvar delta = 0.0001;\n\t\t\t\tvar t1 = t - delta;\n\t\t\t\tvar t2 = t + delta;\n\t\n\t\t\t\t// Capping in case of danger\n\t\n\t\t\t\tif ( t1 < 0 ) t1 = 0;\n\t\t\t\tif ( t2 > 1 ) t2 = 1;\n\t\n\t\t\t\tvar pt1 = this.getPoint( t1 );\n\t\t\t\tvar pt2 = this.getPoint( t2 );\n\t\n\t\t\t\tvar vec = pt2.clone().sub( pt1 );\n\t\t\t\treturn vec.normalize();\n\t\n\t\t\t},\n\t\n\t\t\tgetTangentAt: function ( u ) {\n\t\n\t\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\t\treturn this.getTangent( t );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeFrenetFrames: function ( segments, closed ) {\n\t\n\t\t\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\t\n\t\t\t\tvar normal = new Vector3();\n\t\n\t\t\t\tvar tangents = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar binormals = [];\n\t\n\t\t\t\tvar vec = new Vector3();\n\t\t\t\tvar mat = new Matrix4();\n\t\n\t\t\t\tvar i, u, theta;\n\t\n\t\t\t\t// compute the tangent vectors for each segment on the curve\n\t\n\t\t\t\tfor ( i = 0; i <= segments; i ++ ) {\n\t\n\t\t\t\t\tu = i / segments;\n\t\n\t\t\t\t\ttangents[ i ] = this.getTangentAt( u );\n\t\t\t\t\ttangents[ i ].normalize();\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t\t\t// and in the direction of the minimum tangent xyz component\n\t\n\t\t\t\tnormals[ 0 ] = new Vector3();\n\t\t\t\tbinormals[ 0 ] = new Vector3();\n\t\t\t\tvar min = Number.MAX_VALUE;\n\t\t\t\tvar tx = Math.abs( tangents[ 0 ].x );\n\t\t\t\tvar ty = Math.abs( tangents[ 0 ].y );\n\t\t\t\tvar tz = Math.abs( tangents[ 0 ].z );\n\t\n\t\t\t\tif ( tx <= min ) {\n\t\n\t\t\t\t\tmin = tx;\n\t\t\t\t\tnormal.set( 1, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ty <= min ) {\n\t\n\t\t\t\t\tmin = ty;\n\t\t\t\t\tnormal.set( 0, 1, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( tz <= min ) {\n\t\n\t\t\t\t\tnormal.set( 0, 0, 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\t\n\t\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\t\n\t\n\t\t\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\t\n\t\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\t\n\t\t\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\t\n\t\t\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\t\n\t\t\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\t\n\t\t\t\t\tif ( vec.length() > Number.EPSILON ) {\n\t\n\t\t\t\t\t\tvec.normalize();\n\t\n\t\t\t\t\t\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\t\n\t\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\t\n\t\t\t\tif ( closed === true ) {\n\t\n\t\t\t\t\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\t\t\ttheta /= segments;\n\t\n\t\t\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\t\n\t\t\t\t\t\ttheta = - theta;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\t\n\t\t\t\t\t\t// twist a little...\n\t\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn {\n\t\t\t\t\ttangents: tangents,\n\t\t\t\t\tnormals: normals,\n\t\t\t\t\tbinormals: binormals\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// TODO: Transformation for Curves?\n\t\n\t\t/**************************************************************\n\t\t *\t3D Curves\n\t\t **************************************************************/\n\t\n\t\t// A Factory method for creating new curve subclasses\n\t\n\t\tCurve.create = function ( constructor, getPointFunc ) {\n\t\n\t\t\tconstructor.prototype = Object.create( Curve.prototype );\n\t\t\tconstructor.prototype.constructor = constructor;\n\t\t\tconstructor.prototype.getPoint = getPointFunc;\n\t\n\t\t\treturn constructor;\n\t\n\t\t};\n\t\n\t\t/**************************************************************\n\t\t *\tLine\n\t\t **************************************************************/\n\t\n\t\tfunction LineCurve( v1, v2 ) {\n\t\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\n\t\t}\n\t\n\t\tLineCurve.prototype = Object.create( Curve.prototype );\n\t\tLineCurve.prototype.constructor = LineCurve;\n\t\n\t\tLineCurve.prototype.isLineCurve = true;\n\t\n\t\tLineCurve.prototype.getPoint = function ( t ) {\n\t\n\t\t\tif ( t === 1 ) {\n\t\n\t\t\t\treturn this.v2.clone();\n\t\n\t\t\t}\n\t\n\t\t\tvar point = this.v2.clone().sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\t\n\t\t\treturn point;\n\t\n\t\t};\n\t\n\t\t// Line curve is linear, so we can overwrite default getPointAt\n\t\n\t\tLineCurve.prototype.getPointAt = function ( u ) {\n\t\n\t\t\treturn this.getPoint( u );\n\t\n\t\t};\n\t\n\t\tLineCurve.prototype.getTangent = function( t ) {\n\t\n\t\t\tvar tangent = this.v2.clone().sub( this.v1 );\n\t\n\t\t\treturn tangent.normalize();\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t *\n\t\t **/\n\t\n\t\t/**************************************************************\n\t\t *\tCurved Path - a curve path is simply a array of connected\n\t\t *  curves, but retains the api of a curve\n\t\t **************************************************************/\n\t\n\t\tfunction CurvePath() {\n\t\n\t\t\tthis.curves = [];\n\t\n\t\t\tthis.autoClose = false; // Automatically closes the path\n\t\n\t\t}\n\t\n\t\tCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\n\t\n\t\t\tconstructor: CurvePath,\n\t\n\t\t\tadd: function ( curve ) {\n\t\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t},\n\t\n\t\t\tclosePath: function () {\n\t\n\t\t\t\t// Add a line curve if start and end of lines are not connected\n\t\t\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\t\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\t\n\t\t\t\tif ( ! startPoint.equals( endPoint ) ) {\n\t\n\t\t\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// To get accurate point with reference to\n\t\t\t// entire path distance at time t,\n\t\t\t// following has to be done:\n\t\n\t\t\t// 1. Length of each sub path have to be known\n\t\t\t// 2. Locate and identify type of curve\n\t\t\t// 3. Get t for the curve\n\t\t\t// 4. Return curve.getPointAt(t')\n\t\n\t\t\tgetPoint: function ( t ) {\n\t\n\t\t\t\tvar d = t * this.getLength();\n\t\t\t\tvar curveLengths = this.getCurveLengths();\n\t\t\t\tvar i = 0;\n\t\n\t\t\t\t// To think about boundaries points.\n\t\n\t\t\t\twhile ( i < curveLengths.length ) {\n\t\n\t\t\t\t\tif ( curveLengths[ i ] >= d ) {\n\t\n\t\t\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\t\t\tvar curve = this.curves[ i ];\n\t\n\t\t\t\t\t\tvar segmentLength = curve.getLength();\n\t\t\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\t\n\t\t\t\t\t\treturn curve.getPointAt( u );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ti ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t\t// loop where sum != 0, sum > d , sum+1 <d\n\t\n\t\t\t},\n\t\n\t\t\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t\t// getPoint() depends on getLength\n\t\n\t\t\tgetLength: function () {\n\t\n\t\t\t\tvar lens = this.getCurveLengths();\n\t\t\t\treturn lens[ lens.length - 1 ];\n\t\n\t\t\t},\n\t\n\t\t\t// cacheLengths must be recalculated.\n\t\t\tupdateArcLengths: function () {\n\t\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\tthis.cacheLengths = null;\n\t\t\t\tthis.getLengths();\n\t\n\t\t\t},\n\t\n\t\t\t// Compute lengths and cache them\n\t\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\t\n\t\t\tgetCurveLengths: function () {\n\t\n\t\t\t\t// We use cache values if curves and cache array are same length\n\t\n\t\t\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\t\n\t\t\t\t\treturn this.cacheLengths;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Get length of sub-curve\n\t\t\t\t// Push sums into cached array\n\t\n\t\t\t\tvar lengths = [], sums = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tsums += this.curves[ i ].getLength();\n\t\t\t\t\tlengths.push( sums );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cacheLengths = lengths;\n\t\n\t\t\t\treturn lengths;\n\t\n\t\t\t},\n\t\n\t\t\tgetSpacedPoints: function ( divisions ) {\n\t\n\t\t\t\tif ( ! divisions ) divisions = 40;\n\t\n\t\t\t\tvar points = [];\n\t\n\t\t\t\tfor ( var i = 0; i <= divisions; i ++ ) {\n\t\n\t\t\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.autoClose ) {\n\t\n\t\t\t\t\tpoints.push( points[ 0 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn points;\n\t\n\t\t\t},\n\t\n\t\t\tgetPoints: function ( divisions ) {\n\t\n\t\t\t\tdivisions = divisions || 12;\n\t\n\t\t\t\tvar points = [], last;\n\t\n\t\t\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\t\n\t\t\t\t\tvar curve = curves[ i ];\n\t\t\t\t\tvar resolution = (curve && curve.isEllipseCurve) ? divisions * 2\n\t\t\t\t\t\t: (curve && curve.isLineCurve) ? 1\n\t\t\t\t\t\t: (curve && curve.isSplineCurve) ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\t\n\t\t\t\t\tvar pts = curve.getPoints( resolution );\n\t\n\t\t\t\t\tfor ( var j = 0; j < pts.length; j++ ) {\n\t\n\t\t\t\t\t\tvar point = pts[ j ];\n\t\n\t\t\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\t\n\t\t\t\t\t\tpoints.push( point );\n\t\t\t\t\t\tlast = point;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\t\n\t\t\t\t\tpoints.push( points[ 0 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn points;\n\t\n\t\t\t},\n\t\n\t\t\t/**************************************************************\n\t\t\t *\tCreate Geometries Helpers\n\t\t\t **************************************************************/\n\t\n\t\t\t/// Generate geometry from path points (for Line or Points objects)\n\t\n\t\t\tcreatePointsGeometry: function ( divisions ) {\n\t\n\t\t\t\tvar pts = this.getPoints( divisions );\n\t\t\t\treturn this.createGeometry( pts );\n\t\n\t\t\t},\n\t\n\t\t\t// Generate geometry from equidistant sampling along the path\n\t\n\t\t\tcreateSpacedPointsGeometry: function ( divisions ) {\n\t\n\t\t\t\tvar pts = this.getSpacedPoints( divisions );\n\t\t\t\treturn this.createGeometry( pts );\n\t\n\t\t\t},\n\t\n\t\t\tcreateGeometry: function ( points ) {\n\t\n\t\t\t\tvar geometry = new Geometry();\n\t\n\t\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar point = points[ i ];\n\t\t\t\t\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometry;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**************************************************************\n\t\t *\tEllipse curve\n\t\t **************************************************************/\n\t\n\t\tfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\t\tthis.aX = aX;\n\t\t\tthis.aY = aY;\n\t\n\t\t\tthis.xRadius = xRadius;\n\t\t\tthis.yRadius = yRadius;\n\t\n\t\t\tthis.aStartAngle = aStartAngle;\n\t\t\tthis.aEndAngle = aEndAngle;\n\t\n\t\t\tthis.aClockwise = aClockwise;\n\t\n\t\t\tthis.aRotation = aRotation || 0;\n\t\n\t\t}\n\t\n\t\tEllipseCurve.prototype = Object.create( Curve.prototype );\n\t\tEllipseCurve.prototype.constructor = EllipseCurve;\n\t\n\t\tEllipseCurve.prototype.isEllipseCurve = true;\n\t\n\t\tEllipseCurve.prototype.getPoint = function( t ) {\n\t\n\t\t\tvar twoPi = Math.PI * 2;\n\t\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\t\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\t\n\t\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\t\n\t\t\tif ( deltaAngle < Number.EPSILON ) {\n\t\n\t\t\t\tif ( samePoints ) {\n\t\n\t\t\t\t\tdeltaAngle = 0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdeltaAngle = twoPi;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.aClockwise === true && ! samePoints ) {\n\t\n\t\t\t\tif ( deltaAngle === twoPi ) {\n\t\n\t\t\t\t\tdeltaAngle = - twoPi;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar angle = this.aStartAngle + t * deltaAngle;\n\t\t\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\t\t\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\t\n\t\t\tif ( this.aRotation !== 0 ) {\n\t\n\t\t\t\tvar cos = Math.cos( this.aRotation );\n\t\t\t\tvar sin = Math.sin( this.aRotation );\n\t\n\t\t\t\tvar tx = x - this.aX;\n\t\t\t\tvar ty = y - this.aY;\n\t\n\t\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\t\ty = tx * sin + ty * cos + this.aY;\n\t\n\t\t\t}\n\t\n\t\t\treturn new Vector2( x, y );\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t */\n\t\n\t\tvar CurveUtils = {\n\t\n\t\t\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\t\n\t\t\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\t\n\t\t\t},\n\t\n\t\t\t// Puay Bing, thanks for helping with this derivative!\n\t\n\t\t\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\n\t\n\t\t\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\n\t\t\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\n\t\t\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\n\t\t\t\t\t3 * t * t * p3;\n\t\n\t\t\t},\n\t\n\t\t\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\t\n\t\t\t\t// To check if my formulas are correct\n\t\n\t\t\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\n\t\t\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\n\t\t\t\tvar h01 = - 6 * t * t + 6 * t; \t// − 2t3 + 3t2\n\t\t\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\n\t\n\t\t\t\treturn h00 + h10 + h01 + h11;\n\t\n\t\t\t},\n\t\n\t\t\t// Catmull-Rom\n\t\n\t\t\tinterpolate: function( p0, p1, p2, p3, t ) {\n\t\n\t\t\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\t\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\t\t\tvar t2 = t * t;\n\t\t\t\tvar t3 = t * t2;\n\t\t\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**************************************************************\n\t\t *\tSpline curve\n\t\t **************************************************************/\n\t\n\t\tfunction SplineCurve( points /* array of Vector2 */ ) {\n\t\n\t\t\tthis.points = ( points === undefined ) ? [] : points;\n\t\n\t\t}\n\t\n\t\tSplineCurve.prototype = Object.create( Curve.prototype );\n\t\tSplineCurve.prototype.constructor = SplineCurve;\n\t\n\t\tSplineCurve.prototype.isSplineCurve = true;\n\t\n\t\tSplineCurve.prototype.getPoint = function ( t ) {\n\t\n\t\t\tvar points = this.points;\n\t\t\tvar point = ( points.length - 1 ) * t;\n\t\n\t\t\tvar intPoint = Math.floor( point );\n\t\t\tvar weight = point - intPoint;\n\t\n\t\t\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\t\tvar point1 = points[ intPoint ];\n\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\t\n\t\t\tvar interpolate = CurveUtils.interpolate;\n\t\n\t\t\treturn new Vector2(\n\t\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\n\t\t\t);\n\t\n\t\t};\n\t\n\t\t/**************************************************************\n\t\t *\tCubic Bezier curve\n\t\t **************************************************************/\n\t\n\t\tfunction CubicBezierCurve( v0, v1, v2, v3 ) {\n\t\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\t\n\t\t}\n\t\n\t\tCubicBezierCurve.prototype = Object.create( Curve.prototype );\n\t\tCubicBezierCurve.prototype.constructor = CubicBezierCurve;\n\t\n\t\tCubicBezierCurve.prototype.getPoint = function ( t ) {\n\t\n\t\t\tvar b3 = ShapeUtils.b3;\n\t\n\t\t\treturn new Vector2(\n\t\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t\t);\n\t\n\t\t};\n\t\n\t\tCubicBezierCurve.prototype.getTangent = function( t ) {\n\t\n\t\t\tvar tangentCubicBezier = CurveUtils.tangentCubicBezier;\n\t\n\t\t\treturn new Vector2(\n\t\t\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t\t).normalize();\n\t\n\t\t};\n\t\n\t\t/**************************************************************\n\t\t *\tQuadratic Bezier curve\n\t\t **************************************************************/\n\t\n\t\n\t\tfunction QuadraticBezierCurve( v0, v1, v2 ) {\n\t\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\n\t\t}\n\t\n\t\tQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\n\t\tQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\n\t\n\t\n\t\tQuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\t\n\t\t\tvar b2 = ShapeUtils.b2;\n\t\n\t\t\treturn new Vector2(\n\t\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t\t);\n\t\n\t\t};\n\t\n\t\n\t\tQuadraticBezierCurve.prototype.getTangent = function( t ) {\n\t\n\t\t\tvar tangentQuadraticBezier = CurveUtils.tangentQuadraticBezier;\n\t\n\t\t\treturn new Vector2(\n\t\t\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t\t).normalize();\n\t\n\t\t};\n\t\n\t\tvar PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {\n\t\n\t\t\tfromPoints: function ( vectors ) {\n\t\n\t\t\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\t\n\t\t\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tmoveTo: function ( x, y ) {\n\t\n\t\t\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\t\n\t\t\t},\n\t\n\t\t\tlineTo: function ( x, y ) {\n\t\n\t\t\t\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tthis.currentPoint.set( x, y );\n\t\n\t\t\t},\n\t\n\t\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\n\t\t\t\tvar curve = new QuadraticBezierCurve(\n\t\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\t\t\tnew Vector2( aX, aY )\n\t\t\t\t);\n\t\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tthis.currentPoint.set( aX, aY );\n\t\n\t\t\t},\n\t\n\t\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\n\t\t\t\tvar curve = new CubicBezierCurve(\n\t\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\t\t\tnew Vector2( aX, aY )\n\t\t\t\t);\n\t\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tthis.currentPoint.set( aX, aY );\n\t\n\t\t\t},\n\t\n\t\t\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\t\n\t\t\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\n\t\n\t\t\t\tvar curve = new SplineCurve( npts );\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\t\n\t\t\t},\n\t\n\t\t\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\t\t\tvar x0 = this.currentPoint.x;\n\t\t\t\tvar y0 = this.currentPoint.y;\n\t\n\t\t\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\t\n\t\t\t},\n\t\n\t\t\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\t\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\t\n\t\t\t},\n\t\n\t\t\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\t\t\tvar x0 = this.currentPoint.x;\n\t\t\t\tvar y0 = this.currentPoint.y;\n\t\n\t\t\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\n\t\t\t},\n\t\n\t\t\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\t\t\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\n\t\t\t\tif ( this.curves.length > 0 ) {\n\t\n\t\t\t\t\t// if a previous curve is present, attempt to join\n\t\t\t\t\tvar firstPoint = curve.getPoint( 0 );\n\t\n\t\t\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\t\n\t\t\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tvar lastPoint = curve.getPoint( 1 );\n\t\t\t\tthis.currentPoint.copy( lastPoint );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * Defines a 2d shape plane using paths.\n\t\t **/\n\t\n\t\t// STEP 1 Create a path.\n\t\t// STEP 2 Turn path into shape.\n\t\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n\t\t// STEP 3a - Extract points from each shape, turn to vertices\n\t\t// STEP 3b - Triangulate each shape, add faces.\n\t\n\t\tfunction Shape() {\n\t\n\t\t\tPath.apply( this, arguments );\n\t\n\t\t\tthis.holes = [];\n\t\n\t\t}\n\t\n\t\tShape.prototype = Object.assign( Object.create( PathPrototype ), {\n\t\n\t\t\tconstructor: Shape,\n\t\n\t\t\tgetPointsHoles: function ( divisions ) {\n\t\n\t\t\t\tvar holesPts = [];\n\t\n\t\t\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn holesPts;\n\t\n\t\t\t},\n\t\n\t\t\t// Get points of shape and holes (keypoints based on segments parameter)\n\t\n\t\t\textractAllPoints: function ( divisions ) {\n\t\n\t\t\t\treturn {\n\t\n\t\t\t\t\tshape: this.getPoints( divisions ),\n\t\t\t\t\tholes: this.getPointsHoles( divisions )\n\t\n\t\t\t\t};\n\t\n\t\t\t},\n\t\n\t\t\textractPoints: function ( divisions ) {\n\t\n\t\t\t\treturn this.extractAllPoints( divisions );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * Creates free form 2d path using series of points, lines or curves.\n\t\t *\n\t\t **/\n\t\n\t\tfunction Path( points ) {\n\t\n\t\t\tCurvePath.call( this );\n\t\t\tthis.currentPoint = new Vector2();\n\t\n\t\t\tif ( points ) {\n\t\n\t\t\t\tthis.fromPoints( points );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tPath.prototype = PathPrototype;\n\t\tPathPrototype.constructor = Path;\n\t\n\t\n\t\t// minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n\t\tfunction ShapePath() {\n\t\t\tthis.subPaths = [];\n\t\t\tthis.currentPath = null;\n\t\t}\n\t\n\t\tShapePath.prototype = {\n\t\t\tmoveTo: function ( x, y ) {\n\t\t\t\tthis.currentPath = new Path();\n\t\t\t\tthis.subPaths.push(this.currentPath);\n\t\t\t\tthis.currentPath.moveTo( x, y );\n\t\t\t},\n\t\t\tlineTo: function ( x, y ) {\n\t\t\t\tthis.currentPath.lineTo( x, y );\n\t\t\t},\n\t\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\t\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\t\t\t},\n\t\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\t\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\t\t\t},\n\t\t\tsplineThru: function ( pts ) {\n\t\t\t\tthis.currentPath.splineThru( pts );\n\t\t\t},\n\t\n\t\t\ttoShapes: function ( isCCW, noHoles ) {\n\t\n\t\t\t\tfunction toShapesNoHoles( inSubpaths ) {\n\t\n\t\t\t\t\tvar shapes = [];\n\t\n\t\t\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\t\n\t\t\t\t\t\tvar tmpShape = new Shape();\n\t\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\n\t\t\t\t\t\tshapes.push( tmpShape );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn shapes;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\t\n\t\t\t\t\tvar polyLen = inPolygon.length;\n\t\n\t\t\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\t\t\tvar inside = false;\n\t\t\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\t\n\t\t\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\n\t\t\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\t\n\t\t\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\t\n\t\t\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\t// not parallel\n\t\t\t\t\t\t\tif ( edgeDy < 0 ) {\n\t\n\t\t\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\t\n\t\t\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\t\n\t\t\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t\t\t// continue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn\tinside;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar isClockWise = ShapeUtils.isClockWise;\n\t\n\t\t\t\tvar subPaths = this.subPaths;\n\t\t\t\tif ( subPaths.length === 0 ) return [];\n\t\n\t\t\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\t\n\t\n\t\t\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\t\n\t\t\t\tif ( subPaths.length === 1 ) {\n\t\n\t\t\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\t\t\ttmpShape = new Shape();\n\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\t\tshapes.push( tmpShape );\n\t\t\t\t\treturn shapes;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\t\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\t\n\t\t\t\t// console.log(\"Holes first\", holesFirst);\n\t\n\t\t\t\tvar betterShapeHoles = [];\n\t\t\t\tvar newShapes = [];\n\t\t\t\tvar newShapeHoles = [];\n\t\t\t\tvar mainIdx = 0;\n\t\t\t\tvar tmpPoints;\n\t\n\t\t\t\tnewShapes[ mainIdx ] = undefined;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\t\n\t\t\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\t\n\t\t\t\t\ttmpPath = subPaths[ i ];\n\t\t\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\t\t\tsolid = isCCW ? ! solid : solid;\n\t\n\t\t\t\t\tif ( solid ) {\n\t\n\t\t\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\t\n\t\t\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\t\n\t\t\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\t\n\t\t\t\t\t\t//console.log('cw', i);\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\t\n\t\t\t\t\t\t//console.log('ccw', i);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\t\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\t\n\t\n\t\t\t\tif ( newShapes.length > 1 ) {\n\t\n\t\t\t\t\tvar ambiguous = false;\n\t\t\t\t\tvar toChange = [];\n\t\n\t\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\t\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\t\n\t\t\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\t\n\t\t\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\t\n\t\t\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\t\t\tvar hole_unassigned = true;\n\t\n\t\t\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\t\n\t\t\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\t\n\t\t\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\t\n\t\t\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\t\n\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\tambiguous = true;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\t\n\t\t\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\t\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\t\t\tif ( toChange.length > 0 ) {\n\t\n\t\t\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar tmpHoles;\n\t\n\t\t\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\t\n\t\t\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\t\t\tshapes.push( tmpShape );\n\t\t\t\t\ttmpHoles = newShapeHoles[ i ];\n\t\n\t\t\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//console.log(\"shape\", shapes);\n\t\n\t\t\t\treturn shapes;\n\t\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Font( data ) {\n\t\n\t\t\tthis.data = data;\n\t\n\t\t}\n\t\n\t\tObject.assign( Font.prototype, {\n\t\n\t\t\tisFont: true,\n\t\n\t\t\tgenerateShapes: function ( text, size, divisions ) {\n\t\n\t\t\t\tfunction createPaths( text ) {\n\t\n\t\t\t\t\tvar chars = String( text ).split( '' );\n\t\t\t\t\tvar scale = size / data.resolution;\n\t\t\t\t\tvar offset = 0;\n\t\n\t\t\t\t\tvar paths = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\n\t\t\t\t\t\toffset += ret.offset;\n\t\n\t\t\t\t\t\tpaths.push( ret.path );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn paths;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction createPath( c, scale, offset ) {\n\t\n\t\t\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\t\n\t\t\t\t\tif ( ! glyph ) return;\n\t\n\t\t\t\t\tvar path = new ShapePath();\n\t\n\t\t\t\t\tvar pts = [], b2 = ShapeUtils.b2, b3 = ShapeUtils.b3;\n\t\t\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\t\n\t\t\t\t\tif ( glyph.o ) {\n\t\n\t\t\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\t\n\t\t\t\t\t\t\tvar action = outline[ i ++ ];\n\t\n\t\t\t\t\t\t\tswitch ( action ) {\n\t\n\t\t\t\t\t\t\t\tcase 'm': // moveTo\n\t\n\t\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\t\tpath.moveTo( x, y );\n\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\tcase 'l': // lineTo\n\t\n\t\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\t\tpath.lineTo( x, y );\n\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\t\n\t\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\t\n\t\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\t\n\t\t\t\t\t\t\t\t\tif ( laste ) {\n\t\n\t\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\t\n\t\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\n\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\t\n\t\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\t\n\t\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\t\n\t\t\t\t\t\t\t\t\tif ( laste ) {\n\t\n\t\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\t\n\t\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\n\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn { offset: glyph.ha * scale, path: path };\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( size === undefined ) size = 100;\n\t\t\t\tif ( divisions === undefined ) divisions = 4;\n\t\n\t\t\t\tvar data = this.data;\n\t\n\t\t\t\tvar paths = createPaths( text );\n\t\t\t\tvar shapes = [];\n\t\n\t\t\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\t\n\t\t\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn shapes;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction FontLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( FontLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tvar json;\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\tjson = JSON.parse( text );\n\t\n\t\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar font = scope.parse( json );\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( font );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json ) {\n\t\n\t\t\t\treturn new Font( json );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar context;\n\t\n\t\tfunction getAudioContext() {\n\t\n\t\t\tif ( context === undefined ) {\n\t\n\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\t\n\t\t\t}\n\t\n\t\t\treturn context;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t\t */\n\t\n\t\tfunction AudioLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( AudioLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\t\tvar context = getAudioContext();\n\t\n\t\t\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\t\n\t\t\t\t\t\tonLoad( audioBuffer );\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction StereoCamera() {\n\t\n\t\t\tthis.type = 'StereoCamera';\n\t\n\t\t\tthis.aspect = 1;\n\t\n\t\t\tthis.eyeSep = 0.064;\n\t\n\t\t\tthis.cameraL = new PerspectiveCamera();\n\t\t\tthis.cameraL.layers.enable( 1 );\n\t\t\tthis.cameraL.matrixAutoUpdate = false;\n\t\n\t\t\tthis.cameraR = new PerspectiveCamera();\n\t\t\tthis.cameraR.layers.enable( 2 );\n\t\t\tthis.cameraR.matrixAutoUpdate = false;\n\t\n\t\t}\n\t\n\t\tObject.assign( StereoCamera.prototype, {\n\t\n\t\t\tupdate: ( function () {\n\t\n\t\t\t\tvar instance, focus, fov, aspect, near, far, zoom;\n\t\n\t\t\t\tvar eyeRight = new Matrix4();\n\t\t\t\tvar eyeLeft = new Matrix4();\n\t\n\t\t\t\treturn function update( camera ) {\n\t\n\t\t\t\t\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far || zoom !== camera.zoom;\n\t\n\t\t\t\t\tif ( needsUpdate ) {\n\t\n\t\t\t\t\t\tinstance = this;\n\t\t\t\t\t\tfocus = camera.focus;\n\t\t\t\t\t\tfov = camera.fov;\n\t\t\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\t\t\tnear = camera.near;\n\t\t\t\t\t\tfar = camera.far;\n\t\t\t\t\t\tzoom = camera.zoom;\n\t\n\t\t\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\t\n\t\t\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\t\t\tvar eyeSep = this.eyeSep / 2;\n\t\t\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\t\t\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\n\t\t\t\t\t\tvar xmin, xmax;\n\t\n\t\t\t\t\t\t// translate xOffset\n\t\n\t\t\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\t\n\t\t\t\t\t\t// for left eye\n\t\n\t\t\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\t\n\t\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\t\n\t\t\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\t\n\t\t\t\t\t\t// for right eye\n\t\n\t\t\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\t\n\t\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\t\n\t\t\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * Camera for rendering cube maps\n\t\t *\t- renders scene into axis-aligned cube\n\t\t *\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction CubeCamera( near, far, cubeResolution ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'CubeCamera';\n\t\n\t\t\tvar fov = 90, aspect = 1;\n\t\n\t\t\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\t\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\n\t\t\tthis.add( cameraPX );\n\t\n\t\t\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\t\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\n\t\t\tthis.add( cameraNX );\n\t\n\t\t\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraPY.up.set( 0, 0, 1 );\n\t\t\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\n\t\t\tthis.add( cameraPY );\n\t\n\t\t\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\t\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\n\t\t\tthis.add( cameraNY );\n\t\n\t\t\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\t\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\n\t\t\tthis.add( cameraPZ );\n\t\n\t\t\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\t\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\n\t\t\tthis.add( cameraNZ );\n\t\n\t\t\tvar options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\n\t\n\t\t\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\t\n\t\t\tthis.updateCubeMap = function ( renderer, scene ) {\n\t\n\t\t\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\t\n\t\t\t\tvar renderTarget = this.renderTarget;\n\t\t\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\t\n\t\t\t\trenderTarget.texture.generateMipmaps = false;\n\t\n\t\t\t\trenderTarget.activeCubeFace = 0;\n\t\t\t\trenderer.render( scene, cameraPX, renderTarget );\n\t\n\t\t\t\trenderTarget.activeCubeFace = 1;\n\t\t\t\trenderer.render( scene, cameraNX, renderTarget );\n\t\n\t\t\t\trenderTarget.activeCubeFace = 2;\n\t\t\t\trenderer.render( scene, cameraPY, renderTarget );\n\t\n\t\t\t\trenderTarget.activeCubeFace = 3;\n\t\t\t\trenderer.render( scene, cameraNY, renderTarget );\n\t\n\t\t\t\trenderTarget.activeCubeFace = 4;\n\t\t\t\trenderer.render( scene, cameraPZ, renderTarget );\n\t\n\t\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\t\n\t\t\t\trenderTarget.activeCubeFace = 5;\n\t\t\t\trenderer.render( scene, cameraNZ, renderTarget );\n\t\n\t\t\t\trenderer.setRenderTarget( null );\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tCubeCamera.prototype = Object.create( Object3D.prototype );\n\t\tCubeCamera.prototype.constructor = CubeCamera;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction AudioListener() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'AudioListener';\n\t\n\t\t\tthis.context = getAudioContext();\n\t\n\t\t\tthis.gain = this.context.createGain();\n\t\t\tthis.gain.connect( this.context.destination );\n\t\n\t\t\tthis.filter = null;\n\t\n\t\t}\n\t\n\t\tAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: AudioListener,\n\t\n\t\t\tgetInput: function () {\n\t\n\t\t\t\treturn this.gain;\n\t\n\t\t\t},\n\t\n\t\t\tremoveFilter: function ( ) {\n\t\n\t\t\t\tif ( this.filter !== null ) {\n\t\n\t\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\t\t\tthis.gain.connect( this.context.destination );\n\t\t\t\t\tthis.filter = null;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tgetFilter: function () {\n\t\n\t\t\t\treturn this.filter;\n\t\n\t\t\t},\n\t\n\t\t\tsetFilter: function ( value ) {\n\t\n\t\t\t\tif ( this.filter !== null ) {\n\t\n\t\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.gain.disconnect( this.context.destination );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.filter = value;\n\t\t\t\tthis.gain.connect( this.filter );\n\t\t\t\tthis.filter.connect( this.context.destination );\n\t\n\t\t\t},\n\t\n\t\t\tgetMasterVolume: function () {\n\t\n\t\t\t\treturn this.gain.gain.value;\n\t\n\t\t\t},\n\t\n\t\t\tsetMasterVolume: function ( value ) {\n\t\n\t\t\t\tthis.gain.gain.value = value;\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrixWorld: ( function () {\n\t\n\t\t\t\tvar position = new Vector3();\n\t\t\t\tvar quaternion = new Quaternion();\n\t\t\t\tvar scale = new Vector3();\n\t\n\t\t\t\tvar orientation = new Vector3();\n\t\n\t\t\t\treturn function updateMatrixWorld( force ) {\n\t\n\t\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\t\t\tvar listener = this.context.listener;\n\t\t\t\t\tvar up = this.up;\n\t\n\t\t\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\t\n\t\t\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\t\n\t\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t\t */\n\t\n\t\tfunction Audio( listener ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Audio';\n\t\n\t\t\tthis.context = listener.context;\n\t\t\tthis.source = this.context.createBufferSource();\n\t\t\tthis.source.onended = this.onEnded.bind( this );\n\t\n\t\t\tthis.gain = this.context.createGain();\n\t\t\tthis.gain.connect( listener.getInput() );\n\t\n\t\t\tthis.autoplay = false;\n\t\n\t\t\tthis.startTime = 0;\n\t\t\tthis.playbackRate = 1;\n\t\t\tthis.isPlaying = false;\n\t\t\tthis.hasPlaybackControl = true;\n\t\t\tthis.sourceType = 'empty';\n\t\n\t\t\tthis.filters = [];\n\t\n\t\t}\n\t\n\t\tAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Audio,\n\t\n\t\t\tgetOutput: function () {\n\t\n\t\t\t\treturn this.gain;\n\t\n\t\t\t},\n\t\n\t\t\tsetNodeSource: function ( audioNode ) {\n\t\n\t\t\t\tthis.hasPlaybackControl = false;\n\t\t\t\tthis.sourceType = 'audioNode';\n\t\t\t\tthis.source = audioNode;\n\t\t\t\tthis.connect();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetBuffer: function ( audioBuffer ) {\n\t\n\t\t\t\tthis.source.buffer = audioBuffer;\n\t\t\t\tthis.sourceType = 'buffer';\n\t\n\t\t\t\tif ( this.autoplay ) this.play();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tplay: function () {\n\t\n\t\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar source = this.context.createBufferSource();\n\t\n\t\t\t\tsource.buffer = this.source.buffer;\n\t\t\t\tsource.loop = this.source.loop;\n\t\t\t\tsource.onended = this.source.onended;\n\t\t\t\tsource.start( 0, this.startTime );\n\t\t\t\tsource.playbackRate.value = this.playbackRate;\n\t\n\t\t\t\tthis.isPlaying = true;\n\t\n\t\t\t\tthis.source = source;\n\t\n\t\t\t\treturn this.connect();\n\t\n\t\t\t},\n\t\n\t\t\tpause: function () {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.source.stop();\n\t\t\t\tthis.startTime = this.context.currentTime;\n\t\t\t\tthis.isPlaying = false;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tstop: function () {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.source.stop();\n\t\t\t\tthis.startTime = 0;\n\t\t\t\tthis.isPlaying = false;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tconnect: function () {\n\t\n\t\t\t\tif ( this.filters.length > 0 ) {\n\t\n\t\t\t\t\tthis.source.connect( this.filters[ 0 ] );\n\t\n\t\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.source.connect( this.getOutput() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdisconnect: function () {\n\t\n\t\t\t\tif ( this.filters.length > 0 ) {\n\t\n\t\t\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\t\n\t\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.source.disconnect( this.getOutput() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetFilters: function () {\n\t\n\t\t\t\treturn this.filters;\n\t\n\t\t\t},\n\t\n\t\t\tsetFilters: function ( value ) {\n\t\n\t\t\t\tif ( ! value ) value = [];\n\t\n\t\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\t\tthis.disconnect();\n\t\t\t\t\tthis.filters = value;\n\t\t\t\t\tthis.connect();\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.filters = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetFilter: function () {\n\t\n\t\t\t\treturn this.getFilters()[ 0 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetFilter: function ( filter ) {\n\t\n\t\t\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\t\n\t\t\t},\n\t\n\t\t\tsetPlaybackRate: function ( value ) {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.playbackRate = value;\n\t\n\t\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\t\tthis.source.playbackRate.value = this.playbackRate;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetPlaybackRate: function () {\n\t\n\t\t\t\treturn this.playbackRate;\n\t\n\t\t\t},\n\t\n\t\t\tonEnded: function () {\n\t\n\t\t\t\tthis.isPlaying = false;\n\t\n\t\t\t},\n\t\n\t\t\tgetLoop: function () {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.source.loop;\n\t\n\t\t\t},\n\t\n\t\t\tsetLoop: function ( value ) {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.source.loop = value;\n\t\n\t\t\t},\n\t\n\t\t\tgetVolume: function () {\n\t\n\t\t\t\treturn this.gain.gain.value;\n\t\n\t\t\t},\n\t\n\t\n\t\t\tsetVolume: function ( value ) {\n\t\n\t\t\t\tthis.gain.gain.value = value;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction PositionalAudio( listener ) {\n\t\n\t\t\tAudio.call( this, listener );\n\t\n\t\t\tthis.panner = this.context.createPanner();\n\t\t\tthis.panner.connect( this.gain );\n\t\n\t\t}\n\t\n\t\tPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\n\t\n\t\t\tconstructor: PositionalAudio,\n\t\n\t\t\tgetOutput: function () {\n\t\n\t\t\t\treturn this.panner;\n\t\n\t\t\t},\n\t\n\t\t\tgetRefDistance: function () {\n\t\n\t\t\t\treturn this.panner.refDistance;\n\t\n\t\t\t},\n\t\n\t\t\tsetRefDistance: function ( value ) {\n\t\n\t\t\t\tthis.panner.refDistance = value;\n\t\n\t\t\t},\n\t\n\t\t\tgetRolloffFactor: function () {\n\t\n\t\t\t\treturn this.panner.rolloffFactor;\n\t\n\t\t\t},\n\t\n\t\t\tsetRolloffFactor: function ( value ) {\n\t\n\t\t\t\tthis.panner.rolloffFactor = value;\n\t\n\t\t\t},\n\t\n\t\t\tgetDistanceModel: function () {\n\t\n\t\t\t\treturn this.panner.distanceModel;\n\t\n\t\t\t},\n\t\n\t\t\tsetDistanceModel: function ( value ) {\n\t\n\t\t\t\tthis.panner.distanceModel = value;\n\t\n\t\t\t},\n\t\n\t\t\tgetMaxDistance: function () {\n\t\n\t\t\t\treturn this.panner.maxDistance;\n\t\n\t\t\t},\n\t\n\t\t\tsetMaxDistance: function ( value ) {\n\t\n\t\t\t\tthis.panner.maxDistance = value;\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrixWorld: ( function () {\n\t\n\t\t\t\tvar position = new Vector3();\n\t\n\t\t\t\treturn function updateMatrixWorld( force ) {\n\t\n\t\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction AudioAnalyser( audio, fftSize ) {\n\t\n\t\t\tthis.analyser = audio.context.createAnalyser();\n\t\t\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\t\n\t\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\t\n\t\t\taudio.getOutput().connect( this.analyser );\n\t\n\t\t}\n\t\n\t\tObject.assign( AudioAnalyser.prototype, {\n\t\n\t\t\tgetFrequencyData: function () {\n\t\n\t\t\t\tthis.analyser.getByteFrequencyData( this.data );\n\t\n\t\t\t\treturn this.data;\n\t\n\t\t\t},\n\t\n\t\t\tgetAverageFrequency: function () {\n\t\n\t\t\t\tvar value = 0, data = this.getFrequencyData();\n\t\n\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\t\n\t\t\t\t\tvalue += data[ i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn value / data.length;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * Buffered scene graph property that allows weighted accumulation.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction PropertyMixer( binding, typeName, valueSize ) {\n\t\n\t\t\tthis.binding = binding;\n\t\t\tthis.valueSize = valueSize;\n\t\n\t\t\tvar bufferType = Float64Array,\n\t\t\t\tmixFunction;\n\t\n\t\t\tswitch ( typeName ) {\n\t\n\t\t\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\n\t\n\t\t\t\tcase 'string':\n\t\t\t\tcase 'bool':\n\t\n\t\t\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\n\t\n\t\t\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\n\t\n\t\t\t}\n\t\n\t\t\tthis.buffer = new bufferType( valueSize * 4 );\n\t\t\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t\t\t//\n\t\t\t// interpolators can use .buffer as their .result\n\t\t\t// the data then goes to 'incoming'\n\t\t\t//\n\t\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t\t// the cumulative result and are compared to detect\n\t\t\t// changes\n\t\t\t//\n\t\t\t// 'orig' stores the original state of the property\n\t\n\t\t\tthis._mixBufferRegion = mixFunction;\n\t\n\t\t\tthis.cumulativeWeight = 0;\n\t\n\t\t\tthis.useCount = 0;\n\t\t\tthis.referenceCount = 0;\n\t\n\t\t}\n\t\n\t\tPropertyMixer.prototype = {\n\t\n\t\t\tconstructor: PropertyMixer,\n\t\n\t\t\t// accumulate data in the 'incoming' region into 'accu<i>'\n\t\t\taccumulate: function( accuIndex, weight ) {\n\t\n\t\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t\t\t// the weight and shouldn't have made the call in the first place\n\t\n\t\t\t\tvar buffer = this.buffer,\n\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\toffset = accuIndex * stride + stride,\n\t\n\t\t\t\t\tcurrentWeight = this.cumulativeWeight;\n\t\n\t\t\t\tif ( currentWeight === 0 ) {\n\t\n\t\t\t\t\t// accuN := incoming * weight\n\t\n\t\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcurrentWeight = weight;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// accuN := accuN + incoming * weight\n\t\n\t\t\t\t\tcurrentWeight += weight;\n\t\t\t\t\tvar mix = weight / currentWeight;\n\t\t\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cumulativeWeight = currentWeight;\n\t\n\t\t\t},\n\t\n\t\t\t// apply the state of 'accu<i>' to the binding when accus differ\n\t\t\tapply: function( accuIndex ) {\n\t\n\t\t\t\tvar stride = this.valueSize,\n\t\t\t\t\tbuffer = this.buffer,\n\t\t\t\t\toffset = accuIndex * stride + stride,\n\t\n\t\t\t\t\tweight = this.cumulativeWeight,\n\t\n\t\t\t\t\tbinding = this.binding;\n\t\n\t\t\t\tthis.cumulativeWeight = 0;\n\t\n\t\t\t\tif ( weight < 1 ) {\n\t\n\t\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\t\n\t\t\t\t\tvar originalValueOffset = stride * 3;\n\t\n\t\t\t\t\tthis._mixBufferRegion(\n\t\t\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\t\n\t\t\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\t\n\t\t\t\t\t\t// value has changed -> update scene graph\n\t\n\t\t\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// remember the state of the bound property and copy it to both accus\n\t\t\tsaveOriginalState: function() {\n\t\n\t\t\t\tvar binding = this.binding;\n\t\n\t\t\t\tvar buffer = this.buffer,\n\t\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\t\toriginalValueOffset = stride * 3;\n\t\n\t\t\t\tbinding.getValue( buffer, originalValueOffset );\n\t\n\t\t\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\t\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\t\n\t\t\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cumulativeWeight = 0;\n\t\n\t\t\t},\n\t\n\t\t\t// apply the state previously taken via 'saveOriginalState' to the binding\n\t\t\trestoreOriginalState: function() {\n\t\n\t\t\t\tvar originalValueOffset = this.valueSize * 3;\n\t\t\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\t\n\t\t\t},\n\t\n\t\n\t\t\t// mix functions\n\t\n\t\t\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\t\tif ( t >= 0.5 ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\t\tQuaternion.slerpFlat( buffer, dstOffset,\n\t\t\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\n\t\n\t\t\t},\n\t\n\t\t\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\t\tvar s = 1 - t;\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tvar j = dstOffset + i;\n\t\n\t\t\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t *\n\t\t * A reference to a real property in the scene graph.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction PropertyBinding( rootNode, path, parsedPath ) {\n\t\n\t\t\tthis.path = path;\n\t\t\tthis.parsedPath = parsedPath ||\n\t\t\t\t\tPropertyBinding.parseTrackName( path );\n\t\n\t\t\tthis.node = PropertyBinding.findNode(\n\t\t\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\n\t\n\t\t\tthis.rootNode = rootNode;\n\t\n\t\t}\n\t\n\t\tPropertyBinding.prototype = {\n\t\n\t\t\tconstructor: PropertyBinding,\n\t\n\t\t\tgetValue: function getValue_unbound( targetArray, offset ) {\n\t\n\t\t\t\tthis.bind();\n\t\t\t\tthis.getValue( targetArray, offset );\n\t\n\t\t\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t\t\t// prototype version of these methods with one that represents\n\t\t\t\t// the bound state. When the property is not found, the methods\n\t\t\t\t// become no-ops.\n\t\n\t\t\t},\n\t\n\t\t\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\t\n\t\t\t\tthis.bind();\n\t\t\t\tthis.setValue( sourceArray, offset );\n\t\n\t\t\t},\n\t\n\t\t\t// create getter / setter pair for a property in the scene graph\n\t\t\tbind: function() {\n\t\n\t\t\t\tvar targetObject = this.node,\n\t\t\t\t\tparsedPath = this.parsedPath,\n\t\n\t\t\t\t\tobjectName = parsedPath.objectName,\n\t\t\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\t\n\t\t\t\tif ( ! targetObject ) {\n\t\n\t\t\t\t\ttargetObject = PropertyBinding.findNode(\n\t\t\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\n\t\n\t\t\t\t\tthis.node = targetObject;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// set fail state so we can just 'return' on error\n\t\t\t\tthis.getValue = this._getValue_unavailable;\n\t\t\t\tthis.setValue = this._setValue_unavailable;\n\t\n\t\t \t\t// ensure there is a value node\n\t\t\t\tif ( ! targetObject ) {\n\t\n\t\t\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( objectName ) {\n\t\n\t\t\t\t\tvar objectIndex = parsedPath.objectIndex;\n\t\n\t\t\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\t\t\tswitch ( objectName ) {\n\t\n\t\t\t\t\t\tcase 'materials':\n\t\n\t\t\t\t\t\t\tif ( ! targetObject.material ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\ttargetObject = targetObject.material.materials;\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'bones':\n\t\n\t\t\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t\t\t// and convert the integer string to a true integer.\n\t\n\t\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\t\n\t\t\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\t\n\t\t\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\t\n\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\tif ( objectIndex !== undefined ) {\n\t\n\t\t\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// resolve property\n\t\t\t\tvar nodeProperty = targetObject[ propertyName ];\n\t\n\t\t\t\tif ( nodeProperty === undefined ) {\n\t\n\t\t\t\t\tvar nodeName = parsedPath.nodeName;\n\t\n\t\t\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\n\t\t\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// determine versioning scheme\n\t\t\t\tvar versioning = this.Versioning.None;\n\t\n\t\t\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\t\n\t\t\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\t\t\tthis.targetObject = targetObject;\n\t\n\t\t\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\t\n\t\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\t\t\tthis.targetObject = targetObject;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// determine how the property gets bound\n\t\t\t\tvar bindingType = this.BindingType.Direct;\n\t\n\t\t\t\tif ( propertyIndex !== undefined ) {\n\t\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\t\n\t\t\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\t\n\t\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\t\tif ( ! targetObject.geometry ) {\n\t\n\t\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\t\n\t\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\t\n\t\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbindingType = this.BindingType.ArrayElement;\n\t\n\t\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t\t\tthis.propertyIndex = propertyIndex;\n\t\n\t\t\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\t\t\t\t// must use copy for Object3D.Euler/Quaternion\n\t\n\t\t\t\t\tbindingType = this.BindingType.HasFromToArray;\n\t\n\t\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\n\t\t\t\t} else if ( nodeProperty.length !== undefined ) {\n\t\n\t\t\t\t\tbindingType = this.BindingType.EntireArray;\n\t\n\t\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.propertyName = propertyName;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// select getter / setter\n\t\t\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\t\n\t\t\t},\n\t\n\t\t\tunbind: function() {\n\t\n\t\t\t\tthis.node = null;\n\t\n\t\t\t\t// back to the prototype version of getValue / setValue\n\t\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\t\tthis.setValue = this._setValue_unbound;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tObject.assign( PropertyBinding.prototype, { // prototype, continued\n\t\n\t\t\t// these are used to \"bind\" a nonexistent property\n\t\t\t_getValue_unavailable: function() {},\n\t\t\t_setValue_unavailable: function() {},\n\t\n\t\t\t// initial state of these methods that calls 'bind'\n\t\t\t_getValue_unbound: PropertyBinding.prototype.getValue,\n\t\t\t_setValue_unbound: PropertyBinding.prototype.setValue,\n\t\n\t\t\tBindingType: {\n\t\t\t\tDirect: 0,\n\t\t\t\tEntireArray: 1,\n\t\t\t\tArrayElement: 2,\n\t\t\t\tHasFromToArray: 3\n\t\t\t},\n\t\n\t\t\tVersioning: {\n\t\t\t\tNone: 0,\n\t\t\t\tNeedsUpdate: 1,\n\t\t\t\tMatrixWorldNeedsUpdate: 2\n\t\t\t},\n\t\n\t\t\tGetterByBindingType: [\n\t\n\t\t\t\tfunction getValue_direct( buffer, offset ) {\n\t\n\t\t\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction getValue_array( buffer, offset ) {\n\t\n\t\t\t\t\tvar source = this.resolvedProperty;\n\t\n\t\t\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction getValue_arrayElement( buffer, offset ) {\n\t\n\t\t\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction getValue_toArray( buffer, offset ) {\n\t\n\t\t\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\t\n\t\t\t\t}\n\t\n\t\t\t],\n\t\n\t\t\tSetterByBindingTypeAndVersioning: [\n\t\n\t\t\t\t[\n\t\t\t\t\t// Direct\n\t\n\t\t\t\t\tfunction setValue_direct( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t], [\n\t\n\t\t\t\t\t// EntireArray\n\t\n\t\t\t\t\tfunction setValue_array( buffer, offset ) {\n\t\n\t\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t], [\n\t\n\t\t\t\t\t// ArrayElement\n\t\n\t\t\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t], [\n\t\n\t\t\t\t\t// HasToFromArray\n\t\n\t\t\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t]\n\t\n\t\t\t]\n\t\n\t\t} );\n\t\n\t\tPropertyBinding.Composite =\n\t\t\t\tfunction( targetGroup, path, optionalParsedPath ) {\n\t\n\t\t\tvar parsedPath = optionalParsedPath ||\n\t\t\t\t\tPropertyBinding.parseTrackName( path );\n\t\n\t\t\tthis._targetGroup = targetGroup;\n\t\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\t\n\t\t};\n\t\n\t\tPropertyBinding.Composite.prototype = {\n\t\n\t\t\tconstructor: PropertyBinding.Composite,\n\t\n\t\t\tgetValue: function( array, offset ) {\n\t\n\t\t\t\tthis.bind(); // bind all binding\n\t\n\t\t\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tbinding = this._bindings[ firstValidIndex ];\n\t\n\t\t\t\t// and only call .getValue on the first\n\t\t\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\t\n\t\t\t},\n\t\n\t\t\tsetValue: function( array, offset ) {\n\t\n\t\t\t\tvar bindings = this._bindings;\n\t\n\t\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].setValue( array, offset );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tbind: function() {\n\t\n\t\t\t\tvar bindings = this._bindings;\n\t\n\t\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].bind();\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tunbind: function() {\n\t\n\t\t\t\tvar bindings = this._bindings;\n\t\n\t\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].unbind();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tPropertyBinding.create = function( root, path, parsedPath ) {\n\t\n\t\t\tif ( ! ( (root && root.isAnimationObjectGroup) ) ) {\n\t\n\t\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tPropertyBinding.parseTrackName = function( trackName ) {\n\t\n\t\t\t// matches strings in the form of:\n\t\t\t//    nodeName.property\n\t\t\t//    nodeName.property[accessor]\n\t\t\t//    nodeName.material.property[accessor]\n\t\t\t//    uuid.property[accessor]\n\t\t\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t\t\t//    parentName/nodeName.property\n\t\t\t//    parentName/parentName/nodeName.property[index]\n\t\t\t//    .bone[Armature.DEF_cog].position\n\t\t\t//    scene:helium_balloon_model:helium_balloon_model.position\n\t\t\t// created and tested via https://regex101.com/#javascript\n\t\n\t\t\tvar re = /^((?:\\w+[\\/:])*)(\\w+)?(?:\\.(\\w+)(?:\\[(.+)\\])?)?\\.(\\w+)(?:\\[(.+)\\])?$/;\n\t\t\tvar matches = re.exec( trackName );\n\t\n\t\t\tif ( ! matches ) {\n\t\n\t\t\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\n\t\n\t\t\t}\n\t\n\t\t\tvar results = {\n\t\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\t\tnodeName: matches[ 2 ], \t// allowed to be null, specified root node.\n\t\t\t\tobjectName: matches[ 3 ],\n\t\t\t\tobjectIndex: matches[ 4 ],\n\t\t\t\tpropertyName: matches[ 5 ],\n\t\t\t\tpropertyIndex: matches[ 6 ]\t// allowed to be null, specifies that the whole property is set.\n\t\t\t};\n\t\n\t\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\t\n\t\t\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\n\t\n\t\t\t}\n\t\n\t\t\treturn results;\n\t\n\t\t};\n\t\n\t\tPropertyBinding.findNode = function( root, nodeName ) {\n\t\n\t\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\n\t\n\t\t\t\treturn root;\n\t\n\t\t\t}\n\t\n\t\t\t// search into skeleton bones.\n\t\t\tif ( root.skeleton ) {\n\t\n\t\t\t\tvar searchSkeleton = function( skeleton ) {\n\t\n\t\t\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar bone = skeleton.bones[ i ];\n\t\n\t\t\t\t\t\tif ( bone.name === nodeName ) {\n\t\n\t\t\t\t\t\t\treturn bone;\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t};\n\t\n\t\t\t\tvar bone = searchSkeleton( root.skeleton );\n\t\n\t\t\t\tif ( bone ) {\n\t\n\t\t\t\t\treturn bone;\n\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// search into node subtree.\n\t\t\tif ( root.children ) {\n\t\n\t\t\t\tvar searchNodeSubtree = function( children ) {\n\t\n\t\t\t\t\tfor( var i = 0; i < children.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar childNode = children[ i ];\n\t\n\t\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\t\n\t\t\t\t\t\t\treturn childNode;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\t\n\t\t\t\t\t\tif ( result ) return result;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t};\n\t\n\t\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\t\n\t\t\t\tif ( subTreeNode ) {\n\t\n\t\t\t\t\treturn subTreeNode;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t *\n\t\t * A group of objects that receives a shared animation state.\n\t\t *\n\t\t * Usage:\n\t\t *\n\t\t * \t-\tAdd objects you would otherwise pass as 'root' to the\n\t\t * \t\tconstructor or the .clipAction method of AnimationMixer.\n\t\t *\n\t\t * \t-\tInstead pass this object as 'root'.\n\t\t *\n\t\t * \t-\tYou can also add and remove objects later when the mixer\n\t\t * \t\tis running.\n\t\t *\n\t\t * Note:\n\t\t *\n\t\t *  \tObjects of this class appear as one object to the mixer,\n\t\t *  \tso cache control of the individual objects must be done\n\t\t *  \ton the group.\n\t\t *\n\t\t * Limitation:\n\t\t *\n\t\t * \t- \tThe animated properties must be compatible among the\n\t\t * \t\tall objects in the group.\n\t\t *\n\t\t *  -\tA single property can either be controlled through a\n\t\t *  \ttarget group or directly, but not both.\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction AnimationObjectGroup( var_args ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\t// cached objects followed by the active ones\n\t\t\tthis._objects = Array.prototype.slice.call( arguments );\n\t\n\t\t\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t\t\t// note: read by PropertyBinding.Composite\n\t\n\t\t\tvar indices = {};\n\t\t\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\t\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\tindices[ arguments[ i ].uuid ] = i;\n\t\n\t\t\t}\n\t\n\t\t\tthis._paths = [];\t\t\t\t\t// inside: string\n\t\t\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\t\t\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\t\t\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tthis.stats = {\n\t\n\t\t\t\tobjects: {\n\t\t\t\t\tget total() { return scope._objects.length; },\n\t\t\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\n\t\t\t\t},\n\t\n\t\t\t\tget bindingsPerObject() { return scope._bindings.length; }\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tAnimationObjectGroup.prototype = {\n\t\n\t\t\tconstructor: AnimationObjectGroup,\n\t\n\t\t\tisAnimationObjectGroup: true,\n\t\n\t\t\tadd: function( var_args ) {\n\t\n\t\t\t\tvar objects = this._objects,\n\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\tpaths = this._paths,\n\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\t\tif ( index === undefined ) {\n\t\n\t\t\t\t\t\t// unknown object -> add it to the ACTIVE region\n\t\n\t\t\t\t\t\tindex = nObjects ++;\n\t\t\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\t\t\tobjects.push( object );\n\t\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\tbindings[ j ].push(\n\t\t\t\t\t\t\t\t\tnew PropertyBinding(\n\t\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( index < nCachedObjects ) {\n\t\n\t\t\t\t\t\tvar knownObject = objects[ index ];\n\t\n\t\t\t\t\t\t// move existing object to the ACTIVE region\n\t\n\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\t\n\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\t\n\t\t\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\t\t\tobjects[ firstActiveIndex ] = object;\n\t\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\t\n\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\n\t\t\t\t\t\t\tif ( binding === undefined ) {\n\t\n\t\t\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t\t\t// or may not exist\n\t\n\t\t\t\t\t\t\t\tbinding = new PropertyBinding(\n\t\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( objects[ index ] !== knownObject) {\n\t\n\t\t\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\n\t\t\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\n\t\t\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\n\t\n\t\t\t\t\t} // else the object is already where we want it to be\n\t\n\t\t\t\t} // for arguments\n\t\n\t\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t\t},\n\t\n\t\t\tremove: function( var_args ) {\n\t\n\t\t\t\tvar objects = this._objects,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\t\n\t\t\t\t\t\t// move existing object into the CACHED region\n\t\n\t\t\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\t\n\t\t\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = firstActiveObject;\n\t\n\t\t\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\t\t\tobjects[ lastCachedIndex ] = object;\n\t\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\t\n\t\t\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} // for arguments\n\t\n\t\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t\t},\n\t\n\t\t\t// remove & forget\n\t\t\tuncache: function( var_args ) {\n\t\n\t\t\t\tvar objects = this._objects,\n\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\t\tdelete indicesByUUID[ uuid ];\n\t\n\t\t\t\t\t\tif ( index < nCachedObjects ) {\n\t\n\t\t\t\t\t\t\t// object is cached, shrink the CACHED region\n\t\n\t\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\t\n\t\t\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\t\n\t\t\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\t\t\tobjects.pop();\n\t\n\t\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\t\n\t\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// object is active, just swap with the last and pop\n\t\n\t\t\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\t\n\t\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\t\t\tobjects.pop();\n\t\n\t\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\t\n\t\t\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} // cached or active\n\t\n\t\t\t\t\t} // if object is known\n\t\n\t\t\t\t} // for arguments\n\t\n\t\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t\t},\n\t\n\t\t\t// Internal interface used by befriended PropertyBinding.Composite:\n\t\n\t\t\tsubscribe_: function( path, parsedPath ) {\n\t\t\t\t// returns an array of bindings for the given path that is changed\n\t\t\t\t// according to the contained objects in the group\n\t\n\t\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\t\tindex = indicesByPath[ path ],\n\t\t\t\t\tbindings = this._bindings;\n\t\n\t\t\t\tif ( index !== undefined ) return bindings[ index ];\n\t\n\t\t\t\tvar paths = this._paths,\n\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\tobjects = this._objects,\n\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tbindingsForPath = new Array( nObjects );\n\t\n\t\t\t\tindex = bindings.length;\n\t\n\t\t\t\tindicesByPath[ path ] = index;\n\t\n\t\t\t\tpaths.push( path );\n\t\t\t\tparsedPaths.push( parsedPath );\n\t\t\t\tbindings.push( bindingsForPath );\n\t\n\t\t\t\tfor ( var i = nCachedObjects,\n\t\t\t\t\t\tn = objects.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar object = objects[ i ];\n\t\n\t\t\t\t\tbindingsForPath[ i ] =\n\t\t\t\t\t\t\tnew PropertyBinding( object, path, parsedPath );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn bindingsForPath;\n\t\n\t\t\t},\n\t\n\t\t\tunsubscribe_: function( path ) {\n\t\t\t\t// tells the group to forget about a property path and no longer\n\t\t\t\t// update the array previously obtained with 'subscribe_'\n\t\n\t\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\t\tindex = indicesByPath[ path ];\n\t\n\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\tvar paths = this._paths,\n\t\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\t\n\t\t\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\t\n\t\t\t\t\tbindings[ index ] = lastBindings;\n\t\t\t\t\tbindings.pop();\n\t\n\t\t\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\t\t\tparsedPaths.pop();\n\t\n\t\t\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\t\t\tpaths.pop();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t *\n\t\t * Action provided by AnimationMixer for scheduling clip playback on specific\n\t\t * objects.\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t *\n\t\t */\n\t\n\t\tfunction AnimationAction( mixer, clip, localRoot ) {\n\t\n\t\t\tthis._mixer = mixer;\n\t\t\tthis._clip = clip;\n\t\t\tthis._localRoot = localRoot || null;\n\t\n\t\t\tvar tracks = clip.tracks,\n\t\t\t\tnTracks = tracks.length,\n\t\t\t\tinterpolants = new Array( nTracks );\n\t\n\t\t\tvar interpolantSettings = {\n\t\t\t\t\tendingStart: \tZeroCurvatureEnding,\n\t\t\t\t\tendingEnd:\t\tZeroCurvatureEnding\n\t\t\t};\n\t\n\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\t\n\t\t\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\t\t\tinterpolants[ i ] = interpolant;\n\t\t\t\tinterpolant.settings = interpolantSettings;\n\t\n\t\t\t}\n\t\n\t\t\tthis._interpolantSettings = interpolantSettings;\n\t\n\t\t\tthis._interpolants = interpolants;\t// bound by the mixer\n\t\n\t\t\t// inside: PropertyMixer (managed by the mixer)\n\t\t\tthis._propertyBindings = new Array( nTracks );\n\t\n\t\t\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\t\t\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\t\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._weightInterpolant = null;\n\t\n\t\t\tthis.loop = LoopRepeat;\n\t\t\tthis._loopCount = -1;\n\t\n\t\t\t// global mixer time when the action is to be started\n\t\t\t// it's set back to 'null' upon start of the action\n\t\t\tthis._startTime = null;\n\t\n\t\t\t// scaled local time of the action\n\t\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\t\tthis.time = 0;\n\t\n\t\t\tthis.timeScale = 1;\n\t\t\tthis._effectiveTimeScale = 1;\n\t\n\t\t\tthis.weight = 1;\n\t\t\tthis._effectiveWeight = 1;\n\t\n\t\t\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\t\n\t\t\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\n\t\t\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\n\t\n\t\t\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\t\n\t\t\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\t\t\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\t\n\t\t}\n\t\n\t\tAnimationAction.prototype = {\n\t\n\t\t\tconstructor: AnimationAction,\n\t\n\t\t\t// State & Scheduling\n\t\n\t\t\tplay: function() {\n\t\n\t\t\t\tthis._mixer._activateAction( this );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tstop: function() {\n\t\n\t\t\t\tthis._mixer._deactivateAction( this );\n\t\n\t\t\t\treturn this.reset();\n\t\n\t\t\t},\n\t\n\t\t\treset: function() {\n\t\n\t\t\t\tthis.paused = false;\n\t\t\t\tthis.enabled = true;\n\t\n\t\t\t\tthis.time = 0;\t\t\t// restart clip\n\t\t\t\tthis._loopCount = -1;\t// forget previous loops\n\t\t\t\tthis._startTime = null;\t// forget scheduling\n\t\n\t\t\t\treturn this.stopFading().stopWarping();\n\t\n\t\t\t},\n\t\n\t\t\tisRunning: function() {\n\t\n\t\t\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\t\n\t\t\t},\n\t\n\t\t\t// return true when play has been called\n\t\t\tisScheduled: function() {\n\t\n\t\t\t\treturn this._mixer._isActiveAction( this );\n\t\n\t\t\t},\n\t\n\t\t\tstartAt: function( time ) {\n\t\n\t\t\t\tthis._startTime = time;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetLoop: function( mode, repetitions ) {\n\t\n\t\t\t\tthis.loop = mode;\n\t\t\t\tthis.repetitions = repetitions;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// Weight\n\t\n\t\t\t// set the weight stopping any scheduled fading\n\t\t\t// although .enabled = false yields an effective weight of zero, this\n\t\t\t// method does *not* change .enabled, because it would be confusing\n\t\t\tsetEffectiveWeight: function( weight ) {\n\t\n\t\t\t\tthis.weight = weight;\n\t\n\t\t\t\t// note: same logic as when updated at runtime\n\t\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\t\n\t\t\t\treturn this.stopFading();\n\t\n\t\t\t},\n\t\n\t\t\t// return the weight considering fading and .enabled\n\t\t\tgetEffectiveWeight: function() {\n\t\n\t\t\t\treturn this._effectiveWeight;\n\t\n\t\t\t},\n\t\n\t\t\tfadeIn: function( duration ) {\n\t\n\t\t\t\treturn this._scheduleFading( duration, 0, 1 );\n\t\n\t\t\t},\n\t\n\t\t\tfadeOut: function( duration ) {\n\t\n\t\t\t\treturn this._scheduleFading( duration, 1, 0 );\n\t\n\t\t\t},\n\t\n\t\t\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\n\t\n\t\t\t\tfadeOutAction.fadeOut( duration );\n\t\t\t\tthis.fadeIn( duration );\n\t\n\t\t\t\tif( warp ) {\n\t\n\t\t\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\t\n\t\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\t\n\t\t\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcrossFadeTo: function( fadeInAction, duration, warp ) {\n\t\n\t\t\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\t\n\t\t\t},\n\t\n\t\t\tstopFading: function() {\n\t\n\t\t\t\tvar weightInterpolant = this._weightInterpolant;\n\t\n\t\t\t\tif ( weightInterpolant !== null ) {\n\t\n\t\t\t\t\tthis._weightInterpolant = null;\n\t\t\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// Time Scale Control\n\t\n\t\t\t// set the weight stopping any scheduled warping\n\t\t\t// although .paused = true yields an effective time scale of zero, this\n\t\t\t// method does *not* change .paused, because it would be confusing\n\t\t\tsetEffectiveTimeScale: function( timeScale ) {\n\t\n\t\t\t\tthis.timeScale = timeScale;\n\t\t\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\n\t\n\t\t\t\treturn this.stopWarping();\n\t\n\t\t\t},\n\t\n\t\t\t// return the time scale considering warping and .paused\n\t\t\tgetEffectiveTimeScale: function() {\n\t\n\t\t\t\treturn this._effectiveTimeScale;\n\t\n\t\t\t},\n\t\n\t\t\tsetDuration: function( duration ) {\n\t\n\t\t\t\tthis.timeScale = this._clip.duration / duration;\n\t\n\t\t\t\treturn this.stopWarping();\n\t\n\t\t\t},\n\t\n\t\t\tsyncWith: function( action ) {\n\t\n\t\t\t\tthis.time = action.time;\n\t\t\t\tthis.timeScale = action.timeScale;\n\t\n\t\t\t\treturn this.stopWarping();\n\t\n\t\t\t},\n\t\n\t\t\thalt: function( duration ) {\n\t\n\t\t\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\t\n\t\t\t},\n\t\n\t\t\twarp: function( startTimeScale, endTimeScale, duration ) {\n\t\n\t\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\t\tinterpolant = this._timeScaleInterpolant,\n\t\n\t\t\t\t\ttimeScale = this.timeScale;\n\t\n\t\t\t\tif ( interpolant === null ) {\n\t\n\t\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\t\tthis._timeScaleInterpolant = interpolant;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\t\tvalues = interpolant.sampleValues;\n\t\n\t\t\t\ttimes[ 0 ] = now;\n\t\t\t\ttimes[ 1 ] = now + duration;\n\t\n\t\t\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\t\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tstopWarping: function() {\n\t\n\t\t\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\t\n\t\t\t\tif ( timeScaleInterpolant !== null ) {\n\t\n\t\t\t\t\tthis._timeScaleInterpolant = null;\n\t\t\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// Object Accessors\n\t\n\t\t\tgetMixer: function() {\n\t\n\t\t\t\treturn this._mixer;\n\t\n\t\t\t},\n\t\n\t\t\tgetClip: function() {\n\t\n\t\t\t\treturn this._clip;\n\t\n\t\t\t},\n\t\n\t\t\tgetRoot: function() {\n\t\n\t\t\t\treturn this._localRoot || this._mixer._root;\n\t\n\t\t\t},\n\t\n\t\t\t// Interna\n\t\n\t\t\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\n\t\t\t\t// called by the mixer\n\t\n\t\t\t\tvar startTime = this._startTime;\n\t\n\t\t\t\tif ( startTime !== null ) {\n\t\n\t\t\t\t\t// check for scheduled start of action\n\t\n\t\t\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\t\n\t\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// start\n\t\n\t\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// apply time scale and advance time\n\t\n\t\t\t\tdeltaTime *= this._updateTimeScale( time );\n\t\t\t\tvar clipTime = this._updateTime( deltaTime );\n\t\n\t\t\t\t// note: _updateTime may disable the action resulting in\n\t\t\t\t// an effective weight of 0\n\t\n\t\t\t\tvar weight = this._updateWeight( time );\n\t\n\t\t\t\tif ( weight > 0 ) {\n\t\n\t\t\t\t\tvar interpolants = this._interpolants;\n\t\t\t\t\tvar propertyMixers = this._propertyBindings;\n\t\n\t\t\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_updateWeight: function( time ) {\n\t\n\t\t\t\tvar weight = 0;\n\t\n\t\t\t\tif ( this.enabled ) {\n\t\n\t\t\t\t\tweight = this.weight;\n\t\t\t\t\tvar interpolant = this._weightInterpolant;\n\t\n\t\t\t\t\tif ( interpolant !== null ) {\n\t\n\t\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\t\n\t\t\t\t\t\tweight *= interpolantValue;\n\t\n\t\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\t\n\t\t\t\t\t\t\tthis.stopFading();\n\t\n\t\t\t\t\t\t\tif ( interpolantValue === 0 ) {\n\t\n\t\t\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\t\t\tthis.enabled = false;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._effectiveWeight = weight;\n\t\t\t\treturn weight;\n\t\n\t\t\t},\n\t\n\t\t\t_updateTimeScale: function( time ) {\n\t\n\t\t\t\tvar timeScale = 0;\n\t\n\t\t\t\tif ( ! this.paused ) {\n\t\n\t\t\t\t\ttimeScale = this.timeScale;\n\t\n\t\t\t\t\tvar interpolant = this._timeScaleInterpolant;\n\t\n\t\t\t\t\tif ( interpolant !== null ) {\n\t\n\t\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\t\n\t\t\t\t\t\ttimeScale *= interpolantValue;\n\t\n\t\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\t\n\t\t\t\t\t\t\tthis.stopWarping();\n\t\n\t\t\t\t\t\t\tif ( timeScale === 0 ) {\n\t\n\t\t\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\t\t\tthis.paused = true;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\t\t\tthis.timeScale = timeScale;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._effectiveTimeScale = timeScale;\n\t\t\t\treturn timeScale;\n\t\n\t\t\t},\n\t\n\t\t\t_updateTime: function( deltaTime ) {\n\t\n\t\t\t\tvar time = this.time + deltaTime;\n\t\n\t\t\t\tif ( deltaTime === 0 ) return time;\n\t\n\t\t\t\tvar duration = this._clip.duration,\n\t\n\t\t\t\t\tloop = this.loop,\n\t\t\t\t\tloopCount = this._loopCount;\n\t\n\t\t\t\tif ( loop === LoopOnce ) {\n\t\n\t\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t\t// just started\n\t\n\t\t\t\t\t\tthis.loopCount = 0;\n\t\t\t\t\t\tthis._setEndings( true, true, false );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\thandle_stop: {\n\t\n\t\t\t\t\t\tif ( time >= duration ) {\n\t\n\t\t\t\t\t\t\ttime = duration;\n\t\n\t\t\t\t\t\t} else if ( time < 0 ) {\n\t\n\t\t\t\t\t\t\ttime = 0;\n\t\n\t\t\t\t\t\t} else break handle_stop;\n\t\n\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\t\telse this.enabled = false;\n\t\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else { // repetitive Repeat or PingPong\n\t\n\t\t\t\t\tvar pingPong = ( loop === LoopPingPong );\n\t\n\t\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t\t// just started\n\t\n\t\t\t\t\t\tif ( deltaTime >= 0 ) {\n\t\n\t\t\t\t\t\t\tloopCount = 0;\n\t\n\t\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t\t\t// so leave loopCount at -1\n\t\n\t\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( time >= duration || time < 0 ) {\n\t\t\t\t\t\t// wrap around\n\t\n\t\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\t\t\ttime -= duration * loopDelta;\n\t\n\t\t\t\t\t\tloopCount += Math.abs( loopDelta );\n\t\n\t\t\t\t\t\tvar pending = this.repetitions - loopCount;\n\t\n\t\t\t\t\t\tif ( pending < 0 ) {\n\t\t\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\t\n\t\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\t\t\telse this.enabled = false;\n\t\n\t\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\t\n\t\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// keep running\n\t\n\t\t\t\t\t\t\tif ( pending === 0 ) {\n\t\t\t\t\t\t\t\t// entering the last round\n\t\n\t\t\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tthis._loopCount = loopCount;\n\t\n\t\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\t\t\t\t\t// invert time for the \"pong round\"\n\t\n\t\t\t\t\t\tthis.time = time;\n\t\t\t\t\t\treturn duration - time;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.time = time;\n\t\t\t\treturn time;\n\t\n\t\t\t},\n\t\n\t\t\t_setEndings: function( atStart, atEnd, pingPong ) {\n\t\n\t\t\t\tvar settings = this._interpolantSettings;\n\t\n\t\t\t\tif ( pingPong ) {\n\t\n\t\t\t\t\tsettings.endingStart \t= ZeroSlopeEnding;\n\t\t\t\t\tsettings.endingEnd\t\t= ZeroSlopeEnding;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\t\n\t\t\t\t\tif ( atStart ) {\n\t\n\t\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\n\t\t\t\t\t\t\t\tZeroSlopeEnding : ZeroCurvatureEnding;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( atEnd ) {\n\t\n\t\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\n\t\t\t\t\t\t\t\tZeroSlopeEnding : ZeroCurvatureEnding;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_scheduleFading: function( duration, weightNow, weightThen ) {\n\t\n\t\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\t\tinterpolant = this._weightInterpolant;\n\t\n\t\t\t\tif ( interpolant === null ) {\n\t\n\t\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\t\tthis._weightInterpolant = interpolant;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\t\tvalues = interpolant.sampleValues;\n\t\n\t\t\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\t\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t *\n\t\t * Player for AnimationClips.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction AnimationMixer( root ) {\n\t\n\t\t\tthis._root = root;\n\t\t\tthis._initMemoryManager();\n\t\t\tthis._accuIndex = 0;\n\t\n\t\t\tthis.time = 0;\n\t\n\t\t\tthis.timeScale = 1.0;\n\t\n\t\t}\n\t\n\t\tObject.assign( AnimationMixer.prototype, EventDispatcher.prototype, {\n\t\n\t\t\t// return an action for a clip optionally using a custom root target\n\t\t\t// object (this method allocates a lot of dynamic memory in case a\n\t\t\t// previously unknown clip/root combination is specified)\n\t\t\tclipAction: function( clip, optionalRoot ) {\n\t\n\t\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\t\trootUuid = root.uuid,\n\t\n\t\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\t\n\t\t\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\t\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\t\t\tprototypeAction = null;\n\t\n\t\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\t\tvar existingAction =\n\t\t\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\t\n\t\t\t\t\tif ( existingAction !== undefined ) {\n\t\n\t\t\t\t\t\treturn existingAction;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t\t\t// the bindings again but can just copy\n\t\t\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\t\n\t\t\t\t\t// also, take the clip from the prototype action\n\t\t\t\t\tif ( clipObject === null )\n\t\t\t\t\t\tclipObject = prototypeAction._clip;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// clip must be known when specified via string\n\t\t\t\tif ( clipObject === null ) return null;\n\t\n\t\t\t\t// allocate all resources required to run it\n\t\t\t\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\n\t\n\t\t\t\tthis._bindAction( newAction, prototypeAction );\n\t\n\t\t\t\t// and make the action known to the memory manager\n\t\t\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\t\n\t\t\t\treturn newAction;\n\t\n\t\t\t},\n\t\n\t\t\t// get an existing action\n\t\t\texistingAction: function( clip, optionalRoot ) {\n\t\n\t\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\t\trootUuid = root.uuid,\n\t\n\t\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\t\n\t\t\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\t\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\t\n\t\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t},\n\t\n\t\t\t// deactivates all previously scheduled actions\n\t\t\tstopAllAction: function() {\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tnActions = this._nActiveActions,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tnBindings = this._nActiveBindings;\n\t\n\t\t\t\tthis._nActiveActions = 0;\n\t\t\t\tthis._nActiveBindings = 0;\n\t\n\t\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\t\n\t\t\t\t\tactions[ i ].reset();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].useCount = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// advance the time and update apply the animation\n\t\t\tupdate: function( deltaTime ) {\n\t\n\t\t\t\tdeltaTime *= this.timeScale;\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tnActions = this._nActiveActions,\n\t\n\t\t\t\t\ttime = this.time += deltaTime,\n\t\t\t\t\ttimeDirection = Math.sign( deltaTime ),\n\t\n\t\t\t\t\taccuIndex = this._accuIndex ^= 1;\n\t\n\t\t\t\t// run active actions\n\t\n\t\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\t\n\t\t\t\t\tvar action = actions[ i ];\n\t\n\t\t\t\t\tif ( action.enabled ) {\n\t\n\t\t\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// update scene graph\n\t\n\t\t\t\tvar bindings = this._bindings,\n\t\t\t\t\tnBindings = this._nActiveBindings;\n\t\n\t\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].apply( accuIndex );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// return this mixer's root target object\n\t\t\tgetRoot: function() {\n\t\n\t\t\t\treturn this._root;\n\t\n\t\t\t},\n\t\n\t\t\t// free all resources specific to a particular clip\n\t\t\tuncacheClip: function( clip ) {\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tclipUuid = clip.uuid,\n\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\t\n\t\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t\t\t// iteration state and also require updating the state we can\n\t\t\t\t\t// just throw away\n\t\n\t\t\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\t\n\t\t\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar action = actionsToRemove[ i ];\n\t\n\t\t\t\t\t\tthis._deactivateAction( action );\n\t\n\t\t\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\t\n\t\t\t\t\t\taction._cacheIndex = null;\n\t\t\t\t\t\taction._byClipCacheIndex = null;\n\t\n\t\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\t\t\tactions.pop();\n\t\n\t\t\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdelete actionsByClip[ clipUuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// free all resources specific to a particular root target object\n\t\t\tuncacheRoot: function( root ) {\n\t\n\t\t\t\tvar rootUuid = root.uuid,\n\t\t\t\t\tactionsByClip = this._actionsByClip;\n\t\n\t\t\t\tfor ( var clipUuid in actionsByClip ) {\n\t\n\t\t\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\t\t\taction = actionByRoot[ rootUuid ];\n\t\n\t\t\t\t\tif ( action !== undefined ) {\n\t\n\t\t\t\t\t\tthis._deactivateAction( action );\n\t\t\t\t\t\tthis._removeInactiveAction( action );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\t\n\t\t\t\tif ( bindingByName !== undefined ) {\n\t\n\t\t\t\t\tfor ( var trackName in bindingByName ) {\n\t\n\t\t\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\t\tthis._removeInactiveBinding( binding );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// remove a targeted clip from the cache\n\t\t\tuncacheAction: function( clip, optionalRoot ) {\n\t\n\t\t\t\tvar action = this.existingAction( clip, optionalRoot );\n\t\n\t\t\t\tif ( action !== null ) {\n\t\n\t\t\t\t\tthis._deactivateAction( action );\n\t\t\t\t\tthis._removeInactiveAction( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t// Implementation details:\n\t\n\t\tObject.assign( AnimationMixer.prototype, {\n\t\n\t\t\t_bindAction: function( action, prototypeAction ) {\n\t\n\t\t\t\tvar root = action._localRoot || this._root,\n\t\t\t\t\ttracks = action._clip.tracks,\n\t\t\t\t\tnTracks = tracks.length,\n\t\t\t\t\tbindings = action._propertyBindings,\n\t\t\t\t\tinterpolants = action._interpolants,\n\t\t\t\t\trootUuid = root.uuid,\n\t\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\t\n\t\t\t\tif ( bindingsByName === undefined ) {\n\t\n\t\t\t\t\tbindingsByName = {};\n\t\t\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\t\n\t\t\t\t\tvar track = tracks[ i ],\n\t\t\t\t\t\ttrackName = track.name,\n\t\t\t\t\t\tbinding = bindingsByName[ trackName ];\n\t\n\t\t\t\t\tif ( binding !== undefined ) {\n\t\n\t\t\t\t\t\tbindings[ i ] = binding;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tbinding = bindings[ i ];\n\t\n\t\t\t\t\t\tif ( binding !== undefined ) {\n\t\n\t\t\t\t\t\t\t// existing binding, make sure the cache knows\n\t\n\t\t\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\t\n\t\t\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\t\n\t\t\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\t\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\t\n\t\t\t\t\t\tbindings[ i ] = binding;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_activateAction: function( action ) {\n\t\n\t\t\t\tif ( ! this._isActiveAction( action ) ) {\n\t\n\t\t\t\t\tif ( action._cacheIndex === null ) {\n\t\n\t\t\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t\t\t// appears to be still using it -> rebind\n\t\n\t\t\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\t\n\t\t\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\t\n\t\t\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar bindings = action._propertyBindings;\n\t\n\t\t\t\t\t// increment reference counts / sort out state\n\t\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\t\n\t\t\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\t\t\tbinding.saveOriginalState();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis._lendAction( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_deactivateAction: function( action ) {\n\t\n\t\t\t\tif ( this._isActiveAction( action ) ) {\n\t\n\t\t\t\t\tvar bindings = action._propertyBindings;\n\t\n\t\t\t\t\t// decrement reference counts / sort out state\n\t\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\t\t\tif ( -- binding.useCount === 0 ) {\n\t\n\t\t\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\t\t\tthis._takeBackBinding( binding );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis._takeBackAction( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// Memory manager\n\t\n\t\t\t_initMemoryManager: function() {\n\t\n\t\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\t\t\tthis._nActiveActions = 0;\n\t\n\t\t\t\tthis._actionsByClip = {};\n\t\t\t\t// inside:\n\t\t\t\t// {\n\t\t\t\t// \t\tknownActions: Array< AnimationAction >\t- used as prototypes\n\t\t\t\t// \t\tactionByRoot: AnimationAction\t\t\t- lookup\n\t\t\t\t// }\n\t\n\t\n\t\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\t\t\tthis._nActiveBindings = 0;\n\t\n\t\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\t\n\t\n\t\t\t\tthis._controlInterpolants = []; // same game as above\n\t\t\t\tthis._nActiveControlInterpolants = 0;\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tthis.stats = {\n\t\n\t\t\t\t\tactions: {\n\t\t\t\t\t\tget total() { return scope._actions.length; },\n\t\t\t\t\t\tget inUse() { return scope._nActiveActions; }\n\t\t\t\t\t},\n\t\t\t\t\tbindings: {\n\t\t\t\t\t\tget total() { return scope._bindings.length; },\n\t\t\t\t\t\tget inUse() { return scope._nActiveBindings; }\n\t\t\t\t\t},\n\t\t\t\t\tcontrolInterpolants: {\n\t\t\t\t\t\tget total() { return scope._controlInterpolants.length; },\n\t\t\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t},\n\t\n\t\t\t// Memory management for AnimationAction objects\n\t\n\t\t\t_isActiveAction: function( action ) {\n\t\n\t\t\t\tvar index = action._cacheIndex;\n\t\t\t\treturn index !== null && index < this._nActiveActions;\n\t\n\t\t\t},\n\t\n\t\t\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\t\n\t\t\t\tif ( actionsForClip === undefined ) {\n\t\n\t\t\t\t\tactionsForClip = {\n\t\n\t\t\t\t\t\tknownActions: [ action ],\n\t\t\t\t\t\tactionByRoot: {}\n\t\n\t\t\t\t\t};\n\t\n\t\t\t\t\taction._byClipCacheIndex = 0;\n\t\n\t\t\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar knownActions = actionsForClip.knownActions;\n\t\n\t\t\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\t\t\tknownActions.push( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t\taction._cacheIndex = actions.length;\n\t\t\t\tactions.push( action );\n\t\n\t\t\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\t\n\t\t\t},\n\t\n\t\t\t_removeInactiveAction: function( action ) {\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\t\t\tcacheIndex = action._cacheIndex;\n\t\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\t\n\t\t\t\taction._cacheIndex = null;\n\t\n\t\n\t\t\t\tvar clipUuid = action._clip.uuid,\n\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\t\n\t\t\t\t\tlastKnownAction =\n\t\t\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\t\n\t\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\t\n\t\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\t\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\t\t\tknownActionsForClip.pop();\n\t\n\t\t\t\taction._byClipCacheIndex = null;\n\t\n\t\n\t\t\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\n\t\n\t\t\t\tdelete actionByRoot[ rootUuid ];\n\t\n\t\t\t\tif ( knownActionsForClip.length === 0 ) {\n\t\n\t\t\t\t\tdelete actionsByClip[ clipUuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\t\n\t\t\t},\n\t\n\t\t\t_removeInactiveBindingsForAction: function( action ) {\n\t\n\t\t\t\tvar bindings = action._propertyBindings;\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\t\tif ( -- binding.referenceCount === 0 ) {\n\t\n\t\t\t\t\t\tthis._removeInactiveBinding( binding );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_lendAction: function( action ) {\n\t\n\t\t\t\t// [ active actions |  inactive actions  ]\n\t\t\t\t// [  active actions >| inactive actions ]\n\t\t\t\t//                 s        a\n\t\t\t\t//                  <-swap->\n\t\t\t\t//                 a        s\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tprevIndex = action._cacheIndex,\n\t\n\t\t\t\t\tlastActiveIndex = this._nActiveActions ++,\n\t\n\t\t\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\t\n\t\t\t\taction._cacheIndex = lastActiveIndex;\n\t\t\t\tactions[ lastActiveIndex ] = action;\n\t\n\t\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\t\t\tactions[ prevIndex ] = firstInactiveAction;\n\t\n\t\t\t},\n\t\n\t\t\t_takeBackAction: function( action ) {\n\t\n\t\t\t\t// [  active actions  | inactive actions ]\n\t\t\t\t// [ active actions |< inactive actions  ]\n\t\t\t\t//        a        s\n\t\t\t\t//         <-swap->\n\t\t\t\t//        s        a\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tprevIndex = action._cacheIndex,\n\t\n\t\t\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\t\n\t\t\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\t\n\t\t\t\taction._cacheIndex = firstInactiveIndex;\n\t\t\t\tactions[ firstInactiveIndex ] = action;\n\t\n\t\t\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\t\t\tactions[ prevIndex ] = lastActiveAction;\n\t\n\t\t\t},\n\t\n\t\t\t// Memory management for PropertyMixer objects\n\t\n\t\t\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\n\t\n\t\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\t\n\t\t\t\t\tbindings = this._bindings;\n\t\n\t\t\t\tif ( bindingByName === undefined ) {\n\t\n\t\t\t\t\tbindingByName = {};\n\t\t\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tbindingByName[ trackName ] = binding;\n\t\n\t\t\t\tbinding._cacheIndex = bindings.length;\n\t\t\t\tbindings.push( binding );\n\t\n\t\t\t},\n\t\n\t\t\t_removeInactiveBinding: function( binding ) {\n\t\n\t\t\t\tvar bindings = this._bindings,\n\t\t\t\t\tpropBinding = binding.binding,\n\t\t\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\t\t\ttrackName = propBinding.path,\n\t\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\t\n\t\t\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\t\t\tcacheIndex = binding._cacheIndex;\n\t\n\t\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\t\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\t\t\tbindings.pop();\n\t\n\t\t\t\tdelete bindingByName[ trackName ];\n\t\n\t\t\t\tremove_empty_map: {\n\t\n\t\t\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\n\t\n\t\t\t\t\tdelete bindingsByRoot[ rootUuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_lendBinding: function( binding ) {\n\t\n\t\t\t\tvar bindings = this._bindings,\n\t\t\t\t\tprevIndex = binding._cacheIndex,\n\t\n\t\t\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\t\n\t\t\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\t\n\t\t\t\tbinding._cacheIndex = lastActiveIndex;\n\t\t\t\tbindings[ lastActiveIndex ] = binding;\n\t\n\t\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\t\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\t\n\t\t\t},\n\t\n\t\t\t_takeBackBinding: function( binding ) {\n\t\n\t\t\t\tvar bindings = this._bindings,\n\t\t\t\t\tprevIndex = binding._cacheIndex,\n\t\n\t\t\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\t\n\t\t\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\t\n\t\t\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\t\t\tbindings[ firstInactiveIndex ] = binding;\n\t\n\t\t\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\t\t\tbindings[ prevIndex ] = lastActiveBinding;\n\t\n\t\t\t},\n\t\n\t\n\t\t\t// Memory management of Interpolants for weight and time scale\n\t\n\t\t\t_lendControlInterpolant: function() {\n\t\n\t\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\t\n\t\t\t\tif ( interpolant === undefined ) {\n\t\n\t\t\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\t\n\t\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn interpolant;\n\t\n\t\t\t},\n\t\n\t\t\t_takeBackControlInterpolant: function( interpolant ) {\n\t\n\t\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\t\tprevIndex = interpolant.__cacheIndex,\n\t\n\t\t\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\t\n\t\t\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\t\n\t\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\t\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\t\n\t\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\t\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\t\n\t\t\t},\n\t\n\t\t\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Uniform( value ) {\n\t\n\t\t\tif ( typeof value === 'string' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\t\t\tvalue = arguments[ 1 ];\n\t\n\t\t\t}\n\t\n\t\t\tthis.value = value;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InstancedBufferGeometry() {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'InstancedBufferGeometry';\n\t\t\tthis.maxInstancedCount = undefined;\n\t\n\t\t}\n\t\n\t\tInstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tInstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;\n\t\n\t\tInstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;\n\t\n\t\tInstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {\n\t\n\t\t\tthis.groups.push( {\n\t\n\t\t\t\tstart: start,\n\t\t\t\tcount: count,\n\t\t\t\tmaterialIndex: materialIndex\n\t\n\t\t\t} );\n\t\n\t\t};\n\t\n\t\tInstancedBufferGeometry.prototype.copy = function ( source ) {\n\t\n\t\t\tvar index = source.index;\n\t\n\t\t\tif ( index !== null ) {\n\t\n\t\t\t\tthis.setIndex( index.clone() );\n\t\n\t\t\t}\n\t\n\t\t\tvar attributes = source.attributes;\n\t\n\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\tvar attribute = attributes[ name ];\n\t\t\t\tthis.addAttribute( name, attribute.clone() );\n\t\n\t\t\t}\n\t\n\t\t\tvar groups = source.groups;\n\t\n\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar group = groups[ i ];\n\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.data = interleavedBuffer;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.offset = offset;\n\t\n\t\t\tthis.normalized = normalized === true;\n\t\n\t\t}\n\t\n\t\n\t\tInterleavedBufferAttribute.prototype = {\n\t\n\t\t\tconstructor: InterleavedBufferAttribute,\n\t\n\t\t\tisInterleavedBufferAttribute: true,\n\t\n\t\t\tget count() {\n\t\n\t\t\t\treturn this.data.count;\n\t\n\t\t\t},\n\t\n\t\t\tget array() {\n\t\n\t\t\t\treturn this.data.array;\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( index, x ) {\n\t\n\t\t\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( index, y ) {\n\t\n\t\t\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetZ: function ( index, z ) {\n\t\n\t\t\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetW: function ( index, w ) {\n\t\n\t\t\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetX: function ( index ) {\n\t\n\t\t\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\t\n\t\t\t},\n\t\n\t\t\tgetY: function ( index ) {\n\t\n\t\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\t\n\t\t\t},\n\t\n\t\t\tgetZ: function ( index ) {\n\t\n\t\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\t\n\t\t\t},\n\t\n\t\t\tgetW: function ( index ) {\n\t\n\t\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetXY: function ( index, x, y ) {\n\t\n\t\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\t\tthis.data.array[ index + 1 ] = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXYZ: function ( index, x, y, z ) {\n\t\n\t\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\t\tthis.data.array[ index + 2 ] = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXYZW: function ( index, x, y, z, w ) {\n\t\n\t\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\t\tthis.data.array[ index + 2 ] = z;\n\t\t\t\tthis.data.array[ index + 3 ] = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InterleavedBuffer( array, stride ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.array = array;\n\t\t\tthis.stride = stride;\n\t\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\t\n\t\t\tthis.dynamic = false;\n\t\t\tthis.updateRange = { offset: 0, count: - 1 };\n\t\n\t\t\tthis.version = 0;\n\t\n\t\t}\n\t\n\t\tInterleavedBuffer.prototype = {\n\t\n\t\t\tconstructor: InterleavedBuffer,\n\t\n\t\t\tisInterleavedBuffer: true,\n\t\n\t\t\tset needsUpdate( value ) {\n\t\n\t\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t\t},\n\t\n\t\t\tsetArray: function ( array ) {\n\t\n\t\t\t\tif ( Array.isArray( array ) ) {\n\t\n\t\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.count = array !== undefined ? array.length / this.stride : 0;\n\t\t\t\tthis.array = array;\n\t\n\t\t\t},\n\t\n\t\t\tsetDynamic: function ( value ) {\n\t\n\t\t\t\tthis.dynamic = value;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\t\tthis.count = source.count;\n\t\t\t\tthis.stride = source.stride;\n\t\t\t\tthis.dynamic = source.dynamic;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyAt: function ( index1, attribute, index2 ) {\n\t\n\t\t\t\tindex1 *= this.stride;\n\t\t\t\tindex2 *= attribute.stride;\n\t\n\t\t\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( value, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.array.set( value, offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\n\t\n\t\t\tInterleavedBuffer.call( this, array, stride );\n\t\n\t\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\n\t\t}\n\t\n\t\tInstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );\n\t\tInstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;\n\t\n\t\tInstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;\n\t\n\t\tInstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\t\n\t\t\tInterleavedBuffer.prototype.copy.call( this, source );\n\t\n\t\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {\n\t\n\t\t\tBufferAttribute.call( this, array, itemSize );\n\t\n\t\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\n\t\t}\n\t\n\t\tInstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\t\tInstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;\n\t\n\t\tInstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;\n\t\n\t\tInstancedBufferAttribute.prototype.copy = function ( source ) {\n\t\n\t\t\tBufferAttribute.prototype.copy.call( this, source );\n\t\n\t\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author bhouston / http://clara.io/\n\t\t * @author stephomi / http://stephaneginier.com/\n\t\t */\n\t\n\t\tfunction Raycaster( origin, direction, near, far ) {\n\t\n\t\t\tthis.ray = new Ray( origin, direction );\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\t\n\t\t\tthis.near = near || 0;\n\t\t\tthis.far = far || Infinity;\n\t\n\t\t\tthis.params = {\n\t\t\t\tMesh: {},\n\t\t\t\tLine: {},\n\t\t\t\tLOD: {},\n\t\t\t\tPoints: { threshold: 1 },\n\t\t\t\tSprite: {}\n\t\t\t};\n\t\n\t\t\tObject.defineProperties( this.params, {\n\t\t\t\tPointCloud: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\t\treturn this.Points;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t}\n\t\n\t\tfunction ascSort( a, b ) {\n\t\n\t\t\treturn a.distance - b.distance;\n\t\n\t\t}\n\t\n\t\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\t\n\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\tobject.raycast( raycaster, intersects );\n\t\n\t\t\tif ( recursive === true ) {\n\t\n\t\t\t\tvar children = object.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tRaycaster.prototype = {\n\t\n\t\t\tconstructor: Raycaster,\n\t\n\t\t\tlinePrecision: 1,\n\t\n\t\t\tset: function ( origin, direction ) {\n\t\n\t\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\t\n\t\t\t\tthis.ray.set( origin, direction );\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCamera: function ( coords, camera ) {\n\t\n\t\t\t\tif ( (camera && camera.isPerspectiveCamera) ) {\n\t\n\t\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\n\t\t\t\t} else if ( (camera && camera.isOrthographicCamera) ) {\n\t\n\t\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tintersectObject: function ( object, recursive ) {\n\t\n\t\t\t\tvar intersects = [];\n\t\n\t\t\t\tintersectObject( object, this, intersects, recursive );\n\t\n\t\t\t\tintersects.sort( ascSort );\n\t\n\t\t\t\treturn intersects;\n\t\n\t\t\t},\n\t\n\t\t\tintersectObjects: function ( objects, recursive ) {\n\t\n\t\t\t\tvar intersects = [];\n\t\n\t\t\t\tif ( Array.isArray( objects ) === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\t\treturn intersects;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tintersects.sort( ascSort );\n\t\n\t\t\t\treturn intersects;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Clock( autoStart ) {\n\t\n\t\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\t\n\t\t\tthis.startTime = 0;\n\t\t\tthis.oldTime = 0;\n\t\t\tthis.elapsedTime = 0;\n\t\n\t\t\tthis.running = false;\n\t\n\t\t}\n\t\n\t\tClock.prototype = {\n\t\n\t\t\tconstructor: Clock,\n\t\n\t\t\tstart: function () {\n\t\n\t\t\t\tthis.startTime = ( performance || Date ).now();\n\t\n\t\t\t\tthis.oldTime = this.startTime;\n\t\t\t\tthis.elapsedTime = 0;\n\t\t\t\tthis.running = true;\n\t\n\t\t\t},\n\t\n\t\t\tstop: function () {\n\t\n\t\t\t\tthis.getElapsedTime();\n\t\t\t\tthis.running = false;\n\t\n\t\t\t},\n\t\n\t\t\tgetElapsedTime: function () {\n\t\n\t\t\t\tthis.getDelta();\n\t\t\t\treturn this.elapsedTime;\n\t\n\t\t\t},\n\t\n\t\t\tgetDelta: function () {\n\t\n\t\t\t\tvar diff = 0;\n\t\n\t\t\t\tif ( this.autoStart && ! this.running ) {\n\t\n\t\t\t\t\tthis.start();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.running ) {\n\t\n\t\t\t\t\tvar newTime = ( performance || Date ).now();\n\t\n\t\t\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\t\t\tthis.oldTime = newTime;\n\t\n\t\t\t\t\tthis.elapsedTime += diff;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn diff;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * Spline from Tween.js, slightly optimized (and trashed)\n\t\t * http://sole.github.com/tween.js/examples/05_spline.html\n\t\t *\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Spline( points ) {\n\t\n\t\t\tthis.points = points;\n\t\n\t\t\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\t\t\tpoint, intPoint, weight, w2, w3,\n\t\t\tpa, pb, pc, pd;\n\t\n\t\t\tthis.initFromArray = function ( a ) {\n\t\n\t\t\t\tthis.points = [];\n\t\n\t\t\t\tfor ( var i = 0; i < a.length; i ++ ) {\n\t\n\t\t\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.getPoint = function ( k ) {\n\t\n\t\t\t\tpoint = ( this.points.length - 1 ) * k;\n\t\t\t\tintPoint = Math.floor( point );\n\t\t\t\tweight = point - intPoint;\n\t\n\t\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\t\t\tc[ 1 ] = intPoint;\n\t\t\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\t\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\t\n\t\t\t\tpa = this.points[ c[ 0 ] ];\n\t\t\t\tpb = this.points[ c[ 1 ] ];\n\t\t\t\tpc = this.points[ c[ 2 ] ];\n\t\t\t\tpd = this.points[ c[ 3 ] ];\n\t\n\t\t\t\tw2 = weight * weight;\n\t\t\t\tw3 = weight * w2;\n\t\n\t\t\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\t\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\t\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\t\n\t\t\t\treturn v3;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getControlPointsArray = function () {\n\t\n\t\t\t\tvar i, p, l = this.points.length,\n\t\t\t\t\tcoords = [];\n\t\n\t\t\t\tfor ( i = 0; i < l; i ++ ) {\n\t\n\t\t\t\t\tp = this.points[ i ];\n\t\t\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn coords;\n\t\n\t\t\t};\n\t\n\t\t\t// approximate length by summing linear segments\n\t\n\t\t\tthis.getLength = function ( nSubDivisions ) {\n\t\n\t\t\t\tvar i, index, nSamples, position,\n\t\t\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\t\t\toldPosition = new Vector3(),\n\t\t\t\t\ttmpVec = new Vector3(),\n\t\t\t\t\tchunkLengths = [],\n\t\t\t\t\ttotalLength = 0;\n\t\n\t\t\t\t// first point has 0 length\n\t\n\t\t\t\tchunkLengths[ 0 ] = 0;\n\t\n\t\t\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\n\t\n\t\t\t\tnSamples = this.points.length * nSubDivisions;\n\t\n\t\t\t\toldPosition.copy( this.points[ 0 ] );\n\t\n\t\t\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\t\n\t\t\t\t\tindex = i / nSamples;\n\t\n\t\t\t\t\tposition = this.getPoint( index );\n\t\t\t\t\ttmpVec.copy( position );\n\t\n\t\t\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\t\n\t\t\t\t\toldPosition.copy( position );\n\t\n\t\t\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\t\t\tintPoint = Math.floor( point );\n\t\n\t\t\t\t\tif ( intPoint !== oldIntPoint ) {\n\t\n\t\t\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\t\t\toldIntPoint = intPoint;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// last point ends with total length\n\t\n\t\t\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\t\n\t\t\t\treturn { chunks: chunkLengths, total: totalLength };\n\t\n\t\t\t};\n\t\n\t\t\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\t\n\t\t\t\tvar i, j,\n\t\t\t\t\tindex, indexCurrent, indexNext,\n\t\t\t\t\trealDistance,\n\t\t\t\t\tsampling, position,\n\t\t\t\t\tnewpoints = [],\n\t\t\t\t\ttmpVec = new Vector3(),\n\t\t\t\t\tsl = this.getLength();\n\t\n\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\t\n\t\t\t\tfor ( i = 1; i < this.points.length; i ++ ) {\n\t\n\t\t\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\t\n\t\t\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\t\n\t\t\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\t\n\t\t\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\t\t\tindexNext = i / ( this.points.length - 1 );\n\t\n\t\t\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\n\t\n\t\t\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\t\n\t\t\t\t\t\tposition = this.getPoint( index );\n\t\t\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.points = newpoints;\n\t\n\t\t\t};\n\t\n\t\t\t// Catmull-Rom\n\t\n\t\t\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\t\n\t\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\t\n\t\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n\t\t *\n\t\t * The poles (phi) are at the positive and negative y axis.\n\t\t * The equator starts at positive z.\n\t\t */\n\t\n\t\tfunction Spherical( radius, phi, theta ) {\n\t\n\t\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\t\t\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\t\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t\tSpherical.prototype = {\n\t\n\t\t\tconstructor: Spherical,\n\t\n\t\t\tset: function ( radius, phi, theta ) {\n\t\n\t\t\t\tthis.radius = radius;\n\t\t\t\tthis.phi = phi;\n\t\t\t\tthis.theta = theta;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( other ) {\n\t\n\t\t\t\tthis.radius = other.radius;\n\t\t\t\tthis.phi = other.phi;\n\t\t\t\tthis.theta = other.theta;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\t\tmakeSafe: function() {\n\t\n\t\t\t\tvar EPS = 0.000001;\n\t\t\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromVector3: function( vec3 ) {\n\t\n\t\t\t\tthis.radius = vec3.length();\n\t\n\t\t\t\tif ( this.radius === 0 ) {\n\t\n\t\t\t\t\tthis.theta = 0;\n\t\t\t\t\tthis.phi = 0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\t\t\tthis.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t};\n\t\n\t\t/**\r\n\t\t * @author alteredq / http://alteredqualia.com/\r\n\t\t */\r\n\t\r\n\t\tfunction MorphBlendMesh( geometry, material ) {\n\t\r\n\t\t\tMesh.call( this, geometry, material );\r\n\t\r\n\t\t\tthis.animationsMap = {};\r\n\t\t\tthis.animationsList = [];\r\n\t\r\n\t\t\t// prepare default animation\r\n\t\t\t// (all frames played together in 1 second)\r\n\t\r\n\t\t\tvar numFrames = this.geometry.morphTargets.length;\r\n\t\r\n\t\t\tvar name = \"__default\";\r\n\t\r\n\t\t\tvar startFrame = 0;\r\n\t\t\tvar endFrame = numFrames - 1;\r\n\t\r\n\t\t\tvar fps = numFrames / 1;\r\n\t\r\n\t\t\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\t\t\tthis.setAnimationWeight( name, 1 );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tMorphBlendMesh.prototype = Object.create( Mesh.prototype );\r\n\t\tMorphBlendMesh.prototype.constructor = MorphBlendMesh;\r\n\t\r\n\t\tMorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\t\r\n\t\t\tvar animation = {\r\n\t\r\n\t\t\t\tstart: start,\r\n\t\t\t\tend: end,\r\n\t\r\n\t\t\t\tlength: end - start + 1,\r\n\t\r\n\t\t\t\tfps: fps,\r\n\t\t\t\tduration: ( end - start ) / fps,\r\n\t\r\n\t\t\t\tlastFrame: 0,\r\n\t\t\t\tcurrentFrame: 0,\r\n\t\r\n\t\t\t\tactive: false,\r\n\t\r\n\t\t\t\ttime: 0,\r\n\t\t\t\tdirection: 1,\r\n\t\t\t\tweight: 1,\r\n\t\r\n\t\t\t\tdirectionBackwards: false,\r\n\t\t\t\tmirroredLoop: false\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tthis.animationsMap[ name ] = animation;\r\n\t\t\tthis.animationsList.push( animation );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\t\r\n\t\t\tvar pattern = /([a-z]+)_?(\\d+)/i;\r\n\t\r\n\t\t\tvar firstAnimation, frameRanges = {};\r\n\t\r\n\t\t\tvar geometry = this.geometry;\r\n\t\r\n\t\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\t\t\tvar chunks = morph.name.match( pattern );\r\n\t\r\n\t\t\t\tif ( chunks && chunks.length > 1 ) {\r\n\t\r\n\t\t\t\t\tvar name = chunks[ 1 ];\r\n\t\r\n\t\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\t\r\n\t\t\t\t\tvar range = frameRanges[ name ];\r\n\t\r\n\t\t\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\t\t\tif ( i > range.end ) range.end = i;\r\n\t\r\n\t\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var name in frameRanges ) {\r\n\t\r\n\t\t\t\tvar range = frameRanges[ name ];\r\n\t\t\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.firstAnimation = firstAnimation;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.direction = 1;\r\n\t\t\t\tanimation.directionBackwards = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.direction = - 1;\r\n\t\t\t\tanimation.directionBackwards = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.fps = fps;\r\n\t\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.duration = duration;\r\n\t\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.weight = weight;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.time = time;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\t\r\n\t\t\tvar time = 0;\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\ttime = animation.time;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn time;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\t\r\n\t\t\tvar duration = - 1;\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tduration = animation.duration;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn duration;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.time = 0;\r\n\t\t\t\tanimation.active = true;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.active = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.update = function ( delta ) {\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar animation = this.animationsList[ i ];\r\n\t\r\n\t\t\t\tif ( ! animation.active ) continue;\r\n\t\r\n\t\t\t\tvar frameTime = animation.duration / animation.length;\r\n\t\r\n\t\t\t\tanimation.time += animation.direction * delta;\r\n\t\r\n\t\t\t\tif ( animation.mirroredLoop ) {\r\n\t\r\n\t\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\t\r\n\t\t\t\t\t\tanimation.direction *= - 1;\r\n\t\r\n\t\t\t\t\t\tif ( animation.time > animation.duration ) {\r\n\t\r\n\t\t\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\t\t\tanimation.directionBackwards = true;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( animation.time < 0 ) {\r\n\t\r\n\t\t\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\t\t\tanimation.directionBackwards = false;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tanimation.time = animation.time % animation.duration;\r\n\t\r\n\t\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\t\t\tvar weight = animation.weight;\r\n\t\r\n\t\t\t\tif ( keyframe !== animation.currentFrame ) {\r\n\t\r\n\t\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\t\r\n\t\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\t\r\n\t\t\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\t\t\tanimation.currentFrame = keyframe;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\t\r\n\t\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\t\r\n\t\t\t\tif ( animation.currentFrame !== animation.lastFrame ) {\r\n\t\r\n\t\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction ImmediateRenderObject( material ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.material = material;\n\t\t\tthis.render = function ( renderCallback ) {};\n\t\n\t\t}\n\t\n\t\tImmediateRenderObject.prototype = Object.create( Object3D.prototype );\n\t\tImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\n\t\n\t\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t*/\n\t\n\t\tfunction VertexNormalsHelper( object, size, hex, linewidth ) {\n\t\n\t\t\tthis.object = object;\n\t\n\t\t\tthis.size = ( size !== undefined ) ? size : 1;\n\t\n\t\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\t\n\t\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\t\n\t\t\t//\n\t\n\t\t\tvar nNormals = 0;\n\t\n\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\t\n\t\t\t\tnNormals = objGeometry.faces.length * 3;\n\t\n\t\t\t} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {\n\t\n\t\t\t\tnNormals = objGeometry.attributes.normal.count;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\tvar positions = new Float32Attribute( nNormals * 2 * 3, 3 );\n\t\n\t\t\tgeometry.addAttribute( 'position', positions );\n\t\n\t\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\t\n\t\t\t//\n\t\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\t\tVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\n\t\n\t\tVertexNormalsHelper.prototype.update = ( function () {\n\t\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\t\t\tvar normalMatrix = new Matrix3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\t\n\t\t\t\tthis.object.updateMatrixWorld( true );\n\t\n\t\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\t\n\t\t\t\tvar matrixWorld = this.object.matrixWorld;\n\t\n\t\t\t\tvar position = this.geometry.attributes.position;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\t\n\t\t\t\t\tvar vertices = objGeometry.vertices;\n\t\n\t\t\t\t\tvar faces = objGeometry.faces;\n\t\n\t\t\t\t\tvar idx = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\t\n\t\t\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\t\n\t\t\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\tvar objPos = objGeometry.attributes.position;\n\t\n\t\t\t\t\tvar objNorm = objGeometry.attributes.normal;\n\t\n\t\t\t\t\tvar idx = 0;\n\t\n\t\t\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\t\n\t\t\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\t\n\t\t\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t*/\n\t\n\t\tfunction SpotLightHelper( light ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\tvar positions = [\n\t\t\t\t0, 0, 0,   0,   0,   1,\n\t\t\t\t0, 0, 0,   1,   0,   1,\n\t\t\t\t0, 0, 0, - 1,   0,   1,\n\t\t\t\t0, 0, 0,   0,   1,   1,\n\t\t\t\t0, 0, 0,   0, - 1,   1\n\t\t\t];\n\t\n\t\t\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\t\n\t\t\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\t\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\t\n\t\t\t\tpositions.push(\n\t\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t\t);\n\t\n\t\t\t}\n\t\n\t\t\tgeometry.addAttribute( 'position', new Float32Attribute( positions, 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { fog: false } );\n\t\n\t\t\tthis.cone = new LineSegments( geometry, material );\n\t\t\tthis.add( this.cone );\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tSpotLightHelper.prototype = Object.create( Object3D.prototype );\n\t\tSpotLightHelper.prototype.constructor = SpotLightHelper;\n\t\n\t\tSpotLightHelper.prototype.dispose = function () {\n\t\n\t\t\tthis.cone.geometry.dispose();\n\t\t\tthis.cone.material.dispose();\n\t\n\t\t};\n\t\n\t\tSpotLightHelper.prototype.update = function () {\n\t\n\t\t\tvar vector = new Vector3();\n\t\t\tvar vector2 = new Vector3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\t\n\t\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\t\n\t\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\n\t\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\t\n\t\t\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author Sean Griffin / http://twitter.com/sgrif\n\t\t * @author Michael Guerrero / http://realitymeltdown.com\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author ikerr / http://verold.com\n\t\t */\n\t\n\t\tfunction SkeletonHelper( object ) {\n\t\n\t\t\tthis.bones = this.getBoneList( object );\n\t\n\t\t\tvar geometry = new Geometry();\n\t\n\t\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\t\n\t\t\t\tvar bone = this.bones[ i ];\n\t\n\t\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\t\n\t\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\t\tgeometry.colors.push( new Color( 0, 0, 1 ) );\n\t\t\t\t\tgeometry.colors.push( new Color( 0, 1, 0 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tgeometry.dynamic = true;\n\t\n\t\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t\tthis.root = object;\n\t\n\t\t\tthis.matrix = object.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\n\t\tSkeletonHelper.prototype = Object.create( LineSegments.prototype );\n\t\tSkeletonHelper.prototype.constructor = SkeletonHelper;\n\t\n\t\tSkeletonHelper.prototype.getBoneList = function( object ) {\n\t\n\t\t\tvar boneList = [];\n\t\n\t\t\tif ( (object && object.isBone) ) {\n\t\n\t\t\t\tboneList.push( object );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\t\n\t\t\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn boneList;\n\t\n\t\t};\n\t\n\t\tSkeletonHelper.prototype.update = function () {\n\t\n\t\t\tvar geometry = this.geometry;\n\t\n\t\t\tvar matrixWorldInv = new Matrix4().getInverse( this.root.matrixWorld );\n\t\n\t\t\tvar boneMatrix = new Matrix4();\n\t\n\t\t\tvar j = 0;\n\t\n\t\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\t\n\t\t\t\tvar bone = this.bones[ i ];\n\t\n\t\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\t\n\t\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\n\t\n\t\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\n\t\n\t\t\t\t\tj += 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tgeometry.verticesNeedUpdate = true;\n\t\n\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction PointLightHelper( light, sphereSize ) {\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\n\t\t\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n\t\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t\tMesh.call( this, geometry, material );\n\t\n\t\t\tthis.matrix = this.light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\t/*\n\t\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\t\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\t\n\t\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\t\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\t\n\t\t\tvar d = light.distance;\n\t\n\t\t\tif ( d === 0.0 ) {\n\t\n\t\t\t\tthis.lightDistance.visible = false;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\n\t\t\t}\n\t\n\t\t\tthis.add( this.lightDistance );\n\t\t\t*/\n\t\n\t\t}\n\t\n\t\tPointLightHelper.prototype = Object.create( Mesh.prototype );\n\t\tPointLightHelper.prototype.constructor = PointLightHelper;\n\t\n\t\tPointLightHelper.prototype.dispose = function () {\n\t\n\t\t\tthis.geometry.dispose();\n\t\t\tthis.material.dispose();\n\t\n\t\t};\n\t\n\t\tPointLightHelper.prototype.update = function () {\n\t\n\t\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t\t/*\n\t\t\tvar d = this.light.distance;\n\t\n\t\t\tif ( d === 0.0 ) {\n\t\n\t\t\t\tthis.lightDistance.visible = false;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.lightDistance.visible = true;\n\t\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\n\t\t\t}\n\t\t\t*/\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction HemisphereLightHelper( light, sphereSize ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.colors = [ new Color(), new Color() ];\n\t\n\t\t\tvar geometry = new SphereGeometry( sphereSize, 4, 2 );\n\t\t\tgeometry.rotateX( - Math.PI / 2 );\n\t\n\t\t\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\t\n\t\t\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\t\n\t\t\t}\n\t\n\t\t\tvar material = new MeshBasicMaterial( { vertexColors: FaceColors, wireframe: true } );\n\t\n\t\t\tthis.lightSphere = new Mesh( geometry, material );\n\t\t\tthis.add( this.lightSphere );\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\n\t\tHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\n\t\n\t\tHemisphereLightHelper.prototype.dispose = function () {\n\t\n\t\t\tthis.lightSphere.geometry.dispose();\n\t\t\tthis.lightSphere.material.dispose();\n\t\n\t\t};\n\t\n\t\tHemisphereLightHelper.prototype.update = function () {\n\t\n\t\t\tvar vector = new Vector3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\t\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\t\n\t\t\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\t\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction GridHelper( size, divisions, color1, color2 ) {\n\t\n\t\t\tdivisions = divisions || 1;\n\t\t\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n\t\t\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\t\n\t\t\tvar center = divisions / 2;\n\t\t\tvar step = ( size * 2 ) / divisions;\n\t\t\tvar vertices = [], colors = [];\n\t\n\t\t\tfor ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {\n\t\n\t\t\t\tvertices.push( - size, 0, k, size, 0, k );\n\t\t\t\tvertices.push( k, 0, - size, k, 0, size );\n\t\n\t\t\t\tvar color = i === center ? color1 : color2;\n\t\n\t\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\n\t\t\t}\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new Float32Attribute( vertices, 3 ) );\n\t\t\tgeometry.addAttribute( 'color', new Float32Attribute( colors, 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t}\n\t\n\t\tGridHelper.prototype = Object.create( LineSegments.prototype );\n\t\tGridHelper.prototype.constructor = GridHelper;\n\t\n\t\tGridHelper.prototype.setColors = function () {\n\t\n\t\t\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t*/\n\t\n\t\tfunction FaceNormalsHelper( object, size, hex, linewidth ) {\n\t\n\t\t\t// FaceNormalsHelper only supports THREE.Geometry\n\t\n\t\t\tthis.object = object;\n\t\n\t\t\tthis.size = ( size !== undefined ) ? size : 1;\n\t\n\t\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\t\n\t\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\t\n\t\t\t//\n\t\n\t\t\tvar nNormals = 0;\n\t\n\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\t\n\t\t\t\tnNormals = objGeometry.faces.length;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\tvar positions = new Float32Attribute( nNormals * 2 * 3, 3 );\n\t\n\t\t\tgeometry.addAttribute( 'position', positions );\n\t\n\t\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\t\n\t\t\t//\n\t\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\t\tFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\n\t\n\t\tFaceNormalsHelper.prototype.update = ( function () {\n\t\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\t\t\tvar normalMatrix = new Matrix3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tthis.object.updateMatrixWorld( true );\n\t\n\t\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\t\n\t\t\t\tvar matrixWorld = this.object.matrixWorld;\n\t\n\t\t\t\tvar position = this.geometry.attributes.position;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\t\tvar vertices = objGeometry.vertices;\n\t\n\t\t\t\tvar faces = objGeometry.faces;\n\t\n\t\t\t\tvar idx = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\tvar normal = face.normal;\n\t\n\t\t\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t\t\t.divideScalar( 3 )\n\t\t\t\t\t\t.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction DirectionalLightHelper( light, size ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tif ( size === undefined ) size = 1;\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new Float32Attribute( [\n\t\t\t\t- size,   size, 0,\n\t\t\t\t  size,   size, 0,\n\t\t\t\t  size, - size, 0,\n\t\t\t\t- size, - size, 0,\n\t\t\t\t- size,   size, 0\n\t\t\t], 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { fog: false } );\n\t\n\t\t\tthis.add( new Line( geometry, material ) );\n\t\n\t\t\tgeometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\t\n\t\t\tthis.add( new Line( geometry, material ));\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\n\t\tDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\n\t\n\t\tDirectionalLightHelper.prototype.dispose = function () {\n\t\n\t\t\tvar lightPlane = this.children[ 0 ];\n\t\t\tvar targetLine = this.children[ 1 ];\n\t\n\t\t\tlightPlane.geometry.dispose();\n\t\t\tlightPlane.material.dispose();\n\t\t\ttargetLine.geometry.dispose();\n\t\t\ttargetLine.material.dispose();\n\t\n\t\t};\n\t\n\t\tDirectionalLightHelper.prototype.update = function () {\n\t\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\t\t\tvar v3 = new Vector3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t\t\tv3.subVectors( v2, v1 );\n\t\n\t\t\t\tvar lightPlane = this.children[ 0 ];\n\t\t\t\tvar targetLine = this.children[ 1 ];\n\t\n\t\t\t\tlightPlane.lookAt( v3 );\n\t\t\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t\t\ttargetLine.lookAt( v3 );\n\t\t\t\ttargetLine.scale.z = v3.length();\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t *\t- shows frustum, line of sight and up of the camera\n\t\t *\t- suitable for fast updates\n\t\t * \t- based on frustum visualization in lightgl.js shadowmap example\n\t\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\t\t */\n\t\n\t\tfunction CameraHelper( camera ) {\n\t\n\t\t\tvar geometry = new Geometry();\n\t\t\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\n\t\n\t\t\tvar pointMap = {};\n\t\n\t\t\t// colors\n\t\n\t\t\tvar hexFrustum = 0xffaa00;\n\t\t\tvar hexCone = 0xff0000;\n\t\t\tvar hexUp = 0x00aaff;\n\t\t\tvar hexTarget = 0xffffff;\n\t\t\tvar hexCross = 0x333333;\n\t\n\t\t\t// near\n\t\n\t\t\taddLine( \"n1\", \"n2\", hexFrustum );\n\t\t\taddLine( \"n2\", \"n4\", hexFrustum );\n\t\t\taddLine( \"n4\", \"n3\", hexFrustum );\n\t\t\taddLine( \"n3\", \"n1\", hexFrustum );\n\t\n\t\t\t// far\n\t\n\t\t\taddLine( \"f1\", \"f2\", hexFrustum );\n\t\t\taddLine( \"f2\", \"f4\", hexFrustum );\n\t\t\taddLine( \"f4\", \"f3\", hexFrustum );\n\t\t\taddLine( \"f3\", \"f1\", hexFrustum );\n\t\n\t\t\t// sides\n\t\n\t\t\taddLine( \"n1\", \"f1\", hexFrustum );\n\t\t\taddLine( \"n2\", \"f2\", hexFrustum );\n\t\t\taddLine( \"n3\", \"f3\", hexFrustum );\n\t\t\taddLine( \"n4\", \"f4\", hexFrustum );\n\t\n\t\t\t// cone\n\t\n\t\t\taddLine( \"p\", \"n1\", hexCone );\n\t\t\taddLine( \"p\", \"n2\", hexCone );\n\t\t\taddLine( \"p\", \"n3\", hexCone );\n\t\t\taddLine( \"p\", \"n4\", hexCone );\n\t\n\t\t\t// up\n\t\n\t\t\taddLine( \"u1\", \"u2\", hexUp );\n\t\t\taddLine( \"u2\", \"u3\", hexUp );\n\t\t\taddLine( \"u3\", \"u1\", hexUp );\n\t\n\t\t\t// target\n\t\n\t\t\taddLine( \"c\", \"t\", hexTarget );\n\t\t\taddLine( \"p\", \"c\", hexCross );\n\t\n\t\t\t// cross\n\t\n\t\t\taddLine( \"cn1\", \"cn2\", hexCross );\n\t\t\taddLine( \"cn3\", \"cn4\", hexCross );\n\t\n\t\t\taddLine( \"cf1\", \"cf2\", hexCross );\n\t\t\taddLine( \"cf3\", \"cf4\", hexCross );\n\t\n\t\t\tfunction addLine( a, b, hex ) {\n\t\n\t\t\t\taddPoint( a, hex );\n\t\t\t\taddPoint( b, hex );\n\t\n\t\t\t}\n\t\n\t\t\tfunction addPoint( id, hex ) {\n\t\n\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\tgeometry.colors.push( new Color( hex ) );\n\t\n\t\t\t\tif ( pointMap[ id ] === undefined ) {\n\t\n\t\t\t\t\tpointMap[ id ] = [];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\t\n\t\t\t}\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t\tthis.camera = camera;\n\t\t\tif( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\t\n\t\t\tthis.matrix = camera.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.pointMap = pointMap;\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tCameraHelper.prototype = Object.create( LineSegments.prototype );\n\t\tCameraHelper.prototype.constructor = CameraHelper;\n\t\n\t\tCameraHelper.prototype.update = function () {\n\t\n\t\t\tvar geometry, pointMap;\n\t\n\t\t\tvar vector = new Vector3();\n\t\t\tvar camera = new Camera();\n\t\n\t\t\tfunction setPoint( point, x, y, z ) {\n\t\n\t\t\t\tvector.set( x, y, z ).unproject( camera );\n\t\n\t\t\t\tvar points = pointMap[ point ];\n\t\n\t\t\t\tif ( points !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tgeometry = this.geometry;\n\t\t\t\tpointMap = this.pointMap;\n\t\n\t\t\t\tvar w = 1, h = 1;\n\t\n\t\t\t\t// we need just camera projection matrix\n\t\t\t\t// world matrix must be identity\n\t\n\t\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\t\n\t\t\t\t// center / target\n\t\n\t\t\t\tsetPoint( \"c\", 0, 0, - 1 );\n\t\t\t\tsetPoint( \"t\", 0, 0,  1 );\n\t\n\t\t\t\t// near\n\t\n\t\t\t\tsetPoint( \"n1\", - w, - h, - 1 );\n\t\t\t\tsetPoint( \"n2\",   w, - h, - 1 );\n\t\t\t\tsetPoint( \"n3\", - w,   h, - 1 );\n\t\t\t\tsetPoint( \"n4\",   w,   h, - 1 );\n\t\n\t\t\t\t// far\n\t\n\t\t\t\tsetPoint( \"f1\", - w, - h, 1 );\n\t\t\t\tsetPoint( \"f2\",   w, - h, 1 );\n\t\t\t\tsetPoint( \"f3\", - w,   h, 1 );\n\t\t\t\tsetPoint( \"f4\",   w,   h, 1 );\n\t\n\t\t\t\t// up\n\t\n\t\t\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n\t\t\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n\t\t\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\n\t\n\t\t\t\t// cross\n\t\n\t\t\t\tsetPoint( \"cf1\", - w,   0, 1 );\n\t\t\t\tsetPoint( \"cf2\",   w,   0, 1 );\n\t\t\t\tsetPoint( \"cf3\",   0, - h, 1 );\n\t\t\t\tsetPoint( \"cf4\",   0,   h, 1 );\n\t\n\t\t\t\tsetPoint( \"cn1\", - w,   0, - 1 );\n\t\t\t\tsetPoint( \"cn2\",   w,   0, - 1 );\n\t\t\t\tsetPoint( \"cn3\",   0, - h, - 1 );\n\t\t\t\tsetPoint( \"cn4\",   0,   h, - 1 );\n\t\n\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\t// a helper to show the world-axis-aligned bounding box for an object\n\t\n\t\tfunction BoundingBoxHelper( object, hex ) {\n\t\n\t\t\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\t\n\t\t\tthis.object = object;\n\t\n\t\t\tthis.box = new Box3();\n\t\n\t\t\tMesh.call( this, new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( { color: color, wireframe: true } ) );\n\t\n\t\t}\n\t\n\t\tBoundingBoxHelper.prototype = Object.create( Mesh.prototype );\n\t\tBoundingBoxHelper.prototype.constructor = BoundingBoxHelper;\n\t\n\t\tBoundingBoxHelper.prototype.update = function () {\n\t\n\t\t\tthis.box.setFromObject( this.object );\n\t\n\t\t\tthis.box.getSize( this.scale );\n\t\n\t\t\tthis.box.getCenter( this.position );\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction BoxHelper( object, color ) {\n\t\n\t\t\tif ( color === undefined ) color = 0xffff00;\n\t\n\t\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\t\tvar positions = new Float32Array( 8 * 3 );\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\n\t\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\t\n\t\t\tif ( object !== undefined ) {\n\t\n\t\t\t\tthis.update( object );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tBoxHelper.prototype = Object.create( LineSegments.prototype );\n\t\tBoxHelper.prototype.constructor = BoxHelper;\n\t\n\t\tBoxHelper.prototype.update = ( function () {\n\t\n\t\t\tvar box = new Box3();\n\t\n\t\t\treturn function update( object ) {\n\t\n\t\t\t\tif ( (object && object.isBox3) ) {\n\t\n\t\t\t\t\tbox.copy( object );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tbox.setFromObject( object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( box.isEmpty() ) return;\n\t\n\t\t\t\tvar min = box.min;\n\t\t\t\tvar max = box.max;\n\t\n\t\t\t\t/*\n\t\t\t\t  5____4\n\t\t\t\t1/___0/|\n\t\t\t\t| 6__|_7\n\t\t\t\t2/___3/\n\t\n\t\t\t\t0: max.x, max.y, max.z\n\t\t\t\t1: min.x, max.y, max.z\n\t\t\t\t2: min.x, min.y, max.z\n\t\t\t\t3: max.x, min.y, max.z\n\t\t\t\t4: max.x, max.y, min.z\n\t\t\t\t5: min.x, max.y, min.z\n\t\t\t\t6: min.x, min.y, min.z\n\t\t\t\t7: max.x, min.y, min.z\n\t\t\t\t*/\n\t\n\t\t\t\tvar position = this.geometry.attributes.position;\n\t\t\t\tvar array = position.array;\n\t\n\t\t\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n\t\t\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n\t\t\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n\t\t\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\t\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\t\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\t\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\t\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\t\n\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t\tthis.geometry.computeBoundingSphere();\n\t\n\t\t\t};\n\t\n\t\t} )();\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author zz85 / http://github.com/zz85\n\t\t * @author bhouston / http://clara.io\n\t\t *\n\t\t * Creates an arrow for visualizing directions\n\t\t *\n\t\t * Parameters:\n\t\t *  dir - Vector3\n\t\t *  origin - Vector3\n\t\t *  length - Number\n\t\t *  color - color in hex value\n\t\t *  headLength - Number\n\t\t *  headWidth - Number\n\t\t */\n\t\n\t\tvar lineGeometry = new BufferGeometry();\n\t\tlineGeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\t\n\t\tvar coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\t\tconeGeometry.translate( 0, - 0.5, 0 );\n\t\n\t\tfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\t\n\t\t\t// dir is assumed to be normalized\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tif ( color === undefined ) color = 0xffff00;\n\t\t\tif ( length === undefined ) length = 1;\n\t\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\t\n\t\t\tthis.position.copy( origin );\n\t\n\t\t\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\n\t\t\tthis.line.matrixAutoUpdate = false;\n\t\t\tthis.add( this.line );\n\t\n\t\t\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\n\t\t\tthis.cone.matrixAutoUpdate = false;\n\t\t\tthis.add( this.cone );\n\t\n\t\t\tthis.setDirection( dir );\n\t\t\tthis.setLength( length, headLength, headWidth );\n\t\n\t\t}\n\t\n\t\tArrowHelper.prototype = Object.create( Object3D.prototype );\n\t\tArrowHelper.prototype.constructor = ArrowHelper;\n\t\n\t\tArrowHelper.prototype.setDirection = ( function () {\n\t\n\t\t\tvar axis = new Vector3();\n\t\t\tvar radians;\n\t\n\t\t\treturn function setDirection( dir ) {\n\t\n\t\t\t\t// dir is assumed to be normalized\n\t\n\t\t\t\tif ( dir.y > 0.99999 ) {\n\t\n\t\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\t\n\t\t\t\t} else if ( dir.y < - 0.99999 ) {\n\t\n\t\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\t\n\t\t\t\t\tradians = Math.acos( dir.y );\n\t\n\t\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\tArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\t\n\t\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\t\n\t\t\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\t\t\tthis.line.updateMatrix();\n\t\n\t\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\t\tthis.cone.position.y = length;\n\t\t\tthis.cone.updateMatrix();\n\t\n\t\t};\n\t\n\t\tArrowHelper.prototype.setColor = function ( color ) {\n\t\n\t\t\tthis.line.material.color.copy( color );\n\t\t\tthis.cone.material.color.copy( color );\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author sroucheray / http://sroucheray.org/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction AxisHelper( size ) {\n\t\n\t\t\tsize = size || 1;\n\t\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t0, 0, 0,  size, 0, 0,\n\t\t\t\t0, 0, 0,  0, size, 0,\n\t\t\t\t0, 0, 0,  0, 0, size\n\t\t\t] );\n\t\n\t\t\tvar colors = new Float32Array( [\n\t\t\t\t1, 0, 0,  1, 0.6, 0,\n\t\t\t\t0, 1, 0,  0.6, 1, 0,\n\t\t\t\t0, 0, 1,  0, 0.6, 1\n\t\t\t] );\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t}\n\t\n\t\tAxisHelper.prototype = Object.create( LineSegments.prototype );\n\t\tAxisHelper.prototype.constructor = AxisHelper;\n\t\n\t\t/**\n\t\t * @author zz85 https://github.com/zz85\n\t\t *\n\t\t * Centripetal CatmullRom Curve - which is useful for avoiding\n\t\t * cusps and self-intersections in non-uniform catmull rom curves.\n\t\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\t\t *\n\t\t * curve.type accepts centripetal(default), chordal and catmullrom\n\t\t * curve.tension is used for catmullrom which defaults to 0.5\n\t\t */\n\t\n\t\tvar CatmullRomCurve3 = ( function() {\n\t\n\t\t\tvar\n\t\t\t\ttmp = new Vector3(),\n\t\t\t\tpx = new CubicPoly(),\n\t\t\t\tpy = new CubicPoly(),\n\t\t\t\tpz = new CubicPoly();\n\t\n\t\t\t/*\n\t\t\tBased on an optimized c++ solution in\n\t\t\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t\t\t - http://ideone.com/NoEbVM\n\t\n\t\t\tThis CubicPoly class could be used for reusing some variables and calculations,\n\t\t\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\t\t\twhich can be placed in CurveUtils.\n\t\t\t*/\n\t\n\t\t\tfunction CubicPoly() {}\n\t\n\t\t\t/*\n\t\t\t * Compute coefficients for a cubic polynomial\n\t\t\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t\t\t * such that\n\t\t\t *   p(0) = x0, p(1) = x1\n\t\t\t *  and\n\t\t\t *   p'(0) = t0, p'(1) = t1.\n\t\t\t */\n\t\t\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\n\t\n\t\t\t\tthis.c0 = x0;\n\t\t\t\tthis.c1 = t0;\n\t\t\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\t\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\t\n\t\t\t};\n\t\n\t\t\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\t\n\t\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\t\n\t\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\t\tt1 *= dt1;\n\t\t\t\tt2 *= dt1;\n\t\n\t\t\t\t// initCubicPoly\n\t\t\t\tthis.init( x1, x2, t1, t2 );\n\t\n\t\t\t};\n\t\n\t\t\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\t\t\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\n\t\n\t\t\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\t\n\t\t\t};\n\t\n\t\t\tCubicPoly.prototype.calc = function( t ) {\n\t\n\t\t\t\tvar t2 = t * t;\n\t\t\t\tvar t3 = t2 * t;\n\t\t\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n\t\n\t\t\t};\n\t\n\t\t\t// Subclass Three.js curve\n\t\t\treturn Curve.create(\n\t\n\t\t\t\tfunction ( p /* array of Vector3 */ ) {\n\t\n\t\t\t\t\tthis.points = p || [];\n\t\t\t\t\tthis.closed = false;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction ( t ) {\n\t\n\t\t\t\t\tvar points = this.points,\n\t\t\t\t\t\tpoint, intPoint, weight, l;\n\t\n\t\t\t\t\tl = points.length;\n\t\n\t\t\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\t\n\t\t\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\t\t\tintPoint = Math.floor( point );\n\t\t\t\t\tweight = point - intPoint;\n\t\n\t\t\t\t\tif ( this.closed ) {\n\t\n\t\t\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\t\n\t\t\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\t\n\t\t\t\t\t\tintPoint = l - 2;\n\t\t\t\t\t\tweight = 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar p0, p1, p2, p3; // 4 points\n\t\n\t\t\t\t\tif ( this.closed || intPoint > 0 ) {\n\t\n\t\t\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// extrapolate first point\n\t\t\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\t\t\tp0 = tmp;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tp1 = points[ intPoint % l ];\n\t\t\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\t\n\t\t\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\t\n\t\t\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// extrapolate last point\n\t\t\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\t\t\tp3 = tmp;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\t\n\t\t\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\n\t\t\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\t\n\t\t\t\t\t\t// safety check for repeated points\n\t\t\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\t\n\t\t\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\t\n\t\t\t\t\t} else if ( this.type === 'catmullrom' ) {\n\t\n\t\t\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\n\t\t\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n\t\t\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n\t\t\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar v = new Vector3(\n\t\t\t\t\t\tpx.calc( weight ),\n\t\t\t\t\t\tpy.calc( weight ),\n\t\t\t\t\t\tpz.calc( weight )\n\t\t\t\t\t);\n\t\n\t\t\t\t\treturn v;\n\t\n\t\t\t\t}\n\t\n\t\t\t);\n\t\n\t\t} )();\n\t\n\t\t/**************************************************************\n\t\t *\tClosed Spline 3D curve\n\t\t **************************************************************/\n\t\n\t\n\t\tfunction ClosedSplineCurve3( points ) {\n\t\n\t\t\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\n\t\n\t\t\tCatmullRomCurve3.call( this, points );\n\t\t\tthis.type = 'catmullrom';\n\t\t\tthis.closed = true;\n\t\n\t\t}\n\t\n\t\tClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\t\n\t\t/**************************************************************\n\t\t *\tSpline 3D curve\n\t\t **************************************************************/\n\t\n\t\n\t\tvar SplineCurve3 = Curve.create(\n\t\n\t\t\tfunction ( points /* array of Vector3 */ ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\n\t\t\t\tthis.points = ( points === undefined ) ? [] : points;\n\t\n\t\t\t},\n\t\n\t\t\tfunction ( t ) {\n\t\n\t\t\t\tvar points = this.points;\n\t\t\t\tvar point = ( points.length - 1 ) * t;\n\t\n\t\t\t\tvar intPoint = Math.floor( point );\n\t\t\t\tvar weight = point - intPoint;\n\t\n\t\t\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\n\t\t\t\tvar point1 = points[ intPoint ];\n\t\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\t\n\t\t\t\tvar interpolate = CurveUtils.interpolate;\n\t\n\t\t\t\treturn new Vector3(\n\t\t\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\n\t\t\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\n\t\t\t\t);\n\t\n\t\t\t}\n\t\n\t\t);\n\t\n\t\t/**************************************************************\n\t\t *\tCubic Bezier 3D curve\n\t\t **************************************************************/\n\t\n\t\tvar CubicBezierCurve3 = Curve.create(\n\t\n\t\t\tfunction ( v0, v1, v2, v3 ) {\n\t\n\t\t\t\tthis.v0 = v0;\n\t\t\t\tthis.v1 = v1;\n\t\t\t\tthis.v2 = v2;\n\t\t\t\tthis.v3 = v3;\n\t\n\t\t\t},\n\t\n\t\t\tfunction ( t ) {\n\t\n\t\t\t\tvar b3 = ShapeUtils.b3;\n\t\n\t\t\t\treturn new Vector3(\n\t\t\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\n\t\t\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\n\t\t\t\t);\n\t\n\t\t\t}\n\t\n\t\t);\n\t\n\t\t/**************************************************************\n\t\t *\tQuadratic Bezier 3D curve\n\t\t **************************************************************/\n\t\n\t\tvar QuadraticBezierCurve3 = Curve.create(\n\t\n\t\t\tfunction ( v0, v1, v2 ) {\n\t\n\t\t\t\tthis.v0 = v0;\n\t\t\t\tthis.v1 = v1;\n\t\t\t\tthis.v2 = v2;\n\t\n\t\t\t},\n\t\n\t\t\tfunction ( t ) {\n\t\n\t\t\t\tvar b2 = ShapeUtils.b2;\n\t\n\t\t\t\treturn new Vector3(\n\t\t\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\n\t\t\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\n\t\t\t\t);\n\t\n\t\t\t}\n\t\n\t\t);\n\t\n\t\t/**************************************************************\n\t\t *\tLine3D\n\t\t **************************************************************/\n\t\n\t\tvar LineCurve3 = Curve.create(\n\t\n\t\t\tfunction ( v1, v2 ) {\n\t\n\t\t\t\tthis.v1 = v1;\n\t\t\t\tthis.v2 = v2;\n\t\n\t\t\t},\n\t\n\t\t\tfunction ( t ) {\n\t\n\t\t\t\tif ( t === 1 ) {\n\t\n\t\t\t\t\treturn this.v2.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar vector = new Vector3();\n\t\n\t\t\t\tvector.subVectors( this.v2, this.v1 ); // diff\n\t\t\t\tvector.multiplyScalar( t );\n\t\t\t\tvector.add( this.v1 );\n\t\n\t\t\t\treturn vector;\n\t\n\t\t\t}\n\t\n\t\t);\n\t\n\t\t/**************************************************************\n\t\t *\tArc curve\n\t\t **************************************************************/\n\t\n\t\tfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\t\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\t\n\t\t}\n\t\n\t\tArcCurve.prototype = Object.create( EllipseCurve.prototype );\n\t\tArcCurve.prototype.constructor = ArcCurve;\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tvar SceneUtils = {\n\t\n\t\t\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\t\n\t\t\t\tvar group = new Group();\n\t\n\t\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tgroup.add( new Mesh( geometry, materials[ i ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn group;\n\t\n\t\t\t},\n\t\n\t\t\tdetach: function ( child, parent, scene ) {\n\t\n\t\t\t\tchild.applyMatrix( parent.matrixWorld );\n\t\t\t\tparent.remove( child );\n\t\t\t\tscene.add( child );\n\t\n\t\t\t},\n\t\n\t\t\tattach: function ( child, scene, parent ) {\n\t\n\t\t\t\tvar matrixWorldInverse = new Matrix4();\n\t\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\t\t\tchild.applyMatrix( matrixWorldInverse );\n\t\n\t\t\t\tscene.remove( child );\n\t\t\t\tparent.add( child );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Face4 ( a, b, c, d, normal, color, materialIndex ) {\n\t\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\t\treturn new Face3( a, b, c, normal, color, materialIndex );\n\t\t}\n\t\n\t\tvar LineStrip = 0;\n\t\n\t\tvar LinePieces = 1;\n\t\n\t\tfunction PointCloud ( geometry, material ) {\n\t\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\t\treturn new Points( geometry, material );\n\t\t}\n\t\n\t\tfunction ParticleSystem ( geometry, material ) {\n\t\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\t\treturn new Points( geometry, material );\n\t\t}\n\t\n\t\tfunction PointCloudMaterial ( parameters ) {\n\t\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new PointsMaterial( parameters );\n\t\t}\n\t\n\t\tfunction ParticleBasicMaterial ( parameters ) {\n\t\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new PointsMaterial( parameters );\n\t\t}\n\t\n\t\tfunction ParticleSystemMaterial ( parameters ) {\n\t\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new PointsMaterial( parameters );\n\t\t}\n\t\n\t\tfunction Vertex ( x, y, z ) {\n\t\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\t\treturn new Vector3( x, y, z );\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction EdgesHelper( object, hex ) {\n\t\t\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\n\t\t\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t\t}\n\t\n\t\tfunction WireframeHelper( object, hex ) {\n\t\t\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\n\t\t\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t\t}\n\t\n\t\t//\n\t\n\t\tObject.assign( Box2.prototype, {\n\t\t\tcenter: function ( optionalTarget ) {\n\t\t\t\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\n\t\t\t\treturn this.getCenter( optionalTarget );\n\t\t\t},\n\t\t\tempty: function () {\n\t\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\t\t\treturn this.isEmpty();\n\t\t\t},\n\t\t\tisIntersectionBox: function ( box ) {\n\t\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\t\treturn this.intersectsBox( box );\n\t\t\t},\n\t\t\tsize: function ( optionalTarget ) {\n\t\t\t\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\n\t\t\t\treturn this.getSize( optionalTarget );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Box3.prototype, {\n\t\t\tcenter: function ( optionalTarget ) {\n\t\t\t\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\n\t\t\t\treturn this.getCenter( optionalTarget );\n\t\t\t},\n\t\t\tempty: function () {\n\t\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\t\t\treturn this.isEmpty();\n\t\t\t},\n\t\t\tisIntersectionBox: function ( box ) {\n\t\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\t\treturn this.intersectsBox( box );\n\t\t\t},\n\t\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\t\treturn this.intersectsSphere( sphere );\n\t\t\t},\n\t\t\tsize: function ( optionalTarget ) {\n\t\t\t\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\n\t\t\t\treturn this.getSize( optionalTarget );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Line3.prototype, {\n\t\t\tcenter: function ( optionalTarget ) {\n\t\t\t\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\n\t\t\t\treturn this.getCenter( optionalTarget );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Matrix3.prototype, {\n\t\t\tmultiplyVector3: function ( vector ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\t\t\treturn vector.applyMatrix3( this );\n\t\t\t},\n\t\t\tmultiplyVector3Array: function ( a ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\t\treturn this.applyToVector3Array( a );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Matrix4.prototype, {\n\t\t\textractPosition: function ( m ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\t\t\treturn this.copyPosition( m );\n\t\t\t},\n\t\t\tsetRotationFromQuaternion: function ( q ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\t\t\treturn this.makeRotationFromQuaternion( q );\n\t\t\t},\n\t\t\tmultiplyVector3: function ( vector ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\t\t\treturn vector.applyProjection( this );\n\t\t\t},\n\t\t\tmultiplyVector4: function ( vector ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\t\treturn vector.applyMatrix4( this );\n\t\t\t},\n\t\t\tmultiplyVector3Array: function ( a ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\t\treturn this.applyToVector3Array( a );\n\t\t\t},\n\t\t\trotateAxis: function ( v ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\t\t\tv.transformDirection( this );\n\t\t\t},\n\t\t\tcrossVector: function ( vector ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\t\treturn vector.applyMatrix4( this );\n\t\t\t},\n\t\t\ttranslate: function ( v ) {\n\t\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t\t\t},\n\t\t\trotateX: function ( angle ) {\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t\t\t},\n\t\t\trotateY: function ( angle ) {\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t\t\t},\n\t\t\trotateZ: function ( angle ) {\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t\t\t},\n\t\t\trotateByAxis: function ( axis, angle ) {\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Plane.prototype, {\n\t\t\tisIntersectionLine: function ( line ) {\n\t\t\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\t\t\treturn this.intersectsLine( line );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Quaternion.prototype, {\n\t\t\tmultiplyVector3: function ( vector ) {\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\t\t\treturn vector.applyQuaternion( this );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Ray.prototype, {\n\t\t\tisIntersectionBox: function ( box ) {\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\t\treturn this.intersectsBox( box );\n\t\t\t},\n\t\t\tisIntersectionPlane: function ( plane ) {\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\t\t\treturn this.intersectsPlane( plane );\n\t\t\t},\n\t\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\t\treturn this.intersectsSphere( sphere );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Shape.prototype, {\n\t\t\textrude: function ( options ) {\n\t\t\t\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\n\t\t\t\treturn new ExtrudeGeometry( this, options );\n\t\t\t},\n\t\t\tmakeGeometry: function ( options ) {\n\t\t\t\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\n\t\t\t\treturn new ShapeGeometry( this, options );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Vector3.prototype, {\n\t\t\tsetEulerFromRotationMatrix: function () {\n\t\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t\t\t},\n\t\t\tsetEulerFromQuaternion: function () {\n\t\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t\t\t},\n\t\t\tgetPositionFromMatrix: function ( m ) {\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\t\t\treturn this.setFromMatrixPosition( m );\n\t\t\t},\n\t\t\tgetScaleFromMatrix: function ( m ) {\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\t\t\treturn this.setFromMatrixScale( m );\n\t\t\t},\n\t\t\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\t\t\treturn this.setFromMatrixColumn( matrix, index );\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.assign( Object3D.prototype, {\n\t\t\tgetChildByName: function ( name ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\t\t\treturn this.getObjectByName( name );\n\t\t\t},\n\t\t\trenderDepth: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t\t\t},\n\t\t\ttranslate: function ( distance, axis ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\t\t\treturn this.translateOnAxis( axis, distance );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( Object3D.prototype, {\n\t\t\teulerOrder: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\t\treturn this.rotation.order;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\t\tthis.rotation.order = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tuseQuaternion: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( LOD.prototype, {\n\t\t\tobjects: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\t\t\treturn this.levels;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\t\n\t\t\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\t\n\t\t\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\t\t\tthis.setFocalLength( focalLength );\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( Light.prototype, {\n\t\t\tonlyShadow: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraFov: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\t\t\tthis.shadow.camera.fov = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraLeft: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\t\t\tthis.shadow.camera.left = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraRight: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\t\t\tthis.shadow.camera.right = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraTop: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\t\t\tthis.shadow.camera.top = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraBottom: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\t\t\tthis.shadow.camera.bottom = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraNear: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\t\t\tthis.shadow.camera.near = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraFar: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\t\t\tthis.shadow.camera.far = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraVisible: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowBias: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\t\t\tthis.shadow.bias = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowDarkness: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowMapWidth: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\t\t\tthis.shadow.mapSize.width = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowMapHeight: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\t\t\tthis.shadow.mapSize.height = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( BufferAttribute.prototype, {\n\t\t\tlength: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\t\t\treturn this.array.length;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( BufferGeometry.prototype, {\n\t\t\taddIndex: function ( index ) {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\t\t\tthis.setIndex( index );\n\t\t\t},\n\t\t\taddDrawCall: function ( start, count, indexOffset ) {\n\t\t\t\tif ( indexOffset !== undefined ) {\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\t\t\t}\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\t\t\tthis.addGroup( start, count );\n\t\t\t},\n\t\t\tclearDrawCalls: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\t\t\tthis.clearGroups();\n\t\t\t},\n\t\t\tcomputeTangents: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t\t\t},\n\t\t\tcomputeOffsets: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( BufferGeometry.prototype, {\n\t\t\tdrawcalls: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\t\t\treturn this.groups;\n\t\t\t\t}\n\t\t\t},\n\t\t\toffsets: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\t\t\treturn this.groups;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( Material.prototype, {\n\t\t\twrapAround: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t\t}\n\t\t\t},\n\t\t\twrapRGB: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n\t\t\t\t\treturn new Color();\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( MeshPhongMaterial.prototype, {\n\t\t\tmetal: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( ShaderMaterial.prototype, {\n\t\t\tderivatives: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\t\treturn this.extensions.derivatives;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\t\tthis.extensions.derivatives = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tEventDispatcher.prototype = Object.assign( Object.create( {\n\t\n\t\t\t// Note: Extra base ensures these properties are not 'assign'ed.\n\t\n\t\t\tconstructor: EventDispatcher,\n\t\n\t\t\tapply: function ( target ) {\n\t\n\t\t\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\n\t\t\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\n\t\n\t\t\t\tObject.assign( target, this );\n\t\n\t\t\t}\n\t\n\t\t} ), EventDispatcher.prototype );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( Uniform.prototype, {\n\t\t\tdynamic: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t\t}\n\t\t\t},\n\t\t\tonUpdate: {\n\t\t\t\tvalue: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.assign( WebGLRenderer.prototype, {\n\t\t\tsupportsFloatTextures: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\t\t\treturn this.extensions.get( 'OES_texture_float' );\n\t\t\t},\n\t\t\tsupportsHalfFloatTextures: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t\t\t},\n\t\t\tsupportsStandardDerivatives: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t\t\t},\n\t\t\tsupportsCompressedTextureS3TC: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\t\t},\n\t\t\tsupportsCompressedTexturePVRTC: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\t\t},\n\t\t\tsupportsBlendMinMax: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t\t\t},\n\t\t\tsupportsVertexTextures: function () {\n\t\t\t\treturn this.capabilities.vertexTextures;\n\t\t\t},\n\t\t\tsupportsInstancedArrays: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t\t\t},\n\t\t\tenableScissorTest: function ( boolean ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\t\t\tthis.setScissorTest( boolean );\n\t\t\t},\n\t\t\tinitMaterial: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t\t\t},\n\t\t\taddPrePlugin: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t\t\t},\n\t\t\taddPostPlugin: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t\t\t},\n\t\t\tupdateShadowMap: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( WebGLRenderer.prototype, {\n\t\t\tshadowMapEnabled: {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.shadowMap.enabled;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\t\t\tthis.shadowMap.enabled = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowMapType: {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.shadowMap.type;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\t\t\tthis.shadowMap.type = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowMapCullFace: {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.shadowMap.cullFace;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n\t\t\t\t\tthis.shadowMap.cullFace = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( WebGLShadowMap.prototype, {\n\t\t\tcullFace: {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.renderReverseSided ? CullFaceFront : CullFaceBack;\n\t\t\t\t},\n\t\t\t\tset: function ( cullFace ) {\n\t\t\t\t\tvar value = ( cullFace !== CullFaceBack );\n\t\t\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n\t\t\t\t\tthis.renderReverseSided = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( WebGLRenderTarget.prototype, {\n\t\t\twrapS: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\t\treturn this.texture.wrapS;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\t\tthis.texture.wrapS = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\twrapT: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\t\treturn this.texture.wrapT;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\t\tthis.texture.wrapT = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tmagFilter: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\t\treturn this.texture.magFilter;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\t\tthis.texture.magFilter = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tminFilter: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\t\treturn this.texture.minFilter;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\t\tthis.texture.minFilter = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tanisotropy: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\t\treturn this.texture.anisotropy;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\t\tthis.texture.anisotropy = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\toffset: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\t\treturn this.texture.offset;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\t\tthis.texture.offset = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\trepeat: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\t\treturn this.texture.repeat;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\t\tthis.texture.repeat = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tformat: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\t\treturn this.texture.format;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\t\tthis.texture.format = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\ttype: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\t\treturn this.texture.type;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\t\tthis.texture.type = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tgenerateMipmaps: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\t\treturn this.texture.generateMipmaps;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\t\tthis.texture.generateMipmaps = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.assign( Audio.prototype, {\n\t\t\tload: function ( file ) {\n\t\t\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\n\t\t\t\tvar scope = this;\n\t\t\t\tvar audioLoader = new AudioLoader();\n\t\t\t\taudioLoader.load( file, function ( buffer ) {\n\t\t\t\t\tscope.setBuffer( buffer );\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( AudioAnalyser.prototype, {\n\t\t\tgetData: function ( file ) {\n\t\t\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\t\t\treturn this.getFrequencyData();\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tvar GeometryUtils = {\n\t\n\t\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\t\n\t\t\t\tvar matrix;\n\t\n\t\t\t\tif ( geometry2.isMesh ) {\n\t\n\t\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\t\n\t\t\t\t\tmatrix = geometry2.matrix;\n\t\t\t\t\tgeometry2 = geometry2.geometry;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\t\n\t\t\t},\n\t\n\t\t\tcenter: function ( geometry ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\t\t\treturn geometry.center();\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tvar ImageUtils = {\n\t\n\t\t\tcrossOrigin: undefined,\n\t\n\t\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\t\n\t\t\t\tvar loader = new TextureLoader();\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\t\n\t\t\t\tif ( mapping ) texture.mapping = mapping;\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\t\n\t\t\t\tvar loader = new CubeTextureLoader();\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\t\n\t\t\t\tif ( mapping ) texture.mapping = mapping;\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tloadCompressedTexture: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\t\n\t\t\t},\n\t\n\t\t\tloadCompressedTextureCube: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tfunction Projector () {\n\t\n\t\t\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\t\n\t\t\tthis.projectVector = function ( vector, camera ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\t\t\tvector.project( camera );\n\t\n\t\t\t};\n\t\n\t\t\tthis.unprojectVector = function ( vector, camera ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\t\t\tvector.unproject( camera );\n\t\n\t\t\t};\n\t\n\t\t\tthis.pickingRay = function ( vector, camera ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction CanvasRenderer () {\n\t\n\t\t\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\t\n\t\t\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tthis.clear = function () {};\n\t\t\tthis.render = function () {};\n\t\t\tthis.setClearColor = function () {};\n\t\t\tthis.setSize = function () {};\n\t\n\t\t}\n\t\n\t\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\n\t\texports.WebGLRenderTarget = WebGLRenderTarget;\n\t\texports.WebGLRenderer = WebGLRenderer;\n\t\texports.ShaderLib = ShaderLib;\n\t\texports.UniformsLib = UniformsLib;\n\t\texports.UniformsUtils = UniformsUtils;\n\t\texports.ShaderChunk = ShaderChunk;\n\t\texports.FogExp2 = FogExp2;\n\t\texports.Fog = Fog;\n\t\texports.Scene = Scene;\n\t\texports.LensFlare = LensFlare;\n\t\texports.Sprite = Sprite;\n\t\texports.LOD = LOD;\n\t\texports.SkinnedMesh = SkinnedMesh;\n\t\texports.Skeleton = Skeleton;\n\t\texports.Bone = Bone;\n\t\texports.Mesh = Mesh;\n\t\texports.LineSegments = LineSegments;\n\t\texports.Line = Line;\n\t\texports.Points = Points;\n\t\texports.Group = Group;\n\t\texports.VideoTexture = VideoTexture;\n\t\texports.DataTexture = DataTexture;\n\t\texports.CompressedTexture = CompressedTexture;\n\t\texports.CubeTexture = CubeTexture;\n\t\texports.CanvasTexture = CanvasTexture;\n\t\texports.DepthTexture = DepthTexture;\n\t\texports.TextureIdCount = TextureIdCount;\n\t\texports.Texture = Texture;\n\t\texports.MaterialIdCount = MaterialIdCount;\n\t\texports.CompressedTextureLoader = CompressedTextureLoader;\n\t\texports.BinaryTextureLoader = BinaryTextureLoader;\n\t\texports.DataTextureLoader = DataTextureLoader;\n\t\texports.CubeTextureLoader = CubeTextureLoader;\n\t\texports.TextureLoader = TextureLoader;\n\t\texports.ObjectLoader = ObjectLoader;\n\t\texports.MaterialLoader = MaterialLoader;\n\t\texports.BufferGeometryLoader = BufferGeometryLoader;\n\t\texports.DefaultLoadingManager = DefaultLoadingManager;\n\t\texports.LoadingManager = LoadingManager;\n\t\texports.JSONLoader = JSONLoader;\n\t\texports.ImageLoader = ImageLoader;\n\t\texports.FontLoader = FontLoader;\n\t\texports.XHRLoader = XHRLoader;\n\t\texports.Loader = Loader;\n\t\texports.Cache = Cache;\n\t\texports.AudioLoader = AudioLoader;\n\t\texports.SpotLightShadow = SpotLightShadow;\n\t\texports.SpotLight = SpotLight;\n\t\texports.PointLight = PointLight;\n\t\texports.HemisphereLight = HemisphereLight;\n\t\texports.DirectionalLightShadow = DirectionalLightShadow;\n\t\texports.DirectionalLight = DirectionalLight;\n\t\texports.AmbientLight = AmbientLight;\n\t\texports.LightShadow = LightShadow;\n\t\texports.Light = Light;\n\t\texports.StereoCamera = StereoCamera;\n\t\texports.PerspectiveCamera = PerspectiveCamera;\n\t\texports.OrthographicCamera = OrthographicCamera;\n\t\texports.CubeCamera = CubeCamera;\n\t\texports.Camera = Camera;\n\t\texports.AudioListener = AudioListener;\n\t\texports.PositionalAudio = PositionalAudio;\n\t\texports.getAudioContext = getAudioContext;\n\t\texports.AudioAnalyser = AudioAnalyser;\n\t\texports.Audio = Audio;\n\t\texports.VectorKeyframeTrack = VectorKeyframeTrack;\n\t\texports.StringKeyframeTrack = StringKeyframeTrack;\n\t\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\n\t\texports.NumberKeyframeTrack = NumberKeyframeTrack;\n\t\texports.ColorKeyframeTrack = ColorKeyframeTrack;\n\t\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\n\t\texports.PropertyMixer = PropertyMixer;\n\t\texports.PropertyBinding = PropertyBinding;\n\t\texports.KeyframeTrack = KeyframeTrack;\n\t\texports.AnimationUtils = AnimationUtils;\n\t\texports.AnimationObjectGroup = AnimationObjectGroup;\n\t\texports.AnimationMixer = AnimationMixer;\n\t\texports.AnimationClip = AnimationClip;\n\t\texports.Uniform = Uniform;\n\t\texports.InstancedBufferGeometry = InstancedBufferGeometry;\n\t\texports.BufferGeometry = BufferGeometry;\n\t\texports.GeometryIdCount = GeometryIdCount;\n\t\texports.Geometry = Geometry;\n\t\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\n\t\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\n\t\texports.InterleavedBuffer = InterleavedBuffer;\n\t\texports.InstancedBufferAttribute = InstancedBufferAttribute;\n\t\texports.DynamicBufferAttribute = DynamicBufferAttribute;\n\t\texports.Float64Attribute = Float64Attribute;\n\t\texports.Float32Attribute = Float32Attribute;\n\t\texports.Uint32Attribute = Uint32Attribute;\n\t\texports.Int32Attribute = Int32Attribute;\n\t\texports.Uint16Attribute = Uint16Attribute;\n\t\texports.Int16Attribute = Int16Attribute;\n\t\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\n\t\texports.Uint8Attribute = Uint8Attribute;\n\t\texports.Int8Attribute = Int8Attribute;\n\t\texports.BufferAttribute = BufferAttribute;\n\t\texports.Face3 = Face3;\n\t\texports.Object3DIdCount = Object3DIdCount;\n\t\texports.Object3D = Object3D;\n\t\texports.Raycaster = Raycaster;\n\t\texports.Layers = Layers;\n\t\texports.EventDispatcher = EventDispatcher;\n\t\texports.Clock = Clock;\n\t\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\n\t\texports.LinearInterpolant = LinearInterpolant;\n\t\texports.DiscreteInterpolant = DiscreteInterpolant;\n\t\texports.CubicInterpolant = CubicInterpolant;\n\t\texports.Interpolant = Interpolant;\n\t\texports.Triangle = Triangle;\n\t\texports.Spline = Spline;\n\t\texports.Math = _Math;\n\t\texports.Spherical = Spherical;\n\t\texports.Plane = Plane;\n\t\texports.Frustum = Frustum;\n\t\texports.Sphere = Sphere;\n\t\texports.Ray = Ray;\n\t\texports.Matrix4 = Matrix4;\n\t\texports.Matrix3 = Matrix3;\n\t\texports.Box3 = Box3;\n\t\texports.Box2 = Box2;\n\t\texports.Line3 = Line3;\n\t\texports.Euler = Euler;\n\t\texports.Vector4 = Vector4;\n\t\texports.Vector3 = Vector3;\n\t\texports.Vector2 = Vector2;\n\t\texports.Quaternion = Quaternion;\n\t\texports.ColorKeywords = ColorKeywords;\n\t\texports.Color = Color;\n\t\texports.MorphBlendMesh = MorphBlendMesh;\n\t\texports.ImmediateRenderObject = ImmediateRenderObject;\n\t\texports.VertexNormalsHelper = VertexNormalsHelper;\n\t\texports.SpotLightHelper = SpotLightHelper;\n\t\texports.SkeletonHelper = SkeletonHelper;\n\t\texports.PointLightHelper = PointLightHelper;\n\t\texports.HemisphereLightHelper = HemisphereLightHelper;\n\t\texports.GridHelper = GridHelper;\n\t\texports.FaceNormalsHelper = FaceNormalsHelper;\n\t\texports.DirectionalLightHelper = DirectionalLightHelper;\n\t\texports.CameraHelper = CameraHelper;\n\t\texports.BoundingBoxHelper = BoundingBoxHelper;\n\t\texports.BoxHelper = BoxHelper;\n\t\texports.ArrowHelper = ArrowHelper;\n\t\texports.AxisHelper = AxisHelper;\n\t\texports.ClosedSplineCurve3 = ClosedSplineCurve3;\n\t\texports.CatmullRomCurve3 = CatmullRomCurve3;\n\t\texports.SplineCurve3 = SplineCurve3;\n\t\texports.CubicBezierCurve3 = CubicBezierCurve3;\n\t\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\n\t\texports.LineCurve3 = LineCurve3;\n\t\texports.ArcCurve = ArcCurve;\n\t\texports.EllipseCurve = EllipseCurve;\n\t\texports.SplineCurve = SplineCurve;\n\t\texports.CubicBezierCurve = CubicBezierCurve;\n\t\texports.QuadraticBezierCurve = QuadraticBezierCurve;\n\t\texports.LineCurve = LineCurve;\n\t\texports.Shape = Shape;\n\t\texports.ShapePath = ShapePath;\n\t\texports.Path = Path;\n\t\texports.Font = Font;\n\t\texports.CurvePath = CurvePath;\n\t\texports.Curve = Curve;\n\t\texports.ShapeUtils = ShapeUtils;\n\t\texports.SceneUtils = SceneUtils;\n\t\texports.CurveUtils = CurveUtils;\n\t\texports.WireframeGeometry = WireframeGeometry;\n\t\texports.ParametricGeometry = ParametricGeometry;\n\t\texports.ParametricBufferGeometry = ParametricBufferGeometry;\n\t\texports.TetrahedronGeometry = TetrahedronGeometry;\n\t\texports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;\n\t\texports.OctahedronGeometry = OctahedronGeometry;\n\t\texports.OctahedronBufferGeometry = OctahedronBufferGeometry;\n\t\texports.IcosahedronGeometry = IcosahedronGeometry;\n\t\texports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;\n\t\texports.DodecahedronGeometry = DodecahedronGeometry;\n\t\texports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;\n\t\texports.PolyhedronGeometry = PolyhedronGeometry;\n\t\texports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;\n\t\texports.TubeGeometry = TubeGeometry;\n\t\texports.TubeBufferGeometry = TubeBufferGeometry;\n\t\texports.TorusKnotGeometry = TorusKnotGeometry;\n\t\texports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;\n\t\texports.TorusGeometry = TorusGeometry;\n\t\texports.TorusBufferGeometry = TorusBufferGeometry;\n\t\texports.TextGeometry = TextGeometry;\n\t\texports.SphereBufferGeometry = SphereBufferGeometry;\n\t\texports.SphereGeometry = SphereGeometry;\n\t\texports.RingGeometry = RingGeometry;\n\t\texports.RingBufferGeometry = RingBufferGeometry;\n\t\texports.PlaneBufferGeometry = PlaneBufferGeometry;\n\t\texports.PlaneGeometry = PlaneGeometry;\n\t\texports.LatheGeometry = LatheGeometry;\n\t\texports.LatheBufferGeometry = LatheBufferGeometry;\n\t\texports.ShapeGeometry = ShapeGeometry;\n\t\texports.ExtrudeGeometry = ExtrudeGeometry;\n\t\texports.EdgesGeometry = EdgesGeometry;\n\t\texports.ConeGeometry = ConeGeometry;\n\t\texports.ConeBufferGeometry = ConeBufferGeometry;\n\t\texports.CylinderGeometry = CylinderGeometry;\n\t\texports.CylinderBufferGeometry = CylinderBufferGeometry;\n\t\texports.CircleBufferGeometry = CircleBufferGeometry;\n\t\texports.CircleGeometry = CircleGeometry;\n\t\texports.BoxBufferGeometry = BoxBufferGeometry;\n\t\texports.BoxGeometry = BoxGeometry;\n\t\texports.ShadowMaterial = ShadowMaterial;\n\t\texports.SpriteMaterial = SpriteMaterial;\n\t\texports.RawShaderMaterial = RawShaderMaterial;\n\t\texports.ShaderMaterial = ShaderMaterial;\n\t\texports.PointsMaterial = PointsMaterial;\n\t\texports.MultiMaterial = MultiMaterial;\n\t\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\n\t\texports.MeshStandardMaterial = MeshStandardMaterial;\n\t\texports.MeshPhongMaterial = MeshPhongMaterial;\n\t\texports.MeshNormalMaterial = MeshNormalMaterial;\n\t\texports.MeshLambertMaterial = MeshLambertMaterial;\n\t\texports.MeshDepthMaterial = MeshDepthMaterial;\n\t\texports.MeshBasicMaterial = MeshBasicMaterial;\n\t\texports.LineDashedMaterial = LineDashedMaterial;\n\t\texports.LineBasicMaterial = LineBasicMaterial;\n\t\texports.Material = Material;\n\t\texports.REVISION = REVISION;\n\t\texports.MOUSE = MOUSE;\n\t\texports.CullFaceNone = CullFaceNone;\n\t\texports.CullFaceBack = CullFaceBack;\n\t\texports.CullFaceFront = CullFaceFront;\n\t\texports.CullFaceFrontBack = CullFaceFrontBack;\n\t\texports.FrontFaceDirectionCW = FrontFaceDirectionCW;\n\t\texports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;\n\t\texports.BasicShadowMap = BasicShadowMap;\n\t\texports.PCFShadowMap = PCFShadowMap;\n\t\texports.PCFSoftShadowMap = PCFSoftShadowMap;\n\t\texports.FrontSide = FrontSide;\n\t\texports.BackSide = BackSide;\n\t\texports.DoubleSide = DoubleSide;\n\t\texports.FlatShading = FlatShading;\n\t\texports.SmoothShading = SmoothShading;\n\t\texports.NoColors = NoColors;\n\t\texports.FaceColors = FaceColors;\n\t\texports.VertexColors = VertexColors;\n\t\texports.NoBlending = NoBlending;\n\t\texports.NormalBlending = NormalBlending;\n\t\texports.AdditiveBlending = AdditiveBlending;\n\t\texports.SubtractiveBlending = SubtractiveBlending;\n\t\texports.MultiplyBlending = MultiplyBlending;\n\t\texports.CustomBlending = CustomBlending;\n\t\texports.BlendingMode = BlendingMode;\n\t\texports.AddEquation = AddEquation;\n\t\texports.SubtractEquation = SubtractEquation;\n\t\texports.ReverseSubtractEquation = ReverseSubtractEquation;\n\t\texports.MinEquation = MinEquation;\n\t\texports.MaxEquation = MaxEquation;\n\t\texports.ZeroFactor = ZeroFactor;\n\t\texports.OneFactor = OneFactor;\n\t\texports.SrcColorFactor = SrcColorFactor;\n\t\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\n\t\texports.SrcAlphaFactor = SrcAlphaFactor;\n\t\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\n\t\texports.DstAlphaFactor = DstAlphaFactor;\n\t\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\n\t\texports.DstColorFactor = DstColorFactor;\n\t\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\n\t\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\n\t\texports.NeverDepth = NeverDepth;\n\t\texports.AlwaysDepth = AlwaysDepth;\n\t\texports.LessDepth = LessDepth;\n\t\texports.LessEqualDepth = LessEqualDepth;\n\t\texports.EqualDepth = EqualDepth;\n\t\texports.GreaterEqualDepth = GreaterEqualDepth;\n\t\texports.GreaterDepth = GreaterDepth;\n\t\texports.NotEqualDepth = NotEqualDepth;\n\t\texports.MultiplyOperation = MultiplyOperation;\n\t\texports.MixOperation = MixOperation;\n\t\texports.AddOperation = AddOperation;\n\t\texports.NoToneMapping = NoToneMapping;\n\t\texports.LinearToneMapping = LinearToneMapping;\n\t\texports.ReinhardToneMapping = ReinhardToneMapping;\n\t\texports.Uncharted2ToneMapping = Uncharted2ToneMapping;\n\t\texports.CineonToneMapping = CineonToneMapping;\n\t\texports.UVMapping = UVMapping;\n\t\texports.CubeReflectionMapping = CubeReflectionMapping;\n\t\texports.CubeRefractionMapping = CubeRefractionMapping;\n\t\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\n\t\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\n\t\texports.SphericalReflectionMapping = SphericalReflectionMapping;\n\t\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\n\t\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\n\t\texports.TextureMapping = TextureMapping;\n\t\texports.RepeatWrapping = RepeatWrapping;\n\t\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\n\t\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\n\t\texports.TextureWrapping = TextureWrapping;\n\t\texports.NearestFilter = NearestFilter;\n\t\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\n\t\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\n\t\texports.LinearFilter = LinearFilter;\n\t\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\n\t\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\n\t\texports.TextureFilter = TextureFilter;\n\t\texports.UnsignedByteType = UnsignedByteType;\n\t\texports.ByteType = ByteType;\n\t\texports.ShortType = ShortType;\n\t\texports.UnsignedShortType = UnsignedShortType;\n\t\texports.IntType = IntType;\n\t\texports.UnsignedIntType = UnsignedIntType;\n\t\texports.FloatType = FloatType;\n\t\texports.HalfFloatType = HalfFloatType;\n\t\texports.UnsignedShort4444Type = UnsignedShort4444Type;\n\t\texports.UnsignedShort5551Type = UnsignedShort5551Type;\n\t\texports.UnsignedShort565Type = UnsignedShort565Type;\n\t\texports.UnsignedInt248Type = UnsignedInt248Type;\n\t\texports.AlphaFormat = AlphaFormat;\n\t\texports.RGBFormat = RGBFormat;\n\t\texports.RGBAFormat = RGBAFormat;\n\t\texports.LuminanceFormat = LuminanceFormat;\n\t\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\n\t\texports.RGBEFormat = RGBEFormat;\n\t\texports.DepthFormat = DepthFormat;\n\t\texports.DepthStencilFormat = DepthStencilFormat;\n\t\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\n\t\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\n\t\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\n\t\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\n\t\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\n\t\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\n\t\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\n\t\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\n\t\texports.RGB_ETC1_Format = RGB_ETC1_Format;\n\t\texports.LoopOnce = LoopOnce;\n\t\texports.LoopRepeat = LoopRepeat;\n\t\texports.LoopPingPong = LoopPingPong;\n\t\texports.InterpolateDiscrete = InterpolateDiscrete;\n\t\texports.InterpolateLinear = InterpolateLinear;\n\t\texports.InterpolateSmooth = InterpolateSmooth;\n\t\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\n\t\texports.ZeroSlopeEnding = ZeroSlopeEnding;\n\t\texports.WrapAroundEnding = WrapAroundEnding;\n\t\texports.TrianglesDrawMode = TrianglesDrawMode;\n\t\texports.TriangleStripDrawMode = TriangleStripDrawMode;\n\t\texports.TriangleFanDrawMode = TriangleFanDrawMode;\n\t\texports.LinearEncoding = LinearEncoding;\n\t\texports.sRGBEncoding = sRGBEncoding;\n\t\texports.GammaEncoding = GammaEncoding;\n\t\texports.RGBEEncoding = RGBEEncoding;\n\t\texports.LogLuvEncoding = LogLuvEncoding;\n\t\texports.RGBM7Encoding = RGBM7Encoding;\n\t\texports.RGBM16Encoding = RGBM16Encoding;\n\t\texports.RGBDEncoding = RGBDEncoding;\n\t\texports.BasicDepthPacking = BasicDepthPacking;\n\t\texports.RGBADepthPacking = RGBADepthPacking;\n\t\texports.CubeGeometry = BoxGeometry;\n\t\texports.Face4 = Face4;\n\t\texports.LineStrip = LineStrip;\n\t\texports.LinePieces = LinePieces;\n\t\texports.MeshFaceMaterial = MultiMaterial;\n\t\texports.PointCloud = PointCloud;\n\t\texports.Particle = Sprite;\n\t\texports.ParticleSystem = ParticleSystem;\n\t\texports.PointCloudMaterial = PointCloudMaterial;\n\t\texports.ParticleBasicMaterial = ParticleBasicMaterial;\n\t\texports.ParticleSystemMaterial = ParticleSystemMaterial;\n\t\texports.Vertex = Vertex;\n\t\texports.EdgesHelper = EdgesHelper;\n\t\texports.WireframeHelper = WireframeHelper;\n\t\texports.GeometryUtils = GeometryUtils;\n\t\texports.ImageUtils = ImageUtils;\n\t\texports.Projector = Projector;\n\t\texports.CanvasRenderer = CanvasRenderer;\n\t\n\t\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t\tObject.defineProperty( exports, 'AudioContext', {\n\t\t\tget: function () {\n\t\t\t\treturn exports.getAudioContext();\n\t\t\t}\n\t\t});\n\t\n\t})));\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tvar Stats = function () {\n\t\n\t\tvar mode = 0;\n\t\n\t\tvar container = document.createElement('div');\n\t\tcontainer.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';\n\t\tcontainer.addEventListener('click', function (event) {\n\t\n\t\t\tevent.preventDefault();\n\t\t\tshowPanel(++mode % container.children.length);\n\t\t}, false);\n\t\n\t\t//\n\t\n\t\tfunction addPanel(panel) {\n\t\n\t\t\tcontainer.appendChild(panel.dom);\n\t\t\treturn panel;\n\t\t}\n\t\n\t\tfunction showPanel(id) {\n\t\n\t\t\tfor (var i = 0; i < container.children.length; i++) {\n\t\n\t\t\t\tcontainer.children[i].style.display = i === id ? 'block' : 'none';\n\t\t\t}\n\t\n\t\t\tmode = id;\n\t\t}\n\t\n\t\t//\n\t\n\t\tvar beginTime = (performance || Date).now(),\n\t\t    prevTime = beginTime,\n\t\t    frames = 0;\n\t\n\t\tvar fpsPanel = addPanel(new Stats.Panel('FPS', '#0ff', '#002'));\n\t\tvar msPanel = addPanel(new Stats.Panel('MS', '#0f0', '#020'));\n\t\n\t\tif (self.performance && self.performance.memory) {\n\t\n\t\t\tvar memPanel = addPanel(new Stats.Panel('MB', '#f08', '#201'));\n\t\t}\n\t\n\t\tshowPanel(0);\n\t\n\t\treturn {\n\t\n\t\t\tREVISION: 16,\n\t\n\t\t\tdom: container,\n\t\n\t\t\taddPanel: addPanel,\n\t\t\tshowPanel: showPanel,\n\t\n\t\t\tbegin: function () {\n\t\n\t\t\t\tbeginTime = (performance || Date).now();\n\t\t\t},\n\t\n\t\t\tend: function () {\n\t\n\t\t\t\tframes++;\n\t\n\t\t\t\tvar time = (performance || Date).now();\n\t\n\t\t\t\tmsPanel.update(time - beginTime, 200);\n\t\n\t\t\t\tif (time > prevTime + 1000) {\n\t\n\t\t\t\t\tfpsPanel.update(frames * 1000 / (time - prevTime), 100);\n\t\n\t\t\t\t\tprevTime = time;\n\t\t\t\t\tframes = 0;\n\t\n\t\t\t\t\tif (memPanel) {\n\t\n\t\t\t\t\t\tvar memory = performance.memory;\n\t\t\t\t\t\tmemPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn time;\n\t\t\t},\n\t\n\t\t\tupdate: function () {\n\t\n\t\t\t\tbeginTime = this.end();\n\t\t\t},\n\t\n\t\t\t// Backwards Compatibility\n\t\n\t\t\tdomElement: container,\n\t\t\tsetMode: showPanel\n\t\n\t\t};\n\t};\n\t\n\tStats.Panel = function (name, fg, bg) {\n\t\n\t\tvar min = Infinity,\n\t\t    max = 0,\n\t\t    round = Math.round;\n\t\tvar PR = round(window.devicePixelRatio || 1);\n\t\n\t\tvar WIDTH = 80 * PR,\n\t\t    HEIGHT = 48 * PR,\n\t\t    TEXT_X = 3 * PR,\n\t\t    TEXT_Y = 2 * PR,\n\t\t    GRAPH_X = 3 * PR,\n\t\t    GRAPH_Y = 15 * PR,\n\t\t    GRAPH_WIDTH = 74 * PR,\n\t\t    GRAPH_HEIGHT = 30 * PR;\n\t\n\t\tvar canvas = document.createElement('canvas');\n\t\tcanvas.width = WIDTH;\n\t\tcanvas.height = HEIGHT;\n\t\tcanvas.style.cssText = 'width:80px;height:48px';\n\t\n\t\tvar context = canvas.getContext('2d');\n\t\tcontext.font = 'bold ' + 9 * PR + 'px Helvetica,Arial,sans-serif';\n\t\tcontext.textBaseline = 'top';\n\t\n\t\tcontext.fillStyle = bg;\n\t\tcontext.fillRect(0, 0, WIDTH, HEIGHT);\n\t\n\t\tcontext.fillStyle = fg;\n\t\tcontext.fillText(name, TEXT_X, TEXT_Y);\n\t\tcontext.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);\n\t\n\t\tcontext.fillStyle = bg;\n\t\tcontext.globalAlpha = 0.9;\n\t\tcontext.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);\n\t\n\t\treturn {\n\t\n\t\t\tdom: canvas,\n\t\n\t\t\tupdate: function (value, maxValue) {\n\t\n\t\t\t\tmin = Math.min(min, value);\n\t\t\t\tmax = Math.max(max, value);\n\t\n\t\t\t\tcontext.fillStyle = bg;\n\t\t\t\tcontext.globalAlpha = 1;\n\t\t\t\tcontext.fillRect(0, 0, WIDTH, GRAPH_Y);\n\t\t\t\tcontext.fillStyle = fg;\n\t\t\t\tcontext.fillText(round(value) + ' ' + name + ' (' + round(min) + '-' + round(max) + ')', TEXT_X, TEXT_Y);\n\t\n\t\t\t\tcontext.drawImage(canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT);\n\t\n\t\t\t\tcontext.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT);\n\t\n\t\t\t\tcontext.fillStyle = bg;\n\t\t\t\tcontext.globalAlpha = 0.9;\n\t\t\t\tcontext.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round((1 - value / maxValue) * GRAPH_HEIGHT));\n\t\t\t}\n\t\n\t\t};\n\t};\n\t\n\tif (true) {\n\t\n\t\tmodule.exports = Stats;\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(6)\n\tmodule.exports.color = __webpack_require__(7)\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/**\n\t * dat-gui JavaScript Controller Library\n\t * http://code.google.com/p/dat-gui\n\t *\n\t * Copyright 2011 Data Arts Team, Google Creative Lab\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t */\n\t\n\t/** @namespace */\n\tvar dat = module.exports = dat || {};\n\t\n\t/** @namespace */\n\tdat.gui = dat.gui || {};\n\t\n\t/** @namespace */\n\tdat.utils = dat.utils || {};\n\t\n\t/** @namespace */\n\tdat.controllers = dat.controllers || {};\n\t\n\t/** @namespace */\n\tdat.dom = dat.dom || {};\n\t\n\t/** @namespace */\n\tdat.color = dat.color || {};\n\t\n\tdat.utils.css = (function () {\n\t  return {\n\t    load: function (url, doc) {\n\t      doc = doc || document;\n\t      var link = doc.createElement('link');\n\t      link.type = 'text/css';\n\t      link.rel = 'stylesheet';\n\t      link.href = url;\n\t      doc.getElementsByTagName('head')[0].appendChild(link);\n\t    },\n\t    inject: function(css, doc) {\n\t      doc = doc || document;\n\t      var injected = document.createElement('style');\n\t      injected.type = 'text/css';\n\t      injected.innerHTML = css;\n\t      doc.getElementsByTagName('head')[0].appendChild(injected);\n\t    }\n\t  }\n\t})();\n\t\n\t\n\tdat.utils.common = (function () {\n\t  \n\t  var ARR_EACH = Array.prototype.forEach;\n\t  var ARR_SLICE = Array.prototype.slice;\n\t\n\t  /**\n\t   * Band-aid methods for things that should be a lot easier in JavaScript.\n\t   * Implementation and structure inspired by underscore.js\n\t   * http://documentcloud.github.com/underscore/\n\t   */\n\t\n\t  return { \n\t    \n\t    BREAK: {},\n\t  \n\t    extend: function(target) {\n\t      \n\t      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n\t        \n\t        for (var key in obj)\n\t          if (!this.isUndefined(obj[key])) \n\t            target[key] = obj[key];\n\t        \n\t      }, this);\n\t      \n\t      return target;\n\t      \n\t    },\n\t    \n\t    defaults: function(target) {\n\t      \n\t      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n\t        \n\t        for (var key in obj)\n\t          if (this.isUndefined(target[key])) \n\t            target[key] = obj[key];\n\t        \n\t      }, this);\n\t      \n\t      return target;\n\t    \n\t    },\n\t    \n\t    compose: function() {\n\t      var toCall = ARR_SLICE.call(arguments);\n\t            return function() {\n\t              var args = ARR_SLICE.call(arguments);\n\t              for (var i = toCall.length -1; i >= 0; i--) {\n\t                args = [toCall[i].apply(this, args)];\n\t              }\n\t              return args[0];\n\t            }\n\t    },\n\t    \n\t    each: function(obj, itr, scope) {\n\t\n\t      \n\t      if (ARR_EACH && obj.forEach === ARR_EACH) { \n\t        \n\t        obj.forEach(itr, scope);\n\t        \n\t      } else if (obj.length === obj.length + 0) { // Is number but not NaN\n\t        \n\t        for (var key = 0, l = obj.length; key < l; key++)\n\t          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) \n\t            return;\n\t            \n\t      } else {\n\t\n\t        for (var key in obj) \n\t          if (itr.call(scope, obj[key], key) === this.BREAK)\n\t            return;\n\t            \n\t      }\n\t            \n\t    },\n\t    \n\t    defer: function(fnc) {\n\t      setTimeout(fnc, 0);\n\t    },\n\t    \n\t    toArray: function(obj) {\n\t      if (obj.toArray) return obj.toArray();\n\t      return ARR_SLICE.call(obj);\n\t    },\n\t\n\t    isUndefined: function(obj) {\n\t      return obj === undefined;\n\t    },\n\t    \n\t    isNull: function(obj) {\n\t      return obj === null;\n\t    },\n\t    \n\t    isNaN: function(obj) {\n\t      return obj !== obj;\n\t    },\n\t    \n\t    isArray: Array.isArray || function(obj) {\n\t      return obj.constructor === Array;\n\t    },\n\t    \n\t    isObject: function(obj) {\n\t      return obj === Object(obj);\n\t    },\n\t    \n\t    isNumber: function(obj) {\n\t      return obj === obj+0;\n\t    },\n\t    \n\t    isString: function(obj) {\n\t      return obj === obj+'';\n\t    },\n\t    \n\t    isBoolean: function(obj) {\n\t      return obj === false || obj === true;\n\t    },\n\t    \n\t    isFunction: function(obj) {\n\t      return Object.prototype.toString.call(obj) === '[object Function]';\n\t    }\n\t  \n\t  };\n\t    \n\t})();\n\t\n\t\n\tdat.controllers.Controller = (function (common) {\n\t\n\t  /**\n\t   * @class An \"abstract\" class that represents a given property of an object.\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var Controller = function(object, property) {\n\t\n\t    this.initialValue = object[property];\n\t\n\t    /**\n\t     * Those who extend this class will put their DOM elements in here.\n\t     * @type {DOMElement}\n\t     */\n\t    this.domElement = document.createElement('div');\n\t\n\t    /**\n\t     * The object to manipulate\n\t     * @type {Object}\n\t     */\n\t    this.object = object;\n\t\n\t    /**\n\t     * The name of the property to manipulate\n\t     * @type {String}\n\t     */\n\t    this.property = property;\n\t\n\t    /**\n\t     * The function to be called on change.\n\t     * @type {Function}\n\t     * @ignore\n\t     */\n\t    this.__onChange = undefined;\n\t\n\t    /**\n\t     * The function to be called on finishing change.\n\t     * @type {Function}\n\t     * @ignore\n\t     */\n\t    this.__onFinishChange = undefined;\n\t\n\t  };\n\t\n\t  common.extend(\n\t\n\t      Controller.prototype,\n\t\n\t      /** @lends dat.controllers.Controller.prototype */\n\t      {\n\t\n\t        /**\n\t         * Specify that a function fire every time someone changes the value with\n\t         * this Controller.\n\t         *\n\t         * @param {Function} fnc This function will be called whenever the value\n\t         * is modified via this Controller.\n\t         * @returns {dat.controllers.Controller} this\n\t         */\n\t        onChange: function(fnc) {\n\t          this.__onChange = fnc;\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * Specify that a function fire every time someone \"finishes\" changing\n\t         * the value wih this Controller. Useful for values that change\n\t         * incrementally like numbers or strings.\n\t         *\n\t         * @param {Function} fnc This function will be called whenever\n\t         * someone \"finishes\" changing the value via this Controller.\n\t         * @returns {dat.controllers.Controller} this\n\t         */\n\t        onFinishChange: function(fnc) {\n\t          this.__onFinishChange = fnc;\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * Change the value of <code>object[property]</code>\n\t         *\n\t         * @param {Object} newValue The new value of <code>object[property]</code>\n\t         */\n\t        setValue: function(newValue) {\n\t          this.object[this.property] = newValue;\n\t          if (this.__onChange) {\n\t            this.__onChange.call(this, newValue);\n\t          }\n\t          this.updateDisplay();\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * Gets the value of <code>object[property]</code>\n\t         *\n\t         * @returns {Object} The current value of <code>object[property]</code>\n\t         */\n\t        getValue: function() {\n\t          return this.object[this.property];\n\t        },\n\t\n\t        /**\n\t         * Refreshes the visual display of a Controller in order to keep sync\n\t         * with the object's current value.\n\t         * @returns {dat.controllers.Controller} this\n\t         */\n\t        updateDisplay: function() {\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * @returns {Boolean} true if the value has deviated from initialValue\n\t         */\n\t        isModified: function() {\n\t          return this.initialValue !== this.getValue()\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  return Controller;\n\t\n\t\n\t})(dat.utils.common);\n\t\n\t\n\tdat.dom.dom = (function (common) {\n\t\n\t  var EVENT_MAP = {\n\t    'HTMLEvents': ['change'],\n\t    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],\n\t    'KeyboardEvents': ['keydown']\n\t  };\n\t\n\t  var EVENT_MAP_INV = {};\n\t  common.each(EVENT_MAP, function(v, k) {\n\t    common.each(v, function(e) {\n\t      EVENT_MAP_INV[e] = k;\n\t    });\n\t  });\n\t\n\t  var CSS_VALUE_PIXELS = /(\\d+(\\.\\d+)?)px/;\n\t\n\t  function cssValueToPixels(val) {\n\t\n\t    if (val === '0' || common.isUndefined(val)) return 0;\n\t\n\t    var match = val.match(CSS_VALUE_PIXELS);\n\t\n\t    if (!common.isNull(match)) {\n\t      return parseFloat(match[1]);\n\t    }\n\t\n\t    // TODO ...ems? %?\n\t\n\t    return 0;\n\t\n\t  }\n\t\n\t  /**\n\t   * @namespace\n\t   * @member dat.dom\n\t   */\n\t  var dom = {\n\t\n\t    /**\n\t     * \n\t     * @param elem\n\t     * @param selectable\n\t     */\n\t    makeSelectable: function(elem, selectable) {\n\t\n\t      if (elem === undefined || elem.style === undefined) return;\n\t\n\t      elem.onselectstart = selectable ? function() {\n\t        return false;\n\t      } : function() {\n\t      };\n\t\n\t      elem.style.MozUserSelect = selectable ? 'auto' : 'none';\n\t      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';\n\t      elem.unselectable = selectable ? 'on' : 'off';\n\t\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param horizontal\n\t     * @param vertical\n\t     */\n\t    makeFullscreen: function(elem, horizontal, vertical) {\n\t\n\t      if (common.isUndefined(horizontal)) horizontal = true;\n\t      if (common.isUndefined(vertical)) vertical = true;\n\t\n\t      elem.style.position = 'absolute';\n\t\n\t      if (horizontal) {\n\t        elem.style.left = 0;\n\t        elem.style.right = 0;\n\t      }\n\t      if (vertical) {\n\t        elem.style.top = 0;\n\t        elem.style.bottom = 0;\n\t      }\n\t\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param eventType\n\t     * @param params\n\t     */\n\t    fakeEvent: function(elem, eventType, params, aux) {\n\t      params = params || {};\n\t      var className = EVENT_MAP_INV[eventType];\n\t      if (!className) {\n\t        throw new Error('Event type ' + eventType + ' not supported.');\n\t      }\n\t      var evt = document.createEvent(className);\n\t      switch (className) {\n\t        case 'MouseEvents':\n\t          var clientX = params.x || params.clientX || 0;\n\t          var clientY = params.y || params.clientY || 0;\n\t          evt.initMouseEvent(eventType, params.bubbles || false,\n\t              params.cancelable || true, window, params.clickCount || 1,\n\t              0, //screen X\n\t              0, //screen Y\n\t              clientX, //client X\n\t              clientY, //client Y\n\t              false, false, false, false, 0, null);\n\t          break;\n\t        case 'KeyboardEvents':\n\t          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz\n\t          common.defaults(params, {\n\t            cancelable: true,\n\t            ctrlKey: false,\n\t            altKey: false,\n\t            shiftKey: false,\n\t            metaKey: false,\n\t            keyCode: undefined,\n\t            charCode: undefined\n\t          });\n\t          init(eventType, params.bubbles || false,\n\t              params.cancelable, window,\n\t              params.ctrlKey, params.altKey,\n\t              params.shiftKey, params.metaKey,\n\t              params.keyCode, params.charCode);\n\t          break;\n\t        default:\n\t          evt.initEvent(eventType, params.bubbles || false,\n\t              params.cancelable || true);\n\t          break;\n\t      }\n\t      common.defaults(evt, aux);\n\t      elem.dispatchEvent(evt);\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param event\n\t     * @param func\n\t     * @param bool\n\t     */\n\t    bind: function(elem, event, func, bool) {\n\t      bool = bool || false;\n\t      if (elem.addEventListener)\n\t        elem.addEventListener(event, func, bool);\n\t      else if (elem.attachEvent)\n\t        elem.attachEvent('on' + event, func);\n\t      return dom;\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param event\n\t     * @param func\n\t     * @param bool\n\t     */\n\t    unbind: function(elem, event, func, bool) {\n\t      bool = bool || false;\n\t      if (elem.removeEventListener)\n\t        elem.removeEventListener(event, func, bool);\n\t      else if (elem.detachEvent)\n\t        elem.detachEvent('on' + event, func);\n\t      return dom;\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param className\n\t     */\n\t    addClass: function(elem, className) {\n\t      if (elem.className === undefined) {\n\t        elem.className = className;\n\t      } else if (elem.className !== className) {\n\t        var classes = elem.className.split(/ +/);\n\t        if (classes.indexOf(className) == -1) {\n\t          classes.push(className);\n\t          elem.className = classes.join(' ').replace(/^\\s+/, '').replace(/\\s+$/, '');\n\t        }\n\t      }\n\t      return dom;\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param className\n\t     */\n\t    removeClass: function(elem, className) {\n\t      if (className) {\n\t        if (elem.className === undefined) {\n\t          // elem.className = className;\n\t        } else if (elem.className === className) {\n\t          elem.removeAttribute('class');\n\t        } else {\n\t          var classes = elem.className.split(/ +/);\n\t          var index = classes.indexOf(className);\n\t          if (index != -1) {\n\t            classes.splice(index, 1);\n\t            elem.className = classes.join(' ');\n\t          }\n\t        }\n\t      } else {\n\t        elem.className = undefined;\n\t      }\n\t      return dom;\n\t    },\n\t\n\t    hasClass: function(elem, className) {\n\t      return new RegExp('(?:^|\\\\s+)' + className + '(?:\\\\s+|$)').test(elem.className) || false;\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     */\n\t    getWidth: function(elem) {\n\t\n\t      var style = getComputedStyle(elem);\n\t\n\t      return cssValueToPixels(style['border-left-width']) +\n\t          cssValueToPixels(style['border-right-width']) +\n\t          cssValueToPixels(style['padding-left']) +\n\t          cssValueToPixels(style['padding-right']) +\n\t          cssValueToPixels(style['width']);\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     */\n\t    getHeight: function(elem) {\n\t\n\t      var style = getComputedStyle(elem);\n\t\n\t      return cssValueToPixels(style['border-top-width']) +\n\t          cssValueToPixels(style['border-bottom-width']) +\n\t          cssValueToPixels(style['padding-top']) +\n\t          cssValueToPixels(style['padding-bottom']) +\n\t          cssValueToPixels(style['height']);\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     */\n\t    getOffset: function(elem) {\n\t      var offset = {left: 0, top:0};\n\t      if (elem.offsetParent) {\n\t        do {\n\t          offset.left += elem.offsetLeft;\n\t          offset.top += elem.offsetTop;\n\t        } while (elem = elem.offsetParent);\n\t      }\n\t      return offset;\n\t    },\n\t\n\t    // http://stackoverflow.com/posts/2684561/revisions\n\t    /**\n\t     * \n\t     * @param elem\n\t     */\n\t    isActive: function(elem) {\n\t      return elem === document.activeElement && ( elem.type || elem.href );\n\t    }\n\t\n\t  };\n\t\n\t  return dom;\n\t\n\t})(dat.utils.common);\n\t\n\t\n\tdat.controllers.OptionController = (function (Controller, dom, common) {\n\t\n\t  /**\n\t   * @class Provides a select input to alter the property of an object, using a\n\t   * list of accepted values.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   * @param {Object|string[]} options A map of labels to acceptable values, or\n\t   * a list of acceptable string values.\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var OptionController = function(object, property, options) {\n\t\n\t    OptionController.superclass.call(this, object, property);\n\t\n\t    var _this = this;\n\t\n\t    /**\n\t     * The drop down menu\n\t     * @ignore\n\t     */\n\t    this.__select = document.createElement('select');\n\t\n\t    if (common.isArray(options)) {\n\t      var map = {};\n\t      common.each(options, function(element) {\n\t        map[element] = element;\n\t      });\n\t      options = map;\n\t    }\n\t\n\t    common.each(options, function(value, key) {\n\t\n\t      var opt = document.createElement('option');\n\t      opt.innerHTML = key;\n\t      opt.setAttribute('value', value);\n\t      _this.__select.appendChild(opt);\n\t\n\t    });\n\t\n\t    // Acknowledge original value\n\t    this.updateDisplay();\n\t\n\t    dom.bind(this.__select, 'change', function() {\n\t      var desiredValue = this.options[this.selectedIndex].value;\n\t      _this.setValue(desiredValue);\n\t    });\n\t\n\t    this.domElement.appendChild(this.__select);\n\t\n\t  };\n\t\n\t  OptionController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      OptionController.prototype,\n\t      Controller.prototype,\n\t\n\t      {\n\t\n\t        setValue: function(v) {\n\t          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);\n\t          if (this.__onFinishChange) {\n\t            this.__onFinishChange.call(this, this.getValue());\n\t          }\n\t          return toReturn;\n\t        },\n\t\n\t        updateDisplay: function() {\n\t          this.__select.value = this.getValue();\n\t          return OptionController.superclass.prototype.updateDisplay.call(this);\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  return OptionController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.dom.dom,\n\tdat.utils.common);\n\t\n\t\n\tdat.controllers.NumberController = (function (Controller, common) {\n\t\n\t  /**\n\t   * @class Represents a given property of an object that is a number.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   * @param {Object} [params] Optional parameters\n\t   * @param {Number} [params.min] Minimum allowed value\n\t   * @param {Number} [params.max] Maximum allowed value\n\t   * @param {Number} [params.step] Increment by which to change value\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var NumberController = function(object, property, params) {\n\t\n\t    NumberController.superclass.call(this, object, property);\n\t\n\t    params = params || {};\n\t\n\t    this.__min = params.min;\n\t    this.__max = params.max;\n\t    this.__step = params.step;\n\t\n\t    if (common.isUndefined(this.__step)) {\n\t\n\t      if (this.initialValue == 0) {\n\t        this.__impliedStep = 1; // What are we, psychics?\n\t      } else {\n\t        // Hey Doug, check this out.\n\t        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;\n\t      }\n\t\n\t    } else {\n\t\n\t      this.__impliedStep = this.__step;\n\t\n\t    }\n\t\n\t    this.__precision = numDecimals(this.__impliedStep);\n\t\n\t\n\t  };\n\t\n\t  NumberController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      NumberController.prototype,\n\t      Controller.prototype,\n\t\n\t      /** @lends dat.controllers.NumberController.prototype */\n\t      {\n\t\n\t        setValue: function(v) {\n\t\n\t          if (this.__min !== undefined && v < this.__min) {\n\t            v = this.__min;\n\t          } else if (this.__max !== undefined && v > this.__max) {\n\t            v = this.__max;\n\t          }\n\t\n\t          if (this.__step !== undefined && v % this.__step != 0) {\n\t            v = Math.round(v / this.__step) * this.__step;\n\t          }\n\t\n\t          return NumberController.superclass.prototype.setValue.call(this, v);\n\t\n\t        },\n\t\n\t        /**\n\t         * Specify a minimum value for <code>object[property]</code>.\n\t         *\n\t         * @param {Number} minValue The minimum value for\n\t         * <code>object[property]</code>\n\t         * @returns {dat.controllers.NumberController} this\n\t         */\n\t        min: function(v) {\n\t          this.__min = v;\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * Specify a maximum value for <code>object[property]</code>.\n\t         *\n\t         * @param {Number} maxValue The maximum value for\n\t         * <code>object[property]</code>\n\t         * @returns {dat.controllers.NumberController} this\n\t         */\n\t        max: function(v) {\n\t          this.__max = v;\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * Specify a step value that dat.controllers.NumberController\n\t         * increments by.\n\t         *\n\t         * @param {Number} stepValue The step value for\n\t         * dat.controllers.NumberController\n\t         * @default if minimum and maximum specified increment is 1% of the\n\t         * difference otherwise stepValue is 1\n\t         * @returns {dat.controllers.NumberController} this\n\t         */\n\t        step: function(v) {\n\t          this.__step = v;\n\t          return this;\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  function numDecimals(x) {\n\t    x = x.toString();\n\t    if (x.indexOf('.') > -1) {\n\t      return x.length - x.indexOf('.') - 1;\n\t    } else {\n\t      return 0;\n\t    }\n\t  }\n\t\n\t  return NumberController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.utils.common);\n\t\n\t\n\tdat.controllers.NumberControllerBox = (function (NumberController, dom, common) {\n\t\n\t  /**\n\t   * @class Represents a given property of an object that is a number and\n\t   * provides an input element with which to manipulate it.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   * @extends dat.controllers.NumberController\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   * @param {Object} [params] Optional parameters\n\t   * @param {Number} [params.min] Minimum allowed value\n\t   * @param {Number} [params.max] Maximum allowed value\n\t   * @param {Number} [params.step] Increment by which to change value\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var NumberControllerBox = function(object, property, params) {\n\t\n\t    this.__truncationSuspended = false;\n\t\n\t    NumberControllerBox.superclass.call(this, object, property, params);\n\t\n\t    var _this = this;\n\t\n\t    /**\n\t     * {Number} Previous mouse y position\n\t     * @ignore\n\t     */\n\t    var prev_y;\n\t\n\t    this.__input = document.createElement('input');\n\t    this.__input.setAttribute('type', 'text');\n\t\n\t    // Makes it so manually specified values are not truncated.\n\t\n\t    dom.bind(this.__input, 'change', onChange);\n\t    dom.bind(this.__input, 'blur', onBlur);\n\t    dom.bind(this.__input, 'mousedown', onMouseDown);\n\t    dom.bind(this.__input, 'keydown', function(e) {\n\t\n\t      // When pressing entire, you can be as precise as you want.\n\t      if (e.keyCode === 13) {\n\t        _this.__truncationSuspended = true;\n\t        this.blur();\n\t        _this.__truncationSuspended = false;\n\t      }\n\t\n\t    });\n\t\n\t    function onChange() {\n\t      var attempted = parseFloat(_this.__input.value);\n\t      if (!common.isNaN(attempted)) _this.setValue(attempted);\n\t    }\n\t\n\t    function onBlur() {\n\t      onChange();\n\t      if (_this.__onFinishChange) {\n\t        _this.__onFinishChange.call(_this, _this.getValue());\n\t      }\n\t    }\n\t\n\t    function onMouseDown(e) {\n\t      dom.bind(window, 'mousemove', onMouseDrag);\n\t      dom.bind(window, 'mouseup', onMouseUp);\n\t      prev_y = e.clientY;\n\t    }\n\t\n\t    function onMouseDrag(e) {\n\t\n\t      var diff = prev_y - e.clientY;\n\t      _this.setValue(_this.getValue() + diff * _this.__impliedStep);\n\t\n\t      prev_y = e.clientY;\n\t\n\t    }\n\t\n\t    function onMouseUp() {\n\t      dom.unbind(window, 'mousemove', onMouseDrag);\n\t      dom.unbind(window, 'mouseup', onMouseUp);\n\t    }\n\t\n\t    this.updateDisplay();\n\t\n\t    this.domElement.appendChild(this.__input);\n\t\n\t  };\n\t\n\t  NumberControllerBox.superclass = NumberController;\n\t\n\t  common.extend(\n\t\n\t      NumberControllerBox.prototype,\n\t      NumberController.prototype,\n\t\n\t      {\n\t\n\t        updateDisplay: function() {\n\t\n\t          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);\n\t          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  function roundToDecimal(value, decimals) {\n\t    var tenTo = Math.pow(10, decimals);\n\t    return Math.round(value * tenTo) / tenTo;\n\t  }\n\t\n\t  return NumberControllerBox;\n\t\n\t})(dat.controllers.NumberController,\n\tdat.dom.dom,\n\tdat.utils.common);\n\t\n\t\n\tdat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {\n\t\n\t  /**\n\t   * @class Represents a given property of an object that is a number, contains\n\t   * a minimum and maximum, and provides a slider element with which to\n\t   * manipulate it. It should be noted that the slider element is made up of\n\t   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5\n\t   * <code>&lt;slider&gt;</code> element.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   * @extends dat.controllers.NumberController\n\t   * \n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   * @param {Number} minValue Minimum allowed value\n\t   * @param {Number} maxValue Maximum allowed value\n\t   * @param {Number} stepValue Increment by which to change value\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var NumberControllerSlider = function(object, property, min, max, step) {\n\t\n\t    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });\n\t\n\t    var _this = this;\n\t\n\t    this.__background = document.createElement('div');\n\t    this.__foreground = document.createElement('div');\n\t    \n\t\n\t\n\t    dom.bind(this.__background, 'mousedown', onMouseDown);\n\t    \n\t    dom.addClass(this.__background, 'slider');\n\t    dom.addClass(this.__foreground, 'slider-fg');\n\t\n\t    function onMouseDown(e) {\n\t\n\t      dom.bind(window, 'mousemove', onMouseDrag);\n\t      dom.bind(window, 'mouseup', onMouseUp);\n\t\n\t      onMouseDrag(e);\n\t    }\n\t\n\t    function onMouseDrag(e) {\n\t\n\t      e.preventDefault();\n\t\n\t      var offset = dom.getOffset(_this.__background);\n\t      var width = dom.getWidth(_this.__background);\n\t      \n\t      _this.setValue(\n\t        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)\n\t      );\n\t\n\t      return false;\n\t\n\t    }\n\t\n\t    function onMouseUp() {\n\t      dom.unbind(window, 'mousemove', onMouseDrag);\n\t      dom.unbind(window, 'mouseup', onMouseUp);\n\t      if (_this.__onFinishChange) {\n\t        _this.__onFinishChange.call(_this, _this.getValue());\n\t      }\n\t    }\n\t\n\t    this.updateDisplay();\n\t\n\t    this.__background.appendChild(this.__foreground);\n\t    this.domElement.appendChild(this.__background);\n\t\n\t  };\n\t\n\t  NumberControllerSlider.superclass = NumberController;\n\t\n\t  /**\n\t   * Injects default stylesheet for slider elements.\n\t   */\n\t  NumberControllerSlider.useDefaultStyles = function() {\n\t    css.inject(styleSheet);\n\t  };\n\t\n\t  common.extend(\n\t\n\t      NumberControllerSlider.prototype,\n\t      NumberController.prototype,\n\t\n\t      {\n\t\n\t        updateDisplay: function() {\n\t          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);\n\t          this.__foreground.style.width = pct*100+'%';\n\t          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);\n\t        }\n\t\n\t      }\n\t\n\t\n\t\n\t  );\n\t\n\t  function map(v, i1, i2, o1, o2) {\n\t    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));\n\t  }\n\t\n\t  return NumberControllerSlider;\n\t  \n\t})(dat.controllers.NumberController,\n\tdat.dom.dom,\n\tdat.utils.css,\n\tdat.utils.common,\n\t\".slider {\\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\\n  height: 1em;\\n  border-radius: 1em;\\n  background-color: #eee;\\n  padding: 0 0.5em;\\n  overflow: hidden;\\n}\\n\\n.slider-fg {\\n  padding: 1px 0 2px 0;\\n  background-color: #aaa;\\n  height: 1em;\\n  margin-left: -0.5em;\\n  padding-right: 0.5em;\\n  border-radius: 1em 0 0 1em;\\n}\\n\\n.slider-fg:after {\\n  display: inline-block;\\n  border-radius: 1em;\\n  background-color: #fff;\\n  border:  1px solid #aaa;\\n  content: '';\\n  float: right;\\n  margin-right: -1em;\\n  margin-top: -1px;\\n  height: 0.9em;\\n  width: 0.9em;\\n}\");\n\t\n\t\n\tdat.controllers.FunctionController = (function (Controller, dom, common) {\n\t\n\t  /**\n\t   * @class Provides a GUI interface to fire a specified method, a property of an object.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var FunctionController = function(object, property, text) {\n\t\n\t    FunctionController.superclass.call(this, object, property);\n\t\n\t    var _this = this;\n\t\n\t    this.__button = document.createElement('div');\n\t    this.__button.innerHTML = text === undefined ? 'Fire' : text;\n\t    dom.bind(this.__button, 'click', function(e) {\n\t      e.preventDefault();\n\t      _this.fire();\n\t      return false;\n\t    });\n\t\n\t    dom.addClass(this.__button, 'button');\n\t\n\t    this.domElement.appendChild(this.__button);\n\t\n\t\n\t  };\n\t\n\t  FunctionController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      FunctionController.prototype,\n\t      Controller.prototype,\n\t      {\n\t        \n\t        fire: function() {\n\t          if (this.__onChange) {\n\t            this.__onChange.call(this);\n\t          }\n\t          if (this.__onFinishChange) {\n\t            this.__onFinishChange.call(this, this.getValue());\n\t          }\n\t          this.getValue().call(this.object);\n\t        }\n\t      }\n\t\n\t  );\n\t\n\t  return FunctionController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.dom.dom,\n\tdat.utils.common);\n\t\n\t\n\tdat.controllers.BooleanController = (function (Controller, dom, common) {\n\t\n\t  /**\n\t   * @class Provides a checkbox input to alter the boolean property of an object.\n\t   * @extends dat.controllers.Controller\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var BooleanController = function(object, property) {\n\t\n\t    BooleanController.superclass.call(this, object, property);\n\t\n\t    var _this = this;\n\t    this.__prev = this.getValue();\n\t\n\t    this.__checkbox = document.createElement('input');\n\t    this.__checkbox.setAttribute('type', 'checkbox');\n\t\n\t\n\t    dom.bind(this.__checkbox, 'change', onChange, false);\n\t\n\t    this.domElement.appendChild(this.__checkbox);\n\t\n\t    // Match original value\n\t    this.updateDisplay();\n\t\n\t    function onChange() {\n\t      _this.setValue(!_this.__prev);\n\t    }\n\t\n\t  };\n\t\n\t  BooleanController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      BooleanController.prototype,\n\t      Controller.prototype,\n\t\n\t      {\n\t\n\t        setValue: function(v) {\n\t          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);\n\t          if (this.__onFinishChange) {\n\t            this.__onFinishChange.call(this, this.getValue());\n\t          }\n\t          this.__prev = this.getValue();\n\t          return toReturn;\n\t        },\n\t\n\t        updateDisplay: function() {\n\t          \n\t          if (this.getValue() === true) {\n\t            this.__checkbox.setAttribute('checked', 'checked');\n\t            this.__checkbox.checked = true;    \n\t          } else {\n\t              this.__checkbox.checked = false;\n\t          }\n\t\n\t          return BooleanController.superclass.prototype.updateDisplay.call(this);\n\t\n\t        }\n\t\n\t\n\t      }\n\t\n\t  );\n\t\n\t  return BooleanController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.dom.dom,\n\tdat.utils.common);\n\t\n\t\n\tdat.color.toString = (function (common) {\n\t\n\t  return function(color) {\n\t\n\t    if (color.a == 1 || common.isUndefined(color.a)) {\n\t\n\t      var s = color.hex.toString(16);\n\t      while (s.length < 6) {\n\t        s = '0' + s;\n\t      }\n\t\n\t      return '#' + s;\n\t\n\t    } else {\n\t\n\t      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';\n\t\n\t    }\n\t\n\t  }\n\t\n\t})(dat.utils.common);\n\t\n\t\n\tdat.color.interpret = (function (toString, common) {\n\t\n\t  var result, toReturn;\n\t\n\t  var interpret = function() {\n\t\n\t    toReturn = false;\n\t\n\t    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];\n\t\n\t    common.each(INTERPRETATIONS, function(family) {\n\t\n\t      if (family.litmus(original)) {\n\t\n\t        common.each(family.conversions, function(conversion, conversionName) {\n\t\n\t          result = conversion.read(original);\n\t\n\t          if (toReturn === false && result !== false) {\n\t            toReturn = result;\n\t            result.conversionName = conversionName;\n\t            result.conversion = conversion;\n\t            return common.BREAK;\n\t\n\t          }\n\t\n\t        });\n\t\n\t        return common.BREAK;\n\t\n\t      }\n\t\n\t    });\n\t\n\t    return toReturn;\n\t\n\t  };\n\t\n\t  var INTERPRETATIONS = [\n\t\n\t    // Strings\n\t    {\n\t\n\t      litmus: common.isString,\n\t\n\t      conversions: {\n\t\n\t        THREE_CHAR_HEX: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'HEX',\n\t              hex: parseInt(\n\t                  '0x' +\n\t                      test[1].toString() + test[1].toString() +\n\t                      test[2].toString() + test[2].toString() +\n\t                      test[3].toString() + test[3].toString())\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        SIX_CHAR_HEX: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^#([A-F0-9]{6})$/i);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'HEX',\n\t              hex: parseInt('0x' + test[1].toString())\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        CSS_RGB: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^rgb\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'RGB',\n\t              r: parseFloat(test[1]),\n\t              g: parseFloat(test[2]),\n\t              b: parseFloat(test[3])\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        CSS_RGBA: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^rgba\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\,\\s*(.+)\\s*\\)/);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'RGB',\n\t              r: parseFloat(test[1]),\n\t              g: parseFloat(test[2]),\n\t              b: parseFloat(test[3]),\n\t              a: parseFloat(test[4])\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Numbers\n\t    {\n\t\n\t      litmus: common.isNumber,\n\t\n\t      conversions: {\n\t\n\t        HEX: {\n\t          read: function(original) {\n\t            return {\n\t              space: 'HEX',\n\t              hex: original,\n\t              conversionName: 'HEX'\n\t            }\n\t          },\n\t\n\t          write: function(color) {\n\t            return color.hex;\n\t          }\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Arrays\n\t    {\n\t\n\t      litmus: common.isArray,\n\t\n\t      conversions: {\n\t\n\t        RGB_ARRAY: {\n\t          read: function(original) {\n\t            if (original.length != 3) return false;\n\t            return {\n\t              space: 'RGB',\n\t              r: original[0],\n\t              g: original[1],\n\t              b: original[2]\n\t            };\n\t          },\n\t\n\t          write: function(color) {\n\t            return [color.r, color.g, color.b];\n\t          }\n\t\n\t        },\n\t\n\t        RGBA_ARRAY: {\n\t          read: function(original) {\n\t            if (original.length != 4) return false;\n\t            return {\n\t              space: 'RGB',\n\t              r: original[0],\n\t              g: original[1],\n\t              b: original[2],\n\t              a: original[3]\n\t            };\n\t          },\n\t\n\t          write: function(color) {\n\t            return [color.r, color.g, color.b, color.a];\n\t          }\n\t\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Objects\n\t    {\n\t\n\t      litmus: common.isObject,\n\t\n\t      conversions: {\n\t\n\t        RGBA_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.r) &&\n\t                common.isNumber(original.g) &&\n\t                common.isNumber(original.b) &&\n\t                common.isNumber(original.a)) {\n\t              return {\n\t                space: 'RGB',\n\t                r: original.r,\n\t                g: original.g,\n\t                b: original.b,\n\t                a: original.a\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              r: color.r,\n\t              g: color.g,\n\t              b: color.b,\n\t              a: color.a\n\t            }\n\t          }\n\t        },\n\t\n\t        RGB_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.r) &&\n\t                common.isNumber(original.g) &&\n\t                common.isNumber(original.b)) {\n\t              return {\n\t                space: 'RGB',\n\t                r: original.r,\n\t                g: original.g,\n\t                b: original.b\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              r: color.r,\n\t              g: color.g,\n\t              b: color.b\n\t            }\n\t          }\n\t        },\n\t\n\t        HSVA_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.h) &&\n\t                common.isNumber(original.s) &&\n\t                common.isNumber(original.v) &&\n\t                common.isNumber(original.a)) {\n\t              return {\n\t                space: 'HSV',\n\t                h: original.h,\n\t                s: original.s,\n\t                v: original.v,\n\t                a: original.a\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              h: color.h,\n\t              s: color.s,\n\t              v: color.v,\n\t              a: color.a\n\t            }\n\t          }\n\t        },\n\t\n\t        HSV_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.h) &&\n\t                common.isNumber(original.s) &&\n\t                common.isNumber(original.v)) {\n\t              return {\n\t                space: 'HSV',\n\t                h: original.h,\n\t                s: original.s,\n\t                v: original.v\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              h: color.h,\n\t              s: color.s,\n\t              v: color.v\n\t            }\n\t          }\n\t\n\t        }\n\t\n\t      }\n\t\n\t    }\n\t\n\t\n\t  ];\n\t\n\t  return interpret;\n\t\n\t\n\t})(dat.color.toString,\n\tdat.utils.common);\n\t\n\t\n\tdat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {\n\t\n\t  css.inject(styleSheet);\n\t\n\t  /** Outer-most className for GUI's */\n\t  var CSS_NAMESPACE = 'dg';\n\t\n\t  var HIDE_KEY_CODE = 72;\n\t\n\t  /** The only value shared between the JS and SCSS. Use caution. */\n\t  var CLOSE_BUTTON_HEIGHT = 20;\n\t\n\t  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';\n\t\n\t  var SUPPORTS_LOCAL_STORAGE = (function() {\n\t    try {\n\t      return 'localStorage' in window && window['localStorage'] !== null;\n\t    } catch (e) {\n\t      return false;\n\t    }\n\t  })();\n\t\n\t  var SAVE_DIALOGUE;\n\t\n\t  /** Have we yet to create an autoPlace GUI? */\n\t  var auto_place_virgin = true;\n\t\n\t  /** Fixed position div that auto place GUI's go inside */\n\t  var auto_place_container;\n\t\n\t  /** Are we hiding the GUI's ? */\n\t  var hide = false;\n\t\n\t  /** GUI's which should be hidden */\n\t  var hideable_guis = [];\n\t\n\t  /**\n\t   * A lightweight controller library for JavaScript. It allows you to easily\n\t   * manipulate variables and fire functions on the fly.\n\t   * @class\n\t   *\n\t   * @member dat.gui\n\t   *\n\t   * @param {Object} [params]\n\t   * @param {String} [params.name] The name of this GUI.\n\t   * @param {Object} [params.load] JSON object representing the saved state of\n\t   * this GUI.\n\t   * @param {Boolean} [params.auto=true]\n\t   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.\n\t   * @param {Boolean} [params.closed] If true, starts closed\n\t   */\n\t  var GUI = function(params) {\n\t\n\t    var _this = this;\n\t\n\t    /**\n\t     * Outermost DOM Element\n\t     * @type DOMElement\n\t     */\n\t    this.domElement = document.createElement('div');\n\t    this.__ul = document.createElement('ul');\n\t    this.domElement.appendChild(this.__ul);\n\t\n\t    dom.addClass(this.domElement, CSS_NAMESPACE);\n\t\n\t    /**\n\t     * Nested GUI's by name\n\t     * @ignore\n\t     */\n\t    this.__folders = {};\n\t\n\t    this.__controllers = [];\n\t\n\t    /**\n\t     * List of objects I'm remembering for save, only used in top level GUI\n\t     * @ignore\n\t     */\n\t    this.__rememberedObjects = [];\n\t\n\t    /**\n\t     * Maps the index of remembered objects to a map of controllers, only used\n\t     * in top level GUI.\n\t     *\n\t     * @private\n\t     * @ignore\n\t     *\n\t     * @example\n\t     * [\n\t     *  {\n\t     *    propertyName: Controller,\n\t     *    anotherPropertyName: Controller\n\t     *  },\n\t     *  {\n\t     *    propertyName: Controller\n\t     *  }\n\t     * ]\n\t     */\n\t    this.__rememberedObjectIndecesToControllers = [];\n\t\n\t    this.__listening = [];\n\t\n\t    params = params || {};\n\t\n\t    // Default parameters\n\t    params = common.defaults(params, {\n\t      autoPlace: true,\n\t      width: GUI.DEFAULT_WIDTH\n\t    });\n\t\n\t    params = common.defaults(params, {\n\t      resizable: params.autoPlace,\n\t      hideable: params.autoPlace\n\t    });\n\t\n\t\n\t    if (!common.isUndefined(params.load)) {\n\t\n\t      // Explicit preset\n\t      if (params.preset) params.load.preset = params.preset;\n\t\n\t    } else {\n\t\n\t      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };\n\t\n\t    }\n\t\n\t    if (common.isUndefined(params.parent) && params.hideable) {\n\t      hideable_guis.push(this);\n\t    }\n\t\n\t    // Only root level GUI's are resizable.\n\t    params.resizable = common.isUndefined(params.parent) && params.resizable;\n\t\n\t\n\t    if (params.autoPlace && common.isUndefined(params.scrollable)) {\n\t      params.scrollable = true;\n\t    }\n\t//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;\n\t\n\t    // Not part of params because I don't want people passing this in via\n\t    // constructor. Should be a 'remembered' value.\n\t    var use_local_storage =\n\t        SUPPORTS_LOCAL_STORAGE &&\n\t            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';\n\t\n\t    Object.defineProperties(this,\n\t\n\t        /** @lends dat.gui.GUI.prototype */\n\t        {\n\t\n\t          /**\n\t           * The parent <code>GUI</code>\n\t           * @type dat.gui.GUI\n\t           */\n\t          parent: {\n\t            get: function() {\n\t              return params.parent;\n\t            }\n\t          },\n\t\n\t          scrollable: {\n\t            get: function() {\n\t              return params.scrollable;\n\t            }\n\t          },\n\t\n\t          /**\n\t           * Handles <code>GUI</code>'s element placement for you\n\t           * @type Boolean\n\t           */\n\t          autoPlace: {\n\t            get: function() {\n\t              return params.autoPlace;\n\t            }\n\t          },\n\t\n\t          /**\n\t           * The identifier for a set of saved values\n\t           * @type String\n\t           */\n\t          preset: {\n\t\n\t            get: function() {\n\t              if (_this.parent) {\n\t                return _this.getRoot().preset;\n\t              } else {\n\t                return params.load.preset;\n\t              }\n\t            },\n\t\n\t            set: function(v) {\n\t              if (_this.parent) {\n\t                _this.getRoot().preset = v;\n\t              } else {\n\t                params.load.preset = v;\n\t              }\n\t              setPresetSelectIndex(this);\n\t              _this.revert();\n\t            }\n\t\n\t          },\n\t\n\t          /**\n\t           * The width of <code>GUI</code> element\n\t           * @type Number\n\t           */\n\t          width: {\n\t            get: function() {\n\t              return params.width;\n\t            },\n\t            set: function(v) {\n\t              params.width = v;\n\t              setWidth(_this, v);\n\t            }\n\t          },\n\t\n\t          /**\n\t           * The name of <code>GUI</code>. Used for folders. i.e\n\t           * a folder's name\n\t           * @type String\n\t           */\n\t          name: {\n\t            get: function() {\n\t              return params.name;\n\t            },\n\t            set: function(v) {\n\t              // TODO Check for collisions among sibling folders\n\t              params.name = v;\n\t              if (title_row_name) {\n\t                title_row_name.innerHTML = params.name;\n\t              }\n\t            }\n\t          },\n\t\n\t          /**\n\t           * Whether the <code>GUI</code> is collapsed or not\n\t           * @type Boolean\n\t           */\n\t          closed: {\n\t            get: function() {\n\t              return params.closed;\n\t            },\n\t            set: function(v) {\n\t              params.closed = v;\n\t              if (params.closed) {\n\t                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);\n\t              } else {\n\t                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);\n\t              }\n\t              // For browsers that aren't going to respect the CSS transition,\n\t              // Lets just check our height against the window height right off\n\t              // the bat.\n\t              this.onResize();\n\t\n\t              if (_this.__closeButton) {\n\t                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;\n\t              }\n\t            }\n\t          },\n\t\n\t          /**\n\t           * Contains all presets\n\t           * @type Object\n\t           */\n\t          load: {\n\t            get: function() {\n\t              return params.load;\n\t            }\n\t          },\n\t\n\t          /**\n\t           * Determines whether or not to use <a href=\"https://developer.mozilla.org/en/DOM/Storage#localStorage\">localStorage</a> as the means for\n\t           * <code>remember</code>ing\n\t           * @type Boolean\n\t           */\n\t          useLocalStorage: {\n\t\n\t            get: function() {\n\t              return use_local_storage;\n\t            },\n\t            set: function(bool) {\n\t              if (SUPPORTS_LOCAL_STORAGE) {\n\t                use_local_storage = bool;\n\t                if (bool) {\n\t                  dom.bind(window, 'unload', saveToLocalStorage);\n\t                } else {\n\t                  dom.unbind(window, 'unload', saveToLocalStorage);\n\t                }\n\t                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);\n\t              }\n\t            }\n\t\n\t          }\n\t\n\t        });\n\t\n\t    // Are we a root level GUI?\n\t    if (common.isUndefined(params.parent)) {\n\t\n\t      params.closed = false;\n\t\n\t      dom.addClass(this.domElement, GUI.CLASS_MAIN);\n\t      dom.makeSelectable(this.domElement, false);\n\t\n\t      // Are we supposed to be loading locally?\n\t      if (SUPPORTS_LOCAL_STORAGE) {\n\t\n\t        if (use_local_storage) {\n\t\n\t          _this.useLocalStorage = true;\n\t\n\t          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));\n\t\n\t          if (saved_gui) {\n\t            params.load = JSON.parse(saved_gui);\n\t          }\n\t\n\t        }\n\t\n\t      }\n\t\n\t      this.__closeButton = document.createElement('div');\n\t      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;\n\t      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);\n\t      this.domElement.appendChild(this.__closeButton);\n\t\n\t      dom.bind(this.__closeButton, 'click', function() {\n\t\n\t        _this.closed = !_this.closed;\n\t\n\t\n\t      });\n\t\n\t\n\t      // Oh, you're a nested GUI!\n\t    } else {\n\t\n\t      if (params.closed === undefined) {\n\t        params.closed = true;\n\t      }\n\t\n\t      var title_row_name = document.createTextNode(params.name);\n\t      dom.addClass(title_row_name, 'controller-name');\n\t\n\t      var title_row = addRow(_this, title_row_name);\n\t\n\t      var on_click_title = function(e) {\n\t        e.preventDefault();\n\t        _this.closed = !_this.closed;\n\t        return false;\n\t      };\n\t\n\t      dom.addClass(this.__ul, GUI.CLASS_CLOSED);\n\t\n\t      dom.addClass(title_row, 'title');\n\t      dom.bind(title_row, 'click', on_click_title);\n\t\n\t      if (!params.closed) {\n\t        this.closed = false;\n\t      }\n\t\n\t    }\n\t\n\t    if (params.autoPlace) {\n\t\n\t      if (common.isUndefined(params.parent)) {\n\t\n\t        if (auto_place_virgin) {\n\t          auto_place_container = document.createElement('div');\n\t          dom.addClass(auto_place_container, CSS_NAMESPACE);\n\t          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);\n\t          document.body.appendChild(auto_place_container);\n\t          auto_place_virgin = false;\n\t        }\n\t\n\t        // Put it in the dom for you.\n\t        auto_place_container.appendChild(this.domElement);\n\t\n\t        // Apply the auto styles\n\t        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);\n\t\n\t      }\n\t\n\t\n\t      // Make it not elastic.\n\t      if (!this.parent) setWidth(_this, params.width);\n\t\n\t    }\n\t\n\t    dom.bind(window, 'resize', function() { _this.onResize() });\n\t    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });\n\t    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });\n\t    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });\n\t    this.onResize();\n\t\n\t\n\t    if (params.resizable) {\n\t      addResizeHandle(this);\n\t    }\n\t\n\t    function saveToLocalStorage() {\n\t      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));\n\t    }\n\t\n\t    var root = _this.getRoot();\n\t    function resetWidth() {\n\t        var root = _this.getRoot();\n\t        root.width += 1;\n\t        common.defer(function() {\n\t          root.width -= 1;\n\t        });\n\t      }\n\t\n\t      if (!params.parent) {\n\t        resetWidth();\n\t      }\n\t\n\t  };\n\t\n\t  GUI.toggleHide = function() {\n\t\n\t    hide = !hide;\n\t    common.each(hideable_guis, function(gui) {\n\t      gui.domElement.style.zIndex = hide ? -999 : 999;\n\t      gui.domElement.style.opacity = hide ? 0 : 1;\n\t    });\n\t  };\n\t\n\t  GUI.CLASS_AUTO_PLACE = 'a';\n\t  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';\n\t  GUI.CLASS_MAIN = 'main';\n\t  GUI.CLASS_CONTROLLER_ROW = 'cr';\n\t  GUI.CLASS_TOO_TALL = 'taller-than-window';\n\t  GUI.CLASS_CLOSED = 'closed';\n\t  GUI.CLASS_CLOSE_BUTTON = 'close-button';\n\t  GUI.CLASS_DRAG = 'drag';\n\t\n\t  GUI.DEFAULT_WIDTH = 245;\n\t  GUI.TEXT_CLOSED = 'Close Controls';\n\t  GUI.TEXT_OPEN = 'Open Controls';\n\t\n\t  dom.bind(window, 'keydown', function(e) {\n\t\n\t    if (document.activeElement.type !== 'text' &&\n\t        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {\n\t      GUI.toggleHide();\n\t    }\n\t\n\t  }, false);\n\t\n\t  common.extend(\n\t\n\t      GUI.prototype,\n\t\n\t      /** @lends dat.gui.GUI */\n\t      {\n\t\n\t        /**\n\t         * @param object\n\t         * @param property\n\t         * @returns {dat.controllers.Controller} The new controller that was added.\n\t         * @instance\n\t         */\n\t        add: function(object, property) {\n\t\n\t          return add(\n\t              this,\n\t              object,\n\t              property,\n\t              {\n\t                factoryArgs: Array.prototype.slice.call(arguments, 2)\n\t              }\n\t          );\n\t\n\t        },\n\t\n\t        /**\n\t         * @param object\n\t         * @param property\n\t         * @returns {dat.controllers.ColorController} The new controller that was added.\n\t         * @instance\n\t         */\n\t        addColor: function(object, property) {\n\t\n\t          return add(\n\t              this,\n\t              object,\n\t              property,\n\t              {\n\t                color: true\n\t              }\n\t          );\n\t\n\t        },\n\t\n\t        /**\n\t         * @param controller\n\t         * @instance\n\t         */\n\t        remove: function(controller) {\n\t\n\t          // TODO listening?\n\t          this.__ul.removeChild(controller.__li);\n\t          this.__controllers.slice(this.__controllers.indexOf(controller), 1);\n\t          var _this = this;\n\t          common.defer(function() {\n\t            _this.onResize();\n\t          });\n\t\n\t        },\n\t\n\t        destroy: function() {\n\t\n\t          if (this.autoPlace) {\n\t            auto_place_container.removeChild(this.domElement);\n\t          }\n\t\n\t        },\n\t\n\t        /**\n\t         * @param name\n\t         * @returns {dat.gui.GUI} The new folder.\n\t         * @throws {Error} if this GUI already has a folder by the specified\n\t         * name\n\t         * @instance\n\t         */\n\t        addFolder: function(name) {\n\t\n\t          // We have to prevent collisions on names in order to have a key\n\t          // by which to remember saved values\n\t          if (this.__folders[name] !== undefined) {\n\t            throw new Error('You already have a folder in this GUI by the' +\n\t                ' name \"' + name + '\"');\n\t          }\n\t\n\t          var new_gui_params = { name: name, parent: this };\n\t\n\t          // We need to pass down the autoPlace trait so that we can\n\t          // attach event listeners to open/close folder actions to\n\t          // ensure that a scrollbar appears if the window is too short.\n\t          new_gui_params.autoPlace = this.autoPlace;\n\t\n\t          // Do we have saved appearance data for this folder?\n\t\n\t          if (this.load && // Anything loaded?\n\t              this.load.folders && // Was my parent a dead-end?\n\t              this.load.folders[name]) { // Did daddy remember me?\n\t\n\t            // Start me closed if I was closed\n\t            new_gui_params.closed = this.load.folders[name].closed;\n\t\n\t            // Pass down the loaded data\n\t            new_gui_params.load = this.load.folders[name];\n\t\n\t          }\n\t\n\t          var gui = new GUI(new_gui_params);\n\t          this.__folders[name] = gui;\n\t\n\t          var li = addRow(this, gui.domElement);\n\t          dom.addClass(li, 'folder');\n\t          return gui;\n\t\n\t        },\n\t\n\t        open: function() {\n\t          this.closed = false;\n\t        },\n\t\n\t        close: function() {\n\t          this.closed = true;\n\t        },\n\t\n\t        onResize: function() {\n\t\n\t          var root = this.getRoot();\n\t\n\t          if (root.scrollable) {\n\t\n\t            var top = dom.getOffset(root.__ul).top;\n\t            var h = 0;\n\t\n\t            common.each(root.__ul.childNodes, function(node) {\n\t              if (! (root.autoPlace && node === root.__save_row))\n\t                h += dom.getHeight(node);\n\t            });\n\t\n\t            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {\n\t              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);\n\t              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';\n\t            } else {\n\t              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);\n\t              root.__ul.style.height = 'auto';\n\t            }\n\t\n\t          }\n\t\n\t          if (root.__resize_handle) {\n\t            common.defer(function() {\n\t              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';\n\t            });\n\t          }\n\t\n\t          if (root.__closeButton) {\n\t            root.__closeButton.style.width = root.width + 'px';\n\t          }\n\t\n\t        },\n\t\n\t        /**\n\t         * Mark objects for saving. The order of these objects cannot change as\n\t         * the GUI grows. When remembering new objects, append them to the end\n\t         * of the list.\n\t         *\n\t         * @param {Object...} objects\n\t         * @throws {Error} if not called on a top level GUI.\n\t         * @instance\n\t         */\n\t        remember: function() {\n\t\n\t          if (common.isUndefined(SAVE_DIALOGUE)) {\n\t            SAVE_DIALOGUE = new CenteredDiv();\n\t            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;\n\t          }\n\t\n\t          if (this.parent) {\n\t            throw new Error(\"You can only call remember on a top level GUI.\");\n\t          }\n\t\n\t          var _this = this;\n\t\n\t          common.each(Array.prototype.slice.call(arguments), function(object) {\n\t            if (_this.__rememberedObjects.length == 0) {\n\t              addSaveMenu(_this);\n\t            }\n\t            if (_this.__rememberedObjects.indexOf(object) == -1) {\n\t              _this.__rememberedObjects.push(object);\n\t            }\n\t          });\n\t\n\t          if (this.autoPlace) {\n\t            // Set save row width\n\t            setWidth(this, this.width);\n\t          }\n\t\n\t        },\n\t\n\t        /**\n\t         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.\n\t         * @instance\n\t         */\n\t        getRoot: function() {\n\t          var gui = this;\n\t          while (gui.parent) {\n\t            gui = gui.parent;\n\t          }\n\t          return gui;\n\t        },\n\t\n\t        /**\n\t         * @returns {Object} a JSON object representing the current state of\n\t         * this GUI as well as its remembered properties.\n\t         * @instance\n\t         */\n\t        getSaveObject: function() {\n\t\n\t          var toReturn = this.load;\n\t\n\t          toReturn.closed = this.closed;\n\t\n\t          // Am I remembering any values?\n\t          if (this.__rememberedObjects.length > 0) {\n\t\n\t            toReturn.preset = this.preset;\n\t\n\t            if (!toReturn.remembered) {\n\t              toReturn.remembered = {};\n\t            }\n\t\n\t            toReturn.remembered[this.preset] = getCurrentPreset(this);\n\t\n\t          }\n\t\n\t          toReturn.folders = {};\n\t          common.each(this.__folders, function(element, key) {\n\t            toReturn.folders[key] = element.getSaveObject();\n\t          });\n\t\n\t          return toReturn;\n\t\n\t        },\n\t\n\t        save: function() {\n\t\n\t          if (!this.load.remembered) {\n\t            this.load.remembered = {};\n\t          }\n\t\n\t          this.load.remembered[this.preset] = getCurrentPreset(this);\n\t          markPresetModified(this, false);\n\t\n\t        },\n\t\n\t        saveAs: function(presetName) {\n\t\n\t          if (!this.load.remembered) {\n\t\n\t            // Retain default values upon first save\n\t            this.load.remembered = {};\n\t            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);\n\t\n\t          }\n\t\n\t          this.load.remembered[presetName] = getCurrentPreset(this);\n\t          this.preset = presetName;\n\t          addPresetOption(this, presetName, true);\n\t\n\t        },\n\t\n\t        revert: function(gui) {\n\t\n\t          common.each(this.__controllers, function(controller) {\n\t            // Make revert work on Default.\n\t            if (!this.getRoot().load.remembered) {\n\t              controller.setValue(controller.initialValue);\n\t            } else {\n\t              recallSavedValue(gui || this.getRoot(), controller);\n\t            }\n\t          }, this);\n\t\n\t          common.each(this.__folders, function(folder) {\n\t            folder.revert(folder);\n\t          });\n\t\n\t          if (!gui) {\n\t            markPresetModified(this.getRoot(), false);\n\t          }\n\t\n\t\n\t        },\n\t\n\t        listen: function(controller) {\n\t\n\t          var init = this.__listening.length == 0;\n\t          this.__listening.push(controller);\n\t          if (init) updateDisplays(this.__listening);\n\t\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  function add(gui, object, property, params) {\n\t\n\t    if (object[property] === undefined) {\n\t      throw new Error(\"Object \" + object + \" has no property \\\"\" + property + \"\\\"\");\n\t    }\n\t\n\t    var controller;\n\t\n\t    if (params.color) {\n\t\n\t      controller = new ColorController(object, property);\n\t\n\t    } else {\n\t\n\t      var factoryArgs = [object,property].concat(params.factoryArgs);\n\t      controller = controllerFactory.apply(gui, factoryArgs);\n\t\n\t    }\n\t\n\t    if (params.before instanceof Controller) {\n\t      params.before = params.before.__li;\n\t    }\n\t\n\t    recallSavedValue(gui, controller);\n\t\n\t    dom.addClass(controller.domElement, 'c');\n\t\n\t    var name = document.createElement('span');\n\t    dom.addClass(name, 'property-name');\n\t    name.innerHTML = controller.property;\n\t\n\t    var container = document.createElement('div');\n\t    container.appendChild(name);\n\t    container.appendChild(controller.domElement);\n\t\n\t    var li = addRow(gui, container, params.before);\n\t\n\t    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);\n\t    dom.addClass(li, typeof controller.getValue());\n\t\n\t    augmentController(gui, li, controller);\n\t\n\t    gui.__controllers.push(controller);\n\t\n\t    return controller;\n\t\n\t  }\n\t\n\t  /**\n\t   * Add a row to the end of the GUI or before another row.\n\t   *\n\t   * @param gui\n\t   * @param [dom] If specified, inserts the dom content in the new row\n\t   * @param [liBefore] If specified, places the new row before another row\n\t   */\n\t  function addRow(gui, dom, liBefore) {\n\t    var li = document.createElement('li');\n\t    if (dom) li.appendChild(dom);\n\t    if (liBefore) {\n\t      gui.__ul.insertBefore(li, params.before);\n\t    } else {\n\t      gui.__ul.appendChild(li);\n\t    }\n\t    gui.onResize();\n\t    return li;\n\t  }\n\t\n\t  function augmentController(gui, li, controller) {\n\t\n\t    controller.__li = li;\n\t    controller.__gui = gui;\n\t\n\t    common.extend(controller, {\n\t\n\t      options: function(options) {\n\t\n\t        if (arguments.length > 1) {\n\t          controller.remove();\n\t\n\t          return add(\n\t              gui,\n\t              controller.object,\n\t              controller.property,\n\t              {\n\t                before: controller.__li.nextElementSibling,\n\t                factoryArgs: [common.toArray(arguments)]\n\t              }\n\t          );\n\t\n\t        }\n\t\n\t        if (common.isArray(options) || common.isObject(options)) {\n\t          controller.remove();\n\t\n\t          return add(\n\t              gui,\n\t              controller.object,\n\t              controller.property,\n\t              {\n\t                before: controller.__li.nextElementSibling,\n\t                factoryArgs: [options]\n\t              }\n\t          );\n\t\n\t        }\n\t\n\t      },\n\t\n\t      name: function(v) {\n\t        controller.__li.firstElementChild.firstElementChild.innerHTML = v;\n\t        return controller;\n\t      },\n\t\n\t      listen: function() {\n\t        controller.__gui.listen(controller);\n\t        return controller;\n\t      },\n\t\n\t      remove: function() {\n\t        controller.__gui.remove(controller);\n\t        return controller;\n\t      }\n\t\n\t    });\n\t\n\t    // All sliders should be accompanied by a box.\n\t    if (controller instanceof NumberControllerSlider) {\n\t\n\t      var box = new NumberControllerBox(controller.object, controller.property,\n\t          { min: controller.__min, max: controller.__max, step: controller.__step });\n\t\n\t      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {\n\t        var pc = controller[method];\n\t        var pb = box[method];\n\t        controller[method] = box[method] = function() {\n\t          var args = Array.prototype.slice.call(arguments);\n\t          pc.apply(controller, args);\n\t          return pb.apply(box, args);\n\t        }\n\t      });\n\t\n\t      dom.addClass(li, 'has-slider');\n\t      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);\n\t\n\t    }\n\t    else if (controller instanceof NumberControllerBox) {\n\t\n\t      var r = function(returned) {\n\t\n\t        // Have we defined both boundaries?\n\t        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {\n\t\n\t          // Well, then lets just replace this with a slider.\n\t          controller.remove();\n\t          return add(\n\t              gui,\n\t              controller.object,\n\t              controller.property,\n\t              {\n\t                before: controller.__li.nextElementSibling,\n\t                factoryArgs: [controller.__min, controller.__max, controller.__step]\n\t              });\n\t\n\t        }\n\t\n\t        return returned;\n\t\n\t      };\n\t\n\t      controller.min = common.compose(r, controller.min);\n\t      controller.max = common.compose(r, controller.max);\n\t\n\t    }\n\t    else if (controller instanceof BooleanController) {\n\t\n\t      dom.bind(li, 'click', function() {\n\t        dom.fakeEvent(controller.__checkbox, 'click');\n\t      });\n\t\n\t      dom.bind(controller.__checkbox, 'click', function(e) {\n\t        e.stopPropagation(); // Prevents double-toggle\n\t      })\n\t\n\t    }\n\t    else if (controller instanceof FunctionController) {\n\t\n\t      dom.bind(li, 'click', function() {\n\t        dom.fakeEvent(controller.__button, 'click');\n\t      });\n\t\n\t      dom.bind(li, 'mouseover', function() {\n\t        dom.addClass(controller.__button, 'hover');\n\t      });\n\t\n\t      dom.bind(li, 'mouseout', function() {\n\t        dom.removeClass(controller.__button, 'hover');\n\t      });\n\t\n\t    }\n\t    else if (controller instanceof ColorController) {\n\t\n\t      dom.addClass(li, 'color');\n\t      controller.updateDisplay = common.compose(function(r) {\n\t        li.style.borderLeftColor = controller.__color.toString();\n\t        return r;\n\t      }, controller.updateDisplay);\n\t\n\t      controller.updateDisplay();\n\t\n\t    }\n\t\n\t    controller.setValue = common.compose(function(r) {\n\t      if (gui.getRoot().__preset_select && controller.isModified()) {\n\t        markPresetModified(gui.getRoot(), true);\n\t      }\n\t      return r;\n\t    }, controller.setValue);\n\t\n\t  }\n\t\n\t  function recallSavedValue(gui, controller) {\n\t\n\t    // Find the topmost GUI, that's where remembered objects live.\n\t    var root = gui.getRoot();\n\t\n\t    // Does the object we're controlling match anything we've been told to\n\t    // remember?\n\t    var matched_index = root.__rememberedObjects.indexOf(controller.object);\n\t\n\t    // Why yes, it does!\n\t    if (matched_index != -1) {\n\t\n\t      // Let me fetch a map of controllers for thcommon.isObject.\n\t      var controller_map =\n\t          root.__rememberedObjectIndecesToControllers[matched_index];\n\t\n\t      // Ohp, I believe this is the first controller we've created for this\n\t      // object. Lets make the map fresh.\n\t      if (controller_map === undefined) {\n\t        controller_map = {};\n\t        root.__rememberedObjectIndecesToControllers[matched_index] =\n\t            controller_map;\n\t      }\n\t\n\t      // Keep track of this controller\n\t      controller_map[controller.property] = controller;\n\t\n\t      // Okay, now have we saved any values for this controller?\n\t      if (root.load && root.load.remembered) {\n\t\n\t        var preset_map = root.load.remembered;\n\t\n\t        // Which preset are we trying to load?\n\t        var preset;\n\t\n\t        if (preset_map[gui.preset]) {\n\t\n\t          preset = preset_map[gui.preset];\n\t\n\t        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {\n\t\n\t          // Uhh, you can have the default instead?\n\t          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];\n\t\n\t        } else {\n\t\n\t          // Nada.\n\t\n\t          return;\n\t\n\t        }\n\t\n\t\n\t        // Did the loaded object remember thcommon.isObject?\n\t        if (preset[matched_index] &&\n\t\n\t          // Did we remember this particular property?\n\t            preset[matched_index][controller.property] !== undefined) {\n\t\n\t          // We did remember something for this guy ...\n\t          var value = preset[matched_index][controller.property];\n\t\n\t          // And that's what it is.\n\t          controller.initialValue = value;\n\t          controller.setValue(value);\n\t\n\t        }\n\t\n\t      }\n\t\n\t    }\n\t\n\t  }\n\t\n\t  function getLocalStorageHash(gui, key) {\n\t    // TODO how does this deal with multiple GUI's?\n\t    return document.location.href + '.' + key;\n\t\n\t  }\n\t\n\t  function addSaveMenu(gui) {\n\t\n\t    var div = gui.__save_row = document.createElement('li');\n\t\n\t    dom.addClass(gui.domElement, 'has-save');\n\t\n\t    gui.__ul.insertBefore(div, gui.__ul.firstChild);\n\t\n\t    dom.addClass(div, 'save-row');\n\t\n\t    var gears = document.createElement('span');\n\t    gears.innerHTML = '&nbsp;';\n\t    dom.addClass(gears, 'button gears');\n\t\n\t    // TODO replace with FunctionController\n\t    var button = document.createElement('span');\n\t    button.innerHTML = 'Save';\n\t    dom.addClass(button, 'button');\n\t    dom.addClass(button, 'save');\n\t\n\t    var button2 = document.createElement('span');\n\t    button2.innerHTML = 'New';\n\t    dom.addClass(button2, 'button');\n\t    dom.addClass(button2, 'save-as');\n\t\n\t    var button3 = document.createElement('span');\n\t    button3.innerHTML = 'Revert';\n\t    dom.addClass(button3, 'button');\n\t    dom.addClass(button3, 'revert');\n\t\n\t    var select = gui.__preset_select = document.createElement('select');\n\t\n\t    if (gui.load && gui.load.remembered) {\n\t\n\t      common.each(gui.load.remembered, function(value, key) {\n\t        addPresetOption(gui, key, key == gui.preset);\n\t      });\n\t\n\t    } else {\n\t      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);\n\t    }\n\t\n\t    dom.bind(select, 'change', function() {\n\t\n\t\n\t      for (var index = 0; index < gui.__preset_select.length; index++) {\n\t        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;\n\t      }\n\t\n\t      gui.preset = this.value;\n\t\n\t    });\n\t\n\t    div.appendChild(select);\n\t    div.appendChild(gears);\n\t    div.appendChild(button);\n\t    div.appendChild(button2);\n\t    div.appendChild(button3);\n\t\n\t    if (SUPPORTS_LOCAL_STORAGE) {\n\t\n\t      var saveLocally = document.getElementById('dg-save-locally');\n\t      var explain = document.getElementById('dg-local-explain');\n\t\n\t      saveLocally.style.display = 'block';\n\t\n\t      var localStorageCheckBox = document.getElementById('dg-local-storage');\n\t\n\t      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {\n\t        localStorageCheckBox.setAttribute('checked', 'checked');\n\t      }\n\t\n\t      function showHideExplain() {\n\t        explain.style.display = gui.useLocalStorage ? 'block' : 'none';\n\t      }\n\t\n\t      showHideExplain();\n\t\n\t      // TODO: Use a boolean controller, fool!\n\t      dom.bind(localStorageCheckBox, 'change', function() {\n\t        gui.useLocalStorage = !gui.useLocalStorage;\n\t        showHideExplain();\n\t      });\n\t\n\t    }\n\t\n\t    var newConstructorTextArea = document.getElementById('dg-new-constructor');\n\t\n\t    dom.bind(newConstructorTextArea, 'keydown', function(e) {\n\t      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {\n\t        SAVE_DIALOGUE.hide();\n\t      }\n\t    });\n\t\n\t    dom.bind(gears, 'click', function() {\n\t      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);\n\t      SAVE_DIALOGUE.show();\n\t      newConstructorTextArea.focus();\n\t      newConstructorTextArea.select();\n\t    });\n\t\n\t    dom.bind(button, 'click', function() {\n\t      gui.save();\n\t    });\n\t\n\t    dom.bind(button2, 'click', function() {\n\t      var presetName = prompt('Enter a new preset name.');\n\t      if (presetName) gui.saveAs(presetName);\n\t    });\n\t\n\t    dom.bind(button3, 'click', function() {\n\t      gui.revert();\n\t    });\n\t\n\t//    div.appendChild(button2);\n\t\n\t  }\n\t\n\t  function addResizeHandle(gui) {\n\t\n\t    gui.__resize_handle = document.createElement('div');\n\t\n\t    common.extend(gui.__resize_handle.style, {\n\t\n\t      width: '6px',\n\t      marginLeft: '-3px',\n\t      height: '200px',\n\t      cursor: 'ew-resize',\n\t      position: 'absolute'\n\t//      border: '1px solid blue'\n\t\n\t    });\n\t\n\t    var pmouseX;\n\t\n\t    dom.bind(gui.__resize_handle, 'mousedown', dragStart);\n\t    dom.bind(gui.__closeButton, 'mousedown', dragStart);\n\t\n\t    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);\n\t\n\t    function dragStart(e) {\n\t\n\t      e.preventDefault();\n\t\n\t      pmouseX = e.clientX;\n\t\n\t      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);\n\t      dom.bind(window, 'mousemove', drag);\n\t      dom.bind(window, 'mouseup', dragStop);\n\t\n\t      return false;\n\t\n\t    }\n\t\n\t    function drag(e) {\n\t\n\t      e.preventDefault();\n\t\n\t      gui.width += pmouseX - e.clientX;\n\t      gui.onResize();\n\t      pmouseX = e.clientX;\n\t\n\t      return false;\n\t\n\t    }\n\t\n\t    function dragStop() {\n\t\n\t      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);\n\t      dom.unbind(window, 'mousemove', drag);\n\t      dom.unbind(window, 'mouseup', dragStop);\n\t\n\t    }\n\t\n\t  }\n\t\n\t  function setWidth(gui, w) {\n\t    gui.domElement.style.width = w + 'px';\n\t    // Auto placed save-rows are position fixed, so we have to\n\t    // set the width manually if we want it to bleed to the edge\n\t    if (gui.__save_row && gui.autoPlace) {\n\t      gui.__save_row.style.width = w + 'px';\n\t    }if (gui.__closeButton) {\n\t      gui.__closeButton.style.width = w + 'px';\n\t    }\n\t  }\n\t\n\t  function getCurrentPreset(gui, useInitialValues) {\n\t\n\t    var toReturn = {};\n\t\n\t    // For each object I'm remembering\n\t    common.each(gui.__rememberedObjects, function(val, index) {\n\t\n\t      var saved_values = {};\n\t\n\t      // The controllers I've made for thcommon.isObject by property\n\t      var controller_map =\n\t          gui.__rememberedObjectIndecesToControllers[index];\n\t\n\t      // Remember each value for each property\n\t      common.each(controller_map, function(controller, property) {\n\t        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();\n\t      });\n\t\n\t      // Save the values for thcommon.isObject\n\t      toReturn[index] = saved_values;\n\t\n\t    });\n\t\n\t    return toReturn;\n\t\n\t  }\n\t\n\t  function addPresetOption(gui, name, setSelected) {\n\t    var opt = document.createElement('option');\n\t    opt.innerHTML = name;\n\t    opt.value = name;\n\t    gui.__preset_select.appendChild(opt);\n\t    if (setSelected) {\n\t      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;\n\t    }\n\t  }\n\t\n\t  function setPresetSelectIndex(gui) {\n\t    for (var index = 0; index < gui.__preset_select.length; index++) {\n\t      if (gui.__preset_select[index].value == gui.preset) {\n\t        gui.__preset_select.selectedIndex = index;\n\t      }\n\t    }\n\t  }\n\t\n\t  function markPresetModified(gui, modified) {\n\t    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];\n\t//    console.log('mark', modified, opt);\n\t    if (modified) {\n\t      opt.innerHTML = opt.value + \"*\";\n\t    } else {\n\t      opt.innerHTML = opt.value;\n\t    }\n\t  }\n\t\n\t  function updateDisplays(controllerArray) {\n\t\n\t\n\t    if (controllerArray.length != 0) {\n\t\n\t      requestAnimationFrame(function() {\n\t        updateDisplays(controllerArray);\n\t      });\n\t\n\t    }\n\t\n\t    common.each(controllerArray, function(c) {\n\t      c.updateDisplay();\n\t    });\n\t\n\t  }\n\t\n\t  return GUI;\n\t\n\t})(dat.utils.css,\n\t\"<div id=\\\"dg-save\\\" class=\\\"dg dialogue\\\">\\n\\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\\n\\n  <textarea id=\\\"dg-new-constructor\\\"></textarea>\\n\\n  <div id=\\\"dg-save-locally\\\">\\n\\n    <input id=\\\"dg-local-storage\\\" type=\\\"checkbox\\\"/> Automatically save\\n    values to <code>localStorage</code> on exit.\\n\\n    <div id=\\\"dg-local-explain\\\">The values saved to <code>localStorage</code> will\\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\\n      easier to work incrementally, but <code>localStorage</code> is fragile,\\n      and your friends may not see the same values you do.\\n      \\n    </div>\\n    \\n  </div>\\n\\n</div>\",\n\t\".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\\n\",\n\tdat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {\n\t\n\t      return function(object, property) {\n\t\n\t        var initialValue = object[property];\n\t\n\t        // Providing options?\n\t        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {\n\t          return new OptionController(object, property, arguments[2]);\n\t        }\n\t\n\t        // Providing a map?\n\t\n\t        if (common.isNumber(initialValue)) {\n\t\n\t          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {\n\t\n\t            // Has min and max.\n\t            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);\n\t\n\t          } else {\n\t\n\t            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });\n\t\n\t          }\n\t\n\t        }\n\t\n\t        if (common.isString(initialValue)) {\n\t          return new StringController(object, property);\n\t        }\n\t\n\t        if (common.isFunction(initialValue)) {\n\t          return new FunctionController(object, property, '');\n\t        }\n\t\n\t        if (common.isBoolean(initialValue)) {\n\t          return new BooleanController(object, property);\n\t        }\n\t\n\t      }\n\t\n\t    })(dat.controllers.OptionController,\n\tdat.controllers.NumberControllerBox,\n\tdat.controllers.NumberControllerSlider,\n\tdat.controllers.StringController = (function (Controller, dom, common) {\n\t\n\t  /**\n\t   * @class Provides a text input to alter the string property of an object.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var StringController = function(object, property) {\n\t\n\t    StringController.superclass.call(this, object, property);\n\t\n\t    var _this = this;\n\t\n\t    this.__input = document.createElement('input');\n\t    this.__input.setAttribute('type', 'text');\n\t\n\t    dom.bind(this.__input, 'keyup', onChange);\n\t    dom.bind(this.__input, 'change', onChange);\n\t    dom.bind(this.__input, 'blur', onBlur);\n\t    dom.bind(this.__input, 'keydown', function(e) {\n\t      if (e.keyCode === 13) {\n\t        this.blur();\n\t      }\n\t    });\n\t    \n\t\n\t    function onChange() {\n\t      _this.setValue(_this.__input.value);\n\t    }\n\t\n\t    function onBlur() {\n\t      if (_this.__onFinishChange) {\n\t        _this.__onFinishChange.call(_this, _this.getValue());\n\t      }\n\t    }\n\t\n\t    this.updateDisplay();\n\t\n\t    this.domElement.appendChild(this.__input);\n\t\n\t  };\n\t\n\t  StringController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      StringController.prototype,\n\t      Controller.prototype,\n\t\n\t      {\n\t\n\t        updateDisplay: function() {\n\t          // Stops the caret from moving on account of:\n\t          // keyup -> setValue -> updateDisplay\n\t          if (!dom.isActive(this.__input)) {\n\t            this.__input.value = this.getValue();\n\t          }\n\t          return StringController.superclass.prototype.updateDisplay.call(this);\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  return StringController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.dom.dom,\n\tdat.utils.common),\n\tdat.controllers.FunctionController,\n\tdat.controllers.BooleanController,\n\tdat.utils.common),\n\tdat.controllers.Controller,\n\tdat.controllers.BooleanController,\n\tdat.controllers.FunctionController,\n\tdat.controllers.NumberControllerBox,\n\tdat.controllers.NumberControllerSlider,\n\tdat.controllers.OptionController,\n\tdat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {\n\t\n\t  var ColorController = function(object, property) {\n\t\n\t    ColorController.superclass.call(this, object, property);\n\t\n\t    this.__color = new Color(this.getValue());\n\t    this.__temp = new Color(0);\n\t\n\t    var _this = this;\n\t\n\t    this.domElement = document.createElement('div');\n\t\n\t    dom.makeSelectable(this.domElement, false);\n\t\n\t    this.__selector = document.createElement('div');\n\t    this.__selector.className = 'selector';\n\t\n\t    this.__saturation_field = document.createElement('div');\n\t    this.__saturation_field.className = 'saturation-field';\n\t\n\t    this.__field_knob = document.createElement('div');\n\t    this.__field_knob.className = 'field-knob';\n\t    this.__field_knob_border = '2px solid ';\n\t\n\t    this.__hue_knob = document.createElement('div');\n\t    this.__hue_knob.className = 'hue-knob';\n\t\n\t    this.__hue_field = document.createElement('div');\n\t    this.__hue_field.className = 'hue-field';\n\t\n\t    this.__input = document.createElement('input');\n\t    this.__input.type = 'text';\n\t    this.__input_textShadow = '0 1px 1px ';\n\t\n\t    dom.bind(this.__input, 'keydown', function(e) {\n\t      if (e.keyCode === 13) { // on enter\n\t        onBlur.call(this);\n\t      }\n\t    });\n\t\n\t    dom.bind(this.__input, 'blur', onBlur);\n\t\n\t    dom.bind(this.__selector, 'mousedown', function(e) {\n\t\n\t      dom\n\t        .addClass(this, 'drag')\n\t        .bind(window, 'mouseup', function(e) {\n\t          dom.removeClass(_this.__selector, 'drag');\n\t        });\n\t\n\t    });\n\t\n\t    var value_field = document.createElement('div');\n\t\n\t    common.extend(this.__selector.style, {\n\t      width: '122px',\n\t      height: '102px',\n\t      padding: '3px',\n\t      backgroundColor: '#222',\n\t      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'\n\t    });\n\t\n\t    common.extend(this.__field_knob.style, {\n\t      position: 'absolute',\n\t      width: '12px',\n\t      height: '12px',\n\t      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),\n\t      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',\n\t      borderRadius: '12px',\n\t      zIndex: 1\n\t    });\n\t    \n\t    common.extend(this.__hue_knob.style, {\n\t      position: 'absolute',\n\t      width: '15px',\n\t      height: '2px',\n\t      borderRight: '4px solid #fff',\n\t      zIndex: 1\n\t    });\n\t\n\t    common.extend(this.__saturation_field.style, {\n\t      width: '100px',\n\t      height: '100px',\n\t      border: '1px solid #555',\n\t      marginRight: '3px',\n\t      display: 'inline-block',\n\t      cursor: 'pointer'\n\t    });\n\t\n\t    common.extend(value_field.style, {\n\t      width: '100%',\n\t      height: '100%',\n\t      background: 'none'\n\t    });\n\t    \n\t    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');\n\t\n\t    common.extend(this.__hue_field.style, {\n\t      width: '15px',\n\t      height: '100px',\n\t      display: 'inline-block',\n\t      border: '1px solid #555',\n\t      cursor: 'ns-resize'\n\t    });\n\t\n\t    hueGradient(this.__hue_field);\n\t\n\t    common.extend(this.__input.style, {\n\t      outline: 'none',\n\t//      width: '120px',\n\t      textAlign: 'center',\n\t//      padding: '4px',\n\t//      marginBottom: '6px',\n\t      color: '#fff',\n\t      border: 0,\n\t      fontWeight: 'bold',\n\t      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'\n\t    });\n\t\n\t    dom.bind(this.__saturation_field, 'mousedown', fieldDown);\n\t    dom.bind(this.__field_knob, 'mousedown', fieldDown);\n\t\n\t    dom.bind(this.__hue_field, 'mousedown', function(e) {\n\t      setH(e);\n\t      dom.bind(window, 'mousemove', setH);\n\t      dom.bind(window, 'mouseup', unbindH);\n\t    });\n\t\n\t    function fieldDown(e) {\n\t      setSV(e);\n\t      // document.body.style.cursor = 'none';\n\t      dom.bind(window, 'mousemove', setSV);\n\t      dom.bind(window, 'mouseup', unbindSV);\n\t    }\n\t\n\t    function unbindSV() {\n\t      dom.unbind(window, 'mousemove', setSV);\n\t      dom.unbind(window, 'mouseup', unbindSV);\n\t      // document.body.style.cursor = 'default';\n\t    }\n\t\n\t    function onBlur() {\n\t      var i = interpret(this.value);\n\t      if (i !== false) {\n\t        _this.__color.__state = i;\n\t        _this.setValue(_this.__color.toOriginal());\n\t      } else {\n\t        this.value = _this.__color.toString();\n\t      }\n\t    }\n\t\n\t    function unbindH() {\n\t      dom.unbind(window, 'mousemove', setH);\n\t      dom.unbind(window, 'mouseup', unbindH);\n\t    }\n\t\n\t    this.__saturation_field.appendChild(value_field);\n\t    this.__selector.appendChild(this.__field_knob);\n\t    this.__selector.appendChild(this.__saturation_field);\n\t    this.__selector.appendChild(this.__hue_field);\n\t    this.__hue_field.appendChild(this.__hue_knob);\n\t\n\t    this.domElement.appendChild(this.__input);\n\t    this.domElement.appendChild(this.__selector);\n\t\n\t    this.updateDisplay();\n\t\n\t    function setSV(e) {\n\t\n\t      e.preventDefault();\n\t\n\t      var w = dom.getWidth(_this.__saturation_field);\n\t      var o = dom.getOffset(_this.__saturation_field);\n\t      var s = (e.clientX - o.left + document.body.scrollLeft) / w;\n\t      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;\n\t\n\t      if (v > 1) v = 1;\n\t      else if (v < 0) v = 0;\n\t\n\t      if (s > 1) s = 1;\n\t      else if (s < 0) s = 0;\n\t\n\t      _this.__color.v = v;\n\t      _this.__color.s = s;\n\t\n\t      _this.setValue(_this.__color.toOriginal());\n\t\n\t\n\t      return false;\n\t\n\t    }\n\t\n\t    function setH(e) {\n\t\n\t      e.preventDefault();\n\t\n\t      var s = dom.getHeight(_this.__hue_field);\n\t      var o = dom.getOffset(_this.__hue_field);\n\t      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;\n\t\n\t      if (h > 1) h = 1;\n\t      else if (h < 0) h = 0;\n\t\n\t      _this.__color.h = h * 360;\n\t\n\t      _this.setValue(_this.__color.toOriginal());\n\t\n\t      return false;\n\t\n\t    }\n\t\n\t  };\n\t\n\t  ColorController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      ColorController.prototype,\n\t      Controller.prototype,\n\t\n\t      {\n\t\n\t        updateDisplay: function() {\n\t\n\t          var i = interpret(this.getValue());\n\t\n\t          if (i !== false) {\n\t\n\t            var mismatch = false;\n\t\n\t            // Check for mismatch on the interpreted value.\n\t\n\t            common.each(Color.COMPONENTS, function(component) {\n\t              if (!common.isUndefined(i[component]) &&\n\t                  !common.isUndefined(this.__color.__state[component]) &&\n\t                  i[component] !== this.__color.__state[component]) {\n\t                mismatch = true;\n\t                return {}; // break\n\t              }\n\t            }, this);\n\t\n\t            // If nothing diverges, we keep our previous values\n\t            // for statefulness, otherwise we recalculate fresh\n\t            if (mismatch) {\n\t              common.extend(this.__color.__state, i);\n\t            }\n\t\n\t          }\n\t\n\t          common.extend(this.__temp.__state, this.__color.__state);\n\t\n\t          this.__temp.a = 1;\n\t\n\t          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;\n\t          var _flip = 255 - flip;\n\t\n\t          common.extend(this.__field_knob.style, {\n\t            marginLeft: 100 * this.__color.s - 7 + 'px',\n\t            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',\n\t            backgroundColor: this.__temp.toString(),\n\t            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'\n\t          });\n\t\n\t          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'\n\t\n\t          this.__temp.s = 1;\n\t          this.__temp.v = 1;\n\t\n\t          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());\n\t\n\t          common.extend(this.__input.style, {\n\t            backgroundColor: this.__input.value = this.__color.toString(),\n\t            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',\n\t            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'\n\t          });\n\t\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t  \n\t  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];\n\t  \n\t  function linearGradient(elem, x, a, b) {\n\t    elem.style.background = '';\n\t    common.each(vendors, function(vendor) {\n\t      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';\n\t    });\n\t  }\n\t  \n\t  function hueGradient(elem) {\n\t    elem.style.background = '';\n\t    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'\n\t    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n\t    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n\t    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n\t    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n\t  }\n\t\n\t\n\t  return ColorController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.dom.dom,\n\tdat.color.Color = (function (interpret, math, toString, common) {\n\t\n\t  var Color = function() {\n\t\n\t    this.__state = interpret.apply(this, arguments);\n\t\n\t    if (this.__state === false) {\n\t      throw 'Failed to interpret color arguments';\n\t    }\n\t\n\t    this.__state.a = this.__state.a || 1;\n\t\n\t\n\t  };\n\t\n\t  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];\n\t\n\t  common.extend(Color.prototype, {\n\t\n\t    toString: function() {\n\t      return toString(this);\n\t    },\n\t\n\t    toOriginal: function() {\n\t      return this.__state.conversion.write(this);\n\t    }\n\t\n\t  });\n\t\n\t  defineRGBComponent(Color.prototype, 'r', 2);\n\t  defineRGBComponent(Color.prototype, 'g', 1);\n\t  defineRGBComponent(Color.prototype, 'b', 0);\n\t\n\t  defineHSVComponent(Color.prototype, 'h');\n\t  defineHSVComponent(Color.prototype, 's');\n\t  defineHSVComponent(Color.prototype, 'v');\n\t\n\t  Object.defineProperty(Color.prototype, 'a', {\n\t\n\t    get: function() {\n\t      return this.__state.a;\n\t    },\n\t\n\t    set: function(v) {\n\t      this.__state.a = v;\n\t    }\n\t\n\t  });\n\t\n\t  Object.defineProperty(Color.prototype, 'hex', {\n\t\n\t    get: function() {\n\t\n\t      if (!this.__state.space !== 'HEX') {\n\t        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);\n\t      }\n\t\n\t      return this.__state.hex;\n\t\n\t    },\n\t\n\t    set: function(v) {\n\t\n\t      this.__state.space = 'HEX';\n\t      this.__state.hex = v;\n\t\n\t    }\n\t\n\t  });\n\t\n\t  function defineRGBComponent(target, component, componentHexIndex) {\n\t\n\t    Object.defineProperty(target, component, {\n\t\n\t      get: function() {\n\t\n\t        if (this.__state.space === 'RGB') {\n\t          return this.__state[component];\n\t        }\n\t\n\t        recalculateRGB(this, component, componentHexIndex);\n\t\n\t        return this.__state[component];\n\t\n\t      },\n\t\n\t      set: function(v) {\n\t\n\t        if (this.__state.space !== 'RGB') {\n\t          recalculateRGB(this, component, componentHexIndex);\n\t          this.__state.space = 'RGB';\n\t        }\n\t\n\t        this.__state[component] = v;\n\t\n\t      }\n\t\n\t    });\n\t\n\t  }\n\t\n\t  function defineHSVComponent(target, component) {\n\t\n\t    Object.defineProperty(target, component, {\n\t\n\t      get: function() {\n\t\n\t        if (this.__state.space === 'HSV')\n\t          return this.__state[component];\n\t\n\t        recalculateHSV(this);\n\t\n\t        return this.__state[component];\n\t\n\t      },\n\t\n\t      set: function(v) {\n\t\n\t        if (this.__state.space !== 'HSV') {\n\t          recalculateHSV(this);\n\t          this.__state.space = 'HSV';\n\t        }\n\t\n\t        this.__state[component] = v;\n\t\n\t      }\n\t\n\t    });\n\t\n\t  }\n\t\n\t  function recalculateRGB(color, component, componentHexIndex) {\n\t\n\t    if (color.__state.space === 'HEX') {\n\t\n\t      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);\n\t\n\t    } else if (color.__state.space === 'HSV') {\n\t\n\t      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));\n\t\n\t    } else {\n\t\n\t      throw 'Corrupted color state';\n\t\n\t    }\n\t\n\t  }\n\t\n\t  function recalculateHSV(color) {\n\t\n\t    var result = math.rgb_to_hsv(color.r, color.g, color.b);\n\t\n\t    common.extend(color.__state,\n\t        {\n\t          s: result.s,\n\t          v: result.v\n\t        }\n\t    );\n\t\n\t    if (!common.isNaN(result.h)) {\n\t      color.__state.h = result.h;\n\t    } else if (common.isUndefined(color.__state.h)) {\n\t      color.__state.h = 0;\n\t    }\n\t\n\t  }\n\t\n\t  return Color;\n\t\n\t})(dat.color.interpret,\n\tdat.color.math = (function () {\n\t\n\t  var tmpComponent;\n\t\n\t  return {\n\t\n\t    hsv_to_rgb: function(h, s, v) {\n\t\n\t      var hi = Math.floor(h / 60) % 6;\n\t\n\t      var f = h / 60 - Math.floor(h / 60);\n\t      var p = v * (1.0 - s);\n\t      var q = v * (1.0 - (f * s));\n\t      var t = v * (1.0 - ((1.0 - f) * s));\n\t      var c = [\n\t        [v, t, p],\n\t        [q, v, p],\n\t        [p, v, t],\n\t        [p, q, v],\n\t        [t, p, v],\n\t        [v, p, q]\n\t      ][hi];\n\t\n\t      return {\n\t        r: c[0] * 255,\n\t        g: c[1] * 255,\n\t        b: c[2] * 255\n\t      };\n\t\n\t    },\n\t\n\t    rgb_to_hsv: function(r, g, b) {\n\t\n\t      var min = Math.min(r, g, b),\n\t          max = Math.max(r, g, b),\n\t          delta = max - min,\n\t          h, s;\n\t\n\t      if (max != 0) {\n\t        s = delta / max;\n\t      } else {\n\t        return {\n\t          h: NaN,\n\t          s: 0,\n\t          v: 0\n\t        };\n\t      }\n\t\n\t      if (r == max) {\n\t        h = (g - b) / delta;\n\t      } else if (g == max) {\n\t        h = 2 + (b - r) / delta;\n\t      } else {\n\t        h = 4 + (r - g) / delta;\n\t      }\n\t      h /= 6;\n\t      if (h < 0) {\n\t        h += 1;\n\t      }\n\t\n\t      return {\n\t        h: h * 360,\n\t        s: s,\n\t        v: max / 255\n\t      };\n\t    },\n\t\n\t    rgb_to_hex: function(r, g, b) {\n\t      var hex = this.hex_with_component(0, 2, r);\n\t      hex = this.hex_with_component(hex, 1, g);\n\t      hex = this.hex_with_component(hex, 0, b);\n\t      return hex;\n\t    },\n\t\n\t    component_from_hex: function(hex, componentIndex) {\n\t      return (hex >> (componentIndex * 8)) & 0xFF;\n\t    },\n\t\n\t    hex_with_component: function(hex, componentIndex, value) {\n\t      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));\n\t    }\n\t\n\t  }\n\t\n\t})(),\n\tdat.color.toString,\n\tdat.utils.common),\n\tdat.color.interpret,\n\tdat.utils.common),\n\tdat.utils.requestAnimationFrame = (function () {\n\t\n\t  /**\n\t   * requirejs version of Paul Irish's RequestAnimationFrame\n\t   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\t   */\n\t\n\t  return window.webkitRequestAnimationFrame ||\n\t      window.mozRequestAnimationFrame ||\n\t      window.oRequestAnimationFrame ||\n\t      window.msRequestAnimationFrame ||\n\t      function(callback, element) {\n\t\n\t        window.setTimeout(callback, 1000 / 60);\n\t\n\t      };\n\t})(),\n\tdat.dom.CenteredDiv = (function (dom, common) {\n\t\n\t\n\t  var CenteredDiv = function() {\n\t\n\t    this.backgroundElement = document.createElement('div');\n\t    common.extend(this.backgroundElement.style, {\n\t      backgroundColor: 'rgba(0,0,0,0.8)',\n\t      top: 0,\n\t      left: 0,\n\t      display: 'none',\n\t      zIndex: '1000',\n\t      opacity: 0,\n\t      WebkitTransition: 'opacity 0.2s linear'\n\t    });\n\t\n\t    dom.makeFullscreen(this.backgroundElement);\n\t    this.backgroundElement.style.position = 'fixed';\n\t\n\t    this.domElement = document.createElement('div');\n\t    common.extend(this.domElement.style, {\n\t      position: 'fixed',\n\t      display: 'none',\n\t      zIndex: '1001',\n\t      opacity: 0,\n\t      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'\n\t    });\n\t\n\t\n\t    document.body.appendChild(this.backgroundElement);\n\t    document.body.appendChild(this.domElement);\n\t\n\t    var _this = this;\n\t    dom.bind(this.backgroundElement, 'click', function() {\n\t      _this.hide();\n\t    });\n\t\n\t\n\t  };\n\t\n\t  CenteredDiv.prototype.show = function() {\n\t\n\t    var _this = this;\n\t    \n\t\n\t\n\t    this.backgroundElement.style.display = 'block';\n\t\n\t    this.domElement.style.display = 'block';\n\t    this.domElement.style.opacity = 0;\n\t//    this.domElement.style.top = '52%';\n\t    this.domElement.style.webkitTransform = 'scale(1.1)';\n\t\n\t    this.layout();\n\t\n\t    common.defer(function() {\n\t      _this.backgroundElement.style.opacity = 1;\n\t      _this.domElement.style.opacity = 1;\n\t      _this.domElement.style.webkitTransform = 'scale(1)';\n\t    });\n\t\n\t  };\n\t\n\t  CenteredDiv.prototype.hide = function() {\n\t\n\t    var _this = this;\n\t\n\t    var hide = function() {\n\t\n\t      _this.domElement.style.display = 'none';\n\t      _this.backgroundElement.style.display = 'none';\n\t\n\t      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);\n\t      dom.unbind(_this.domElement, 'transitionend', hide);\n\t      dom.unbind(_this.domElement, 'oTransitionEnd', hide);\n\t\n\t    };\n\t\n\t    dom.bind(this.domElement, 'webkitTransitionEnd', hide);\n\t    dom.bind(this.domElement, 'transitionend', hide);\n\t    dom.bind(this.domElement, 'oTransitionEnd', hide);\n\t\n\t    this.backgroundElement.style.opacity = 0;\n\t//    this.domElement.style.top = '48%';\n\t    this.domElement.style.opacity = 0;\n\t    this.domElement.style.webkitTransform = 'scale(1.1)';\n\t\n\t  };\n\t\n\t  CenteredDiv.prototype.layout = function() {\n\t    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';\n\t    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';\n\t  };\n\t  \n\t  function lockScroll(e) {\n\t    console.log(e);\n\t  }\n\t\n\t  return CenteredDiv;\n\t\n\t})(dat.dom.dom,\n\tdat.utils.common),\n\tdat.dom.dom,\n\tdat.utils.common);\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * dat-gui JavaScript Controller Library\n\t * http://code.google.com/p/dat-gui\n\t *\n\t * Copyright 2011 Data Arts Team, Google Creative Lab\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t */\n\t\n\t/** @namespace */\n\tvar dat = module.exports = dat || {};\n\t\n\t/** @namespace */\n\tdat.color = dat.color || {};\n\t\n\t/** @namespace */\n\tdat.utils = dat.utils || {};\n\t\n\tdat.utils.common = (function () {\n\t  \n\t  var ARR_EACH = Array.prototype.forEach;\n\t  var ARR_SLICE = Array.prototype.slice;\n\t\n\t  /**\n\t   * Band-aid methods for things that should be a lot easier in JavaScript.\n\t   * Implementation and structure inspired by underscore.js\n\t   * http://documentcloud.github.com/underscore/\n\t   */\n\t\n\t  return { \n\t    \n\t    BREAK: {},\n\t  \n\t    extend: function(target) {\n\t      \n\t      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n\t        \n\t        for (var key in obj)\n\t          if (!this.isUndefined(obj[key])) \n\t            target[key] = obj[key];\n\t        \n\t      }, this);\n\t      \n\t      return target;\n\t      \n\t    },\n\t    \n\t    defaults: function(target) {\n\t      \n\t      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n\t        \n\t        for (var key in obj)\n\t          if (this.isUndefined(target[key])) \n\t            target[key] = obj[key];\n\t        \n\t      }, this);\n\t      \n\t      return target;\n\t    \n\t    },\n\t    \n\t    compose: function() {\n\t      var toCall = ARR_SLICE.call(arguments);\n\t            return function() {\n\t              var args = ARR_SLICE.call(arguments);\n\t              for (var i = toCall.length -1; i >= 0; i--) {\n\t                args = [toCall[i].apply(this, args)];\n\t              }\n\t              return args[0];\n\t            }\n\t    },\n\t    \n\t    each: function(obj, itr, scope) {\n\t\n\t      \n\t      if (ARR_EACH && obj.forEach === ARR_EACH) { \n\t        \n\t        obj.forEach(itr, scope);\n\t        \n\t      } else if (obj.length === obj.length + 0) { // Is number but not NaN\n\t        \n\t        for (var key = 0, l = obj.length; key < l; key++)\n\t          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) \n\t            return;\n\t            \n\t      } else {\n\t\n\t        for (var key in obj) \n\t          if (itr.call(scope, obj[key], key) === this.BREAK)\n\t            return;\n\t            \n\t      }\n\t            \n\t    },\n\t    \n\t    defer: function(fnc) {\n\t      setTimeout(fnc, 0);\n\t    },\n\t    \n\t    toArray: function(obj) {\n\t      if (obj.toArray) return obj.toArray();\n\t      return ARR_SLICE.call(obj);\n\t    },\n\t\n\t    isUndefined: function(obj) {\n\t      return obj === undefined;\n\t    },\n\t    \n\t    isNull: function(obj) {\n\t      return obj === null;\n\t    },\n\t    \n\t    isNaN: function(obj) {\n\t      return obj !== obj;\n\t    },\n\t    \n\t    isArray: Array.isArray || function(obj) {\n\t      return obj.constructor === Array;\n\t    },\n\t    \n\t    isObject: function(obj) {\n\t      return obj === Object(obj);\n\t    },\n\t    \n\t    isNumber: function(obj) {\n\t      return obj === obj+0;\n\t    },\n\t    \n\t    isString: function(obj) {\n\t      return obj === obj+'';\n\t    },\n\t    \n\t    isBoolean: function(obj) {\n\t      return obj === false || obj === true;\n\t    },\n\t    \n\t    isFunction: function(obj) {\n\t      return Object.prototype.toString.call(obj) === '[object Function]';\n\t    }\n\t  \n\t  };\n\t    \n\t})();\n\t\n\t\n\tdat.color.toString = (function (common) {\n\t\n\t  return function(color) {\n\t\n\t    if (color.a == 1 || common.isUndefined(color.a)) {\n\t\n\t      var s = color.hex.toString(16);\n\t      while (s.length < 6) {\n\t        s = '0' + s;\n\t      }\n\t\n\t      return '#' + s;\n\t\n\t    } else {\n\t\n\t      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';\n\t\n\t    }\n\t\n\t  }\n\t\n\t})(dat.utils.common);\n\t\n\t\n\tdat.Color = dat.color.Color = (function (interpret, math, toString, common) {\n\t\n\t  var Color = function() {\n\t\n\t    this.__state = interpret.apply(this, arguments);\n\t\n\t    if (this.__state === false) {\n\t      throw 'Failed to interpret color arguments';\n\t    }\n\t\n\t    this.__state.a = this.__state.a || 1;\n\t\n\t\n\t  };\n\t\n\t  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];\n\t\n\t  common.extend(Color.prototype, {\n\t\n\t    toString: function() {\n\t      return toString(this);\n\t    },\n\t\n\t    toOriginal: function() {\n\t      return this.__state.conversion.write(this);\n\t    }\n\t\n\t  });\n\t\n\t  defineRGBComponent(Color.prototype, 'r', 2);\n\t  defineRGBComponent(Color.prototype, 'g', 1);\n\t  defineRGBComponent(Color.prototype, 'b', 0);\n\t\n\t  defineHSVComponent(Color.prototype, 'h');\n\t  defineHSVComponent(Color.prototype, 's');\n\t  defineHSVComponent(Color.prototype, 'v');\n\t\n\t  Object.defineProperty(Color.prototype, 'a', {\n\t\n\t    get: function() {\n\t      return this.__state.a;\n\t    },\n\t\n\t    set: function(v) {\n\t      this.__state.a = v;\n\t    }\n\t\n\t  });\n\t\n\t  Object.defineProperty(Color.prototype, 'hex', {\n\t\n\t    get: function() {\n\t\n\t      if (!this.__state.space !== 'HEX') {\n\t        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);\n\t      }\n\t\n\t      return this.__state.hex;\n\t\n\t    },\n\t\n\t    set: function(v) {\n\t\n\t      this.__state.space = 'HEX';\n\t      this.__state.hex = v;\n\t\n\t    }\n\t\n\t  });\n\t\n\t  function defineRGBComponent(target, component, componentHexIndex) {\n\t\n\t    Object.defineProperty(target, component, {\n\t\n\t      get: function() {\n\t\n\t        if (this.__state.space === 'RGB') {\n\t          return this.__state[component];\n\t        }\n\t\n\t        recalculateRGB(this, component, componentHexIndex);\n\t\n\t        return this.__state[component];\n\t\n\t      },\n\t\n\t      set: function(v) {\n\t\n\t        if (this.__state.space !== 'RGB') {\n\t          recalculateRGB(this, component, componentHexIndex);\n\t          this.__state.space = 'RGB';\n\t        }\n\t\n\t        this.__state[component] = v;\n\t\n\t      }\n\t\n\t    });\n\t\n\t  }\n\t\n\t  function defineHSVComponent(target, component) {\n\t\n\t    Object.defineProperty(target, component, {\n\t\n\t      get: function() {\n\t\n\t        if (this.__state.space === 'HSV')\n\t          return this.__state[component];\n\t\n\t        recalculateHSV(this);\n\t\n\t        return this.__state[component];\n\t\n\t      },\n\t\n\t      set: function(v) {\n\t\n\t        if (this.__state.space !== 'HSV') {\n\t          recalculateHSV(this);\n\t          this.__state.space = 'HSV';\n\t        }\n\t\n\t        this.__state[component] = v;\n\t\n\t      }\n\t\n\t    });\n\t\n\t  }\n\t\n\t  function recalculateRGB(color, component, componentHexIndex) {\n\t\n\t    if (color.__state.space === 'HEX') {\n\t\n\t      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);\n\t\n\t    } else if (color.__state.space === 'HSV') {\n\t\n\t      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));\n\t\n\t    } else {\n\t\n\t      throw 'Corrupted color state';\n\t\n\t    }\n\t\n\t  }\n\t\n\t  function recalculateHSV(color) {\n\t\n\t    var result = math.rgb_to_hsv(color.r, color.g, color.b);\n\t\n\t    common.extend(color.__state,\n\t        {\n\t          s: result.s,\n\t          v: result.v\n\t        }\n\t    );\n\t\n\t    if (!common.isNaN(result.h)) {\n\t      color.__state.h = result.h;\n\t    } else if (common.isUndefined(color.__state.h)) {\n\t      color.__state.h = 0;\n\t    }\n\t\n\t  }\n\t\n\t  return Color;\n\t\n\t})(dat.color.interpret = (function (toString, common) {\n\t\n\t  var result, toReturn;\n\t\n\t  var interpret = function() {\n\t\n\t    toReturn = false;\n\t\n\t    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];\n\t\n\t    common.each(INTERPRETATIONS, function(family) {\n\t\n\t      if (family.litmus(original)) {\n\t\n\t        common.each(family.conversions, function(conversion, conversionName) {\n\t\n\t          result = conversion.read(original);\n\t\n\t          if (toReturn === false && result !== false) {\n\t            toReturn = result;\n\t            result.conversionName = conversionName;\n\t            result.conversion = conversion;\n\t            return common.BREAK;\n\t\n\t          }\n\t\n\t        });\n\t\n\t        return common.BREAK;\n\t\n\t      }\n\t\n\t    });\n\t\n\t    return toReturn;\n\t\n\t  };\n\t\n\t  var INTERPRETATIONS = [\n\t\n\t    // Strings\n\t    {\n\t\n\t      litmus: common.isString,\n\t\n\t      conversions: {\n\t\n\t        THREE_CHAR_HEX: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'HEX',\n\t              hex: parseInt(\n\t                  '0x' +\n\t                      test[1].toString() + test[1].toString() +\n\t                      test[2].toString() + test[2].toString() +\n\t                      test[3].toString() + test[3].toString())\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        SIX_CHAR_HEX: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^#([A-F0-9]{6})$/i);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'HEX',\n\t              hex: parseInt('0x' + test[1].toString())\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        CSS_RGB: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^rgb\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'RGB',\n\t              r: parseFloat(test[1]),\n\t              g: parseFloat(test[2]),\n\t              b: parseFloat(test[3])\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        CSS_RGBA: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^rgba\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\,\\s*(.+)\\s*\\)/);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'RGB',\n\t              r: parseFloat(test[1]),\n\t              g: parseFloat(test[2]),\n\t              b: parseFloat(test[3]),\n\t              a: parseFloat(test[4])\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Numbers\n\t    {\n\t\n\t      litmus: common.isNumber,\n\t\n\t      conversions: {\n\t\n\t        HEX: {\n\t          read: function(original) {\n\t            return {\n\t              space: 'HEX',\n\t              hex: original,\n\t              conversionName: 'HEX'\n\t            }\n\t          },\n\t\n\t          write: function(color) {\n\t            return color.hex;\n\t          }\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Arrays\n\t    {\n\t\n\t      litmus: common.isArray,\n\t\n\t      conversions: {\n\t\n\t        RGB_ARRAY: {\n\t          read: function(original) {\n\t            if (original.length != 3) return false;\n\t            return {\n\t              space: 'RGB',\n\t              r: original[0],\n\t              g: original[1],\n\t              b: original[2]\n\t            };\n\t          },\n\t\n\t          write: function(color) {\n\t            return [color.r, color.g, color.b];\n\t          }\n\t\n\t        },\n\t\n\t        RGBA_ARRAY: {\n\t          read: function(original) {\n\t            if (original.length != 4) return false;\n\t            return {\n\t              space: 'RGB',\n\t              r: original[0],\n\t              g: original[1],\n\t              b: original[2],\n\t              a: original[3]\n\t            };\n\t          },\n\t\n\t          write: function(color) {\n\t            return [color.r, color.g, color.b, color.a];\n\t          }\n\t\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Objects\n\t    {\n\t\n\t      litmus: common.isObject,\n\t\n\t      conversions: {\n\t\n\t        RGBA_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.r) &&\n\t                common.isNumber(original.g) &&\n\t                common.isNumber(original.b) &&\n\t                common.isNumber(original.a)) {\n\t              return {\n\t                space: 'RGB',\n\t                r: original.r,\n\t                g: original.g,\n\t                b: original.b,\n\t                a: original.a\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              r: color.r,\n\t              g: color.g,\n\t              b: color.b,\n\t              a: color.a\n\t            }\n\t          }\n\t        },\n\t\n\t        RGB_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.r) &&\n\t                common.isNumber(original.g) &&\n\t                common.isNumber(original.b)) {\n\t              return {\n\t                space: 'RGB',\n\t                r: original.r,\n\t                g: original.g,\n\t                b: original.b\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              r: color.r,\n\t              g: color.g,\n\t              b: color.b\n\t            }\n\t          }\n\t        },\n\t\n\t        HSVA_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.h) &&\n\t                common.isNumber(original.s) &&\n\t                common.isNumber(original.v) &&\n\t                common.isNumber(original.a)) {\n\t              return {\n\t                space: 'HSV',\n\t                h: original.h,\n\t                s: original.s,\n\t                v: original.v,\n\t                a: original.a\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              h: color.h,\n\t              s: color.s,\n\t              v: color.v,\n\t              a: color.a\n\t            }\n\t          }\n\t        },\n\t\n\t        HSV_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.h) &&\n\t                common.isNumber(original.s) &&\n\t                common.isNumber(original.v)) {\n\t              return {\n\t                space: 'HSV',\n\t                h: original.h,\n\t                s: original.s,\n\t                v: original.v\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              h: color.h,\n\t              s: color.s,\n\t              v: color.v\n\t            }\n\t          }\n\t\n\t        }\n\t\n\t      }\n\t\n\t    }\n\t\n\t\n\t  ];\n\t\n\t  return interpret;\n\t\n\t\n\t})(dat.color.toString,\n\tdat.utils.common),\n\tdat.color.math = (function () {\n\t\n\t  var tmpComponent;\n\t\n\t  return {\n\t\n\t    hsv_to_rgb: function(h, s, v) {\n\t\n\t      var hi = Math.floor(h / 60) % 6;\n\t\n\t      var f = h / 60 - Math.floor(h / 60);\n\t      var p = v * (1.0 - s);\n\t      var q = v * (1.0 - (f * s));\n\t      var t = v * (1.0 - ((1.0 - f) * s));\n\t      var c = [\n\t        [v, t, p],\n\t        [q, v, p],\n\t        [p, v, t],\n\t        [p, q, v],\n\t        [t, p, v],\n\t        [v, p, q]\n\t      ][hi];\n\t\n\t      return {\n\t        r: c[0] * 255,\n\t        g: c[1] * 255,\n\t        b: c[2] * 255\n\t      };\n\t\n\t    },\n\t\n\t    rgb_to_hsv: function(r, g, b) {\n\t\n\t      var min = Math.min(r, g, b),\n\t          max = Math.max(r, g, b),\n\t          delta = max - min,\n\t          h, s;\n\t\n\t      if (max != 0) {\n\t        s = delta / max;\n\t      } else {\n\t        return {\n\t          h: NaN,\n\t          s: 0,\n\t          v: 0\n\t        };\n\t      }\n\t\n\t      if (r == max) {\n\t        h = (g - b) / delta;\n\t      } else if (g == max) {\n\t        h = 2 + (b - r) / delta;\n\t      } else {\n\t        h = 4 + (r - g) / delta;\n\t      }\n\t      h /= 6;\n\t      if (h < 0) {\n\t        h += 1;\n\t      }\n\t\n\t      return {\n\t        h: h * 360,\n\t        s: s,\n\t        v: max / 255\n\t      };\n\t    },\n\t\n\t    rgb_to_hex: function(r, g, b) {\n\t      var hex = this.hex_with_component(0, 2, r);\n\t      hex = this.hex_with_component(hex, 1, g);\n\t      hex = this.hex_with_component(hex, 0, b);\n\t      return hex;\n\t    },\n\t\n\t    component_from_hex: function(hex, componentIndex) {\n\t      return (hex >> (componentIndex * 8)) & 0xFF;\n\t    },\n\t\n\t    hex_with_component: function(hex, componentIndex, value) {\n\t      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));\n\t    }\n\t\n\t  }\n\t\n\t})(),\n\tdat.color.toString,\n\tdat.utils.common);\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\twindow.THREE = __webpack_require__(3);\n\t\n\t(function () {\n\t  /**\n\t   * Planeクラス\n\t   */\n\t  var Plane = window.Plane || {};\n\t\n\t  window.Plane = function () {\n\t    //Planeクラスをイニシャライズ\n\t    p.init();\n\t  };\n\t\n\t  var p, s;\n\t\n\t  s = window.Plane;\n\t  p = s.prototype;\n\t\n\t  /**\n\t   * Planeクラスイニシャライズ\n\t   **/\n\t  p.init = function () {\n\t    var self = this;\n\t\n\t    //planeGeometry\n\t    self.planeGeometry = new THREE.PlaneGeometry(60, 40, 1, 1);\n\t\n\t    //planeMaterial\n\t    self.planeMaterial = new THREE.MeshLambertMaterial({\n\t      color: 0xffffff\n\t    });\n\t\n\t    //plane\n\t    self.PlaneObject = new THREE.Mesh(self.planeGeometry, self.planeMaterial);\n\t    self.PlaneObject.receiveShadow = true;\n\t    //planeを回転\n\t    self.PlaneObject.rotation.x = -0.5 * Math.PI;\n\t    self.PlaneObject.position.x = 0;\n\t    self.PlaneObject.position.y = 0;\n\t    self.PlaneObject.position.z = 0;\n\t\n\t    //オブジェクトとしてPlaneObject返す\n\t    return self.PlaneObject;\n\t  };\n\t})();\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\twindow.THREE = __webpack_require__(3);\n\t\n\t/**\n\t * Scene\n\t */\n\t\n\t'use strict';\n\t\n\tvar Scene = function () {\n\t\n\t  function Scene() {\n\t    this.init.apply(this, arguments);\n\t  }\n\t\n\t  var p, s;\n\t\n\t  s = Scene;\n\t  p = s.prototype;\n\t\n\t  p.init = function () {\n\t    this.scene;\n\t\n\t    this.setup();\n\t    this.create();\n\t  };\n\t\n\t  p.setup = function () {\n\t\n\t    // console.log('this',this);\n\t    // console.log('Scene_setup!!!!!');\n\t\n\t  };\n\t\n\t  //\n\t  p.create = function () {\n\t    this.scene = new THREE.Scene();\n\t  };\n\t\n\t  //\n\t  p.update = function () {};\n\t\n\t  //\n\t  p.setEvents = function () {};\n\t\n\t  return Scene;\n\t}();\n\t\n\tmodule.exports = Scene;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\twindow.THREE = __webpack_require__(3);\n\t\n\t/**\n\t * Camera\n\t */\n\t\n\t'use strict';\n\t\n\tvar Camera = function () {\n\t\n\t  function Camera() {\n\t    this.init.apply(this, arguments);\n\t  }\n\t\n\t  var p, s;\n\t\n\t  s = Camera;\n\t  p = s.prototype;\n\t\n\t  p.init = function () {\n\t    this.camera;\n\t    this.vec3 = new THREE.Vector3(0, 0, 0);\n\t\n\t    this.setup();\n\t    this.create();\n\t\n\t    this.update();\n\t  };\n\t\n\t  p.setup = function () {\n\t\n\t    // console.log('this',this);\n\t    // console.log('Camera_setup!!!!!');\n\t\n\t  };\n\t\n\t  //\n\t  p.create = function () {\n\t    // this.scene = new THREE.Camera();\n\t\n\t    this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\n\t\n\t    this.camera.position.x = -30;\n\t    this.camera.position.y = 40;\n\t    this.camera.position.z = 30;\n\t    // this.camera.lookAt( gb.in.scene.scene.position );\n\t    this.camera.lookAt(this.vec3);\n\t    // window.console.log('A',this.camera);\n\t  };\n\t\n\t  //\n\t  p.update = function () {\n\t\n\t    // window.console.log('B',this.camera);\n\t    // this.camera.position.x = Math.cos(this.timer) * 500;\n\t    // this.camera.position.y = Math.sin(this.timer*2) * 100;\n\t    // this.camera.position.z = Math.sin(this.timer) * 100 + 200;\n\t    // //\n\t    // this.camera.lookAt(this.vec3);\n\t\n\t    // this.lookat_x = Math.sin(this.timer*0.8)*10;\n\t    // this.lookat_y = Math.cos(this.timer*2)*10;\n\t    // this.camera.lookAt(new THREE.Vector3(this.lookat_x, this.lookat_y, 0));\n\t    // gb.in.camera.lookAt(new THREE.Vector3(0, 0, 0));\n\t\n\t    // requestAnimationFrame(p.update);\n\t    // gb.in.renderer.render(gb.in.scene.scene, this.camera);\n\t  };\n\t\n\t  //\n\t  p.setEvents = function () {};\n\t\n\t  return Camera;\n\t}();\n\t\n\tmodule.exports = Camera;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\twindow.THREE = __webpack_require__(3);\n\tvar Stats = __webpack_require__(4);\n\t\n\t/**\n\t * Cube\n\t */\n\t'use strict';\n\t\n\tvar Cube = function () {\n\t  // globalオブジェクト\n\t  if (window.gb === undefined) window.gb = {};\n\t  window.gb.in = {}; //instance\n\t\n\t\n\t  function Cube() {\n\t    this.init.apply(this, arguments);\n\t  }\n\t\n\t  var p, s;\n\t\n\t  s = Cube;\n\t  p = s.prototype;\n\t\n\t  p.init = function () {\n\t    this.cube = null;\n\t    this.geometry = null;\n\t    this.material = null;\n\t\n\t    //イニシャライズ実行\n\t    this.setup();\n\t\n\t    this.update();\n\t  };\n\t\n\t  p.setup = function () {\n\t    // console.log('this',this);\n\t    // console.log('Cube_setup!!!!!');\n\t\n\t    //cubeGeometry\n\t    this.geometry = new THREE.BoxGeometry(10, 10, 10);\n\t\n\t    //cubeMaterial\n\t    this.material = new THREE.MeshLambertMaterial({\n\t      color: 0xff0000, wireframe: false\n\t    });\n\t\n\t    this.cube = new THREE.Mesh(this.geometry, this.material);\n\t    this.cube.castShadow = true;\n\t    //Cubeを回転\n\t    this.cube.position.x = -4;\n\t    this.cube.position.y = 3;\n\t    this.cube.position.z = 0;\n\t\n\t    // this.cube.rotation.x += 0.02;\n\t    // this.cube.rotation.y += 0.02;\n\t    // this.cube.rotation.z += 0.02;\n\t\n\t    return this.cube;\n\t  };\n\t\n\t  //\n\t  p.create = function () {};\n\t\n\t  //\n\t  p.update = function () {\n\t\n\t    // this.CubeObject.cube.rotation.x += 0.02;\n\t    // this.cube.rotation.x += 0.02;\n\t    //\n\t    // gb.in.renderer.render(gb.in.scene.scene, gb.in.camera.camera);\n\t    // requestAnimationFrame(p.update);\n\t\n\t  };\n\t\n\t  //\n\t  p.setEvents = function () {};\n\t\n\t  return Cube;\n\t\n\t  //グローバルオブジェクト化\n\t  // gb.Cube = Cube;\n\t}();\n\t\n\tmodule.exports = Cube;\n\t\n\t//   p.animate = function () {\n\t//     var self = this;\n\t//\n\t//     // self.CubeObject.rotation.x += 0.02;\n\t//     // self.CubeObject.rotation.y += 0.02;\n\t//     // self.CubeObject.rotation.z += 0.02;\n\t//\n\t//   };\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// index.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 50a4f013a530453067de","var cats = require('./main.js');\n\n// console.log(cats);\n\n\n// WEBPACK FOOTER //\n// ./src/js/app.js","window.THREE = require('three');\nvar Stats = require('./libs/stats.js');\nvar dat　= require('dat-gui');\n\nrequire('./object/Plane.js');\n// require('./libs/ParametricGeometries.js');\n// require('./libs/ConvexGeometry.js');\n\nvar Scene = require('./object/Scene.js');\nvar Camera = require('./object/Camera.js');\n\nvar Cube = require('./object/Cube.js');\n\n'use strict';\n\n(function() {\n\n  // globalオブジェクト\n  if (window.gb === undefined) window.gb = {};\n  window.gb.in = {}; //instance\n\n  var sample = window.sample || {};\n  window.sample = sample;\n\n  //初期化実行\n  $(function() {\n    new sample.MainDisplay();\n  });\n\n})();\n\n\n\n//Planeをインスタンス化\nvar PlaneObject = new Plane();\n\n(function(){\n  var sample = window.sample || {};\n  window.sample = sample;\n\n  /**\n   * メインクラス\n   */\n  sample.MainDisplay = function () {\n    //イニシャライズ\n    p.init();\n  };\n\n  var p, s;\n\n  s = sample.MainDisplay;\n  p = s.prototype;\n\n  var renderScene;\n\n  /**\n   * イニシャライズ\n   */\n  p.init = function () {\n    var self = this;\n\n    var stats = initStats();\n\n    this.$window = $(window);\n    this.$MainDisplay = $('#WebGL-output');\n\n    this.timer += 0.01;\n\n    //WebGL renderer\n    gb.in.renderer = this.renderer = new THREE.WebGLRenderer({antialias: true});\n    if (!this.renderer) {\n      alert('Three.jsの初期化に失敗しました。');\n    }\n    this.renderer.setClearColor(new THREE.Color(0xEEEEEE));\n    this.renderer.setSize( window.innerWidth, window.innerHeight );\n    this.renderer.shadowMap.enabled = true;\n\n    // 高解像度対応\n    var pixelRatio = Math.min(window.devicePixelRatio || 1, 2);\n    this.renderer.setPixelRatio(pixelRatio);\n\n    //scene\n    gb.in.scene = new Scene();\n    this.scene = gb.in.scene.scene;\n\n    //camera\n    gb.in.camera = new Camera();\n    this.camera = gb.in.camera.camera;\n\n    // add subtle ambient lighting\n    var ambientLight = new THREE.AmbientLight(0x090909);\n    this.scene.add(ambientLight);\n\n    // add spotlight for the shadows\n    var spotLight = new THREE.SpotLight(0xffffff);\n    spotLight.position.set(-25, 25, 32);\n    spotLight.castShadow = true;\n    this.scene.add(spotLight);\n\n    // window resize\n    this.$window.on('resize', function(e) {\n      self.onResize();\n    });\n\n    // resizeイベントを発火してキャンバスサイズをリサイズ\n    this.$window.trigger('resize');\n\n\n    //Planeをシーンに追加\n    this.scene.add(PlaneObject.init());\n\n    //Cubeをインスタンス化\n    gb.in.CubeObject = new Cube();\n    this.CubeObject = gb.in.CubeObject.cube;\n    // window.console.log(this.CubeObject);\n\n    // //Cubeをシーンに追加\n    this.scene.add(this.CubeObject);\n\n    //sphereGeometry\n    var sphereGeometry = new THREE.SphereGeometry(4, 20,20);\n\n    //sphereMaterial\n    var sphereMaterial = new THREE.MeshLambertMaterial({\n      color: 0x7777ff, wireframe: false\n    });\n\n    //sphere\n    var sphere = new THREE.Mesh(sphereGeometry,sphereMaterial);\n    sphere.castShadow = true;\n    //sphereを回転\n    sphere.position.x = 20;\n    sphere.position.y = 4;\n    sphere.position.z = 2;\n    // this.scene.add(sphere);\n\n\n    document.getElementById(\"WebGL-output\").appendChild(this.renderer.domElement);\n\n    // window.console.log(this.CubeObject.setup());\n\n    renderScene = function () {\n      stats.update();\n\n      // rotate the cube around its axes\n      this.CubeObject.rotation.x += 0.02;\n      this.CubeObject.rotation.y += 0.02;\n      this.CubeObject.rotation.z += 0.02;\n\n      step += 0.01;\n      this.camera.position.z += (this.CubeObject.position.z+100 - this.camera.position.z)*0.1;\n      this.camera.position.y += (this.CubeObject.position.y+50 - this.camera.position.y)*0.1;\n      // this.camera.position.x = Math.cos(step) * 200;\n      // this.camera.position.y = Math.sin(step*2) * 90;\n      // this.camera.position.z = Math.sin(step) * 90 + 200;\n\n      this.lookat_x = Math.sin(step*0.4)*50;\n      this.lookat_y = Math.cos(step*1.4)*50;\n      this.camera.lookAt(new THREE.Vector3(this.lookat_x, this.lookat_y, 0));\n\n\n      // bounce the sphere up and down\n      // step += 0.04;\n      // sphere.position.x = 20 + ( 10 * (Math.cos(step)));\n      // sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step)));\n\n      // render using requestAnimationFrame\n      requestAnimationFrame(renderScene);\n      this.renderer.render(this.scene, this.camera);\n      // this.updateAnimation();\n    }.bind(this);\n\n    // call the render function\n    var step = 0;\n    renderScene();\n\n\n\n    /**\n     * dat.gui\n     * dat.guiのコントローラーを定義\n     */\n    var controls = new function () {\n      this.rotationSpeed = 0.001;\n      this.bouncingSpeed = 0.001;\n    };\n\n    var gui = new dat.GUI();\n    gui.add(controls, 'rotationSpeed', 0, 0.1);\n    gui.add(controls, 'bouncingSpeed', 0, 0.1);\n\n    // var render =  function() {\n    //   stats.update();\n    //\n    //\n    //\n    //\n    //   // window.console.log('CubeX',CubeObject.init().rotation.x);\n    //   // rotate the cube around its axes\n    //   // CubeObject.init().rotation.x += controls.rotationSpeed;\n    //   // CubeObject.init().rotation.y += controls.rotationSpeed;\n    //   // CubeObject.init().rotation.z += controls.rotationSpeed;\n    //\n    //   // bounce the sphere up and down\n    //   // step += controls.bouncingSpeed;\n    //   // sphere.position.x = 20 + ( 10 * (Math.cos(step)));\n    //   // sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step)));\n    //\n    //   requestAnimationFrame(render);\n    //   this.renderer.render(this.scene, this.camera);\n    // }.bind(this);\n    // render();\n\n  };\n\n  //Stats表示設定\n  function initStats() {\n\n    var stats = gb.in.stats = new Stats();\n\n    stats.setMode(0); // 0: fps, 1: ms\n\n    // Align top-left\n    stats.domElement.style.position = 'absolute';\n    stats.domElement.style.left = '0px';\n    stats.domElement.style.top = '0px';\n\n    document.getElementById(\"Stats-output\").appendChild(stats.domElement);\n\n    return stats;\n  }\n\n  /**\n   * アニメーション開始\n   */\n  // p.start = function() {\n  //   var self = this;\n  //\n  //   var enterFrameHandler = function() {\n  //     requestAnimationFrame(enterFrameHandler);\n  //     self.update();\n  //   };\n  //\n  //   enterFrameHandler();\n  // }\n\n  /**\n   * アニメーションループ内で実行される\n   */\n  p.updateAnimation = function() {\n    requestAnimationFrame(renderScene);\n    this.renderer.render(this.scene, this.camera);\n  };\n\n\n  /**\n   * リサイズ処理\n   */\n  p.onResize = function () {\n\n    this.width = this.$window.width();\n    this.height = this.$window.height();\n\n    this.camera.aspect = this.width / this.height;\n    this.camera.updateProjectionMatrix();\n\n    this.renderer.setSize(this.width, this.height);\n  };\n\n\n\n  // p.createDatGUIBox = function () {\n\n  // };\n\n})();\n\n\n// WEBPACK FOOTER //\n// ./src/js/main.js","/*!\n * jQuery JavaScript Library v3.1.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-09-22T22:30Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\n\n\n\tfunction DOMEval( code, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar script = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.1.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = jQuery.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type( obj ) === \"function\";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\n\t\t// As of jQuery 3.0, isNumeric is limited to\n\t\t// strings and numbers (primitives or objects)\n\t\t// that can be coerced to finite numbers (gh-2662)\n\t\tvar type = jQuery.type( obj );\n\t\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t\t// subtraction forces infinities to NaN\n\t\t\t!isNaN( obj - parseFloat( obj ) );\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\n\t\t/* eslint-disable no-unused-vars */\n\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\n\t\t// Support: Android <=2.3 only (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tDOMEval( code );\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE <=9 - 11, Edge 12 - 13\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Simple selector that can be filtered directly, removing non-Elements\n\tif ( risSimple.test( qualifier ) ) {\n\t\treturn jQuery.filter( qualifier, elements, not );\n\t}\n\n\t// Complex selector, compare the two sets, removing non-Elements\n\tqualifier = jQuery.filter( qualifier, elements );\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\n\t} );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Support: Android 4.0 only\n\t\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\t\tresolve.call( undefined, value );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.call( undefined, value );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( jQuery.isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ jQuery.camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( jQuery.camelCase );\n\t\t\t} else {\n\t\t\t\tkey = jQuery.camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted,\n\t\tscale = 1,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\tdo {\n\n\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\tscale = scale || \".5\";\n\n\t\t\t// Adjust and apply\n\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t// Break the loop if scale is unchanged or perfect, or if we've just had enough.\n\t\t} while (\n\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t);\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\nvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\nvar documentElement = document.documentElement;\n\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 only\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: jQuery.isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\nfunction manipulationTarget( elem, content ) {\n\tif ( jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn elem.getElementsByTagName( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tisFunction = jQuery.isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( isFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( isFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rmargin = ( /^margin/ );\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdiv.style.cssText =\n\t\t\t\"box-sizing:border-box;\" +\n\t\t\t\"position:relative;display:block;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"top:1%;width:50%\";\n\t\tdiv.innerHTML = \"\";\n\t\tdocumentElement.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = divStyle.marginLeft === \"2px\";\n\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.marginRight = \"50%\";\n\t\tpixelMarginRightVal = divStyle.marginRight === \"4px\";\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tcontainer.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\n\t\t\"padding:0;margin-top:1px;position:absolute\";\n\tcontainer.appendChild( div );\n\n\tjQuery.extend( support, {\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelMarginRight: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelMarginRightVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// Support: IE <=9 only\n\t// getPropertyValue is only needed for .css('filter') (#12537)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i,\n\t\tval = 0;\n\n\t// If we already have the right measurement, avoid augmentation\n\tif ( extra === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\ti = 4;\n\n\t// Otherwise initialize for horizontal or vertical properties\n\t} else {\n\t\ti = name === \"width\" ? 1 : 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\n\t\t\t// At this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar val,\n\t\tvalueIsBorderBox = true,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// Support: IE <=11 only\n\t// Running getBoundingClientRect on a disconnected node\n\t// in IE throws an error.\n\tif ( elem.getClientRects().length ) {\n\t\tval = elem.getBoundingClientRect()[ name ];\n\t}\n\n\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test( val ) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// Check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === \"number\" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = extra && getStyles( elem ),\n\t\t\t\tsubtract = extra && augmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ name ] = value;\n\t\t\t\tvalue = jQuery.css( elem, name );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction raf() {\n\tif ( timerId ) {\n\t\twindow.requestAnimationFrame( raf );\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off or if document is hidden\n\tif ( jQuery.fx.off || document.hidden ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = window.requestAnimationFrame ?\n\t\t\twindow.requestAnimationFrame( raf ) :\n\t\t\twindow.setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tif ( window.cancelAnimationFrame ) {\n\t\twindow.cancelAnimationFrame( timerId );\n\t} else {\n\t\twindow.clearInterval( timerId );\n\t}\n\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( type === \"string\" ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = value.match( rnothtmlwhite ) || [];\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = jQuery.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = jQuery.isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( jQuery.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 13\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar docElem, win, rect, doc,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\trect = elem.getBoundingClientRect();\n\n\t\t// Make sure element is not hidden (display: none)\n\t\tif ( rect.width || rect.height ) {\n\t\t\tdoc = elem.ownerDocument;\n\t\t\twin = getWindow( doc );\n\t\t\tdocElem = doc.documentElement;\n\n\t\t\treturn {\n\t\t\t\ttop: rect.top + win.pageYOffset - docElem.clientTop,\n\t\t\t\tleft: rect.left + win.pageXOffset - docElem.clientLeft\n\t\t\t};\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden elements (gh-2310)\n\t\treturn rect;\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t// because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset = {\n\t\t\t\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true ),\n\t\t\t\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true )\n\t\t\t};\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\njQuery.parseJSON = JSON.parse;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( \"jquery\", [], function() {\n\t\treturn jQuery;\n\t} );\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\n\nreturn jQuery;\n} );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jquery/dist/jquery.js\n// module id = 2\n// module chunks = 0","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.THREE = global.THREE || {})));\n}(this, (function (exports) { 'use strict';\n\n\t// Polyfills\n\n\tif ( Number.EPSILON === undefined ) {\n\n\t\tNumber.EPSILON = Math.pow( 2, - 52 );\n\n\t}\n\n\t//\n\n\tif ( Math.sign === undefined ) {\n\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n\t\tMath.sign = function ( x ) {\n\n\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\n\t\t};\n\n\t}\n\n\tif ( Function.prototype.name === undefined ) {\n\n\t\t// Missing in IE9-11.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n\t\tObject.defineProperty( Function.prototype, 'name', {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tif ( Object.assign === undefined ) {\n\n\t\t// Missing in IE.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n\t\t( function () {\n\n\t\t\tObject.assign = function ( target ) {\n\n\t\t\t\t'use strict';\n\n\t\t\t\tif ( target === undefined || target === null ) {\n\n\t\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\n\t\t\t\t}\n\n\t\t\t\tvar output = Object( target );\n\n\t\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\n\t\t\t\t\tvar source = arguments[ index ];\n\n\t\t\t\t\tif ( source !== undefined && source !== null ) {\n\n\t\t\t\t\t\tfor ( var nextKey in source ) {\n\n\t\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\n\t\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn output;\n\n\t\t\t};\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * https://github.com/mrdoob/eventdispatcher.js/\n\t */\n\n\tfunction EventDispatcher() {}\n\n\tObject.assign( EventDispatcher.prototype, {\n\n\t\taddEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\t\tvar listeners = this._listeners;\n\n\t\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\t\tlisteners[ type ] = [];\n\n\t\t\t}\n\n\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\t\tlisteners[ type ].push( listener );\n\n\t\t\t}\n\n\t\t},\n\n\t\thasEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) return false;\n\n\t\t\tvar listeners = this._listeners;\n\n\t\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) return;\n\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ type ];\n\n\t\t\tif ( listenerArray !== undefined ) {\n\n\t\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tdispatchEvent: function ( event ) {\n\n\t\t\tif ( this._listeners === undefined ) return;\n\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ event.type ];\n\n\t\t\tif ( listenerArray !== undefined ) {\n\n\t\t\t\tevent.target = this;\n\n\t\t\t\tvar array = [], i = 0;\n\t\t\t\tvar length = listenerArray.length;\n\n\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = listenerArray[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tvar REVISION = '82';\n\tvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\n\tvar CullFaceNone = 0;\n\tvar CullFaceBack = 1;\n\tvar CullFaceFront = 2;\n\tvar CullFaceFrontBack = 3;\n\tvar FrontFaceDirectionCW = 0;\n\tvar FrontFaceDirectionCCW = 1;\n\tvar BasicShadowMap = 0;\n\tvar PCFShadowMap = 1;\n\tvar PCFSoftShadowMap = 2;\n\tvar FrontSide = 0;\n\tvar BackSide = 1;\n\tvar DoubleSide = 2;\n\tvar FlatShading = 1;\n\tvar SmoothShading = 2;\n\tvar NoColors = 0;\n\tvar FaceColors = 1;\n\tvar VertexColors = 2;\n\tvar NoBlending = 0;\n\tvar NormalBlending = 1;\n\tvar AdditiveBlending = 2;\n\tvar SubtractiveBlending = 3;\n\tvar MultiplyBlending = 4;\n\tvar CustomBlending = 5;\n\tvar BlendingMode = {\n\t\tNoBlending: NoBlending,\n\t\tNormalBlending: NormalBlending,\n\t\tAdditiveBlending: AdditiveBlending,\n\t\tSubtractiveBlending: SubtractiveBlending,\n\t\tMultiplyBlending: MultiplyBlending,\n\t\tCustomBlending: CustomBlending\n\t};\n\tvar AddEquation = 100;\n\tvar SubtractEquation = 101;\n\tvar ReverseSubtractEquation = 102;\n\tvar MinEquation = 103;\n\tvar MaxEquation = 104;\n\tvar ZeroFactor = 200;\n\tvar OneFactor = 201;\n\tvar SrcColorFactor = 202;\n\tvar OneMinusSrcColorFactor = 203;\n\tvar SrcAlphaFactor = 204;\n\tvar OneMinusSrcAlphaFactor = 205;\n\tvar DstAlphaFactor = 206;\n\tvar OneMinusDstAlphaFactor = 207;\n\tvar DstColorFactor = 208;\n\tvar OneMinusDstColorFactor = 209;\n\tvar SrcAlphaSaturateFactor = 210;\n\tvar NeverDepth = 0;\n\tvar AlwaysDepth = 1;\n\tvar LessDepth = 2;\n\tvar LessEqualDepth = 3;\n\tvar EqualDepth = 4;\n\tvar GreaterEqualDepth = 5;\n\tvar GreaterDepth = 6;\n\tvar NotEqualDepth = 7;\n\tvar MultiplyOperation = 0;\n\tvar MixOperation = 1;\n\tvar AddOperation = 2;\n\tvar NoToneMapping = 0;\n\tvar LinearToneMapping = 1;\n\tvar ReinhardToneMapping = 2;\n\tvar Uncharted2ToneMapping = 3;\n\tvar CineonToneMapping = 4;\n\tvar UVMapping = 300;\n\tvar CubeReflectionMapping = 301;\n\tvar CubeRefractionMapping = 302;\n\tvar EquirectangularReflectionMapping = 303;\n\tvar EquirectangularRefractionMapping = 304;\n\tvar SphericalReflectionMapping = 305;\n\tvar CubeUVReflectionMapping = 306;\n\tvar CubeUVRefractionMapping = 307;\n\tvar TextureMapping = {\n\t\tUVMapping: UVMapping,\n\t\tCubeReflectionMapping: CubeReflectionMapping,\n\t\tCubeRefractionMapping: CubeRefractionMapping,\n\t\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\t\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\t\tSphericalReflectionMapping: SphericalReflectionMapping,\n\t\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\t\tCubeUVRefractionMapping: CubeUVRefractionMapping\n\t};\n\tvar RepeatWrapping = 1000;\n\tvar ClampToEdgeWrapping = 1001;\n\tvar MirroredRepeatWrapping = 1002;\n\tvar TextureWrapping = {\n\t\tRepeatWrapping: RepeatWrapping,\n\t\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\t\tMirroredRepeatWrapping: MirroredRepeatWrapping\n\t};\n\tvar NearestFilter = 1003;\n\tvar NearestMipMapNearestFilter = 1004;\n\tvar NearestMipMapLinearFilter = 1005;\n\tvar LinearFilter = 1006;\n\tvar LinearMipMapNearestFilter = 1007;\n\tvar LinearMipMapLinearFilter = 1008;\n\tvar TextureFilter = {\n\t\tNearestFilter: NearestFilter,\n\t\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\n\t\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\n\t\tLinearFilter: LinearFilter,\n\t\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\n\t\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\n\t};\n\tvar UnsignedByteType = 1009;\n\tvar ByteType = 1010;\n\tvar ShortType = 1011;\n\tvar UnsignedShortType = 1012;\n\tvar IntType = 1013;\n\tvar UnsignedIntType = 1014;\n\tvar FloatType = 1015;\n\tvar HalfFloatType = 1016;\n\tvar UnsignedShort4444Type = 1017;\n\tvar UnsignedShort5551Type = 1018;\n\tvar UnsignedShort565Type = 1019;\n\tvar UnsignedInt248Type = 1020;\n\tvar AlphaFormat = 1021;\n\tvar RGBFormat = 1022;\n\tvar RGBAFormat = 1023;\n\tvar LuminanceFormat = 1024;\n\tvar LuminanceAlphaFormat = 1025;\n\tvar RGBEFormat = RGBAFormat;\n\tvar DepthFormat = 1026;\n\tvar DepthStencilFormat = 1027;\n\tvar RGB_S3TC_DXT1_Format = 2001;\n\tvar RGBA_S3TC_DXT1_Format = 2002;\n\tvar RGBA_S3TC_DXT3_Format = 2003;\n\tvar RGBA_S3TC_DXT5_Format = 2004;\n\tvar RGB_PVRTC_4BPPV1_Format = 2100;\n\tvar RGB_PVRTC_2BPPV1_Format = 2101;\n\tvar RGBA_PVRTC_4BPPV1_Format = 2102;\n\tvar RGBA_PVRTC_2BPPV1_Format = 2103;\n\tvar RGB_ETC1_Format = 2151;\n\tvar LoopOnce = 2200;\n\tvar LoopRepeat = 2201;\n\tvar LoopPingPong = 2202;\n\tvar InterpolateDiscrete = 2300;\n\tvar InterpolateLinear = 2301;\n\tvar InterpolateSmooth = 2302;\n\tvar ZeroCurvatureEnding = 2400;\n\tvar ZeroSlopeEnding = 2401;\n\tvar WrapAroundEnding = 2402;\n\tvar TrianglesDrawMode = 0;\n\tvar TriangleStripDrawMode = 1;\n\tvar TriangleFanDrawMode = 2;\n\tvar LinearEncoding = 3000;\n\tvar sRGBEncoding = 3001;\n\tvar GammaEncoding = 3007;\n\tvar RGBEEncoding = 3002;\n\tvar LogLuvEncoding = 3003;\n\tvar RGBM7Encoding = 3004;\n\tvar RGBM16Encoding = 3005;\n\tvar RGBDEncoding = 3006;\n\tvar BasicDepthPacking = 3200;\n\tvar RGBADepthPacking = 3201;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar _Math = {\n\n\t\tDEG2RAD: Math.PI / 180,\n\t\tRAD2DEG: 180 / Math.PI,\n\n\t\tgenerateUUID: function () {\n\n\t\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\n\t\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n\t\t\tvar uuid = new Array( 36 );\n\t\t\tvar rnd = 0, r;\n\n\t\t\treturn function generateUUID() {\n\n\t\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\n\t\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\n\t\t\t\t\t\tuuid[ i ] = '-';\n\n\t\t\t\t\t} else if ( i === 14 ) {\n\n\t\t\t\t\t\tuuid[ i ] = '4';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n\t\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn uuid.join( '' );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclamp: function ( value, min, max ) {\n\n\t\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t\t},\n\n\t\t// compute euclidian modulo of m % n\n\t\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\t\teuclideanModulo: function ( n, m ) {\n\n\t\t\treturn ( ( n % m ) + m ) % m;\n\n\t\t},\n\n\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t\t},\n\n\t\t// https://en.wikipedia.org/wiki/Linear_interpolation\n\n\t\tlerp: function ( x, y, t ) {\n\n\t\t\treturn ( 1 - t ) * x + t * y;\n\n\t\t},\n\n\t\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\t\tsmoothstep: function ( x, min, max ) {\n\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\n\t\t\tx = ( x - min ) / ( max - min );\n\n\t\t\treturn x * x * ( 3 - 2 * x );\n\n\t\t},\n\n\t\tsmootherstep: function ( x, min, max ) {\n\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\n\t\t\tx = ( x - min ) / ( max - min );\n\n\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n\t\t},\n\n\t\trandom16: function () {\n\n\t\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n\t\t\treturn Math.random();\n\n\t\t},\n\n\t\t// Random integer from <low, high> interval\n\n\t\trandInt: function ( low, high ) {\n\n\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t\t},\n\n\t\t// Random float from <low, high> interval\n\n\t\trandFloat: function ( low, high ) {\n\n\t\t\treturn low + Math.random() * ( high - low );\n\n\t\t},\n\n\t\t// Random float from <-range/2, range/2> interval\n\n\t\trandFloatSpread: function ( range ) {\n\n\t\t\treturn range * ( 0.5 - Math.random() );\n\n\t\t},\n\n\t\tdegToRad: function ( degrees ) {\n\n\t\t\treturn degrees * _Math.DEG2RAD;\n\n\t\t},\n\n\t\tradToDeg: function ( radians ) {\n\n\t\t\treturn radians * _Math.RAD2DEG;\n\n\t\t},\n\n\t\tisPowerOfTwo: function ( value ) {\n\n\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n\t\t},\n\n\t\tnearestPowerOfTwo: function ( value ) {\n\n\t\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\n\t\t},\n\n\t\tnextPowerOfTwo: function ( value ) {\n\n\t\t\tvalue --;\n\t\t\tvalue |= value >> 1;\n\t\t\tvalue |= value >> 2;\n\t\t\tvalue |= value >> 4;\n\t\t\tvalue |= value >> 8;\n\t\t\tvalue |= value >> 16;\n\t\t\tvalue ++;\n\n\t\t\treturn value;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author egraether / http://egraether.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tfunction Vector2( x, y ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\n\t}\n\n\tVector2.prototype = {\n\n\t\tconstructor: Vector2,\n\n\t\tisVector2: true,\n\n\t\tget width() {\n\n\t\t\treturn this.x;\n\n\t\t},\n\n\t\tset width( value ) {\n\n\t\t\tthis.x = value;\n\n\t\t},\n\n\t\tget height() {\n\n\t\t\treturn this.y;\n\n\t\t},\n\n\t\tset height( value ) {\n\n\t\t\tthis.y = value;\n\n\t\t},\n\n\t\t//\n\n\t\tset: function ( x, y ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( v ) {\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tif ( isFinite( scalar ) ) {\n\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivide: function ( v ) {\n\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min, max;\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tif ( min === undefined ) {\n\n\t\t\t\t\tmin = new Vector2();\n\t\t\t\t\tmax = new Vector2();\n\n\t\t\t\t}\n\n\t\t\t\tmin.set( minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclampLength: function ( min, max ) {\n\n\t\t\tvar length = this.length();\n\n\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t\t},\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t\t},\n\n\t\tlengthManhattan: function() {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() );\n\n\t\t},\n\n\t\tangle: function () {\n\n\t\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\t\tvar angle = Math.atan2( this.y, this.x );\n\n\t\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\n\t\t\treturn angle;\n\n\t\t},\n\n\t\tdistanceTo: function ( v ) {\n\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t\t},\n\n\t\tdistanceToSquared: function ( v ) {\n\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\t\treturn dx * dx + dy * dy;\n\n\t\t},\n\n\t\tdistanceToManhattan: function ( v ) {\n\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tindex = index * attribute.itemSize + offset;\n\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateAround: function ( center, angle ) {\n\n\t\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\t\tvar x = this.x - center.x;\n\t\t\tvar y = this.y - center.y;\n\n\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\tthis.y = x * s + y * c + center.y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t */\n\n\tfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\t\tObject.defineProperty( this, 'id', { value: TextureIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.sourceFile = '';\n\n\t\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n\n\t\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n\t\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\n\n\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\t\tthis.format = format !== undefined ? format : RGBAFormat;\n\t\tthis.type = type !== undefined ? type : UnsignedByteType;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\n\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t//\n\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\t\tthis.encoding = encoding !== undefined ? encoding :  LinearEncoding;\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t}\n\n\tTexture.DEFAULT_IMAGE = undefined;\n\tTexture.DEFAULT_MAPPING = UVMapping;\n\n\tTexture.prototype = {\n\n\t\tconstructor: Texture,\n\n\t\tisTexture: true,\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.image = source.image;\n\t\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\t\tthis.mapping = source.mapping;\n\n\t\t\tthis.wrapS = source.wrapS;\n\t\t\tthis.wrapT = source.wrapT;\n\n\t\t\tthis.magFilter = source.magFilter;\n\t\t\tthis.minFilter = source.minFilter;\n\n\t\t\tthis.anisotropy = source.anisotropy;\n\n\t\t\tthis.format = source.format;\n\t\t\tthis.type = source.type;\n\n\t\t\tthis.offset.copy( source.offset );\n\t\t\tthis.repeat.copy( source.repeat );\n\n\t\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\t\tthis.flipY = source.flipY;\n\t\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\t\tthis.encoding = source.encoding;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t\t}\n\n\t\t\tfunction getDataURL( image ) {\n\n\t\t\t\tvar canvas;\n\n\t\t\t\tif ( image.toDataURL !== undefined ) {\n\n\t\t\t\t\tcanvas = image;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\tcanvas.width = image.width;\n\t\t\t\t\tcanvas.height = image.height;\n\n\t\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t\t}\n\n\t\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Texture',\n\t\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t\t},\n\n\t\t\t\tuuid: this.uuid,\n\t\t\t\tname: this.name,\n\n\t\t\t\tmapping: this.mapping,\n\n\t\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\t\tminFilter: this.minFilter,\n\t\t\t\tmagFilter: this.magFilter,\n\t\t\t\tanisotropy: this.anisotropy,\n\n\t\t\t\tflipY: this.flipY\n\t\t\t};\n\n\t\t\tif ( this.image !== undefined ) {\n\n\t\t\t\t// TODO: Move to THREE.Image\n\n\t\t\t\tvar image = this.image;\n\n\t\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\t\timage.uuid = _Math.generateUUID(); // UGH\n\n\t\t\t\t}\n\n\t\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\toutput.image = image.uuid;\n\n\t\t\t}\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t\treturn output;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t},\n\n\t\ttransformUv: function ( uv ) {\n\n\t\t\tif ( this.mapping !== UVMapping )  return;\n\n\t\t\tuv.multiply( this.repeat );\n\t\t\tuv.add( this.offset );\n\n\t\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.flipY ) {\n\n\t\t\t\tuv.y = 1 - uv.y;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tObject.assign( Texture.prototype, EventDispatcher.prototype );\n\n\tvar count = 0;\n\tfunction TextureIdCount() { return count++; }\n\n\t/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Vector4( x, y, z, w ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\t\tthis.w = ( w !== undefined ) ? w : 1;\n\n\t}\n\n\tVector4.prototype = {\n\n\t\tconstructor: Vector4,\n\n\t\tisVector4: true,\n\n\t\tset: function ( x, y, z, w ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\t\t\tthis.w = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( z ) {\n\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetW: function ( w ) {\n\n\t\t\tthis.w = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tcase 3: this.w = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tcase 3: return this.w;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\t\t\tthis.w += v.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\t\t\tthis.w += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\t\t\tthis.w = a.w + b.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\t\t\tthis.w += v.w * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\t\t\tthis.w -= v.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\t\t\tthis.w -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\t\t\tthis.w = a.w - b.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tif ( isFinite( scalar ) ) {\n\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\t\t\tthis.z *= scalar;\n\t\t\t\tthis.w *= scalar;\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\t\t\t\tthis.w = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( m ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t\t// q is assumed to be normalized\n\n\t\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\t\tif ( s < 0.0001 ) {\n\n\t\t\t\t this.x = 1;\n\t\t\t\t this.y = 0;\n\t\t\t\t this.z = 0;\n\n\t\t\t} else {\n\n\t\t\t\t this.x = q.x / s;\n\t\t\t\t this.y = q.y / s;\n\t\t\t\t this.z = q.z / s;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\t\tte = m.elements,\n\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t\t// singularity found\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t\t}\n\n\t\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\t\tangle = Math.PI;\n\n\t\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\t\ty = xy / x;\n\t\t\t\t\t\tz = xz / x;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\t\tx = xy / y;\n\t\t\t\t\t\tz = yz / y;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\t\tx = xz / z;\n\t\t\t\t\t\ty = yz / z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.set( x, y, z, angle );\n\n\t\t\t\treturn this; // return 180 deg rotation\n\n\t\t\t}\n\n\t\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\t\tthis.x = ( m32 - m23 ) / s;\n\t\t\tthis.y = ( m13 - m31 ) / s;\n\t\t\tthis.z = ( m21 - m12 ) / s;\n\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\t\t\tthis.w = Math.min( this.w, v.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\t\t\tthis.w = Math.max( this.w, v.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min, max;\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tif ( min === undefined ) {\n\n\t\t\t\t\tmin = new Vector4();\n\t\t\t\t\tmax = new Vector4();\n\n\t\t\t\t}\n\n\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\t\t\tthis.w = Math.floor( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\t\t\tthis.w = Math.ceil( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\t\t\tthis.w = Math.round( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\t\t\tthis.w = - this.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t\t},\n\n\t\tlengthManhattan: function () {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\t\t\tthis.w = array[ offset + 3 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\t\t\tarray[ offset + 3 ] = this.w;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tindex = index * attribute.itemSize + offset;\n\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\tthis.z = attribute.array[ index + 2 ];\n\t\t\tthis.w = attribute.array[ index + 3 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author szimek / https://github.com/szimek/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author Marius Kintel / https://github.com/kintel\n\t */\n\n\t/*\n\t In options, we can specify:\n\t * Texture parameters for an auto-generated target texture\n\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n\t*/\n\tfunction WebGLRenderTarget( width, height, options ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\tthis.scissorTest = false;\n\n\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\t\toptions = options || {};\n\n\t\tif ( options.minFilter === undefined ) options.minFilter = LinearFilter;\n\n\t\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\t\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\n\t}\n\n\tObject.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {\n\n\t\tisWebGLRenderTarget: true,\n\n\t\tsetSize: function ( width, height ) {\n\n\t\t\tif ( this.width !== width || this.height !== height ) {\n\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\n\t\t\t\tthis.dispose();\n\n\t\t\t}\n\n\t\t\tthis.viewport.set( 0, 0, width, height );\n\t\t\tthis.scissor.set( 0, 0, width, height );\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\n\t\t\tthis.viewport.copy( source.viewport );\n\n\t\t\tthis.texture = source.texture.clone();\n\n\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\tthis.depthTexture = source.depthTexture;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com\n\t */\n\n\tfunction WebGLRenderTargetCube( width, height, options ) {\n\n\t\tWebGLRenderTarget.call( this, width, height, options );\n\n\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\t\tthis.activeMipMapLevel = 0;\n\n\t}\n\n\tWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\n\tWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\n\n\tWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Quaternion( x, y, z, w ) {\n\n\t\tthis._x = x || 0;\n\t\tthis._y = y || 0;\n\t\tthis._z = z || 0;\n\t\tthis._w = ( w !== undefined ) ? w : 1;\n\n\t}\n\n\tQuaternion.prototype = {\n\n\t\tconstructor: Quaternion,\n\n\t\tget x () {\n\n\t\t\treturn this._x;\n\n\t\t},\n\n\t\tset x ( value ) {\n\n\t\t\tthis._x = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget y () {\n\n\t\t\treturn this._y;\n\n\t\t},\n\n\t\tset y ( value ) {\n\n\t\t\tthis._y = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget z () {\n\n\t\t\treturn this._z;\n\n\t\t},\n\n\t\tset z ( value ) {\n\n\t\t\tthis._z = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget w () {\n\n\t\t\treturn this._w;\n\n\t\t},\n\n\t\tset w ( value ) {\n\n\t\t\tthis._w = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tset: function ( x, y, z, w ) {\n\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._w = w;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t\t},\n\n\t\tcopy: function ( quaternion ) {\n\n\t\t\tthis._x = quaternion.x;\n\t\t\tthis._y = quaternion.y;\n\t\t\tthis._z = quaternion.z;\n\t\t\tthis._w = quaternion.w;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromEuler: function ( euler, update ) {\n\n\t\t\tif ( (euler && euler.isEuler) === false ) {\n\n\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t//\tcontent/SpinCalc.m\n\n\t\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\t\tvar s3 = Math.sin( euler._z / 2 );\n\n\t\t\tvar order = euler.order;\n\n\t\t\tif ( order === 'XYZ' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'YZX' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'XZY' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t}\n\n\t\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t\t// assumes axis is normalized\n\n\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\t\tthis._x = axis.x * s;\n\t\t\tthis._y = axis.y * s;\n\t\t\tthis._z = axis.z * s;\n\t\t\tthis._w = Math.cos( halfAngle );\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromRotationMatrix: function ( m ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar te = m.elements,\n\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\t\ttrace = m11 + m22 + m33,\n\t\t\t\ts;\n\n\t\t\tif ( trace > 0 ) {\n\n\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t\t} else if ( m22 > m33 ) {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t\t} else {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\t\tthis._z = 0.25 * s;\n\n\t\t\t}\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromUnitVectors: function () {\n\n\t\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\t\tvar v1, r;\n\n\t\t\tvar EPS = 0.000001;\n\n\t\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\tr = vFrom.dot( vTo ) + 1;\n\n\t\t\t\tif ( r < EPS ) {\n\n\t\t\t\t\tr = 0;\n\n\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv1.crossVectors( vFrom, vTo );\n\n\t\t\t\t}\n\n\t\t\t\tthis._x = v1.x;\n\t\t\t\tthis._y = v1.y;\n\t\t\t\tthis._z = v1.z;\n\t\t\t\tthis._w = r;\n\n\t\t\t\treturn this.normalize();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tinverse: function () {\n\n\t\t\treturn this.conjugate().normalize();\n\n\t\t},\n\n\t\tconjugate: function () {\n\n\t\t\tthis._x *= - 1;\n\t\t\tthis._y *= - 1;\n\t\t\tthis._z *= - 1;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\tvar l = this.length();\n\n\t\t\tif ( l === 0 ) {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = 1;\n\n\t\t\t} else {\n\n\t\t\t\tl = 1 / l;\n\n\t\t\t\tthis._x = this._x * l;\n\t\t\t\tthis._y = this._y * l;\n\t\t\t\tthis._z = this._z * l;\n\t\t\t\tthis._w = this._w * l;\n\n\t\t\t}\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( q, p ) {\n\n\t\t\tif ( p !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t\t}\n\n\t\t\treturn this.multiplyQuaternions( this, q );\n\n\t\t},\n\n\t\tpremultiply: function ( q ) {\n\n\t\t\treturn this.multiplyQuaternions( q, this );\n\n\t\t},\n\n\t\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tslerp: function ( qb, t ) {\n\n\t\t\tif ( t === 0 ) return this;\n\t\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\t\tthis._w = - qb._w;\n\t\t\t\tthis._x = - qb._x;\n\t\t\t\tthis._y = - qb._y;\n\t\t\t\tthis._z = - qb._z;\n\n\t\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t\t} else {\n\n\t\t\t\tthis.copy( qb );\n\n\t\t\t}\n\n\t\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\t\tthis._w = w;\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\t\tthis._z = 0.5 * ( z + this._z );\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( quaternion ) {\n\n\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis._x = array[ offset ];\n\t\t\tthis._y = array[ offset + 1 ];\n\t\t\tthis._z = array[ offset + 2 ];\n\t\t\tthis._w = array[ offset + 3 ];\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._w;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tonChange: function ( callback ) {\n\n\t\t\tthis.onChangeCallback = callback;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tonChangeCallback: function () {}\n\n\t};\n\n\tObject.assign( Quaternion, {\n\n\t\tslerp: function( qa, qb, qm, t ) {\n\n\t\t\treturn qm.copy( qa ).slerp( qb, t );\n\n\t\t},\n\n\t\tslerpFlat: function(\n\t\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\n\t\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\t\tvar s = 1 - t,\n\n\t\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\n\t\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t\t}\n\n\t\t\t\tvar tDir = t * dir;\n\n\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t\t// Normalize in case we just did a lerp:\n\t\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\t\tx0 *= f;\n\t\t\t\t\ty0 *= f;\n\t\t\t\t\tz0 *= f;\n\t\t\t\t\tw0 *= f;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdst[ dstOffset ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author *kile / http://kile.stravaganza.org/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Vector3( x, y, z ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\n\t}\n\n\tVector3.prototype = {\n\n\t\tconstructor: Vector3,\n\n\t\tisVector3: true,\n\n\t\tset: function ( x, y, z ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( z ) {\n\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\tthis.z *= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tif ( isFinite( scalar ) ) {\n\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\t\t\tthis.z *= scalar;\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x * b.x;\n\t\t\tthis.y = a.y * b.y;\n\t\t\tthis.z = a.z * b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyEuler: function () {\n\n\t\t\tvar quaternion;\n\n\t\t\treturn function applyEuler( euler ) {\n\n\t\t\t\tif ( (euler && euler.isEuler) === false ) {\n\n\t\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( quaternion === undefined ) quaternion = new Quaternion();\n\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyAxisAngle: function () {\n\n\t\t\tvar quaternion;\n\n\t\t\treturn function applyAxisAngle( axis, angle ) {\n\n\t\t\t\tif ( quaternion === undefined ) quaternion = new Quaternion();\n\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyMatrix3: function ( m ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( m ) {\n\n\t\t\t// input: THREE.Matrix4 affine matrix\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyProjection: function ( m ) {\n\n\t\t\t// input: THREE.Matrix4 projection matrix\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\t\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\n\n\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\n\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\n\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyQuaternion: function ( q ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t\t// calculate quat * vector\n\n\t\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\t\tvar iw = - qx * x - qy * y - qz * z;\n\n\t\t\t// calculate result * inverse quat\n\n\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tproject: function () {\n\n\t\t\tvar matrix;\n\n\t\t\treturn function project( camera ) {\n\n\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\n\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\t\treturn this.applyProjection( matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tunproject: function () {\n\n\t\t\tvar matrix;\n\n\t\t\treturn function unproject( camera ) {\n\n\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\n\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\t\treturn this.applyProjection( matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttransformDirection: function ( m ) {\n\n\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t// vector interpreted as a direction\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\t\treturn this.normalize();\n\n\t\t},\n\n\t\tdivide: function ( v ) {\n\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\t\tthis.z /= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min, max;\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tif ( min === undefined ) {\n\n\t\t\t\t\tmin = new Vector3();\n\t\t\t\t\tmax = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclampLength: function ( min, max ) {\n\n\t\t\tvar length = this.length();\n\n\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t\t},\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t\t},\n\n\t\tlengthManhattan: function () {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tcross: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\t\treturn this.crossVectors( v, w );\n\n\t\t\t}\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\t\tthis.x = y * v.z - z * v.y;\n\t\t\tthis.y = z * v.x - x * v.z;\n\t\t\tthis.z = x * v.y - y * v.x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcrossVectors: function ( a, b ) {\n\n\t\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\t\tvar bx = b.x, by = b.y, bz = b.z;\n\n\t\t\tthis.x = ay * bz - az * by;\n\t\t\tthis.y = az * bx - ax * bz;\n\t\t\tthis.z = ax * by - ay * bx;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tprojectOnVector: function ( vector ) {\n\n\t\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\n\t\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\n\t\t},\n\n\t\tprojectOnPlane: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function projectOnPlane( planeNormal ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\t\treturn this.sub( v1 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\treflect: function () {\n\n\t\t\t// reflect incident vector off plane orthogonal to normal\n\t\t\t// normal is assumed to have unit length\n\n\t\t\tvar v1;\n\n\t\t\treturn function reflect( normal ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tangleTo: function ( v ) {\n\n\t\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\n\t\t\t// clamp, to handle numerical problems\n\n\t\t\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\n\n\t\t},\n\n\t\tdistanceTo: function ( v ) {\n\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t\t},\n\n\t\tdistanceToSquared: function ( v ) {\n\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t\t},\n\n\t\tdistanceToManhattan: function ( v ) {\n\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t\t},\n\n\t\tsetFromSpherical: function( s ) {\n\n\t\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\n\t\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrixPosition: function ( m ) {\n\n\t\t\treturn this.setFromMatrixColumn( m, 3 );\n\n\t\t},\n\n\t\tsetFromMatrixScale: function ( m ) {\n\n\t\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\tthis.x = sx;\n\t\t\tthis.y = sy;\n\t\t\tthis.z = sz;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrixColumn: function ( m, index ) {\n\n\t\t\tif ( typeof m === 'number' ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n\t\t\t\tvar temp = m;\n\t\t\t\tm = index;\n\t\t\t\tindex = temp;\n\n\t\t\t}\n\n\t\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tindex = index * attribute.itemSize + offset;\n\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\tthis.z = attribute.array[ index + 2 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author jordi_ros / http://plattsoft.com\n\t * @author D1plo1d / http://github.com/D1plo1d\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author timknip / http://www.floorplanner.com/\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Matrix4() {\n\n\t\tthis.elements = new Float32Array( [\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t] );\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tMatrix4.prototype = {\n\n\t\tconstructor: Matrix4,\n\n\t\tisMatrix4: true,\n\n\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tidentity: function () {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new Matrix4().fromArray( this.elements );\n\n\t\t},\n\n\t\tcopy: function ( m ) {\n\n\t\t\tthis.elements.set( m.elements );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyPosition: function ( m ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tte[ 12 ] = me[ 12 ];\n\t\t\tte[ 13 ] = me[ 13 ];\n\t\t\tte[ 14 ] = me[ 14 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\t\tthis.set(\n\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t\t0,       0,       0,       1\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\textractRotation: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function extractRotation( m ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = m.elements;\n\n\t\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\n\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\n\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmakeRotationFromEuler: function ( euler ) {\n\n\t\t\tif ( (euler && euler.isEuler) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - c * f;\n\t\t\t\tte[ 8 ] = d;\n\n\t\t\t\tte[ 1 ] = af + be * d;\n\t\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\t\tte[ 9 ] = - b * c;\n\n\t\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\t\tte[ 6 ] = be + af * d;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\t\tte[ 0 ] = ce + df * b;\n\t\t\t\tte[ 4 ] = de * b - cf;\n\t\t\t\tte[ 8 ] = a * d;\n\n\t\t\t\tte[ 1 ] = a * f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b;\n\n\t\t\t\tte[ 2 ] = cf * b - de;\n\t\t\t\tte[ 6 ] = df + ce * b;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\t\tte[ 0 ] = ce - df * b;\n\t\t\t\tte[ 4 ] = - a * f;\n\t\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\t\tte[ 1 ] = cf + de * b;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\t\tte[ 2 ] = - a * d;\n\t\t\t\tte[ 6 ] = b;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = be * d - af;\n\t\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\t\tte[ 1 ] = c * f;\n\t\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\t\tte[ 2 ] = - d;\n\t\t\t\tte[ 6 ] = b * c;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\t\tte[ 1 ] = f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b * e;\n\n\t\t\t\tte[ 2 ] = - d * e;\n\t\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - f;\n\t\t\t\tte[ 8 ] = d * e;\n\n\t\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\t\tte[ 6 ] = b * e;\n\t\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t\t}\n\n\t\t\t// last column\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\t// bottom row\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationFromQuaternion: function ( q ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\t\tte[ 4 ] = xy - wz;\n\t\t\tte[ 8 ] = xz + wy;\n\n\t\t\tte[ 1 ] = xy + wz;\n\t\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\t\tte[ 9 ] = yz - wx;\n\n\t\t\tte[ 2 ] = xz - wy;\n\t\t\tte[ 6 ] = yz + wx;\n\t\t\tte[ 10 ] = 1 - ( xx + yy );\n\n\t\t\t// last column\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\t// bottom row\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlookAt: function () {\n\n\t\t\tvar x, y, z;\n\n\t\t\treturn function lookAt( eye, target, up ) {\n\n\t\t\t\tif ( x === undefined ) {\n\n\t\t\t\t\tx = new Vector3();\n\t\t\t\t\ty = new Vector3();\n\t\t\t\t\tz = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tvar te = this.elements;\n\n\t\t\t\tz.subVectors( eye, target ).normalize();\n\n\t\t\t\tif ( z.lengthSq() === 0 ) {\n\n\t\t\t\t\tz.z = 1;\n\n\t\t\t\t}\n\n\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t\tif ( x.lengthSq() === 0 ) {\n\n\t\t\t\t\tz.z += 0.0001;\n\t\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\ty.crossVectors( z, x );\n\n\n\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmultiply: function ( m, n ) {\n\n\t\t\tif ( n !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t\t}\n\n\t\t\treturn this.multiplyMatrices( this, m );\n\n\t\t},\n\n\t\tpremultiply: function ( m ) {\n\n\t\t\treturn this.multiplyMatrices( m, this );\n\n\t\t},\n\n\t\tmultiplyMatrices: function ( a, b ) {\n\n\t\t\tvar ae = a.elements;\n\t\t\tvar be = b.elements;\n\t\t\tvar te = this.elements;\n\n\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyToArray: function ( a, b, r ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tthis.multiplyMatrices( a, b );\n\n\t\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n\t\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n\t\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n\t\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyToVector3Array: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\tv1.applyMatrix4( this );\n\t\t\t\t\tv1.toArray( array, j );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyToBuffer: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\t\tv1.applyMatrix4( this );\n\n\t\t\t\t\tbuffer.setXYZ( j, v1.x, v1.y, v1.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn buffer;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tdeterminant: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t\t//TODO: make this more efficient\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\t\treturn (\n\t\t\t\tn41 * (\n\t\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t\t - n13 * n24 * n32\n\t\t\t\t\t - n14 * n22 * n33\n\t\t\t\t\t + n12 * n24 * n33\n\t\t\t\t\t + n13 * n22 * n34\n\t\t\t\t\t - n12 * n23 * n34\n\t\t\t\t) +\n\t\t\t\tn42 * (\n\t\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t\t - n11 * n24 * n33\n\t\t\t\t\t + n14 * n21 * n33\n\t\t\t\t\t - n13 * n21 * n34\n\t\t\t\t\t + n13 * n24 * n31\n\t\t\t\t\t - n14 * n23 * n31\n\t\t\t\t) +\n\t\t\t\tn43 * (\n\t\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t\t - n11 * n22 * n34\n\t\t\t\t\t - n14 * n21 * n32\n\t\t\t\t\t + n12 * n21 * n34\n\t\t\t\t\t + n14 * n22 * n31\n\t\t\t\t\t - n12 * n24 * n31\n\t\t\t\t) +\n\t\t\t\tn44 * (\n\t\t\t\t\t- n13 * n22 * n31\n\t\t\t\t\t - n11 * n23 * n32\n\t\t\t\t\t + n11 * n22 * n33\n\t\t\t\t\t + n13 * n21 * n32\n\t\t\t\t\t - n12 * n21 * n33\n\t\t\t\t\t + n12 * n23 * n31\n\t\t\t\t)\n\n\t\t\t);\n\n\t\t},\n\n\t\ttranspose: function () {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar tmp;\n\n\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\t\treturn this.toArray( array, offset );\n\n\t\t},\n\n\t\tgetPosition: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function getPosition() {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\n\t\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetPosition: function ( v ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 12 ] = v.x;\n\t\t\tte[ 13 ] = v.y;\n\t\t\tte[ 14 ] = v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetInverse: function ( m, throwOnDegenerate ) {\n\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\tvar te = this.elements,\n\t\t\t\tme = m.elements,\n\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\n\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\t\tif ( det === 0 ) {\n\n\t\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\t\tif ( throwOnDegenerate === true ) {\n\n\t\t\t\t\tthrow new Error( msg );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( msg );\n\n\t\t\t\t}\n\n\t\t\t\treturn this.identity();\n\n\t\t\t}\n\n\t\t\tvar detInv = 1 / det;\n\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\t\tte[ 4 ] = t12 * detInv;\n\t\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\t\tte[ 8 ] = t13 * detInv;\n\t\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\t\tte[ 12 ] = t14 * detInv;\n\t\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tscale: function ( v ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetMaxScaleOnAxis: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t\t},\n\n\t\tmakeTranslation: function ( x, y, z ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x,\n\t\t\t\t0, 1, 0, y,\n\t\t\t\t0, 0, 1, z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationX: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0,  0, 0,\n\t\t\t\t0, c, - s, 0,\n\t\t\t\t0, s,  c, 0,\n\t\t\t\t0, 0,  0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationY: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\t c, 0, s, 0,\n\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t- s, 0, c, 0,\n\t\t\t\t 0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationZ: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\tc, - s, 0, 0,\n\t\t\t\ts,  c, 0, 0,\n\t\t\t\t0,  0, 1, 0,\n\t\t\t\t0,  0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\t\tvar c = Math.cos( angle );\n\t\t\tvar s = Math.sin( angle );\n\t\t\tvar t = 1 - c;\n\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\t\tvar tx = t * x, ty = t * y;\n\n\t\t\tthis.set(\n\n\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\t return this;\n\n\t\t},\n\n\t\tmakeScale: function ( x, y, z ) {\n\n\t\t\tthis.set(\n\n\t\t\t\tx, 0, 0, 0,\n\t\t\t\t0, y, 0, 0,\n\t\t\t\t0, 0, z, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcompose: function ( position, quaternion, scale ) {\n\n\t\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\t\tthis.scale( scale );\n\t\t\tthis.setPosition( position );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdecompose: function () {\n\n\t\t\tvar vector, matrix;\n\n\t\t\treturn function decompose( position, quaternion, scale ) {\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tvector = new Vector3();\n\t\t\t\t\tmatrix = new Matrix4();\n\n\t\t\t\t}\n\n\t\t\t\tvar te = this.elements;\n\n\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t\t\t// if determine is negative, we need to invert one scale\n\t\t\t\tvar det = this.determinant();\n\t\t\t\tif ( det < 0 ) {\n\n\t\t\t\t\tsx = - sx;\n\n\t\t\t\t}\n\n\t\t\t\tposition.x = te[ 12 ];\n\t\t\t\tposition.y = te[ 13 ];\n\t\t\t\tposition.z = te[ 14 ];\n\n\t\t\t\t// scale the rotation part\n\n\t\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\n\t\t\t\tvar invSX = 1 / sx;\n\t\t\t\tvar invSY = 1 / sy;\n\t\t\t\tvar invSZ = 1 / sz;\n\n\t\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\t\tmatrix.elements[ 2 ] *= invSX;\n\n\t\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\t\tmatrix.elements[ 6 ] *= invSY;\n\n\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\n\t\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\t\tscale.x = sx;\n\t\t\t\tscale.y = sy;\n\t\t\t\tscale.z = sz;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar x = 2 * near / ( right - left );\n\t\t\tvar y = 2 * near / ( top - bottom );\n\n\t\t\tvar a = ( right + left ) / ( right - left );\n\t\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\t\tvar c = - ( far + near ) / ( far - near );\n\t\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakePerspective: function ( fov, aspect, near, far ) {\n\n\t\t\tvar ymax = near * Math.tan( _Math.DEG2RAD * fov * 0.5 );\n\t\t\tvar ymin = - ymax;\n\t\t\tvar xmin = ymin * aspect;\n\t\t\tvar xmax = ymax * aspect;\n\n\t\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\n\t\t},\n\n\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar w = 1.0 / ( right - left );\n\t\t\tvar h = 1.0 / ( top - bottom );\n\t\t\tvar p = 1.0 / ( far - near );\n\n\t\t\tvar x = ( right + left ) * w;\n\t\t\tvar y = ( top + bottom ) * h;\n\t\t\tvar z = ( far + near ) * p;\n\n\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( matrix ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = matrix.elements;\n\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tfor( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar te = this.elements;\n\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\t\tarray[ offset + 9 ]  = te[ 9 ];\n\t\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\t\treturn array;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\t\timages = images !== undefined ? images : [];\n\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\n\t\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.flipY = false;\n\n\t}\n\n\tCubeTexture.prototype = Object.create( Texture.prototype );\n\tCubeTexture.prototype.constructor = CubeTexture;\n\n\tCubeTexture.prototype.isCubeTexture = true;\n\n\tObject.defineProperty( CubeTexture.prototype, 'images', {\n\n\t\tget: function () {\n\n\t\t\treturn this.image;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis.image = value;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t *\n\t * Uniforms of a program.\n\t * Those form a tree structure with a special top-level container for the root,\n\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n\t *\n\t *\n\t * Properties of inner nodes including the top-level container:\n\t *\n\t * .seq - array of nested uniforms\n\t * .map - nested uniforms by name\n\t *\n\t *\n\t * Methods of all nodes except the top-level container:\n\t *\n\t * .setValue( gl, value, [renderer] )\n\t *\n\t * \t\tuploads a uniform value(s)\n\t *  \tthe 'renderer' parameter is needed for sampler uniforms\n\t *\n\t *\n\t * Static methods of the top-level container (renderer factorizations):\n\t *\n\t * .upload( gl, seq, values, renderer )\n\t *\n\t * \t\tsets uniforms in 'seq' to 'values[id].value'\n\t *\n\t * .seqWithValue( seq, values ) : filteredSeq\n\t *\n\t * \t\tfilters 'seq' entries with corresponding entry in values\n\t *\n\t *\n\t * Methods of the top-level container (renderer factorizations):\n\t *\n\t * .setValue( gl, name, value )\n\t *\n\t * \t\tsets uniform with  name 'name' to 'value'\n\t *\n\t * .set( gl, obj, prop )\n\t *\n\t * \t\tsets uniform from object and property with same name than uniform\n\t *\n\t * .setOptional( gl, obj, prop )\n\t *\n\t * \t\tlike .set for an optional property of the object\n\t *\n\t */\n\n\tvar emptyTexture = new Texture();\n\tvar emptyCubeTexture = new CubeTexture();\n\n\t// --- Base for inner nodes (including the root) ---\n\n\tfunction UniformContainer() {\n\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\n\t}\n\n\t// --- Utilities ---\n\n\t// Array Caches (provide typed arrays for temporary by size)\n\n\tvar arrayCacheF32 = [];\n\tvar arrayCacheI32 = [];\n\n\t// Flattening for arrays of vectors and matrices\n\n\tfunction flatten( array, nBlocks, blockSize ) {\n\n\t\tvar firstElem = array[ 0 ];\n\n\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t// unoptimized: ! isNaN( firstElem )\n\t\t// see http://jacksondunstan.com/articles/983\n\n\t\tvar n = nBlocks * blockSize,\n\t\t\tr = arrayCacheF32[ n ];\n\n\t\tif ( r === undefined ) {\n\n\t\t\tr = new Float32Array( n );\n\t\t\tarrayCacheF32[ n ] = r;\n\n\t\t}\n\n\t\tif ( nBlocks !== 0 ) {\n\n\t\t\tfirstElem.toArray( r, 0 );\n\n\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\t\toffset += blockSize;\n\t\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn r;\n\n\t}\n\n\t// Texture unit allocation\n\n\tfunction allocTexUnits( renderer, n ) {\n\n\t\tvar r = arrayCacheI32[ n ];\n\n\t\tif ( r === undefined ) {\n\n\t\t\tr = new Int32Array( n );\n\t\t\tarrayCacheI32[ n ] = r;\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\tr[ i ] = renderer.allocTextureUnit();\n\n\t\treturn r;\n\n\t}\n\n\t// --- Setters ---\n\n\t// Note: Defining these methods externally, because they come in a bunch\n\t// and this way their names minify.\n\n\t// Single scalar\n\n\tfunction setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }\n\tfunction setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }\n\n\t// Single float vector (from flat array or THREE.VectorN)\n\n\tfunction setValue2fv( gl, v ) {\n\n\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n\t\telse gl.uniform2f( this.addr, v.x, v.y );\n\n\t}\n\n\tfunction setValue3fv( gl, v ) {\n\n\t\tif ( v.x !== undefined )\n\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\telse if ( v.r !== undefined )\n\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\telse\n\t\t\tgl.uniform3fv( this.addr, v );\n\n\t}\n\n\tfunction setValue4fv( gl, v ) {\n\n\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t}\n\n\t// Single matrix (from flat array or MatrixN)\n\n\tfunction setValue2fm( gl, v ) {\n\n\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\n\t}\n\n\tfunction setValue3fm( gl, v ) {\n\n\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\n\t}\n\n\tfunction setValue4fm( gl, v ) {\n\n\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\n\t}\n\n\t// Single texture (2D / Cube)\n\n\tfunction setValueT1( gl, v, renderer ) {\n\n\t\tvar unit = renderer.allocTextureUnit();\n\t\tgl.uniform1i( this.addr, unit );\n\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\n\t}\n\n\tfunction setValueT6( gl, v, renderer ) {\n\n\t\tvar unit = renderer.allocTextureUnit();\n\t\tgl.uniform1i( this.addr, unit );\n\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\n\t}\n\n\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\n\tfunction setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }\n\tfunction setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }\n\tfunction setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }\n\n\t// Helper to pick the right setter for the singular case\n\n\tfunction getSingularSetter( type ) {\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\n\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\n\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\n\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\n\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t}\n\n\t}\n\n\t// Array of scalars\n\n\tfunction setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }\n\tfunction setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }\n\n\t// Array of vectors (flat or from THREE classes)\n\n\tfunction setValueV2a( gl, v ) {\n\n\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\n\t}\n\n\tfunction setValueV3a( gl, v ) {\n\n\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\n\t}\n\n\tfunction setValueV4a( gl, v ) {\n\n\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\n\t}\n\n\t// Array of matrices (flat or from THREE clases)\n\n\tfunction setValueM2a( gl, v ) {\n\n\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\n\t}\n\n\tfunction setValueM3a( gl, v ) {\n\n\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\n\t}\n\n\tfunction setValueM4a( gl, v ) {\n\n\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\n\t}\n\n\t// Array of textures (2D / Cube)\n\n\tfunction setValueT1a( gl, v, renderer ) {\n\n\t\tvar n = v.length,\n\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t\t}\n\n\t}\n\n\tfunction setValueT6a( gl, v, renderer ) {\n\n\t\tvar n = v.length,\n\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t\t}\n\n\t}\n\n\t// Helper to pick the right setter for a pure (bottom-level) array\n\n\tfunction getPureArraySetter( type ) {\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\n\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\n\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\n\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t}\n\n\t}\n\n\t// --- Uniform Classes ---\n\n\tfunction SingleUniform( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n\tfunction PureArrayUniform( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.size = activeInfo.size;\n\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n\tfunction StructuredUniform( id ) {\n\n\t\tthis.id = id;\n\n\t\tUniformContainer.call( this ); // mix-in\n\n\t}\n\n\tStructuredUniform.prototype.setValue = function( gl, value ) {\n\n\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t// are not allowed in structured uniforms.\n\n\t\tvar seq = this.seq;\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tu.setValue( gl, value[ u.id ] );\n\n\t\t}\n\n\t};\n\n\t// --- Top-level ---\n\n\t// Parser - builds up the property tree from the path strings\n\n\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\n\n\t// extracts\n\t// \t- the identifier (member name or array index)\n\t//  - followed by an optional right bracket (found when array index)\n\t//  - followed by an optional left bracket or dot (type of subscript)\n\t//\n\t// Note: These portions can be read in a non-overlapping fashion and\n\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t// in the uniform names.\n\n\tfunction addUniform( container, uniformObject ) {\n\n\t\tcontainer.seq.push( uniformObject );\n\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n\t}\n\n\tfunction parseUniform( activeInfo, addr, container ) {\n\n\t\tvar path = activeInfo.name,\n\t\t\tpathLength = path.length;\n\n\t\t// reset RegExp object, because of the early exit of a previous run\n\t\tRePathPart.lastIndex = 0;\n\n\t\tfor (; ;) {\n\n\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\n\t\t\t\tid = match[ 1 ],\n\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\tsubscript = match[ 3 ];\n\n\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\t\tif ( subscript === undefined ||\n\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\n\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\t\tvar map = container.map,\n\t\t\t\t\tnext = map[ id ];\n\n\t\t\t\tif ( next === undefined ) {\n\n\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\taddUniform( container, next );\n\n\t\t\t\t}\n\n\t\t\t\tcontainer = next;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Root Container\n\n\tfunction WebGLUniforms( gl, program, renderer ) {\n\n\t\tUniformContainer.call( this );\n\n\t\tthis.renderer = renderer;\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\tpath = info.name,\n\t\t\t\taddr = gl.getUniformLocation( program, path );\n\n\t\t\tparseUniform( info, addr, this );\n\n\t\t}\n\n\t}\n\n\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.set = function( gl, object, name ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\n\t\tvar v = object[ name ];\n\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n\t};\n\n\n\t// Static interface\n\n\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v.needsUpdate !== false ) {\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\n\t\t\t\tu.setValue( gl, v.value, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tWebGLUniforms.seqWithValue = function( seq, values ) {\n\n\t\tvar r = [];\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tif ( u.id in values ) r.push( u );\n\n\t\t}\n\n\t\treturn r;\n\n\t};\n\n\t/**\n\t * Uniform Utilities\n\t */\n\n\tvar UniformsUtils = {\n\n\t\tmerge: function ( uniforms ) {\n\n\t\t\tvar merged = {};\n\n\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\n\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\n\t\t\t\tfor ( var p in tmp ) {\n\n\t\t\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn merged;\n\n\t\t},\n\n\t\tclone: function ( uniforms_src ) {\n\n\t\t\tvar uniforms_dst = {};\n\n\t\t\tfor ( var u in uniforms_src ) {\n\n\t\t\t\tuniforms_dst[ u ] = {};\n\n\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\n\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\n\t\t\t\t\tif ( parameter_src && ( parameter_src.isColor ||\n\t\t\t\t\t\tparameter_src.isMatrix3 || parameter_src.isMatrix4 ||\n\t\t\t\t\t\tparameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||\n\t\t\t\t\t\tparameter_src.isTexture ) ) {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\n\t\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn uniforms_dst;\n\n\t\t}\n\n\t};\n\n\tvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\n\tvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\n\tvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\n\tvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\\n\";\n\n\tvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\n\tvar begin_vertex = \"\\nvec3 transformed = vec3( position );\\n\";\n\n\tvar beginnormal_vertex = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\n\tvar bsdfs = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\t\\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\t\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\t\\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\\t\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\n\tvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = dFdx( surf_pos );\\n\\t\\tvec3 vSigmaY = dFdy( surf_pos );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n\";\n\n\tvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\\n\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t\\t\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\\t\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t\\n\\t#endif\\n#endif\\n\";\n\n\tvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\n\tvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\n\tvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\n\tvar color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\n\tvar color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n\";\n\n\tvar color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\n\tvar color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\";\n\n\tvar common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\n\n\tvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\n\tvar defaultnormal_vertex = \"#ifdef FLIP_SIDED\\n\\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\n\tvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\\n\";\n\n\tvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\n\tvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\n\tvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\n\tvar encodings_fragment = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\n\tvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\n\tvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\n\";\n\n\tvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\t#else\\n\\t\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\t#endif\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\n\tvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\n\tvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\n\tvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\n\tvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\n\tvar lights_pars = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\\t\\t\\tdirectLight.color = pointLight.color;\\n\\t\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\t#include <normal_flip>\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\t#include <normal_flip>\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\\n\";\n\n\tvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\n\tvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\\n\";\n\n\tvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\n\tvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\n\tvar lights_template = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t \\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\\t#endif\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\\t#ifndef STANDARD\\n\\t\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\\t#else\\n\\t\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\\t#endif\\n\\t\\t\\n\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\n\tvar logdepthbuf_fragment = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\n\tvar logdepthbuf_pars_fragment = \"#ifdef USE_LOGDEPTHBUF\\n\\tuniform float logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n#endif\\n\";\n\n\tvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n\\tuniform float logDepthBufFC;\\n#endif\";\n\n\tvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\t#endif\\n#endif\\n\";\n\n\tvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\n\tvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\n\tvar map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\n\tvar map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform vec4 offsetRepeat;\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\n\tvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\n\tvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\n\tvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\n\tvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\n\tvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\\n\";\n\n\tvar normal_flip = \"#ifdef DOUBLE_SIDED\\n\\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\n\tvar normal_fragment = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\n\tvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\tvec3 q0 = dFdx( eye_pos.xyz );\\n\\t\\tvec3 q1 = dFdy( eye_pos.xyz );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\\t\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\t}\\n#endif\\n\";\n\n\tvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\n\tvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\n\tvar project_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\n\tvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\n\tvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\n\tvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\n\tvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\\n\";\n\n\tvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\\n\";\n\n\tvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\\n\";\n\n\tvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\n\tvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureWidth;\\n\\t\\tuniform int boneTextureHeight;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureWidth ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureWidth ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureWidth );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureHeight );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\\n\";\n\n\tvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\n\tvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\n\tvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\n\tvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\n\tvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\n\tvar tonemapping_pars_fragment = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\n\tvar uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\";\n\n\tvar uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\n\tvar uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\n\tvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n\tvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n\tvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\";\n\n\tvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\t#ifdef USE_SKINNING\\n\\t\\tvec4 worldPosition = modelMatrix * skinned;\\n\\t#else\\n\\t\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\t#endif\\n#endif\\n\";\n\n\tvar cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\\tgl_FragColor.a *= opacity;\\n}\\n\";\n\n\tvar cube_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\n\tvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\\n\";\n\n\tvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n\tvar distanceRGBA_frag = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\n\tvar distanceRGBA_vert = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition;\\n}\\n\";\n\n\tvar equirect_frag = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldPosition );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\";\n\n\tvar equirect_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\n\tvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n\tvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight;\\n\\treflectedLight.directDiffuse = vec3( 0.0 );\\n\\treflectedLight.directSpecular = vec3( 0.0 );\\n\\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n}\\n\";\n\n\tvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar normal_frag = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n\tvar normal_vert = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvNormal = normalize( normalMatrix * normal );\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n\tvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\\t#else\\n\\t\\tgl_PointSize = size;\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar shadow_frag = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\n\n\tvar shadow_vert = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar ShaderChunk = {\n\t\talphamap_fragment: alphamap_fragment,\n\t\talphamap_pars_fragment: alphamap_pars_fragment,\n\t\talphatest_fragment: alphatest_fragment,\n\t\taomap_fragment: aomap_fragment,\n\t\taomap_pars_fragment: aomap_pars_fragment,\n\t\tbegin_vertex: begin_vertex,\n\t\tbeginnormal_vertex: beginnormal_vertex,\n\t\tbsdfs: bsdfs,\n\t\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\t\tclipping_planes_fragment: clipping_planes_fragment,\n\t\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\t\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\t\tclipping_planes_vertex: clipping_planes_vertex,\n\t\tcolor_fragment: color_fragment,\n\t\tcolor_pars_fragment: color_pars_fragment,\n\t\tcolor_pars_vertex: color_pars_vertex,\n\t\tcolor_vertex: color_vertex,\n\t\tcommon: common,\n\t\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\t\tdefaultnormal_vertex: defaultnormal_vertex,\n\t\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\t\tdisplacementmap_vertex: displacementmap_vertex,\n\t\temissivemap_fragment: emissivemap_fragment,\n\t\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\t\tencodings_fragment: encodings_fragment,\n\t\tencodings_pars_fragment: encodings_pars_fragment,\n\t\tenvmap_fragment: envmap_fragment,\n\t\tenvmap_pars_fragment: envmap_pars_fragment,\n\t\tenvmap_pars_vertex: envmap_pars_vertex,\n\t\tenvmap_vertex: envmap_vertex,\n\t\tfog_fragment: fog_fragment,\n\t\tfog_pars_fragment: fog_pars_fragment,\n\t\tlightmap_fragment: lightmap_fragment,\n\t\tlightmap_pars_fragment: lightmap_pars_fragment,\n\t\tlights_lambert_vertex: lights_lambert_vertex,\n\t\tlights_pars: lights_pars,\n\t\tlights_phong_fragment: lights_phong_fragment,\n\t\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\t\tlights_physical_fragment: lights_physical_fragment,\n\t\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\t\tlights_template: lights_template,\n\t\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\t\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\t\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\t\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\t\tmap_fragment: map_fragment,\n\t\tmap_pars_fragment: map_pars_fragment,\n\t\tmap_particle_fragment: map_particle_fragment,\n\t\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\t\tmetalnessmap_fragment: metalnessmap_fragment,\n\t\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\t\tmorphnormal_vertex: morphnormal_vertex,\n\t\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\t\tmorphtarget_vertex: morphtarget_vertex,\n\t\tnormal_flip: normal_flip,\n\t\tnormal_fragment: normal_fragment,\n\t\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\t\tpacking: packing,\n\t\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\t\tproject_vertex: project_vertex,\n\t\troughnessmap_fragment: roughnessmap_fragment,\n\t\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\t\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\t\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\t\tshadowmap_vertex: shadowmap_vertex,\n\t\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\t\tskinbase_vertex: skinbase_vertex,\n\t\tskinning_pars_vertex: skinning_pars_vertex,\n\t\tskinning_vertex: skinning_vertex,\n\t\tskinnormal_vertex: skinnormal_vertex,\n\t\tspecularmap_fragment: specularmap_fragment,\n\t\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\t\ttonemapping_fragment: tonemapping_fragment,\n\t\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\t\tuv_pars_fragment: uv_pars_fragment,\n\t\tuv_pars_vertex: uv_pars_vertex,\n\t\tuv_vertex: uv_vertex,\n\t\tuv2_pars_fragment: uv2_pars_fragment,\n\t\tuv2_pars_vertex: uv2_pars_vertex,\n\t\tuv2_vertex: uv2_vertex,\n\t\tworldpos_vertex: worldpos_vertex,\n\n\t\tcube_frag: cube_frag,\n\t\tcube_vert: cube_vert,\n\t\tdepth_frag: depth_frag,\n\t\tdepth_vert: depth_vert,\n\t\tdistanceRGBA_frag: distanceRGBA_frag,\n\t\tdistanceRGBA_vert: distanceRGBA_vert,\n\t\tequirect_frag: equirect_frag,\n\t\tequirect_vert: equirect_vert,\n\t\tlinedashed_frag: linedashed_frag,\n\t\tlinedashed_vert: linedashed_vert,\n\t\tmeshbasic_frag: meshbasic_frag,\n\t\tmeshbasic_vert: meshbasic_vert,\n\t\tmeshlambert_frag: meshlambert_frag,\n\t\tmeshlambert_vert: meshlambert_vert,\n\t\tmeshphong_frag: meshphong_frag,\n\t\tmeshphong_vert: meshphong_vert,\n\t\tmeshphysical_frag: meshphysical_frag,\n\t\tmeshphysical_vert: meshphysical_vert,\n\t\tnormal_frag: normal_frag,\n\t\tnormal_vert: normal_vert,\n\t\tpoints_frag: points_frag,\n\t\tpoints_vert: points_vert,\n\t\tshadow_frag: shadow_frag,\n\t\tshadow_vert: shadow_vert\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Color( r, g, b ) {\n\n\t\tif ( g === undefined && b === undefined ) {\n\n\t\t\t// r is THREE.Color, hex or string\n\t\t\treturn this.set( r );\n\n\t\t}\n\n\t\treturn this.setRGB( r, g, b );\n\n\t}\n\n\tColor.prototype = {\n\n\t\tconstructor: Color,\n\n\t\tisColor: true,\n\n\t\tr: 1, g: 1, b: 1,\n\n\t\tset: function ( value ) {\n\n\t\t\tif ( (value && value.isColor) ) {\n\n\t\t\t\tthis.copy( value );\n\n\t\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\t\tthis.setHex( value );\n\n\t\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\t\tthis.setStyle( value );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.r = scalar;\n\t\t\tthis.g = scalar;\n\t\t\tthis.b = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetHex: function ( hex ) {\n\n\t\t\thex = Math.floor( hex );\n\n\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetRGB: function ( r, g, b ) {\n\n\t\t\tthis.r = r;\n\t\t\tthis.g = g;\n\t\t\tthis.b = b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetHSL: function () {\n\n\t\t\tfunction hue2rgb( p, q, t ) {\n\n\t\t\t\tif ( t < 0 ) t += 1;\n\t\t\t\tif ( t > 1 ) t -= 1;\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\t\treturn p;\n\n\t\t\t}\n\n\t\t\treturn function setHSL( h, s, l ) {\n\n\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\t\th = _Math.euclideanModulo( h, 1 );\n\t\t\t\ts = _Math.clamp( s, 0, 1 );\n\t\t\t\tl = _Math.clamp( l, 0, 1 );\n\n\t\t\t\tif ( s === 0 ) {\n\n\t\t\t\t\tthis.r = this.g = this.b = l;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetStyle: function ( style ) {\n\n\t\t\tfunction handleAlpha( string ) {\n\n\t\t\t\tif ( string === undefined ) return;\n\n\t\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tvar m;\n\n\t\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t\t// rgb / hsl\n\n\t\t\t\tvar color;\n\t\t\t\tvar name = m[ 1 ];\n\t\t\t\tvar components = m[ 2 ];\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'rgb':\n\t\t\t\t\tcase 'rgba':\n\n\t\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'hsl':\n\t\t\t\t\tcase 'hsla':\n\n\t\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\n\t\t\t\t// hex color\n\n\t\t\t\tvar hex = m[ 1 ];\n\t\t\t\tvar size = hex.length;\n\n\t\t\t\tif ( size === 3 ) {\n\n\t\t\t\t\t// #ff0\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t\t// #ff0000\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( style && style.length > 0 ) {\n\n\t\t\t\t// color keywords\n\t\t\t\tvar hex = ColorKeywords[ style ];\n\n\t\t\t\tif ( hex !== undefined ) {\n\n\t\t\t\t\t// red\n\t\t\t\t\tthis.setHex( hex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// unknown color\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t\t},\n\n\t\tcopy: function ( color ) {\n\n\t\t\tthis.r = color.r;\n\t\t\tthis.g = color.g;\n\t\t\tthis.b = color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\t\tthis.b = Math.pow( color.b, gammaFactor );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n\t\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\t\tthis.b = Math.pow( color.b, safeInverse );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconvertGammaToLinear: function () {\n\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\t\tthis.r = r * r;\n\t\t\tthis.g = g * g;\n\t\t\tthis.b = b * b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconvertLinearToGamma: function () {\n\n\t\t\tthis.r = Math.sqrt( this.r );\n\t\t\tthis.g = Math.sqrt( this.g );\n\t\t\tthis.b = Math.sqrt( this.b );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetHex: function () {\n\n\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t\t},\n\n\t\tgetHexString: function () {\n\n\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t\t},\n\n\t\tgetHSL: function ( optionalTarget ) {\n\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\t\tvar max = Math.max( r, g, b );\n\t\t\tvar min = Math.min( r, g, b );\n\n\t\t\tvar hue, saturation;\n\t\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\t\tif ( min === max ) {\n\n\t\t\t\thue = 0;\n\t\t\t\tsaturation = 0;\n\n\t\t\t} else {\n\n\t\t\t\tvar delta = max - min;\n\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\t\tswitch ( max ) {\n\n\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t\t}\n\n\t\t\t\thue /= 6;\n\n\t\t\t}\n\n\t\t\thsl.h = hue;\n\t\t\thsl.s = saturation;\n\t\t\thsl.l = lightness;\n\n\t\t\treturn hsl;\n\n\t\t},\n\n\t\tgetStyle: function () {\n\n\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t\t},\n\n\t\toffsetHSL: function ( h, s, l ) {\n\n\t\t\tvar hsl = this.getHSL();\n\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( color ) {\n\n\t\t\tthis.r += color.r;\n\t\t\tthis.g += color.g;\n\t\t\tthis.b += color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddColors: function ( color1, color2 ) {\n\n\t\t\tthis.r = color1.r + color2.r;\n\t\t\tthis.g = color1.g + color2.g;\n\t\t\tthis.b = color1.b + color2.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.r += s;\n\t\t\tthis.g += s;\n\t\t\tthis.b += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function( color ) {\n\n\t\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( color ) {\n\n\t\t\tthis.r *= color.r;\n\t\t\tthis.g *= color.g;\n\t\t\tthis.b *= color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tthis.r *= s;\n\t\t\tthis.g *= s;\n\t\t\tthis.b *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerp: function ( color, alpha ) {\n\n\t\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( c ) {\n\n\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.r = array[ offset ];\n\t\t\tthis.g = array[ offset + 1 ];\n\t\t\tthis.b = array[ offset + 2 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.r;\n\t\t\tarray[ offset + 1 ] = this.g;\n\t\t\tarray[ offset + 2 ] = this.b;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\treturn this.getHex();\n\n\t\t}\n\n\t};\n\n\tvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\n\t/**\n\t * Uniforms library for shared webgl shaders\n\t */\n\n\tvar UniformsLib = {\n\n\t\tcommon: {\n\n\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\topacity: { value: 1.0 },\n\n\t\t\tmap: { value: null },\n\t\t\toffsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },\n\n\t\t\tspecularMap: { value: null },\n\t\t\talphaMap: { value: null },\n\n\t\t\tenvMap: { value: null },\n\t\t\tflipEnvMap: { value: - 1 },\n\t\t\treflectivity: { value: 1.0 },\n\t\t\trefractionRatio: { value: 0.98 }\n\n\t\t},\n\n\t\taomap: {\n\n\t\t\taoMap: { value: null },\n\t\t\taoMapIntensity: { value: 1 }\n\n\t\t},\n\n\t\tlightmap: {\n\n\t\t\tlightMap: { value: null },\n\t\t\tlightMapIntensity: { value: 1 }\n\n\t\t},\n\n\t\temissivemap: {\n\n\t\t\temissiveMap: { value: null }\n\n\t\t},\n\n\t\tbumpmap: {\n\n\t\t\tbumpMap: { value: null },\n\t\t\tbumpScale: { value: 1 }\n\n\t\t},\n\n\t\tnormalmap: {\n\n\t\t\tnormalMap: { value: null },\n\t\t\tnormalScale: { value: new Vector2( 1, 1 ) }\n\n\t\t},\n\n\t\tdisplacementmap: {\n\n\t\t\tdisplacementMap: { value: null },\n\t\t\tdisplacementScale: { value: 1 },\n\t\t\tdisplacementBias: { value: 0 }\n\n\t\t},\n\n\t\troughnessmap: {\n\n\t\t\troughnessMap: { value: null }\n\n\t\t},\n\n\t\tmetalnessmap: {\n\n\t\t\tmetalnessMap: { value: null }\n\n\t\t},\n\n\t\tfog: {\n\n\t\t\tfogDensity: { value: 0.00025 },\n\t\t\tfogNear: { value: 1 },\n\t\t\tfogFar: { value: 2000 },\n\t\t\tfogColor: { value: new Color( 0xffffff ) }\n\n\t\t},\n\n\t\tlights: {\n\n\t\t\tambientLightColor: { value: [] },\n\n\t\t\tdirectionalLights: { value: [], properties: {\n\t\t\t\tdirection: {},\n\t\t\t\tcolor: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tdirectionalShadowMap: { value: [] },\n\t\t\tdirectionalShadowMatrix: { value: [] },\n\n\t\t\tspotLights: { value: [], properties: {\n\t\t\t\tcolor: {},\n\t\t\t\tposition: {},\n\t\t\t\tdirection: {},\n\t\t\t\tdistance: {},\n\t\t\t\tconeCos: {},\n\t\t\t\tpenumbraCos: {},\n\t\t\t\tdecay: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tspotShadowMap: { value: [] },\n\t\t\tspotShadowMatrix: { value: [] },\n\n\t\t\tpointLights: { value: [], properties: {\n\t\t\t\tcolor: {},\n\t\t\t\tposition: {},\n\t\t\t\tdecay: {},\n\t\t\t\tdistance: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tpointShadowMap: { value: [] },\n\t\t\tpointShadowMatrix: { value: [] },\n\n\t\t\themisphereLights: { value: [], properties: {\n\t\t\t\tdirection: {},\n\t\t\t\tskyColor: {},\n\t\t\t\tgroundColor: {}\n\t\t\t} }\n\n\t\t},\n\n\t\tpoints: {\n\n\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\topacity: { value: 1.0 },\n\t\t\tsize: { value: 1.0 },\n\t\t\tscale: { value: 1.0 },\n\t\t\tmap: { value: null },\n\t\t\toffsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t */\n\n\tvar ShaderLib = {\n\n\t\tbasic: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.fog\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\n\t\t},\n\n\t\tlambert: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\n\t\t\t\t{\n\t\t\t\t\temissive : { value: new Color( 0x000000 ) }\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\n\t\t},\n\n\t\tphong: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\tUniformsLib.normalmap,\n\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\n\t\t\t\t{\n\t\t\t\t\temissive : { value: new Color( 0x000000 ) },\n\t\t\t\t\tspecular : { value: new Color( 0x111111 ) },\n\t\t\t\t\tshininess: { value: 30 }\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphong_frag\n\n\t\t},\n\n\t\tstandard: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\tUniformsLib.normalmap,\n\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\tUniformsLib.roughnessmap,\n\t\t\t\tUniformsLib.metalnessmap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\n\t\t\t\t{\n\t\t\t\t\temissive : { value: new Color( 0x000000 ) },\n\t\t\t\t\troughness: { value: 0.5 },\n\t\t\t\t\tmetalness: { value: 0 },\n\t\t\t\t\tenvMapIntensity : { value: 1 }, // temporary\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t\t},\n\n\t\tpoints: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.points,\n\t\t\t\tUniformsLib.fog\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.points_vert,\n\t\t\tfragmentShader: ShaderChunk.points_frag\n\n\t\t},\n\n\t\tdashed: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.fog,\n\n\t\t\t\t{\n\t\t\t\t\tscale    : { value: 1 },\n\t\t\t\t\tdashSize : { value: 1 },\n\t\t\t\t\ttotalSize: { value: 2 }\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\t\tfragmentShader: ShaderChunk.linedashed_frag\n\n\t\t},\n\n\t\tdepth: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.displacementmap\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.depth_vert,\n\t\t\tfragmentShader: ShaderChunk.depth_frag\n\n\t\t},\n\n\t\tnormal: {\n\n\t\t\tuniforms: {\n\n\t\t\t\topacity : { value: 1.0 }\n\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.normal_vert,\n\t\t\tfragmentShader: ShaderChunk.normal_frag\n\n\t\t},\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\n\t\tcube: {\n\n\t\t\tuniforms: {\n\t\t\t\ttCube: { value: null },\n\t\t\t\ttFlip: { value: - 1 },\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.cube_vert,\n\t\t\tfragmentShader: ShaderChunk.cube_frag\n\n\t\t},\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\n\t\tequirect: {\n\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: { value: null },\n\t\t\t\ttFlip: { value: - 1 }\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\t\tfragmentShader: ShaderChunk.equirect_frag\n\n\t\t},\n\n\t\tdistanceRGBA: {\n\n\t\t\tuniforms: {\n\n\t\t\t\tlightPos: { value: new Vector3() }\n\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\n\t\t}\n\n\t};\n\n\tShaderLib.physical = {\n\n\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\tShaderLib.standard.uniforms,\n\n\t\t\t{\n\t\t\t\tclearCoat: { value: 0 },\n\t\t\t\tclearCoatRoughness: { value: 0 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Box2( min, max ) {\n\n\t\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\n\t\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\n\n\t}\n\n\tBox2.prototype = {\n\n\t\tconstructor: Box2,\n\n\t\tset: function ( min, max ) {\n\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCenterAndSize: function () {\n\n\t\t\tvar v1 = new Vector2();\n\n\t\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( box ) {\n\n\t\t\tthis.min.copy( box.min );\n\t\t\tthis.max.copy( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeEmpty: function () {\n\n\t\t\tthis.min.x = this.min.y = + Infinity;\n\t\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tisEmpty: function () {\n\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tgetSize: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );\n\n\t\t},\n\n\t\texpandByPoint: function ( point ) {\n\n\t\t\tthis.min.min( point );\n\t\t\tthis.max.max( point );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByVector: function ( vector ) {\n\n\t\t\tthis.min.sub( vector );\n\t\t\tthis.max.add( vector );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByScalar: function ( scalar ) {\n\n\t\t\tthis.min.addScalar( - scalar );\n\t\t\tthis.max.addScalar( scalar );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tcontainsBox: function ( box ) {\n\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\n\t\t\treturn result.set(\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t\t);\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\t// using 6 splitting planes to rule out intersections.\n\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t\t},\n\n\t\tdistanceToPoint: function () {\n\n\t\t\tvar v1 = new Vector2();\n\n\t\t\treturn function distanceToPoint( point ) {\n\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersect: function ( box ) {\n\n\t\t\tthis.min.max( box.min );\n\t\t\tthis.max.min( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tunion: function ( box ) {\n\n\t\t\tthis.min.min( box.min );\n\t\t\tthis.max.max( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.min.add( offset );\n\t\t\tthis.max.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( box ) {\n\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction LensFlarePlugin( renderer, flares ) {\n\n\t\tvar gl = renderer.context;\n\t\tvar state = renderer.state;\n\n\t\tvar vertexBuffer, elementBuffer;\n\t\tvar shader, program, attributes, uniforms;\n\n\t\tvar tempTexture, occlusionTexture;\n\n\t\tfunction init() {\n\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t- 1, - 1,  0, 0,\n\t\t\t\t 1, - 1,  1, 0,\n\t\t\t\t 1,  1,  1, 1,\n\t\t\t\t- 1,  1,  0, 1\n\t\t\t] );\n\n\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t0, 1, 2,\n\t\t\t\t0, 2, 3\n\t\t\t] );\n\n\t\t\t// buffers\n\n\t\t\tvertexBuffer     = gl.createBuffer();\n\t\t\telementBuffer    = gl.createBuffer();\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t\t// textures\n\n\t\t\ttempTexture      = gl.createTexture();\n\t\t\tocclusionTexture = gl.createTexture();\n\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\t\tshader = {\n\n\t\t\t\tvertexShader: [\n\n\t\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\t\t\"uniform vec2 scale;\",\n\t\t\t\t\t\"uniform float rotation;\",\n\n\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\n\n\t\t\t\t\t\"attribute vec2 position;\",\n\t\t\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\t\t\"if ( renderType == 2 ) {\",\n\n\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\n\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\t\t\"}\"\n\n\t\t\t\t].join( \"\\n\" ),\n\n\t\t\t\tfragmentShader: [\n\n\t\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\t\"uniform sampler2D map;\",\n\t\t\t\t\t\"uniform float opacity;\",\n\t\t\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\t// pink square\n\n\t\t\t\t\t\t\"if ( renderType == 0 ) {\",\n\n\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n\t\t\t\t\t\t// restore\n\n\t\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\n\n\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t\t\t// flare\n\n\t\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"}\"\n\n\t\t\t\t].join( \"\\n\" )\n\n\t\t\t};\n\n\t\t\tprogram = createProgram( shader );\n\n\t\t\tattributes = {\n\t\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\n\t\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\n\t\t\t};\n\n\t\t\tuniforms = {\n\t\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\n\t\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\n\t\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n\t\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\n\t\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\n\t\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\n\t\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\n\t\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n\t\t\t};\n\n\t\t}\n\n\t\t/*\n\t\t * Render lens flares\n\t\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t\t *         reads these back and calculates occlusion.\n\t\t */\n\n\t\tthis.render = function ( scene, camera, viewport ) {\n\n\t\t\tif ( flares.length === 0 ) return;\n\n\t\t\tvar tempPosition = new Vector3();\n\n\t\t\tvar invAspect = viewport.w / viewport.z,\n\t\t\t\thalfViewportWidth = viewport.z * 0.5,\n\t\t\t\thalfViewportHeight = viewport.w * 0.5;\n\n\t\t\tvar size = 16 / viewport.w,\n\t\t\t\tscale = new Vector2( size * invAspect, size );\n\n\t\t\tvar screenPosition = new Vector3( 1, 1, 0 ),\n\t\t\t\tscreenPositionPixels = new Vector2( 1, 1 );\n\n\t\t\tvar validArea = new Box2();\n\n\t\t\tvalidArea.min.set( viewport.x, viewport.y );\n\t\t\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tinit();\n\n\t\t\t}\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tstate.initAttributes();\n\t\t\tstate.enableAttribute( attributes.vertex );\n\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\t// loop through all lens flares to update their occlusion and positions\n\t\t\t// setup gl and common used attribs/uniforms\n\n\t\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\n\t\t\tgl.uniform1i( uniforms.map, 1 );\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\tstate.setDepthWrite( false );\n\n\t\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\n\n\t\t\t\tsize = 16 / viewport.w;\n\t\t\t\tscale.set( size * invAspect, size );\n\n\t\t\t\t// calc object screen position\n\n\t\t\t\tvar flare = flares[ i ];\n\n\t\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\n\t\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\n\t\t\t\t// setup arrays for gl programs\n\n\t\t\t\tscreenPosition.copy( tempPosition );\n\n\t\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t\t\t// screen cull\n\n\t\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\n\t\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t\t// render pink quad\n\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\n\t\t\t\t\tstate.disable( gl.BLEND );\n\t\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t\t// restore graphics\n\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t\t// update object positions\n\n\t\t\t\t\tflare.positionScreen.copy( screenPosition );\n\n\t\t\t\t\tif ( flare.customUpdateCallback ) {\n\n\t\t\t\t\t\tflare.customUpdateCallback( flare );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tflare.updateLensFlares();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// render flares\n\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\t\tstate.enable( gl.BLEND );\n\n\t\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\n\n\t\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\n\t\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\n\t\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\n\n\t\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\t\tscale.y = size;\n\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\n\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n\t\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\n\n\t\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// restore gl\n\n\t\t\tstate.enable( gl.CULL_FACE );\n\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\t\tstate.setDepthWrite( true );\n\n\t\t\trenderer.resetGLState();\n\n\t\t};\n\n\t\tfunction createProgram( shader ) {\n\n\t\t\tvar program = gl.createProgram();\n\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\n\t\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\n\t\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\n\t\t\tgl.compileShader( fragmentShader );\n\t\t\tgl.compileShader( vertexShader );\n\n\t\t\tgl.attachShader( program, fragmentShader );\n\t\t\tgl.attachShader( program, vertexShader );\n\n\t\t\tgl.linkProgram( program );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction SpritePlugin( renderer, sprites ) {\n\n\t\tvar gl = renderer.context;\n\t\tvar state = renderer.state;\n\n\t\tvar vertexBuffer, elementBuffer;\n\t\tvar program, attributes, uniforms;\n\n\t\tvar texture;\n\n\t\t// decompose matrixWorld\n\n\t\tvar spritePosition = new Vector3();\n\t\tvar spriteRotation = new Quaternion();\n\t\tvar spriteScale = new Vector3();\n\n\t\tfunction init() {\n\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t- 0.5, - 0.5,  0, 0,\n\t\t\t\t  0.5, - 0.5,  1, 0,\n\t\t\t\t  0.5,   0.5,  1, 1,\n\t\t\t\t- 0.5,   0.5,  0, 1\n\t\t\t] );\n\n\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t0, 1, 2,\n\t\t\t\t0, 2, 3\n\t\t\t] );\n\n\t\t\tvertexBuffer  = gl.createBuffer();\n\t\t\telementBuffer = gl.createBuffer();\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t\tprogram = createProgram();\n\n\t\t\tattributes = {\n\t\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\n\t\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\n\t\t\t};\n\n\t\t\tuniforms = {\n\t\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\n\t\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\n\n\t\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\n\t\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\n\n\t\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\n\t\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\n\t\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\n\n\t\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\n\n\t\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\n\t\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\n\t\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\n\t\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\n\t\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\n\n\t\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\n\t\t\t};\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = 8;\n\t\t\tcanvas.height = 8;\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.fillStyle = 'white';\n\t\t\tcontext.fillRect( 0, 0, 8, 8 );\n\n\t\t\ttexture = new Texture( canvas );\n\t\t\ttexture.needsUpdate = true;\n\n\t\t}\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( sprites.length === 0 ) return;\n\n\t\t\t// setup gl\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tinit();\n\n\t\t\t}\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tstate.initAttributes();\n\t\t\tstate.enableAttribute( attributes.position );\n\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\tstate.enable( gl.BLEND );\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\tgl.uniform1i( uniforms.map, 0 );\n\n\t\t\tvar oldFogType = 0;\n\t\t\tvar sceneFogType = 0;\n\t\t\tvar fog = scene.fog;\n\n\t\t\tif ( fog ) {\n\n\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\n\t\t\t\tif ( (fog && fog.isFog) ) {\n\n\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\t\toldFogType = 1;\n\t\t\t\t\tsceneFogType = 1;\n\n\t\t\t\t} else if ( (fog && fog.isFogExp2) ) {\n\n\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\t\toldFogType = 2;\n\t\t\t\t\tsceneFogType = 2;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\t\toldFogType = 0;\n\t\t\t\tsceneFogType = 0;\n\n\t\t\t}\n\n\n\t\t\t// update positions and sort\n\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\t\tvar sprite = sprites[ i ];\n\n\t\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\n\t\t\t}\n\n\t\t\tsprites.sort( painterSortStable );\n\n\t\t\t// render all sprites\n\n\t\t\tvar scale = [];\n\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\t\tvar sprite = sprites[ i ];\n\t\t\t\tvar material = sprite.material;\n\n\t\t\t\tif ( material.visible === false ) continue;\n\n\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\n\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\n\t\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\t\tscale[ 1 ] = spriteScale.y;\n\n\t\t\t\tvar fogType = 0;\n\n\t\t\t\tif ( scene.fog && material.fog ) {\n\n\t\t\t\t\tfogType = sceneFogType;\n\n\t\t\t\t}\n\n\t\t\t\tif ( oldFogType !== fogType ) {\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\t\toldFogType = fogType;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.map !== null ) {\n\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\n\t\t\t\t}\n\n\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\n\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\t\tstate.setDepthWrite( material.depthWrite );\n\n\t\t\t\tif ( material.map ) {\n\n\t\t\t\t\trenderer.setTexture2D( material.map, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setTexture2D( texture, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t}\n\n\t\t\t// restore gl\n\n\t\t\tstate.enable( gl.CULL_FACE );\n\n\t\t\trenderer.resetGLState();\n\n\t\t};\n\n\t\tfunction createProgram() {\n\n\t\t\tvar program = gl.createProgram();\n\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\n\t\t\tgl.shaderSource( vertexShader, [\n\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform float rotation;',\n\t\t\t\t'uniform vec2 scale;',\n\t\t\t\t'uniform vec2 uvOffset;',\n\t\t\t\t'uniform vec2 uvScale;',\n\n\t\t\t\t'attribute vec2 position;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'varying vec2 vUV;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\n\t\t\t\t\t'vec2 alignedPosition = position * scale;',\n\n\t\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\n\t\t\t\t\t'vec4 finalPosition;',\n\n\t\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\n\t\t\t\t\t'gl_Position = finalPosition;',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ) );\n\n\t\t\tgl.shaderSource( fragmentShader, [\n\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t\t'uniform vec3 color;',\n\t\t\t\t'uniform sampler2D map;',\n\t\t\t\t'uniform float opacity;',\n\n\t\t\t\t'uniform int fogType;',\n\t\t\t\t'uniform vec3 fogColor;',\n\t\t\t\t'uniform float fogDensity;',\n\t\t\t\t'uniform float fogNear;',\n\t\t\t\t'uniform float fogFar;',\n\t\t\t\t'uniform float alphaTest;',\n\n\t\t\t\t'varying vec2 vUV;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\n\t\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\n\t\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\n\t\t\t\t\t'if ( fogType > 0 ) {',\n\n\t\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t\t'float fogFactor = 0.0;',\n\n\t\t\t\t\t\t'if ( fogType == 1 ) {',\n\n\t\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\n\t\t\t\t\t\t'} else {',\n\n\t\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\n\t\t\t\t\t\t'}',\n\n\t\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\n\t\t\t\t\t'}',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ) );\n\n\t\t\tgl.compileShader( vertexShader );\n\t\t\tgl.compileShader( fragmentShader );\n\n\t\t\tgl.attachShader( program, vertexShader );\n\t\t\tgl.attachShader( program, fragmentShader );\n\n\t\t\tgl.linkProgram( program );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\tfunction painterSortStable( a, b ) {\n\n\t\t\tif ( a.renderOrder !== b.renderOrder ) {\n\n\t\t\t\treturn a.renderOrder - b.renderOrder;\n\n\t\t\t} else if ( a.z !== b.z ) {\n\n\t\t\t\treturn b.z - a.z;\n\n\t\t\t} else {\n\n\t\t\t\treturn b.id - a.id;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Material() {\n\n\t\tObject.defineProperty( this, 'id', { value: MaterialIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Material';\n\n\t\tthis.fog = true;\n\t\tthis.lights = true;\n\n\t\tthis.blending = NormalBlending;\n\t\tthis.side = FrontSide;\n\t\tthis.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n\t\tthis.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\n\t\tthis.opacity = 1;\n\t\tthis.transparent = false;\n\n\t\tthis.blendSrc = SrcAlphaFactor;\n\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\tthis.blendEquation = AddEquation;\n\t\tthis.blendSrcAlpha = null;\n\t\tthis.blendDstAlpha = null;\n\t\tthis.blendEquationAlpha = null;\n\n\t\tthis.depthFunc = LessEqualDepth;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\n\t\tthis.clippingPlanes = null;\n\t\tthis.clipIntersection = false;\n\t\tthis.clipShadows = false;\n\n\t\tthis.colorWrite = true;\n\n\t\tthis.precision = null; // override the renderer's default precision for this material\n\n\t\tthis.polygonOffset = false;\n\t\tthis.polygonOffsetFactor = 0;\n\t\tthis.polygonOffsetUnits = 0;\n\n\t\tthis.alphaTest = 0;\n\t\tthis.premultipliedAlpha = false;\n\n\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\n\t\tthis.visible = true;\n\n\t\tthis._needsUpdate = true;\n\n\t}\n\n\tMaterial.prototype = {\n\n\t\tconstructor: Material,\n\n\t\tisMaterial: true,\n\n\t\tget needsUpdate() {\n\n\t\t\treturn this._needsUpdate;\n\n\t\t},\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.update();\n\t\t\tthis._needsUpdate = value;\n\n\t\t},\n\n\t\tsetValues: function ( values ) {\n\n\t\t\tif ( values === undefined ) return;\n\n\t\t\tfor ( var key in values ) {\n\n\t\t\t\tvar newValue = values[ key ];\n\n\t\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar currentValue = this[ key ];\n\n\t\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( (currentValue && currentValue.isColor) ) {\n\n\t\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t\t} else if ( (currentValue && currentValue.isVector3) && (newValue && newValue.isVector3) ) {\n\n\t\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t\t} else if ( key === 'overdraw' ) {\n\n\t\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\t\tthis[ key ] = Number( newValue );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar isRoot = meta === undefined;\n\n\t\t\tif ( isRoot ) {\n\n\t\t\t\tmeta = {\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Material',\n\t\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard Material serialization\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( (this.color && this.color.isColor) ) data.color = this.color.getHex();\n\n\t\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\t\tif ( (this.emissive && this.emissive.isColor) ) data.emissive = this.emissive.getHex();\n\t\t\tif ( (this.specular && this.specular.isColor) ) data.specular = this.specular.getHex();\n\t\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\n\t\t\tif ( (this.map && this.map.isTexture) ) data.map = this.map.toJSON( meta ).uuid;\n\t\t\tif ( (this.alphaMap && this.alphaMap.isTexture) ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.lightMap && this.lightMap.isTexture) ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.bumpMap && this.bumpMap.isTexture) ) {\n\n\t\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t\t}\n\t\t\tif ( (this.normalMap && this.normalMap.isTexture) ) {\n\n\t\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t\t}\n\t\t\tif ( (this.displacementMap && this.displacementMap.isTexture) ) {\n\n\t\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t\t}\n\t\t\tif ( (this.roughnessMap && this.roughnessMap.isTexture) ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.metalnessMap && this.metalnessMap.isTexture) ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\t\tif ( (this.emissiveMap && this.emissiveMap.isTexture) ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.specularMap && this.specularMap.isTexture) ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n\t\t\tif ( (this.envMap && this.envMap.isTexture) ) {\n\n\t\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\n\t\t\t}\n\n\t\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\t\tif ( this.shading !== SmoothShading ) data.shading = this.shading;\n\t\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\t\tif ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\n\n\t\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\n\t\t\tdata.depthFunc = this.depthFunc;\n\t\t\tdata.depthTest = this.depthTest;\n\t\t\tdata.depthWrite = this.depthWrite;\n\n\t\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n\t\t\tdata.skinning = this.skinning;\n\t\t\tdata.morphTargets = this.morphTargets;\n\n\t\t\t// TODO: Copied from Object3D.toJSON\n\n\t\t\tfunction extractFromCache( cache ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in cache ) {\n\n\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\n\t\t\t}\n\n\t\t\tif ( isRoot ) {\n\n\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.name = source.name;\n\n\t\t\tthis.fog = source.fog;\n\t\t\tthis.lights = source.lights;\n\n\t\t\tthis.blending = source.blending;\n\t\t\tthis.side = source.side;\n\t\t\tthis.shading = source.shading;\n\t\t\tthis.vertexColors = source.vertexColors;\n\n\t\t\tthis.opacity = source.opacity;\n\t\t\tthis.transparent = source.transparent;\n\n\t\t\tthis.blendSrc = source.blendSrc;\n\t\t\tthis.blendDst = source.blendDst;\n\t\t\tthis.blendEquation = source.blendEquation;\n\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\t\tthis.depthFunc = source.depthFunc;\n\t\t\tthis.depthTest = source.depthTest;\n\t\t\tthis.depthWrite = source.depthWrite;\n\n\t\t\tthis.colorWrite = source.colorWrite;\n\n\t\t\tthis.precision = source.precision;\n\n\t\t\tthis.polygonOffset = source.polygonOffset;\n\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\t\tthis.alphaTest = source.alphaTest;\n\n\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\n\t\t\tthis.overdraw = source.overdraw;\n\n\t\t\tthis.visible = source.visible;\n\t\t\tthis.clipShadows = source.clipShadows;\n\t\t\tthis.clipIntersection = source.clipIntersection;\n\n\t\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\t\tdstPlanes = null;\n\n\t\t\tif ( srcPlanes !== null ) {\n\n\t\t\t\tvar n = srcPlanes.length;\n\t\t\t\tdstPlanes = new Array( n );\n\n\t\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t\t}\n\n\t\t\tthis.clippingPlanes = dstPlanes;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdate: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'update' } );\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t};\n\n\tObject.assign( Material.prototype, EventDispatcher.prototype );\n\n\tvar count$1 = 0;\n\tfunction MaterialIdCount() { return count$1++; }\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  defines: { \"label\" : \"value\" },\n\t *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n\t *\n\t *  fragmentShader: <string>,\n\t *  vertexShader: <string>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  lights: <bool>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction ShaderMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'ShaderMaterial';\n\n\t\tthis.defines = {};\n\t\tthis.uniforms = {};\n\n\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = false; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\tthis.skinning = false; // set to use skinning attribute streams\n\t\tthis.morphTargets = false; // set to use morph targets\n\t\tthis.morphNormals = false; // set to use morph normals\n\n\t\tthis.extensions = {\n\t\t\tderivatives: false, // set to use derivatives\n\t\t\tfragDepth: false, // set to use fragment depth values\n\t\t\tdrawBuffers: false, // set to use draw buffers\n\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t\t};\n\n\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\tthis.defaultAttributeValues = {\n\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t'uv': [ 0, 0 ],\n\t\t\t'uv2': [ 0, 0 ]\n\t\t};\n\n\t\tthis.index0AttributeName = undefined;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t\tthis.setValues( parameters );\n\n\t\t}\n\n\t}\n\n\tShaderMaterial.prototype = Object.create( Material.prototype );\n\tShaderMaterial.prototype.constructor = ShaderMaterial;\n\n\tShaderMaterial.prototype.isShaderMaterial = true;\n\n\tShaderMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.fragmentShader = source.fragmentShader;\n\t\tthis.vertexShader = source.vertexShader;\n\n\t\tthis.uniforms = UniformsUtils.clone( source.uniforms );\n\n\t\tthis.defines = source.defines;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.lights = source.lights;\n\t\tthis.clipping = source.clipping;\n\n\t\tthis.skinning = source.skinning;\n\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\tthis.extensions = source.extensions;\n\n\t\treturn this;\n\n\t};\n\n\tShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\t\tvar data = Material.prototype.toJSON.call( this, meta );\n\n\t\tdata.uniforms = this.uniforms;\n\t\tdata.vertexShader = this.vertexShader;\n\t\tdata.fragmentShader = this.fragmentShader;\n\n\t\treturn data;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / https://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t * }\n\t */\n\n\tfunction MeshDepthMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshDepthMaterial';\n\n\t\tthis.depthPacking = BasicDepthPacking;\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshDepthMaterial.prototype = Object.create( Material.prototype );\n\tMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\n\n\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\n\tMeshDepthMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.depthPacking = source.depthPacking;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Box3( min, max ) {\n\n\t\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\n\t\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\n\n\t}\n\n\tBox3.prototype = {\n\n\t\tconstructor: Box3,\n\n\t\tisBox3: true,\n\n\t\tset: function ( min, max ) {\n\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromArray: function ( array ) {\n\n\t\t\tvar minX = + Infinity;\n\t\t\tvar minY = + Infinity;\n\t\t\tvar minZ = + Infinity;\n\n\t\t\tvar maxX = - Infinity;\n\t\t\tvar maxY = - Infinity;\n\t\t\tvar maxZ = - Infinity;\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tvar x = array[ i ];\n\t\t\t\tvar y = array[ i + 1 ];\n\t\t\t\tvar z = array[ i + 2 ];\n\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\t\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t\t}\n\n\t\t\tthis.min.set( minX, minY, minZ );\n\t\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\t},\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCenterAndSize: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetFromObject: function () {\n\n\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t\t// accounting for both the object's, and children's, world transforms\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function setFromObject( object ) {\n\n\t\t\t\tvar scope = this;\n\n\t\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\t\tthis.makeEmpty();\n\n\t\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\t\t\tvar attribute = geometry.attributes.position;\n\n\t\t\t\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\t\t\t\tvar array, offset, stride;\n\n\t\t\t\t\t\t\t\tif ( (attribute && attribute.isInterleavedBufferAttribute) ) {\n\n\t\t\t\t\t\t\t\t\tarray = attribute.data.array;\n\t\t\t\t\t\t\t\t\toffset = attribute.offset;\n\t\t\t\t\t\t\t\t\tstride = attribute.data.stride;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tarray = attribute.array;\n\t\t\t\t\t\t\t\t\toffset = 0;\n\t\t\t\t\t\t\t\t\tstride = 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfor ( var i = offset, il = array.length; i < il; i += stride ) {\n\n\t\t\t\t\t\t\t\t\tv1.fromArray( array, i );\n\t\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( box ) {\n\n\t\t\tthis.min.copy( box.min );\n\t\t\tthis.max.copy( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeEmpty: function () {\n\n\t\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tisEmpty: function () {\n\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tgetSize: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );\n\n\t\t},\n\n\t\texpandByPoint: function ( point ) {\n\n\t\t\tthis.min.min( point );\n\t\t\tthis.max.max( point );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByVector: function ( vector ) {\n\n\t\t\tthis.min.sub( vector );\n\t\t\tthis.max.add( vector );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByScalar: function ( scalar ) {\n\n\t\t\tthis.min.addScalar( - scalar );\n\t\t\tthis.max.addScalar( scalar );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tcontainsBox: function ( box ) {\n\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn result.set(\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t\t);\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\t// using 6 splitting planes to rule out intersections.\n\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tintersectsSphere: ( function () {\n\n\t\t\tvar closestPoint;\n\n\t\t\treturn function intersectsSphere( sphere ) {\n\n\t\t\t\tif ( closestPoint === undefined ) closestPoint = new Vector3();\n\n\t\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\t\tvar min, max;\n\n\t\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t\t} else {\n\n\t\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t\t}\n\n\t\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t\t} else {\n\n\t\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t\t}\n\n\t\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t\t} else {\n\n\t\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t\t}\n\n\t\t\treturn ( min <= plane.constant && max >= plane.constant );\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t\t},\n\n\t\tdistanceToPoint: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function distanceToPoint( point ) {\n\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetBoundingSphere: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function getBoundingSphere( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Sphere();\n\n\t\t\t\tthis.getCenter( result.center );\n\n\t\t\t\tresult.radius = this.getSize( v1 ).length() * 0.5;\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersect: function ( box ) {\n\n\t\t\tthis.min.max( box.min );\n\t\t\tthis.max.min( box.max );\n\n\t\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\t\tif( this.isEmpty() ) this.makeEmpty();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tunion: function ( box ) {\n\n\t\t\tthis.min.min( box.min );\n\t\t\tthis.max.max( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function () {\n\n\t\t\tvar points = [\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3()\n\t\t\t];\n\n\t\t\treturn function applyMatrix4( matrix ) {\n\n\t\t\t\t// transform of empty box is an empty box.\n\t\t\t\tif( this.isEmpty() ) return this;\n\n\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\n\t\t\t\tthis.setFromPoints( points );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.min.add( offset );\n\t\t\tthis.max.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( box ) {\n\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Sphere( center, radius ) {\n\n\t\tthis.center = ( center !== undefined ) ? center : new Vector3();\n\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n\t}\n\n\tSphere.prototype = {\n\n\t\tconstructor: Sphere,\n\n\t\tset: function ( center, radius ) {\n\n\t\t\tthis.center.copy( center );\n\t\t\tthis.radius = radius;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPoints: function () {\n\n\t\t\tvar box = new Box3();\n\n\t\t\treturn function setFromPoints( points, optionalCenter ) {\n\n\t\t\t\tvar center = this.center;\n\n\t\t\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\t\t\tcenter.copy( optionalCenter );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbox.setFromPoints( points ).getCenter( center );\n\n\t\t\t\t}\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( sphere ) {\n\n\t\t\tthis.center.copy( sphere.center );\n\t\t\tthis.radius = sphere.radius;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tempty: function () {\n\n\t\t\treturn ( this.radius <= 0 );\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t\t},\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\treturn box.intersectsSphere( this );\n\n\t\t},\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// We use the following equation to compute the signed distance from\n\t\t\t// the center of the sphere to the plane.\n\t\t\t//\n\t\t\t// distance = q * n - d\n\t\t\t//\n\t\t\t// If this distance is greater than the radius of the sphere,\n\t\t\t// then there is no intersection.\n\n\t\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tresult.copy( point );\n\n\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\t\tresult.sub( this.center ).normalize();\n\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\tgetBoundingBox: function ( optionalTarget ) {\n\n\t\t\tvar box = optionalTarget || new Box3();\n\n\t\t\tbox.set( this.center, this.center );\n\t\t\tbox.expandByScalar( this.radius );\n\n\t\t\treturn box;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( matrix ) {\n\n\t\t\tthis.center.applyMatrix4( matrix );\n\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.center.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( sphere ) {\n\n\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t * @author tschw\n\t */\n\n\tfunction Matrix3() {\n\n\t\tthis.elements = new Float32Array( [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t] );\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tMatrix3.prototype = {\n\n\t\tconstructor: Matrix3,\n\n\t\tisMatrix3: true,\n\n\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tidentity: function () {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().fromArray( this.elements );\n\n\t\t},\n\n\t\tcopy: function ( m ) {\n\n\t\t\tvar me = m.elements;\n\n\t\t\tthis.set(\n\n\t\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\n\t\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\n\t\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrix4: function( m ) {\n\n\t\t\tvar me = m.elements;\n\n\t\t\tthis.set(\n\n\t\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\n\t\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\n\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyToVector3Array: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\tv1.applyMatrix3( this );\n\t\t\t\t\tv1.toArray( array, j );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyToBuffer: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\t\tv1.applyMatrix3( this );\n\n\t\t\t\t\tbuffer.setXYZ( j, v1.x, v1.y, v1.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn buffer;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdeterminant: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t\t},\n\n\t\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\n\t\t\tif ( (matrix && matrix.isMatrix4) ) {\n\n\t\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\n\t\t\t}\n\n\t\t\tvar me = matrix.elements,\n\t\t\t\tte = this.elements,\n\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\n\t\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\t\tif ( det === 0 ) {\n\n\t\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\t\tif ( throwOnDegenerate === true ) {\n\n\t\t\t\t\tthrow new Error( msg );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( msg );\n\n\t\t\t\t}\n\n\t\t\t\treturn this.identity();\n\t\t\t}\n\n\t\t\tvar detInv = 1 / det;\n\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\t\tte[ 3 ] = t12 * detInv;\n\t\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\t\tte[ 6 ] = t13 * detInv;\n\t\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranspose: function () {\n\n\t\t\tvar tmp, m = this.elements;\n\n\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\t\treturn this.toArray( array, offset );\n\n\t\t},\n\n\t\tgetNormalMatrix: function ( matrix4 ) {\n\n\t\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\n\t\t},\n\n\t\ttransposeIntoArray: function ( r ) {\n\n\t\t\tvar m = this.elements;\n\n\t\t\tr[ 0 ] = m[ 0 ];\n\t\t\tr[ 1 ] = m[ 3 ];\n\t\t\tr[ 2 ] = m[ 6 ];\n\t\t\tr[ 3 ] = m[ 1 ];\n\t\t\tr[ 4 ] = m[ 4 ];\n\t\t\tr[ 5 ] = m[ 7 ];\n\t\t\tr[ 6 ] = m[ 2 ];\n\t\t\tr[ 7 ] = m[ 5 ];\n\t\t\tr[ 8 ] = m[ 8 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tfor( var i = 0; i < 9; i ++ ) {\n\n\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar te = this.elements;\n\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\n\t\t\treturn array;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Plane( normal, constant ) {\n\n\t\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n\t}\n\n\tPlane.prototype = {\n\n\t\tconstructor: Plane,\n\n\t\tset: function ( normal, constant ) {\n\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = constant;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponents: function ( x, y, z, w ) {\n\n\t\t\tthis.normal.set( x, y, z );\n\t\t\tthis.constant = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCoplanarPoints: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\n\t\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\n\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( plane ) {\n\n\t\t\tthis.normal.copy( plane.normal );\n\t\t\tthis.constant = plane.constant;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\t\tthis.constant *= inverseNormalLength;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.constant *= - 1;\n\t\t\tthis.normal.negate();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn this.normal.dot( point ) + this.constant;\n\n\t\t},\n\n\t\tdistanceToSphere: function ( sphere ) {\n\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t\t},\n\n\t\tprojectPoint: function ( point, optionalTarget ) {\n\n\t\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\n\t\t},\n\n\t\torthoPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\n\t\t},\n\n\t\tintersectLine: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function intersectLine( line, optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tvar direction = line.delta( v1 );\n\n\t\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t\t// line is coplanar, return origin\n\t\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\t\t\treturn result.copy( line.start );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t}\n\n\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t}\n\n\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsLine: function ( line ) {\n\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\t\tvar startSign = this.distanceToPoint( line.start );\n\t\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\treturn box.intersectsPlane( this );\n\n\t\t},\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\treturn sphere.intersectsPlane( this );\n\n\t\t},\n\n\t\tcoplanarPoint: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t\t},\n\n\t\tapplyMatrix4: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar m1 = new Matrix3();\n\n\t\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\n\t\t\t\t// transform normal based on theory here:\n\t\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.constant = this.constant - offset.dot( this.normal );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( plane ) {\n\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tthis.planes = [\n\n\t\t\t( p0 !== undefined ) ? p0 : new Plane(),\n\t\t\t( p1 !== undefined ) ? p1 : new Plane(),\n\t\t\t( p2 !== undefined ) ? p2 : new Plane(),\n\t\t\t( p3 !== undefined ) ? p3 : new Plane(),\n\t\t\t( p4 !== undefined ) ? p4 : new Plane(),\n\t\t\t( p5 !== undefined ) ? p5 : new Plane()\n\n\t\t];\n\n\t}\n\n\tFrustum.prototype = {\n\n\t\tconstructor: Frustum,\n\n\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tplanes[ 0 ].copy( p0 );\n\t\t\tplanes[ 1 ].copy( p1 );\n\t\t\tplanes[ 2 ].copy( p2 );\n\t\t\tplanes[ 3 ].copy( p3 );\n\t\t\tplanes[ 4 ].copy( p4 );\n\t\t\tplanes[ 5 ].copy( p5 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( frustum ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrix: function ( m ) {\n\n\t\t\tvar planes = this.planes;\n\t\t\tvar me = m.elements;\n\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tintersectsObject: function () {\n\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function intersectsObject( object ) {\n\n\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t\t.applyMatrix4( object.matrixWorld );\n\n\t\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSprite: function () {\n\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function intersectsSprite( sprite ) {\n\n\t\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\tvar planes = this.planes;\n\t\t\tvar center = sphere.center;\n\t\t\tvar negRadius = - sphere.radius;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tintersectsBox: function () {\n\n\t\t\tvar p1 = new Vector3(),\n\t\t\t\tp2 = new Vector3();\n\n\t\t\treturn function intersectsBox( box ) {\n\n\t\t\t\tvar planes = this.planes;\n\n\t\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\n\t\t\t\t\tvar plane = planes[ i ];\n\n\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\n\t\t\t\t\t// if both outside plane, no intersection\n\n\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t}(),\n\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {\n\n\t\tvar _gl = _renderer.context,\n\t\t_state = _renderer.state,\n\t\t_frustum = new Frustum(),\n\t\t_projScreenMatrix = new Matrix4(),\n\n\t\t_lightShadows = _lights.shadows,\n\n\t\t_shadowMapSize = new Vector2(),\n\t\t_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),\n\n\t\t_lookTarget = new Vector3(),\n\t\t_lightPositionWorld = new Vector3(),\n\n\t\t_renderList = [],\n\n\t\t_MorphingFlag = 1,\n\t\t_SkinningFlag = 2,\n\n\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\n\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\n\t\t_materialCache = {};\n\n\t\tvar cubeDirections = [\n\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t];\n\n\t\tvar cubeUps = [\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t];\n\n\t\tvar cube2DViewPorts = [\n\t\t\tnew Vector4(), new Vector4(), new Vector4(),\n\t\t\tnew Vector4(), new Vector4(), new Vector4()\n\t\t];\n\n\t\t// init\n\n\t\tvar depthMaterialTemplate = new MeshDepthMaterial();\n\t\tdepthMaterialTemplate.depthPacking = RGBADepthPacking;\n\t\tdepthMaterialTemplate.clipping = true;\n\n\t\tvar distanceShader = ShaderLib[ \"distanceRGBA\" ];\n\t\tvar distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );\n\n\t\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\n\t\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\n\t\t\tvar depthMaterial = depthMaterialTemplate.clone();\n\t\t\tdepthMaterial.morphTargets = useMorphing;\n\t\t\tdepthMaterial.skinning = useSkinning;\n\n\t\t\t_depthMaterials[ i ] = depthMaterial;\n\n\t\t\tvar distanceMaterial = new ShaderMaterial( {\n\t\t\t\tdefines: {\n\t\t\t\t\t'USE_SHADOWMAP': ''\n\t\t\t\t},\n\t\t\t\tuniforms: distanceUniforms,\n\t\t\t\tvertexShader: distanceShader.vertexShader,\n\t\t\t\tfragmentShader: distanceShader.fragmentShader,\n\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\tskinning: useSkinning,\n\t\t\t\tclipping: true\n\t\t\t} );\n\n\t\t\t_distanceMaterials[ i ] = distanceMaterial;\n\n\t\t}\n\n\t\t//\n\n\t\tvar scope = this;\n\n\t\tthis.enabled = false;\n\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\n\t\tthis.type = PCFShadowMap;\n\n\t\tthis.renderReverseSided = true;\n\t\tthis.renderSingleSided = true;\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\t\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\t\tif ( _lightShadows.length === 0 ) return;\n\n\t\t\t// Set GL state for depth map.\n\t\t\t_state.clearColor( 1, 1, 1, 1 );\n\t\t\t_state.disable( _gl.BLEND );\n\t\t\t_state.setDepthTest( true );\n\t\t\t_state.setScissorTest( false );\n\n\t\t\t// render depth map\n\n\t\t\tvar faceCount, isPointLight;\n\n\t\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\n\t\t\t\tvar light = _lightShadows[ i ];\n\t\t\t\tvar shadow = light.shadow;\n\n\t\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar shadowCamera = shadow.camera;\n\n\t\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t\t\t_shadowMapSize.min( _maxShadowMapSize );\n\n\t\t\t\tif ( (light && light.isPointLight) ) {\n\n\t\t\t\t\tfaceCount = 6;\n\t\t\t\t\tisPointLight = true;\n\n\t\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\n\t\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t\t// following orientation:\n\t\t\t\t\t//\n\t\t\t\t\t//  xzXZ\n\t\t\t\t\t//   y Y\n\t\t\t\t\t//\n\t\t\t\t\t// X - Positive x direction\n\t\t\t\t\t// x - Negative x direction\n\t\t\t\t\t// Y - Positive y direction\n\t\t\t\t\t// y - Negative y direction\n\t\t\t\t\t// Z - Positive z direction\n\t\t\t\t\t// z - Negative z direction\n\n\t\t\t\t\t// positive X\n\t\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// negative X\n\t\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// positive Z\n\t\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// negative Z\n\t\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// positive Y\n\t\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t\t// negative Y\n\t\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\n\t\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t\t_shadowMapSize.y *= 2.0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfaceCount = 1;\n\t\t\t\t\tisPointLight = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\t\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\n\n\t\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\n\t\t\t\t\tshadowCamera.updateProjectionMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tif ( (shadow && shadow.isSpotLightShadow) ) {\n\n\t\t\t\t\tshadow.update( light );\n\n\t\t\t\t}\n\n\t\t\t\tvar shadowMap = shadow.map;\n\t\t\t\tvar shadowMatrix = shadow.matrix;\n\n\t\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\n\t\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t\t_renderer.clear();\n\n\t\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t\t// run a single pass if not\n\n\t\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\n\t\t\t\t\tif ( isPointLight ) {\n\n\t\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t\t_state.viewport( vpDimensions );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\n\t\t\t\t\t// compute shadow matrix\n\n\t\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t\t);\n\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t\t\t// update camera matrices and frustum\n\n\t\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t\t\t// set object matrices & frustum culling\n\n\t\t\t\t\t_renderList.length = 0;\n\n\t\t\t\t\tprojectObject( scene, camera, shadowCamera );\n\n\t\t\t\t\t// render shadow map\n\t\t\t\t\t// render regular objects\n\n\t\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar object = _renderList[ j ];\n\t\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\t\tif ( (material && material.isMultiMaterial) ) {\n\n\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Restore GL state.\n\t\t\tvar clearColor = _renderer.getClearColor(),\n\t\t\tclearAlpha = _renderer.getClearAlpha();\n\t\t\t_renderer.setClearColor( clearColor, clearAlpha );\n\n\t\t\tscope.needsUpdate = false;\n\n\t\t};\n\n\t\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tvar result = null;\n\n\t\t\tvar materialVariants = _depthMaterials;\n\t\t\tvar customMaterial = object.customDepthMaterial;\n\n\t\t\tif ( isPointLight ) {\n\n\t\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t\t}\n\n\t\t\tif ( ! customMaterial ) {\n\n\t\t\t\tvar useMorphing = false;\n\n\t\t\t\tif ( material.morphTargets ) {\n\n\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\n\t\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\t\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar useSkinning = object.isSkinnedMesh && material.skinning;\n\n\t\t\t\tvar variantIndex = 0;\n\n\t\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\n\t\t\t\tresult = materialVariants[ variantIndex ];\n\n\t\t\t} else {\n\n\t\t\t\tresult = customMaterial;\n\n\t\t\t}\n\n\t\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\t material.clipShadows === true &&\n\t\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t// appropriate state\n\n\t\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\n\t\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\n\t\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t\t}\n\n\t\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t\t}\n\n\t\t\t\tresult = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult.visible = material.visible;\n\t\t\tresult.wireframe = material.wireframe;\n\n\t\t\tvar side = material.side;\n\n\t\t\tif ( scope.renderSingleSided && side == DoubleSide ) {\n\n\t\t\t\tside = FrontSide;\n\n\t\t\t}\n\n\t\t\tif ( scope.renderReverseSided ) {\n\n\t\t\t\tif ( side === FrontSide ) side = BackSide;\n\t\t\t\telse if ( side === BackSide ) side = FrontSide;\n\n\t\t\t}\n\n\t\t\tresult.side = side;\n\n\t\t\tresult.clipShadows = material.clipShadows;\n\t\t\tresult.clippingPlanes = material.clippingPlanes;\n\n\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\t\tresult.linewidth = material.linewidth;\n\n\t\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\n\t\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfunction projectObject( object, camera, shadowCamera ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tvar visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\n\t\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\t\t_renderList.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tprojectObject( children[ i ], camera, shadowCamera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Ray( origin, direction ) {\n\n\t\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\n\t\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\n\n\t}\n\n\tRay.prototype = {\n\n\t\tconstructor: Ray,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\tthis.origin.copy( origin );\n\t\t\tthis.direction.copy( direction );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( ray ) {\n\n\t\t\tthis.origin.copy( ray.origin );\n\t\t\tthis.direction.copy( ray.direction );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tat: function ( t, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t\t},\n\n\t\tlookAt: function ( v ) {\n\n\t\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trecast: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function recast( t ) {\n\n\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclosestPointToPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\tresult.subVectors( point, this.origin );\n\t\t\tvar directionDistance = result.dot( this.direction );\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn result.copy( this.origin );\n\n\t\t\t}\n\n\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t\t},\n\n\t\tdistanceSqToPoint: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function distanceSqToPoint( point ) {\n\n\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t\t// point behind the ray\n\n\t\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t\t\t}\n\n\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\t\treturn v1.distanceToSquared( point );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tdistanceSqToSegment: function () {\n\n\t\t\tvar segCenter = new Vector3();\n\t\t\tvar segDir = new Vector3();\n\t\t\tvar diff = new Vector3();\n\n\t\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t\t// defined by v0 and v1\n\t\t\t\t// It can also set two optional targets :\n\t\t\t\t// - The closest point on the ray\n\t\t\t\t// - The closest point on the segment\n\n\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\n\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\t\tvar c = diff.lengthSq();\n\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\t\tvar s0, s1, sqrDist, extDet;\n\n\t\t\t\tif ( det > 0 ) {\n\n\t\t\t\t\t// The ray and segment are not parallel.\n\n\t\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\t\textDet = segExtent * det;\n\n\t\t\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 5\n\n\t\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t\t\t// region 4\n\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t// region 3\n\n\t\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 2\n\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Ray and segment are parallel.\n\n\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t\tif ( optionalPointOnRay ) {\n\n\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t\t\t}\n\n\t\t\t\tif ( optionalPointOnSegment ) {\n\n\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\n\t\t\t\t}\n\n\t\t\t\treturn sqrDist;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectSphere: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\n\t\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\t\tvar tca = v1.dot( this.direction );\n\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\n\t\t\t\tif ( d2 > radius2 ) return null;\n\n\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\n\t\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\t\tvar t0 = tca - thc;\n\n\t\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\t\tvar t1 = tca + thc;\n\n\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t\t\t// test to see if t0 is behind the ray:\n\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\n\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\t\treturn this.at( t0, optionalTarget );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\n\t\t},\n\n\t\tdistanceToPlane: function ( plane ) {\n\n\t\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\t\treturn 0;\n\n\t\t\t\t}\n\n\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t\t// Return if the ray never intersects the plane\n\n\t\t\treturn t >= 0 ? t :  null;\n\n\t\t},\n\n\t\tintersectPlane: function ( plane, optionalTarget ) {\n\n\t\t\tvar t = this.distanceToPlane( plane );\n\n\t\t\tif ( t === null ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\treturn this.at( t, optionalTarget );\n\n\t\t},\n\n\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// check if the ray lies on the plane first\n\n\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\n\t\t\tif ( distToPoint === 0 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tintersectBox: function ( box, optionalTarget ) {\n\n\t\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\t\tvar invdirx = 1 / this.direction.x,\n\t\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\t\tvar origin = this.origin;\n\n\t\t\tif ( invdirx >= 0 ) {\n\n\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t\t} else {\n\n\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t\t}\n\n\t\t\tif ( invdiry >= 0 ) {\n\n\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t\t} else {\n\n\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t\t}\n\n\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\t\tif ( invdirz >= 0 ) {\n\n\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t\t} else {\n\n\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t\t}\n\n\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t\t//return point closest to the ray (positive side)\n\n\t\t\tif ( tmax < 0 ) return null;\n\n\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\n\t\t},\n\n\t\tintersectsBox: ( function () {\n\n\t\t\tvar v = new Vector3();\n\n\t\t\treturn function intersectsBox( box ) {\n\n\t\t\t\treturn this.intersectBox( box, v ) !== null;\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tintersectTriangle: function () {\n\n\t\t\t// Compute the offset origin, edges, and normal.\n\t\t\tvar diff = new Vector3();\n\t\t\tvar edge1 = new Vector3();\n\t\t\tvar edge2 = new Vector3();\n\t\t\tvar normal = new Vector3();\n\n\t\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t\t\tedge1.subVectors( b, a );\n\t\t\t\tedge2.subVectors( c, a );\n\t\t\t\tnormal.crossVectors( edge1, edge2 );\n\n\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\t\tvar sign;\n\n\t\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\t\tsign = 1;\n\n\t\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\t\tsign = - 1;\n\t\t\t\t\tDdN = - DdN;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tdiff.subVectors( this.origin, a );\n\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n\t\t\t\t// b1 < 0, no intersection\n\t\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n\t\t\t\t// b2 < 0, no intersection\n\t\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// b1+b2 > 1, no intersection\n\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// Line intersects triangle, check if ray does.\n\t\t\t\tvar QdN = - sign * diff.dot( normal );\n\n\t\t\t\t// t < 0, no intersection\n\t\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// Ray intersects triangle.\n\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyMatrix4: function ( matrix4 ) {\n\n\t\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\t\tthis.origin.applyMatrix4( matrix4 );\n\t\t\tthis.direction.sub( this.origin );\n\t\t\tthis.direction.normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( ray ) {\n\n\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Euler( x, y, z, order ) {\n\n\t\tthis._x = x || 0;\n\t\tthis._y = y || 0;\n\t\tthis._z = z || 0;\n\t\tthis._order = order || Euler.DefaultOrder;\n\n\t}\n\n\tEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\n\tEuler.DefaultOrder = 'XYZ';\n\n\tEuler.prototype = {\n\n\t\tconstructor: Euler,\n\n\t\tisEuler: true,\n\n\t\tget x () {\n\n\t\t\treturn this._x;\n\n\t\t},\n\n\t\tset x ( value ) {\n\n\t\t\tthis._x = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget y () {\n\n\t\t\treturn this._y;\n\n\t\t},\n\n\t\tset y ( value ) {\n\n\t\t\tthis._y = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget z () {\n\n\t\t\treturn this._z;\n\n\t\t},\n\n\t\tset z ( value ) {\n\n\t\t\tthis._z = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget order () {\n\n\t\t\treturn this._order;\n\n\t\t},\n\n\t\tset order ( value ) {\n\n\t\t\tthis._order = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tset: function ( x, y, z, order ) {\n\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._order = order || this._order;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t\t},\n\n\t\tcopy: function ( euler ) {\n\n\t\t\tthis._x = euler._x;\n\t\t\tthis._y = euler._y;\n\t\t\tthis._z = euler._z;\n\t\t\tthis._order = euler._order;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromRotationMatrix: function ( m, order, update ) {\n\n\t\t\tvar clamp = _Math.clamp;\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar te = m.elements;\n\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\t\torder = order || this._order;\n\n\t\t\tif ( order === 'XYZ' ) {\n\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'YZX' ) {\n\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'XZY' ) {\n\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._y = 0;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\n\t\t\t}\n\n\t\t\tthis._order = order;\n\n\t\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromQuaternion: function () {\n\n\t\t\tvar matrix;\n\n\t\t\treturn function setFromQuaternion( q, order, update ) {\n\n\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\n\t\t\t\tmatrix.makeRotationFromQuaternion( q );\n\n\t\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetFromVector3: function ( v, order ) {\n\n\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\n\t\t},\n\n\t\treorder: function () {\n\n\t\t\t// WARNING: this discards revolution information -bhouston\n\n\t\t\tvar q = new Quaternion();\n\n\t\t\treturn function reorder( newOrder ) {\n\n\t\t\t\tq.setFromEuler( this );\n\n\t\t\t\treturn this.setFromQuaternion( q, newOrder );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tequals: function ( euler ) {\n\n\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t\t},\n\n\t\tfromArray: function ( array ) {\n\n\t\t\tthis._x = array[ 0 ];\n\t\t\tthis._y = array[ 1 ];\n\t\t\tthis._z = array[ 2 ];\n\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._order;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\ttoVector3: function ( optionalResult ) {\n\n\t\t\tif ( optionalResult ) {\n\n\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\n\t\t\t} else {\n\n\t\t\t\treturn new Vector3( this._x, this._y, this._z );\n\n\t\t\t}\n\n\t\t},\n\n\t\tonChange: function ( callback ) {\n\n\t\t\tthis.onChangeCallback = callback;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tonChangeCallback: function () {}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Layers() {\n\n\t\tthis.mask = 1;\n\n\t}\n\n\tLayers.prototype = {\n\n\t\tconstructor: Layers,\n\n\t\tset: function ( channel ) {\n\n\t\t\tthis.mask = 1 << channel;\n\n\t\t},\n\n\t\tenable: function ( channel ) {\n\n\t\t\tthis.mask |= 1 << channel;\n\n\t\t},\n\n\t\ttoggle: function ( channel ) {\n\n\t\t\tthis.mask ^= 1 << channel;\n\n\t\t},\n\n\t\tdisable: function ( channel ) {\n\n\t\t\tthis.mask &= ~ ( 1 << channel );\n\n\t\t},\n\n\t\ttest: function ( layers ) {\n\n\t\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author elephantatwork / www.elephantatwork.ch\n\t */\n\n\tfunction Object3D() {\n\n\t\tObject.defineProperty( this, 'id', { value: Object3DIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Object3D';\n\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\n\t\tthis.up = Object3D.DefaultUp.clone();\n\n\t\tvar position = new Vector3();\n\t\tvar rotation = new Euler();\n\t\tvar quaternion = new Quaternion();\n\t\tvar scale = new Vector3( 1, 1, 1 );\n\n\t\tfunction onRotationChange() {\n\n\t\t\tquaternion.setFromEuler( rotation, false );\n\n\t\t}\n\n\t\tfunction onQuaternionChange() {\n\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t\t}\n\n\t\trotation.onChange( onRotationChange );\n\t\tquaternion.onChange( onQuaternionChange );\n\n\t\tObject.defineProperties( this, {\n\t\t\tposition: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: position\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: rotation\n\t\t\t},\n\t\t\tquaternion: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: quaternion\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: scale\n\t\t\t},\n\t\t\tmodelViewMatrix: {\n\t\t\t\tvalue: new Matrix4()\n\t\t\t},\n\t\t\tnormalMatrix: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t} );\n\n\t\tthis.matrix = new Matrix4();\n\t\tthis.matrixWorld = new Matrix4();\n\n\t\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tthis.layers = new Layers();\n\t\tthis.visible = true;\n\n\t\tthis.castShadow = false;\n\t\tthis.receiveShadow = false;\n\n\t\tthis.frustumCulled = true;\n\t\tthis.renderOrder = 0;\n\n\t\tthis.userData = {};\n\n\t\tthis.onBeforeRender = function(){}; \n\t\tthis.onAfterRender = function(){};\n\n\t}\n\n\tObject3D.DefaultUp = new Vector3( 0, 1, 0 );\n\tObject3D.DefaultMatrixAutoUpdate = true;\n\n\tObject.assign( Object3D.prototype, EventDispatcher.prototype, {\n\n\t\tisObject3D: true,\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\n\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t\t},\n\n\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t\t// assumes axis is normalized\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t\t},\n\n\t\tsetRotationFromEuler: function ( euler ) {\n\n\t\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t\t},\n\n\t\tsetRotationFromMatrix: function ( m ) {\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t\t},\n\n\t\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t\t// assumes q is normalized\n\n\t\t\tthis.quaternion.copy( q );\n\n\t\t},\n\n\t\trotateOnAxis: function () {\n\n\t\t\t// rotate object on axis in object space\n\t\t\t// axis is assumed to be normalized\n\n\t\t\tvar q1 = new Quaternion();\n\n\t\t\treturn function rotateOnAxis( axis, angle ) {\n\n\t\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\t\tthis.quaternion.multiply( q1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateX: function () {\n\n\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateOnAxis: function () {\n\n\t\t\t// translate object by distance along axis in object space\n\t\t\t// axis is assumed to be normalized\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function translateOnAxis( axis, distance ) {\n\n\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateX: function () {\n\n\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\n\t\t\treturn function translateX( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateY: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\n\t\t\treturn function translateY( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateZ: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\n\t\t\treturn function translateZ( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlocalToWorld: function ( vector ) {\n\n\t\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t\t},\n\n\t\tworldToLocal: function () {\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function worldToLocal( vector ) {\n\n\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tm1.lookAt( vector, this.position, this.up );\n\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tadd: function ( object ) {\n\n\t\t\tif ( arguments.length > 1 ) {\n\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tif ( object === this ) {\n\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tif ( (object && object.isObject3D) ) {\n\n\t\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\t\tobject.parent.remove( object );\n\n\t\t\t\t}\n\n\t\t\t\tobject.parent = this;\n\t\t\t\tobject.dispatchEvent( { type: 'added' } );\n\n\t\t\t\tthis.children.push( object );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tremove: function ( object ) {\n\n\t\t\tif ( arguments.length > 1 ) {\n\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar index = this.children.indexOf( object );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tobject.parent = null;\n\n\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\n\t\t\t\tthis.children.splice( index, 1 );\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetObjectById: function ( id ) {\n\n\t\t\treturn this.getObjectByProperty( 'id', id );\n\n\t\t},\n\n\t\tgetObjectByName: function ( name ) {\n\n\t\t\treturn this.getObjectByProperty( 'name', name );\n\n\t\t},\n\n\t\tgetObjectByProperty: function ( name, value ) {\n\n\t\t\tif ( this[ name ] === value ) return this;\n\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = this.children[ i ];\n\t\t\t\tvar object = child.getObjectByProperty( name, value );\n\n\t\t\t\tif ( object !== undefined ) {\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn undefined;\n\n\t\t},\n\n\t\tgetWorldPosition: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\n\t\t},\n\n\t\tgetWorldQuaternion: function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar scale = new Vector3();\n\n\t\t\treturn function getWorldQuaternion( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Quaternion();\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldRotation: function () {\n\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldRotation( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Euler();\n\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldScale: function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldScale( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldDirection: function () {\n\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\traycast: function () {},\n\n\t\ttraverse: function ( callback ) {\n\n\t\t\tcallback( this );\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].traverse( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttraverseVisible: function ( callback ) {\n\n\t\t\tif ( this.visible === false ) return;\n\n\t\t\tcallback( this );\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttraverseAncestors: function ( callback ) {\n\n\t\t\tvar parent = this.parent;\n\n\t\t\tif ( parent !== null ) {\n\n\t\t\t\tcallback( parent );\n\n\t\t\t\tparent.traverseAncestors( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdateMatrix: function () {\n\n\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t\t},\n\n\t\tupdateMatrixWorld: function ( force ) {\n\n\t\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\n\t\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\n\t\t\t\tif ( this.parent === null ) {\n\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t\t}\n\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t\tforce = true;\n\n\t\t\t}\n\n\t\t\t// update children\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].updateMatrixWorld( force );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\t// meta is '' when called from JSON.stringify\n\t\t\tvar isRootObject = ( meta === undefined || meta === '' );\n\n\t\t\tvar output = {};\n\n\t\t\t// meta is a hash used to collect geometries, materials.\n\t\t\t// not providing it implies that this is the root object\n\t\t\t// being serialized.\n\t\t\tif ( isRootObject ) {\n\n\t\t\t\t// initialize meta obj\n\t\t\t\tmeta = {\n\t\t\t\t\tgeometries: {},\n\t\t\t\t\tmaterials: {},\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\n\t\t\t\toutput.metadata = {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Object',\n\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// standard Object3D serialization\n\n\t\t\tvar object = {};\n\n\t\t\tobject.uuid = this.uuid;\n\t\t\tobject.type = this.type;\n\n\t\t\tif ( this.name !== '' ) object.name = this.name;\n\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\t\tif ( this.visible === false ) object.visible = false;\n\n\t\t\tobject.matrix = this.matrix.toArray();\n\n\t\t\t//\n\n\t\t\tif ( this.geometry !== undefined ) {\n\n\t\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\n\t\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\n\t\t\t\t}\n\n\t\t\t\tobject.geometry = this.geometry.uuid;\n\n\t\t\t}\n\n\t\t\tif ( this.material !== undefined ) {\n\n\t\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\n\n\t\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\n\t\t\t\t}\n\n\t\t\t\tobject.material = this.material.uuid;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( this.children.length > 0 ) {\n\n\t\t\t\tobject.children = [];\n\n\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( isRootObject ) {\n\n\t\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\t\tif ( images.length > 0 ) output.images = images;\n\n\t\t\t}\n\n\t\t\toutput.object = object;\n\n\t\t\treturn output;\n\n\t\t\t// extract data from the cache hash\n\t\t\t// remove metadata on each item\n\t\t\t// and return as array\n\t\t\tfunction extractFromCache( cache ) {\n\n\t\t\t\tvar values = [];\n\t\t\t\tfor ( var key in cache ) {\n\n\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\n\t\t\t\t}\n\t\t\t\treturn values;\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function ( recursive ) {\n\n\t\t\treturn new this.constructor().copy( this, recursive );\n\n\t\t},\n\n\t\tcopy: function ( source, recursive ) {\n\n\t\t\tif ( recursive === undefined ) recursive = true;\n\n\t\t\tthis.name = source.name;\n\n\t\t\tthis.up.copy( source.up );\n\n\t\t\tthis.position.copy( source.position );\n\t\t\tthis.quaternion.copy( source.quaternion );\n\t\t\tthis.scale.copy( source.scale );\n\n\t\t\tthis.matrix.copy( source.matrix );\n\t\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\t\tthis.visible = source.visible;\n\n\t\t\tthis.castShadow = source.castShadow;\n\t\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\tthis.renderOrder = source.renderOrder;\n\n\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\t\tvar child = source.children[ i ];\n\t\t\t\t\tthis.add( child.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\tvar count$2 = 0;\n\tfunction Object3DIdCount() { return count$2++; }\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Line3( start, end ) {\n\n\t\tthis.start = ( start !== undefined ) ? start : new Vector3();\n\t\tthis.end = ( end !== undefined ) ? end : new Vector3();\n\n\t}\n\n\tLine3.prototype = {\n\n\t\tconstructor: Line3,\n\n\t\tset: function ( start, end ) {\n\n\t\t\tthis.start.copy( start );\n\t\t\tthis.end.copy( end );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( line ) {\n\n\t\t\tthis.start.copy( line.start );\n\t\t\tthis.end.copy( line.end );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tdelta: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.subVectors( this.end, this.start );\n\n\t\t},\n\n\t\tdistanceSq: function () {\n\n\t\t\treturn this.start.distanceToSquared( this.end );\n\n\t\t},\n\n\t\tdistance: function () {\n\n\t\t\treturn this.start.distanceTo( this.end );\n\n\t\t},\n\n\t\tat: function ( t, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t\t},\n\n\t\tclosestPointToPointParameter: function () {\n\n\t\t\tvar startP = new Vector3();\n\t\t\tvar startEnd = new Vector3();\n\n\t\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\n\t\t\t\tstartP.subVectors( point, this.start );\n\t\t\t\tstartEnd.subVectors( this.end, this.start );\n\n\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\n\t\t\t\tvar t = startEnd_startP / startEnd2;\n\n\t\t\t\tif ( clampToLine ) {\n\n\t\t\t\t\tt = _Math.clamp( t, 0, 1 );\n\n\t\t\t\t}\n\n\t\t\t\treturn t;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\n\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t\t},\n\n\t\tapplyMatrix4: function ( matrix ) {\n\n\t\t\tthis.start.applyMatrix4( matrix );\n\t\t\tthis.end.applyMatrix4( matrix );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( line ) {\n\n\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Triangle( a, b, c ) {\n\n\t\tthis.a = ( a !== undefined ) ? a : new Vector3();\n\t\tthis.b = ( b !== undefined ) ? b : new Vector3();\n\t\tthis.c = ( c !== undefined ) ? c : new Vector3();\n\n\t}\n\n\tTriangle.normal = function () {\n\n\t\tvar v0 = new Vector3();\n\n\t\treturn function normal( a, b, c, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tresult.subVectors( c, b );\n\t\t\tv0.subVectors( a, b );\n\t\t\tresult.cross( v0 );\n\n\t\t\tvar resultLengthSq = result.lengthSq();\n\t\t\tif ( resultLengthSq > 0 ) {\n\n\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\n\t\t\t}\n\n\t\t\treturn result.set( 0, 0, 0 );\n\n\t\t};\n\n\t}();\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tTriangle.barycoordFromPoint = function () {\n\n\t\tvar v0 = new Vector3();\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\n\t\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\n\t\t\tv0.subVectors( c, a );\n\t\t\tv1.subVectors( b, a );\n\t\t\tv2.subVectors( point, a );\n\n\t\t\tvar dot00 = v0.dot( v0 );\n\t\t\tvar dot01 = v0.dot( v1 );\n\t\t\tvar dot02 = v0.dot( v2 );\n\t\t\tvar dot11 = v1.dot( v1 );\n\t\t\tvar dot12 = v1.dot( v2 );\n\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t// collinear or singular triangle\n\t\t\tif ( denom === 0 ) {\n\n\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\treturn result.set( - 2, - 1, - 1 );\n\n\t\t\t}\n\n\t\t\tvar invDenom = 1 / denom;\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t\t// barycentric coordinates must always sum to 1\n\t\t\treturn result.set( 1 - u - v, v, u );\n\n\t\t};\n\n\t}();\n\n\tTriangle.containsPoint = function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function containsPoint( point, a, b, c ) {\n\n\t\t\tvar result = Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\n\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\n\t\t};\n\n\t}();\n\n\tTriangle.prototype = {\n\n\t\tconstructor: Triangle,\n\n\t\tset: function ( a, b, c ) {\n\n\t\t\tthis.a.copy( a );\n\t\t\tthis.b.copy( b );\n\t\t\tthis.c.copy( c );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\t\tthis.a.copy( points[ i0 ] );\n\t\t\tthis.b.copy( points[ i1 ] );\n\t\t\tthis.c.copy( points[ i2 ] );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( triangle ) {\n\n\t\t\tthis.a.copy( triangle.a );\n\t\t\tthis.b.copy( triangle.b );\n\t\t\tthis.c.copy( triangle.c );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tarea: function () {\n\n\t\t\tvar v0 = new Vector3();\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function area() {\n\n\t\t\t\tv0.subVectors( this.c, this.b );\n\t\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmidpoint: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t\t},\n\n\t\tnormal: function ( optionalTarget ) {\n\n\t\t\treturn Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\n\t\t},\n\n\t\tplane: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Plane();\n\n\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t\t},\n\n\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\n\t\t\treturn Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t\t},\n\n\t\tclosestPointToPoint: function () {\n\n\t\t\tvar plane, edgeList, projectedPoint, closestPoint;\n\n\t\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\n\t\t\t\tif ( plane === undefined ) {\n\n\t\t\t\t\tplane = new Plane();\n\t\t\t\t\tedgeList = [ new Line3(), new Line3(), new Line3() ];\n\t\t\t\t\tprojectedPoint = new Vector3();\n\t\t\t\t\tclosestPoint = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\tvar minDistance = Infinity;\n\n\t\t\t\t// project the point onto the plane of the triangle\n\n\t\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\t\tplane.projectPoint( point, projectedPoint );\n\n\t\t\t\t// check if the projection lies within the triangle\n\n\t\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\n\n\t\t\t\t\t// if so, this is the closest point\n\n\t\t\t\t\tresult.copy( projectedPoint );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\n\t\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\n\t\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\n\n\t\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\n\t\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\n\t\t\t\t\t\tif( distance < minDistance ) {\n\n\t\t\t\t\t\t\tminDistance = distance;\n\n\t\t\t\t\t\t\tresult.copy( closestPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tequals: function ( triangle ) {\n\n\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Face3( a, b, c, normal, color, materialIndex ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t\tthis.normal = (normal && normal.isVector3) ? normal : new Vector3();\n\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\t\tthis.color = (color && color.isColor) ? color : new Color();\n\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n\t}\n\n\tFace3.prototype = {\n\n\t\tconstructor: Face3,\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.a = source.a;\n\t\t\tthis.b = source.b;\n\t\t\tthis.c = source.c;\n\n\t\t\tthis.normal.copy( source.normal );\n\t\t\tthis.color.copy( source.color );\n\n\t\t\tthis.materialIndex = source.materialIndex;\n\n\t\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  shading: THREE.SmoothShading,\n\t *  depthTest: <bool>,\n\t *  depthWrite: <bool>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>\n\t * }\n\t */\n\n\tfunction MeshBasicMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // emissive\n\n\t\tthis.map = null;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshBasicMaterial.prototype = Object.create( Material.prototype );\n\tMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\n\n\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\n\tMeshBasicMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferAttribute( array, itemSize, normalized ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.array = array;\n\t\tthis.itemSize = itemSize;\n\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\tthis.normalized = normalized === true;\n\n\t\tthis.dynamic = false;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\n\t\tthis.version = 0;\n\n\t}\n\n\tBufferAttribute.prototype = {\n\n\t\tconstructor: BufferAttribute,\n\n\t\tisBufferAttribute: true,\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t},\n\n\t\tsetArray: function ( array ) {\n\n\t\t\tif ( Array.isArray( array ) ) {\n\n\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t\t}\n\n\t\t\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\n\t\t\tthis.array = array;\n\n\t\t},\n\n\t\tsetDynamic: function ( value ) {\n\n\t\t\tthis.dynamic = value;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\tthis.itemSize = source.itemSize;\n\t\t\tthis.count = source.count;\n\t\t\tthis.normalized = source.normalized;\n\n\t\t\tthis.dynamic = source.dynamic;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\t\tindex1 *= this.itemSize;\n\t\t\tindex2 *= attribute.itemSize;\n\n\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyArray: function ( array ) {\n\n\t\t\tthis.array.set( array );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyColorsArray: function ( colors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\t\tvar color = colors[ i ];\n\n\t\t\t\tif ( color === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\t\tcolor = new Color();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = color.r;\n\t\t\t\tarray[ offset ++ ] = color.g;\n\t\t\t\tarray[ offset ++ ] = color.b;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyIndicesArray: function ( indices ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tvar index = indices[ i ];\n\n\t\t\t\tarray[ offset ++ ] = index.a;\n\t\t\t\tarray[ offset ++ ] = index.b;\n\t\t\t\tarray[ offset ++ ] = index.c;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector2sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector2();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector3sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\tarray[ offset ++ ] = vector.z;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector4sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector4();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\t\tarray[ offset ++ ] = vector.w;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tset: function ( value, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.array.set( value, offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetX: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize ];\n\n\t\t},\n\n\t\tsetX: function ( index, x ) {\n\n\t\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetY: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 1 ];\n\n\t\t},\n\n\t\tsetY: function ( index, y ) {\n\n\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetZ: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 2 ];\n\n\t\t},\n\n\t\tsetZ: function ( index, z ) {\n\n\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetW: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 3 ];\n\n\t\t},\n\n\t\tsetW: function ( index, w ) {\n\n\t\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXY: function ( index, x, y ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZ: function ( index, x, y, z ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\t\tthis.array[ index + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\t\tthis.array[ index + 2 ] = z;\n\t\t\tthis.array[ index + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tfunction Int8Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Int8Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint8Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint8Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint8ClampedAttribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint8ClampedArray( array ), itemSize );\n\n\t}\n\n\tfunction Int16Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Int16Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint16Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint16Array( array ), itemSize );\n\n\t}\n\n\tfunction Int32Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Int32Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint32Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint32Array( array ), itemSize );\n\n\t}\n\n\tfunction Float32Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Float32Array( array ), itemSize );\n\n\t}\n\n\tfunction Float64Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Float64Array( array ), itemSize );\n\n\t}\n\n\t// Deprecated\n\n\tfunction DynamicBufferAttribute( array, itemSize ) {\n\n\t\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\t\treturn new BufferAttribute( array, itemSize ).setDynamic( true );\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author kile / http://kile.stravaganza.org/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Geometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Geometry';\n\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [ [] ];\n\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\tthis.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.elementsNeedUpdate = false;\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.lineDistancesNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tObject.assign( Geometry.prototype, EventDispatcher.prototype, {\n\n\t\tisGeometry: true,\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\t\tvar face = this.faces[ i ];\n\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tthis.computeBoundingSphere();\n\n\t\t\t}\n\n\t\t\tthis.verticesNeedUpdate = true;\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateX: function () {\n\n\t\t\t// rotate geometry around world x-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationX( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\t// rotate geometry around world y-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationY( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\t// rotate geometry around world z-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationZ( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function () {\n\n\t\t\t// translate geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function translate( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tscale: function () {\n\n\t\t\t// scale geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function scale( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeScale( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\tvar obj;\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tif ( obj === undefined ) obj = new Object3D();\n\n\t\t\t\tobj.lookAt( vector );\n\n\t\t\t\tobj.updateMatrix();\n\n\t\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tfromBufferGeometry: function ( geometry ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\t\tvar attributes = geometry.attributes;\n\n\t\t\tvar positions = attributes.position.array;\n\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n\t\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\t\tvar tempNormals = [];\n\t\t\tvar tempUVs = [];\n\t\t\tvar tempUVs2 = [];\n\n\t\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\t\tscope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\n\t\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\t\ttempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\tscope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\ttempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\t\ttempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\n\t\t\t\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\t\tscope.faces.push( face );\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( indices !== undefined ) {\n\n\t\t\t\tvar groups = geometry.groups;\n\n\t\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcenter: function () {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\t\treturn offset;\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t\tvar center = this.boundingSphere.center;\n\t\t\tvar radius = this.boundingSphere.radius;\n\n\t\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\t\tvar matrix = new Matrix4();\n\t\t\tmatrix.set(\n\t\t\t\ts, 0, 0, - s * center.x,\n\t\t\t\t0, s, 0, - s * center.y,\n\t\t\t\t0, 0, s, - s * center.z,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\n\t\t\tthis.applyMatrix( matrix );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tvar face = this.faces[ f ];\n\n\t\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tcb.normalize();\n\n\t\t\t\tface.normal.copy( cb );\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\t\tvar v, vl, f, fl, face, vertices;\n\n\t\t\tvertices = new Array( this.vertices.length );\n\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tvertices[ v ] = new Vector3();\n\n\t\t\t}\n\n\t\t\tif ( areaWeighted ) {\n\n\t\t\t\t// vertex normals weighted by triangle areas\n\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\t\tvar vA, vB, vC;\n\t\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.computeFaceNormals();\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tvertices[ v ].normalize();\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.faces.length > 0 ) {\n\n\t\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeFlatVertexNormals: function () {\n\n\t\t\tvar f, fl, face;\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.faces.length > 0 ) {\n\n\t\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeMorphNormals: function () {\n\n\t\t\tvar i, il, f, fl, face;\n\n\t\t\t// save original normals\n\t\t\t// - create temp variables on first access\n\t\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\t\tvar tmpGeo = new Geometry();\n\t\t\ttmpGeo.faces = this.faces;\n\n\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t\t// create on first access\n\n\t\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\tfaceNormal = new Vector3();\n\t\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\n\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t\t// set vertices to morph target\n\n\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t\t// compute morph normals\n\n\t\t\t\ttmpGeo.computeFaceNormals();\n\t\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t\t// store morph normals\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// restore original normals\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeTangents: function () {\n\n\t\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t\t},\n\n\t\tcomputeLineDistances: function () {\n\n\t\t\tvar d = 0;\n\t\t\tvar vertices = this.vertices;\n\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tif ( i > 0 ) {\n\n\t\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.lineDistances[ i ] = d;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeBoundingBox: function () {\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.boundingBox = new Box3();\n\n\t\t\t}\n\n\t\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t\t},\n\n\t\tcomputeBoundingSphere: function () {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t\t},\n\n\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\t\tif ( (geometry && geometry.isGeometry) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar normalMatrix,\n\t\t\tvertexOffset = this.vertices.length,\n\t\t\tvertices1 = this.vertices,\n\t\t\tvertices2 = geometry.vertices,\n\t\t\tfaces1 = this.faces,\n\t\t\tfaces2 = geometry.faces,\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ],\n\t\t\tcolors1 = this.colors,\n\t\t\tcolors2 = geometry.colors;\n\n\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\t\tif ( matrix !== undefined ) {\n\n\t\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\t}\n\n\t\t\t// vertices\n\n\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\t\tvertices1.push( vertexCopy );\n\n\t\t\t}\n\n\t\t\t// colors\n\n\t\t\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\n\n\t\t\t\tcolors1.push( colors2[ i ].clone() );\n\n\t\t\t}\n\n\t\t\t// faces\n\n\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\t\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\t\tfaces1.push( faceCopy );\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\t\tif ( uv === undefined ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t\tuvs1.push( uvCopy );\n\n\t\t\t}\n\n\t\t},\n\n\t\tmergeMesh: function ( mesh ) {\n\n\t\t\tif ( (mesh && mesh.isMesh) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\n\t\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t\t},\n\n\t\t/*\n\t\t * Checks for duplicate vertices with hashmap.\n\t\t * Duplicated vertices are removed\n\t\t * and faces' vertices are updated.\n\t\t */\n\n\t\tmergeVertices: function () {\n\n\t\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\t\tvar unique = [], changes = [];\n\n\t\t\tvar v, key;\n\t\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\t\tvar i, il, face;\n\t\t\tvar indices, j, jl;\n\n\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\t\tv = this.vertices[ i ];\n\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// if faces are completely degenerate after merging vertices, we\n\t\t\t// have to remove them from the geometry.\n\t\t\tvar faceIndicesToRemove = [];\n\n\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\t\tface = this.faces[ i ];\n\n\t\t\t\tface.a = changes[ face.a ];\n\t\t\t\tface.b = changes[ face.b ];\n\t\t\t\tface.c = changes[ face.c ];\n\n\t\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\t\tvar dupIndex = - 1;\n\n\t\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t\t// we have to remove the face as nothing can be saved\n\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\n\t\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\t\tdupIndex = n;\n\t\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Use unique set of vertices\n\n\t\t\tvar diff = this.vertices.length - unique.length;\n\t\t\tthis.vertices = unique;\n\t\t\treturn diff;\n\n\t\t},\n\n\t\tsortFacesByMaterialIndex: function () {\n\n\t\t\tvar faces = this.faces;\n\t\t\tvar length = faces.length;\n\n\t\t\t// tag faces\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tfaces[ i ]._id = i;\n\n\t\t\t}\n\n\t\t\t// sort faces\n\n\t\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t\t}\n\n\t\t\tfaces.sort( materialIndexSort );\n\n\t\t\t// sort uvs\n\n\t\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\t\tvar newUvs1, newUvs2;\n\n\t\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tvar id = faces[ i ]._id;\n\n\t\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t\t}\n\n\t\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Geometry',\n\t\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard Geometry serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( this.parameters !== undefined ) {\n\n\t\t\t\tvar parameters = this.parameters;\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tvar vertices = [];\n\n\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t\tvar faces = [];\n\t\t\tvar normals = [];\n\t\t\tvar normalsHash = {};\n\t\t\tvar colors = [];\n\t\t\tvar colorsHash = {};\n\t\t\tvar uvs = [];\n\t\t\tvar uvsHash = {};\n\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\t\tvar face = this.faces[ i ];\n\n\t\t\t\tvar hasMaterial = true;\n\t\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\t\tvar faceType = 0;\n\n\t\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\t\tfaces.push( faceType );\n\t\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\t\tfaces.push( face.materialIndex );\n\n\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t\t}\n\n\t\t\tfunction getNormalIndex( normal ) {\n\n\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tfunction getColorIndex( color ) {\n\n\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\t\tcolors.push( color.getHex() );\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tfunction getUvIndex( uv ) {\n\n\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\n\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tdata.data = {};\n\n\t\t\tdata.data.vertices = vertices;\n\t\t\tdata.data.normals = normals;\n\t\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\t\tdata.data.faces = faces;\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\t/*\n\t\t\t// Handle primitives\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tif ( parameters !== undefined ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\treturn new this.constructor().copy( this );\n\t\t\t*/\n\n\t\t\treturn new Geometry().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.vertices = [];\n\t\t\tthis.faces = [];\n\t\t\tthis.faceVertexUvs = [ [] ];\n\t\t\tthis.colors = [];\n\n\t\t\tvar vertices = source.vertices;\n\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tvar colors = source.colors;\n\n\t\t\tfor ( var i = 0, il = colors.length; i < il; i ++ ) {\n\n\t\t\t\tthis.colors.push( colors[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tvar faces = source.faces;\n\n\t\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tvar uv = uvs[ k ];\n\n\t\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\tvar count$3 = 0;\n\tfunction GeometryIdCount() { return count$3++; }\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction DirectGeometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'DirectGeometry';\n\n\t\tthis.indices = [];\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tthis.colors = [];\n\t\tthis.uvs = [];\n\t\tthis.uvs2 = [];\n\n\t\tthis.groups = [];\n\n\t\tthis.morphTargets = {};\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\t// this.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tObject.assign( DirectGeometry.prototype, EventDispatcher.prototype, {\n\n\t\tcomputeBoundingBox: Geometry.prototype.computeBoundingBox,\n\t\tcomputeBoundingSphere: Geometry.prototype.computeBoundingSphere,\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\n\n\t\t},\n\n\t\tcomputeVertexNormals: function () {\n\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\n\n\t\t},\n\n\t\tcomputeGroups: function ( geometry ) {\n\n\t\t\tvar group;\n\t\t\tvar groups = [];\n\t\t\tvar materialIndex;\n\n\t\t\tvar faces = geometry.faces;\n\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t// materials\n\n\t\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgroup = {\n\t\t\t\t\t\tstart: i * 3,\n\t\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( group !== undefined ) {\n\n\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\tgroups.push( group );\n\n\t\t\t}\n\n\t\t\tthis.groups = groups;\n\n\t\t},\n\n\t\tfromGeometry: function ( geometry ) {\n\n\t\t\tvar faces = geometry.faces;\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\n\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t\t// morphs\n\n\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\tvar morphTargetsLength = morphTargets.length;\n\n\t\t\tvar morphTargetsPosition;\n\n\t\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\t\tmorphTargetsPosition = [];\n\n\t\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\t\tmorphTargetsPosition[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t\t}\n\n\t\t\tvar morphNormals = geometry.morphNormals;\n\t\t\tvar morphNormalsLength = morphNormals.length;\n\n\t\t\tvar morphTargetsNormal;\n\n\t\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\t\tmorphTargetsNormal = [];\n\n\t\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\t\tmorphTargetsNormal[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tvar skinIndices = geometry.skinIndices;\n\t\t\tvar skinWeights = geometry.skinWeights;\n\n\t\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t\t//\n\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar normal = face.normal;\n\n\t\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t\t}\n\n\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar color = face.color;\n\n\t\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// morphs\n\n\t\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t\t}\n\n\t\t\t\t// skins\n\n\t\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.computeGroups( geometry );\n\n\t\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferGeometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\n\t\tthis.morphAttributes = {};\n\n\t\tthis.groups = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t}\n\n\tObject.assign( BufferGeometry.prototype, EventDispatcher.prototype, {\n\n\t\tisBufferGeometry: true,\n\n\t\tgetIndex: function () {\n\n\t\t\treturn this.index;\n\n\t\t},\n\n\t\tsetIndex: function ( index ) {\n\n\t\t\tthis.index = index;\n\n\t\t},\n\n\t\taddAttribute: function ( name, attribute ) {\n\n\t\t\tif ( (attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n\t\t\t\tthis.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( name === 'index' ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\t\tthis.setIndex( attribute );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.attributes[ name ] = attribute;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetAttribute: function ( name ) {\n\n\t\t\treturn this.attributes[ name ];\n\n\t\t},\n\n\t\tremoveAttribute: function ( name ) {\n\n\t\t\tdelete this.attributes[ name ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddGroup: function ( start, count, materialIndex ) {\n\n\t\t\tthis.groups.push( {\n\n\t\t\t\tstart: start,\n\t\t\t\tcount: count,\n\t\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t\t} );\n\n\t\t},\n\n\t\tclearGroups: function () {\n\n\t\t\tthis.groups = [];\n\n\t\t},\n\n\t\tsetDrawRange: function ( start, count ) {\n\n\t\t\tthis.drawRange.start = start;\n\t\t\tthis.drawRange.count = count;\n\n\t\t},\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tvar position = this.attributes.position;\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tmatrix.applyToVector3Array( position.array );\n\t\t\t\tposition.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tvar normal = this.attributes.normal;\n\n\t\t\tif ( normal !== undefined ) {\n\n\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\t\tnormalMatrix.applyToVector3Array( normal.array );\n\t\t\t\tnormal.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tthis.computeBoundingSphere();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateX: function () {\n\n\t\t\t// rotate geometry around world x-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationX( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\t// rotate geometry around world y-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationY( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\t// rotate geometry around world z-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationZ( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function () {\n\n\t\t\t// translate geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function translate( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tscale: function () {\n\n\t\t\t// scale geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function scale( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeScale( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\tvar obj;\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tif ( obj === undefined ) obj = new Object3D();\n\n\t\t\t\tobj.lookAt( vector );\n\n\t\t\t\tobj.updateMatrix();\n\n\t\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tcenter: function () {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\t\treturn offset;\n\n\t\t},\n\n\t\tsetFromObject: function ( object ) {\n\n\t\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( (object && object.isPoints) || (object && object.isLine) ) {\n\n\t\t\t\tvar positions = new Float32Attribute( geometry.vertices.length * 3, 3 );\n\t\t\t\tvar colors = new Float32Attribute( geometry.colors.length * 3, 3 );\n\n\t\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\t\tvar lineDistances = new Float32Attribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t\t}\n\n\t\t\t} else if ( (object && object.isMesh) ) {\n\n\t\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdateFromObject: function ( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( (object && object.isMesh) ) {\n\n\t\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\t\tif ( geometry.elementsNeedUpdate === true ) {\n\n\t\t\t\t\tdirect = undefined;\n\t\t\t\t\tgeometry.elementsNeedUpdate = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( direct === undefined ) {\n\n\t\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t\t}\n\n\t\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\t\tgeometry = direct;\n\n\t\t\t}\n\n\t\t\tvar attribute;\n\n\t\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.position;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.normal;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.color;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\t\tattribute = this.attributes.uv;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\t\tattribute = this.attributes.lineDistance;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\t\tthis.groups = geometry.groups;\n\n\t\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tfromGeometry: function ( geometry ) {\n\n\t\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\n\n\t\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t\t},\n\n\t\tfromDirectGeometry: function ( geometry ) {\n\n\t\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\t\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\t\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.indices.length > 0 ) {\n\n\t\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n\t\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\n\t\t\t}\n\n\t\t\t// groups\n\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\t// morphs\n\n\t\t\tfor ( var name in geometry.morphTargets ) {\n\n\t\t\t\tvar array = [];\n\t\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\n\t\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar morphTarget = morphTargets[ i ];\n\n\t\t\t\t\tvar attribute = new Float32Attribute( morphTarget.length * 3, 3 );\n\n\t\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t\t}\n\n\t\t\t// skinning\n\n\t\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\t\tvar skinIndices = new Float32Attribute( geometry.skinIndices.length * 4, 4 );\n\t\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\t\tvar skinWeights = new Float32Attribute( geometry.skinWeights.length * 4, 4 );\n\t\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcomputeBoundingBox: function () {\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.boundingBox = new Box3();\n\n\t\t\t}\n\n\t\t\tvar positions = this.attributes.position.array;\n\n\t\t\tif ( positions !== undefined ) {\n\n\t\t\t\tthis.boundingBox.setFromArray( positions );\n\n\t\t\t} else {\n\n\t\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t\t}\n\n\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeBoundingSphere: function () {\n\n\t\t\tvar box = new Box3();\n\t\t\tvar vector = new Vector3();\n\n\t\t\treturn function computeBoundingSphere() {\n\n\t\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t\t\t}\n\n\t\t\t\tvar positions = this.attributes.position;\n\n\t\t\t\tif ( positions ) {\n\n\t\t\t\t\tvar array = positions.array;\n\t\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\t\tbox.setFromArray( array );\n\t\t\t\t\tbox.getCenter( center );\n\n\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\t\t\t\tvector.fromArray( array, i );\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\t// backwards compatibility\n\n\t\t},\n\n\t\tcomputeVertexNormals: function () {\n\n\t\t\tvar index = this.index;\n\t\t\tvar attributes = this.attributes;\n\t\t\tvar groups = this.groups;\n\n\t\t\tif ( attributes.position ) {\n\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( attributes.normal === undefined ) {\n\n\t\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// reset existing normals to zero\n\n\t\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tarray[ i ] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar normals = attributes.normal.array;\n\n\t\t\t\tvar vA, vB, vC,\n\n\t\t\t\tpA = new Vector3(),\n\t\t\t\tpB = new Vector3(),\n\t\t\t\tpC = new Vector3(),\n\n\t\t\t\tcb = new Vector3(),\n\t\t\t\tab = new Vector3();\n\n\t\t\t\t// indexed elements\n\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\t\tthis.addGroup( 0, indices.length );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\n\t\t\t\t\t\tvar group = groups[ j ];\n\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\n\t\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\t\tpC.fromArray( positions, vC );\n\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\n\t\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\n\t\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.normalizeNormals();\n\n\t\t\t\tattributes.normal.needsUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tmerge: function ( geometry, offset ) {\n\n\t\t\tif ( (geometry && geometry.isBufferGeometry) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\t\tvar attribute1 = attributes[ key ];\n\t\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\t\tvar attributeSize = attribute2.itemSize;\n\n\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\n\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnormalizeNormals: function () {\n\n\t\t\tvar normals = this.attributes.normal.array;\n\n\t\t\tvar x, y, z, n;\n\n\t\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\n\t\t\t\tx = normals[ i ];\n\t\t\t\ty = normals[ i + 1 ];\n\t\t\t\tz = normals[ i + 2 ];\n\n\t\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\n\t\t\t\tnormals[ i ] *= n;\n\t\t\t\tnormals[ i + 1 ] *= n;\n\t\t\t\tnormals[ i + 2 ] *= n;\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoNonIndexed: function () {\n\n\t\t\tif ( this.index === null ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar geometry2 = new BufferGeometry();\n\n\t\t\tvar indices = this.index.array;\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ name ];\n\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\t\tvar index = 0, index2 = 0;\n\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\n\n\t\t\t}\n\n\t\t\treturn geometry2;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard BufferGeometry serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( this.parameters !== undefined ) {\n\n\t\t\t\tvar parameters = this.parameters;\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tdata.data = { attributes: {} };\n\n\t\t\tvar index = this.index;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tvar array = Array.prototype.slice.call( index.array );\n\n\t\t\t\tdata.data.index = {\n\t\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\t\tarray: array\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ key ];\n\n\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\n\t\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\t\tarray: array,\n\t\t\t\t\tnormalized: attribute.normalized\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar groups = this.groups;\n\n\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t\t}\n\n\t\t\tvar boundingSphere = this.boundingSphere;\n\n\t\t\tif ( boundingSphere !== null ) {\n\n\t\t\t\tdata.data.boundingSphere = {\n\t\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\t\tradius: boundingSphere.radius\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\t/*\n\t\t\t// Handle primitives\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tif ( parameters !== undefined ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\treturn new this.constructor().copy( this );\n\t\t\t*/\n\n\t\t\treturn new BufferGeometry().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tvar index = source.index;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tthis.setIndex( index.clone() );\n\n\t\t\t}\n\n\t\t\tvar attributes = source.attributes;\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ name ];\n\t\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t\t}\n\n\t\t\tvar groups = source.groups;\n\n\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\tvar group = groups[ i ];\n\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\tBufferGeometry.MaxIndex = 65535;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author jonobr1 / http://jonobr1.com/\n\t */\n\n\tfunction Mesh( geometry, material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Mesh';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\t\tthis.drawMode = TrianglesDrawMode;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Mesh,\n\n\t\tisMesh: true,\n\n\t\tsetDrawMode: function ( value ) {\n\n\t\t\tthis.drawMode = value;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.drawMode = source.drawMode;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdateMorphTargets: function () {\n\n\t\t\tvar morphTargets = this.geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ morphTargets[ m ].name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\tvar vA = new Vector3();\n\t\t\tvar vB = new Vector3();\n\t\t\tvar vC = new Vector3();\n\n\t\t\tvar tempA = new Vector3();\n\t\t\tvar tempB = new Vector3();\n\t\t\tvar tempC = new Vector3();\n\n\t\t\tvar uvA = new Vector2();\n\t\t\tvar uvB = new Vector2();\n\t\t\tvar uvC = new Vector2();\n\n\t\t\tvar barycoord = new Vector3();\n\n\t\t\tvar intersectionPoint = new Vector3();\n\t\t\tvar intersectionPointWorld = new Vector3();\n\n\t\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\n\t\t\t\tTriangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\n\t\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\t\tuv3.multiplyScalar( barycoord.z );\n\n\t\t\t\tuv1.add( uv2 ).add( uv3 );\n\n\t\t\t\treturn uv1.clone();\n\n\t\t\t}\n\n\t\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\n\t\t\t\tvar intersect;\n\t\t\t\tvar material = object.material;\n\n\t\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\n\t\t\t\t}\n\n\t\t\t\tif ( intersect === null ) return null;\n\n\t\t\t\tintersectionPointWorld.copy( point );\n\t\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\t\t\t\treturn {\n\t\t\t\t\tdistance: distance,\n\t\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\t\tobject: object\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\n\t\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\n\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );\n\t\t\t\t\tintersection.faceIndex = a;\n\n\t\t\t\t}\n\n\t\t\t\treturn intersection;\n\n\t\t\t}\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar material = this.material;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t\tif ( material === undefined ) return;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\t// Check boundingBox before continuing\n\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t\t\t}\n\n\t\t\t\tvar uvs, intersection;\n\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\tvar a, b, c;\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\n\t\t\t\t\t\tuvs = attributes.uv.array;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\ta = indices[ i ];\n\t\t\t\t\t\t\tb = indices[ i + 1 ];\n\t\t\t\t\t\t\tc = indices[ i + 2 ];\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\n\n\t\t\t\t\t\t\ta = i / 3;\n\t\t\t\t\t\t\tb = a + 1;\n\t\t\t\t\t\t\tc = a + 2;\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\t\tvar isFaceMaterial = (material && material.isMultiMaterial);\n\t\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\n\t\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\n\t\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\t\tfvC = vertices[ face.c ];\n\n\t\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\n\t\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\t\tvC.add( fvC );\n\n\t\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\t\tfvC = vC;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\n\t\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'BoxBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tvar scope = this;\n\n\t\t// segments\n\t\twidthSegments = Math.floor( widthSegments ) || 1;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\tdepthSegments = Math.floor( depthSegments ) || 1;\n\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\n\t\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\n\n\t\t// buffers\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t\t// offset variables\n\t\tvar vertexBufferOffset = 0;\n\t\tvar uvBufferOffset = 0;\n\t\tvar indexBufferOffset = 0;\n\t\tvar numberOfVertices = 0;\n\n\t\t// group variables\n\t\tvar groupStart = 0;\n\n\t\t// build each side of the box geometry\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t\t// helper functions\n\n\t\tfunction calculateVertexCount( w, h, d ) {\n\n\t\t\tvar vertices = 0;\n\n\t\t\t// calculate the amount of vertices for each side (plane)\n\t\t\tvertices += (w + 1) * (h + 1) * 2; // xy\n\t\t\tvertices += (w + 1) * (d + 1) * 2; // xz\n\t\t\tvertices += (d + 1) * (h + 1) * 2; // zy\n\n\t\t\treturn vertices;\n\n\t\t}\n\n\t\tfunction calculateIndexCount( w, h, d ) {\n\n\t\t\tvar index = 0;\n\n\t\t\t// calculate the amount of squares for each side\n\t\t\tindex += w * h * 2; // xy\n\t\t\tindex += w * d * 2; // xz\n\t\t\tindex += d * h * 2; // zy\n\n\t\t\treturn index * 6; // two triangles per square => six vertices per square\n\n\t\t}\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tvar segmentWidth\t= width / gridX;\n\t\t\tvar segmentHeight = height / gridY;\n\n\t\t\tvar widthHalf = width / 2;\n\t\t\tvar heightHalf = height / 2;\n\t\t\tvar depthHalf = depth / 2;\n\n\t\t\tvar gridX1 = gridX + 1;\n\t\t\tvar gridY1 = gridY + 1;\n\n\t\t\tvar vertexCounter = 0;\n\t\t\tvar groupCount = 0;\n\n\t\t\tvar vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tvar y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\t\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\t\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t\t// uvs\n\t\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\n\t\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\n\n\t\t\t\t\t// update offsets and counters\n\t\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\t\tuvBufferOffset += 2;\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// face one\n\t\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t\t\t// face two\n\t\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t\t\t// update offsets and counters\n\t\t\t\t\tindexBufferOffset += 6;\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n\tBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t */\n\n\tfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'PlaneBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tvar width_half = width / 2;\n\t\tvar height_half = height / 2;\n\n\t\tvar gridX = Math.floor( widthSegments ) || 1;\n\t\tvar gridY = Math.floor( heightSegments ) || 1;\n\n\t\tvar gridX1 = gridX + 1;\n\t\tvar gridY1 = gridY + 1;\n\n\t\tvar segment_width = width / gridX;\n\t\tvar segment_height = height / gridY;\n\n\t\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\n\t\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\n\t\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\n\n\t\tvar offset = 0;\n\t\tvar offset2 = 0;\n\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tvar y = iy * segment_height - height_half;\n\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar x = ix * segment_width - width_half;\n\n\t\t\t\tvertices[ offset ] = x;\n\t\t\t\tvertices[ offset + 1 ] = - y;\n\n\t\t\t\tnormals[ offset + 2 ] = 1;\n\n\t\t\t\tuvs[ offset2 ] = ix / gridX;\n\t\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\n\n\t\t\t\toffset += 3;\n\t\t\t\toffset2 += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\toffset = 0;\n\n\t\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\n\n\t\tfor ( var iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tvar a = ix + gridX1 * iy;\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tindices[ offset ] = a;\n\t\t\t\tindices[ offset + 1 ] = b;\n\t\t\t\tindices[ offset + 2 ] = d;\n\n\t\t\t\tindices[ offset + 3 ] = b;\n\t\t\t\tindices[ offset + 4 ] = c;\n\t\t\t\tindices[ offset + 5 ] = d;\n\n\t\t\t\toffset += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction Camera() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Camera';\n\n\t\tthis.matrixWorldInverse = new Matrix4();\n\t\tthis.projectionMatrix = new Matrix4();\n\n\t}\n\n\tCamera.prototype = Object.create( Object3D.prototype );\n\tCamera.prototype.constructor = Camera;\n\n\tCamera.prototype.isCamera = true;\n\n\tCamera.prototype.getWorldDirection = function () {\n\n\t\tvar quaternion = new Quaternion();\n\n\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t};\n\n\t}();\n\n\tCamera.prototype.lookAt = function () {\n\n\t\t// This routine does not support cameras with rotated and/or translated parent(s)\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tm1.lookAt( this.position, vector, this.up );\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t};\n\n\t}();\n\n\tCamera.prototype.clone = function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t};\n\n\tCamera.prototype.copy = function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author greggman / http://games.greggman.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author tschw\n\t */\n\n\tfunction PerspectiveCamera( fov, aspect, near, far ) {\n\n\t\tCamera.call( this );\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\tthis.fov = fov !== undefined ? fov : 50;\n\t\tthis.zoom = 1;\n\n\t\tthis.near = near !== undefined ? near : 0.1;\n\t\tthis.far = far !== undefined ? far : 2000;\n\t\tthis.focus = 10;\n\n\t\tthis.aspect = aspect !== undefined ? aspect : 1;\n\t\tthis.view = null;\n\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\t\tconstructor: PerspectiveCamera,\n\n\t\tisPerspectiveCamera: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tCamera.prototype.copy.call( this, source );\n\n\t\t\tthis.fov = source.fov;\n\t\t\tthis.zoom = source.zoom;\n\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\t\t\tthis.focus = source.focus;\n\n\t\t\tthis.aspect = source.aspect;\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\t\tthis.filmGauge = source.filmGauge;\n\t\t\tthis.filmOffset = source.filmOffset;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t/**\n\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t\t *\n\t\t * The default film gauge is 35, so that the focal length can be specified for\n\t\t * a 35mm (full frame) camera.\n\t\t *\n\t\t * Values for focal length and film gauge must have the same unit.\n\t\t */\n\t\tsetFocalLength: function ( focalLength ) {\n\n\t\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\t\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\t/**\n\t\t * Calculates the focal length from the current .fov and .filmGauge.\n\t\t */\n\t\tgetFocalLength: function () {\n\n\t\t\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\n\n\t\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t\t},\n\n\t\tgetEffectiveFOV: function () {\n\n\t\t\treturn _Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\t\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t\t},\n\n\t\tgetFilmWidth: function () {\n\n\t\t\t// film not completely covered in portrait format (aspect < 1)\n\t\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t\t},\n\n\t\tgetFilmHeight: function () {\n\n\t\t\t// film not completely covered in landscape format (aspect > 1)\n\t\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t\t},\n\n\t\t/**\n\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t\t * multi-monitor/multi-machine setups.\n\t\t *\n\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t\t * the monitors are in grid like this\n\t\t *\n\t\t *   +---+---+---+\n\t\t *   | A | B | C |\n\t\t *   +---+---+---+\n\t\t *   | D | E | F |\n\t\t *   +---+---+---+\n\t\t *\n\t\t * then for each monitor you would call it like this\n\t\t *\n\t\t *   var w = 1920;\n\t\t *   var h = 1080;\n\t\t *   var fullWidth = w * 3;\n\t\t *   var fullHeight = h * 2;\n\t\t *\n\t\t *   --A--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t\t *   --B--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t\t *   --C--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t\t *   --D--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t\t *   --E--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t\t *   --F--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t\t *\n\t\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t\t */\n\t\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\t\tthis.view = {\n\t\t\t\tfullWidth: fullWidth,\n\t\t\t\tfullHeight: fullHeight,\n\t\t\t\toffsetX: x,\n\t\t\t\toffsetY: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tclearViewOffset: function() {\n\n\t\t\tthis.view = null;\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tupdateProjectionMatrix: function () {\n\n\t\t\tvar near = this.near,\n\t\t\t\ttop = near * Math.tan(\n\t\t\t\t\t\t_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\t\theight = 2 * top,\n\t\t\t\twidth = this.aspect * height,\n\t\t\t\tleft = - 0.5 * width,\n\t\t\t\tview = this.view;\n\n\t\t\tif ( view !== null ) {\n\n\t\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\t\twidth *= view.width / fullWidth;\n\t\t\t\theight *= view.height / fullHeight;\n\n\t\t\t}\n\n\t\t\tvar skew = this.filmOffset;\n\t\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\t\tthis.projectionMatrix.makeFrustum(\n\t\t\t\t\tleft, left + width, top - height, top, near, this.far );\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.fov = this.fov;\n\t\t\tdata.object.zoom = this.zoom;\n\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\t\t\tdata.object.focus = this.focus;\n\n\t\t\tdata.object.aspect = this.aspect;\n\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\t\tdata.object.filmGauge = this.filmGauge;\n\t\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author arose / http://github.com/arose\n\t */\n\n\tfunction OrthographicCamera( left, right, top, bottom, near, far ) {\n\n\t\tCamera.call( this );\n\n\t\tthis.type = 'OrthographicCamera';\n\n\t\tthis.zoom = 1;\n\t\tthis.view = null;\n\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.top = top;\n\t\tthis.bottom = bottom;\n\n\t\tthis.near = ( near !== undefined ) ? near : 0.1;\n\t\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\t\tconstructor: OrthographicCamera,\n\n\t\tisOrthographicCamera: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tCamera.prototype.copy.call( this, source );\n\n\t\t\tthis.left = source.left;\n\t\t\tthis.right = source.right;\n\t\t\tthis.top = source.top;\n\t\t\tthis.bottom = source.bottom;\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\n\t\t\tthis.zoom = source.zoom;\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\t\tthis.view = {\n\t\t\t\tfullWidth: fullWidth,\n\t\t\t\tfullHeight: fullHeight,\n\t\t\t\toffsetX: x,\n\t\t\t\toffsetY: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tclearViewOffset: function() {\n\n\t\t\tthis.view = null;\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tupdateProjectionMatrix: function () {\n\n\t\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\t\tvar cx = ( this.right + this.left ) / 2;\n\t\t\tvar cy = ( this.top + this.bottom ) / 2;\n\n\t\t\tvar left = cx - dx;\n\t\t\tvar right = cx + dx;\n\t\t\tvar top = cy + dy;\n\t\t\tvar bottom = cy - dy;\n\n\t\t\tif ( this.view !== null ) {\n\n\t\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\n\t\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\n\t\t\t}\n\n\t\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.zoom = this.zoom;\n\t\t\tdata.object.left = this.left;\n\t\t\tdata.object.right = this.right;\n\t\t\tdata.object.top = this.top;\n\t\t\tdata.object.bottom = this.bottom;\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {\n\n\t\tvar mode;\n\n\t\tfunction setMode( value ) {\n\n\t\t\tmode = value;\n\n\t\t}\n\n\t\tvar type, size;\n\n\t\tfunction setIndex( index ) {\n\n\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\t\t\ttype = gl.UNSIGNED_INT;\n\t\t\t\tsize = 4;\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\t\t\t\tsize = 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction render( start, count ) {\n\n\t\t\tgl.drawElements( mode, count, type, start * size );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\n\t\t}\n\n\t\tfunction renderInstances( geometry, start, count ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tsetMode: setMode,\n\t\t\tsetIndex: setIndex,\n\t\t\trender: render,\n\t\t\trenderInstances: renderInstances\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLBufferRenderer( gl, extensions, infoRender ) {\n\n\t\tvar mode;\n\n\t\tfunction setMode( value ) {\n\n\t\t\tmode = value;\n\n\t\t}\n\n\t\tfunction render( start, count ) {\n\n\t\t\tgl.drawArrays( mode, start, count );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\n\t\t}\n\n\t\tfunction renderInstances( geometry ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar position = geometry.attributes.position;\n\n\t\t\tvar count = 0;\n\n\t\t\tif ( (position && position.isInterleavedBufferAttribute) ) {\n\n\t\t\t\tcount = position.data.count;\n\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t\t} else {\n\n\t\t\t\tcount = position.count;\n\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t\t}\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n\t\t}\n\n\t\treturn {\n\t\t\tsetMode: setMode,\n\t\t\trender: render,\n\t\t\trenderInstances: renderInstances\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLLights() {\n\n\t\tvar lights = {};\n\n\t\treturn {\n\n\t\t\tget: function ( light ) {\n\n\t\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\t\treturn lights[ light.id ];\n\n\t\t\t\t}\n\n\t\t\t\tvar uniforms;\n\n\t\t\t\tswitch ( light.type ) {\n\n\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\t\treturn uniforms;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction addLineNumbers( string ) {\n\n\t\tvar lines = string.split( '\\n' );\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n\t\t}\n\n\t\treturn lines.join( '\\n' );\n\n\t}\n\n\tfunction WebGLShader( gl, type, string ) {\n\n\t\tvar shader = gl.createShader( type );\n\n\t\tgl.shaderSource( shader, string );\n\t\tgl.compileShader( shader );\n\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\n\t\t}\n\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\n\t\t}\n\n\t\t// --enable-privileged-webgl-extension\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\treturn shader;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar programIdCount = 0;\n\n\tfunction getEncodingComponents( encoding ) {\n\n\t\tswitch ( encoding ) {\n\n\t\t\tcase LinearEncoding:\n\t\t\t\treturn [ 'Linear','( value )' ];\n\t\t\tcase sRGBEncoding:\n\t\t\t\treturn [ 'sRGB','( value )' ];\n\t\t\tcase RGBEEncoding:\n\t\t\t\treturn [ 'RGBE','( value )' ];\n\t\t\tcase RGBM7Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\n\t\t\tcase RGBM16Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\n\t\t\tcase RGBDEncoding:\n\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\n\t\t\tcase GammaEncoding:\n\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\n\t\t}\n\n\t}\n\n\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\t\tvar toneMappingName;\n\n\t\tswitch ( toneMapping ) {\n\n\t\t\tcase LinearToneMapping:\n\t\t\t\ttoneMappingName = \"Linear\";\n\t\t\t\tbreak;\n\n\t\t\tcase ReinhardToneMapping:\n\t\t\t\ttoneMappingName = \"Reinhard\";\n\t\t\t\tbreak;\n\n\t\t\tcase Uncharted2ToneMapping:\n\t\t\t\ttoneMappingName = \"Uncharted2\";\n\t\t\t\tbreak;\n\n\t\t\tcase CineonToneMapping:\n\t\t\t\ttoneMappingName = \"OptimizedCineon\";\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\n\t\t}\n\n\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\n\t}\n\n\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\n\t\textensions = extensions || {};\n\n\t\tvar chunks = [\n\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\n\t\t];\n\n\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tfunction generateDefines( defines ) {\n\n\t\tvar chunks = [];\n\n\t\tfor ( var name in defines ) {\n\n\t\t\tvar value = defines[ name ];\n\n\t\t\tif ( value === false ) continue;\n\n\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t\t}\n\n\t\treturn chunks.join( '\\n' );\n\n\t}\n\n\tfunction fetchAttributeLocations( gl, program, identifiers ) {\n\n\t\tvar attributes = {};\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n\t\tfor ( var i = 0; i < n; i ++ ) {\n\n\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\tvar name = info.name;\n\n\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\n\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\n\t\t}\n\n\t\treturn attributes;\n\n\t}\n\n\tfunction filterEmptyLine( string ) {\n\n\t\treturn string !== '';\n\n\t}\n\n\tfunction replaceLightNums( string, parameters ) {\n\n\t\treturn string\n\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\n\t}\n\n\tfunction parseIncludes( string ) {\n\n\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\n\n\t\tfunction replace( match, include ) {\n\n\t\t\tvar replace = ShaderChunk[ include ];\n\n\t\t\tif ( replace === undefined ) {\n\n\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t\t}\n\n\t\t\treturn parseIncludes( replace );\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction unrollLoops( string ) {\n\n\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\n\t\tfunction replace( match, start, end, snippet ) {\n\n\t\t\tvar unroll = '';\n\n\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\n\t\t\t}\n\n\t\t\treturn unroll;\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction WebGLProgram( renderer, code, material, parameters ) {\n\n\t\tvar gl = renderer.context;\n\n\t\tvar extensions = material.extensions;\n\t\tvar defines = material.defines;\n\n\t\tvar vertexShader = material.__webglShader.vertexShader;\n\t\tvar fragmentShader = material.__webglShader.fragmentShader;\n\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\t\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t\t}\n\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\n\t\tif ( parameters.envMap ) {\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase CubeReflectionMapping:\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CubeUVReflectionMapping:\n\t\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EquirectangularReflectionMapping:\n\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SphericalReflectionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MixOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AddOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n\t\t// console.log( 'building new program ' );\n\n\t\t//\n\n\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\n\t\tvar customDefines = generateDefines( defines );\n\n\t\t//\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar prefixVertex, prefixFragment;\n\n\t\tif ( material.isRawShaderMaterial ) {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\t\t\t\tcustomDefines,\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t} else {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t'attribute vec3 position;',\n\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'#ifdef USE_COLOR',\n\n\t\t\t\t'\tattribute vec3 color;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\n\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t\t'\t#else',\n\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t\t'\t#endif',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\t\t\t\t'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\n\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\n\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\n\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t}\n\n\t\tvertexShader = parseIncludes( vertexShader, parameters );\n\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\n\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\n\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\n\t\tif ( ! material.isShaderMaterial ) {\n\n\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\n\t\t}\n\n\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\n\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\t\tvar glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\tvar glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n\t\tgl.attachShader( program, glVertexShader );\n\t\tgl.attachShader( program, glFragmentShader );\n\n\t\t// Force a particular attribute to index 0.\n\n\t\tif ( material.index0AttributeName !== undefined ) {\n\n\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\n\t\t} else if ( parameters.morphTargets === true ) {\n\n\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t\t}\n\n\t\tgl.linkProgram( program );\n\n\t\tvar programLog = gl.getProgramInfoLog( program );\n\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\n\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\n\t\tvar runnable = true;\n\t\tvar haveDiagnostics = true;\n\n\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\n\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n\t\t\trunnable = false;\n\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\n\t\t} else if ( programLog !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\thaveDiagnostics = false;\n\n\t\t}\n\n\t\tif ( haveDiagnostics ) {\n\n\t\t\tthis.diagnostics = {\n\n\t\t\t\trunnable: runnable,\n\t\t\t\tmaterial: material,\n\n\t\t\t\tprogramLog: programLog,\n\n\t\t\t\tvertexShader: {\n\n\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t},\n\n\t\t\t\tfragmentShader: {\n\n\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t// clean up\n\n\t\tgl.deleteShader( glVertexShader );\n\t\tgl.deleteShader( glFragmentShader );\n\n\t\t// set up caching for uniform locations\n\n\t\tvar cachedUniforms;\n\n\t\tthis.getUniforms = function() {\n\n\t\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\t\tcachedUniforms =\n\t\t\t\t\t\tnew WebGLUniforms( gl, program, renderer );\n\n\t\t\t}\n\n\t\t\treturn cachedUniforms;\n\n\t\t};\n\n\t\t// set up caching for attribute locations\n\n\t\tvar cachedAttributes;\n\n\t\tthis.getAttributes = function() {\n\n\t\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t\t}\n\n\t\t\treturn cachedAttributes;\n\n\t\t};\n\n\t\t// free resource\n\n\t\tthis.destroy = function() {\n\n\t\t\tgl.deleteProgram( program );\n\t\t\tthis.program = undefined;\n\n\t\t};\n\n\t\t// DEPRECATED\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tuniforms: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\treturn this.getUniforms();\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tattributes: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\treturn this.getAttributes();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\n\t\t//\n\n\t\tthis.id = programIdCount ++;\n\t\tthis.code = code;\n\t\tthis.usedTimes = 1;\n\t\tthis.program = program;\n\t\tthis.vertexShader = glVertexShader;\n\t\tthis.fragmentShader = glFragmentShader;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLPrograms( renderer, capabilities ) {\n\n\t\tvar programs = [];\n\n\t\tvar shaderIDs = {\n\t\t\tMeshDepthMaterial: 'depth',\n\t\t\tMeshNormalMaterial: 'normal',\n\t\t\tMeshBasicMaterial: 'basic',\n\t\t\tMeshLambertMaterial: 'lambert',\n\t\t\tMeshPhongMaterial: 'phong',\n\t\t\tMeshStandardMaterial: 'physical',\n\t\t\tMeshPhysicalMaterial: 'physical',\n\t\t\tLineBasicMaterial: 'basic',\n\t\t\tLineDashedMaterial: 'dashed',\n\t\t\tPointsMaterial: 'points'\n\t\t};\n\n\t\tvar parameterNames = [\n\t\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\t\"roughnessMap\", \"metalnessMap\",\n\t\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\n\t\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"numClipIntersection\", \"depthPacking\"\n\t\t];\n\n\n\t\tfunction allocateBones( object ) {\n\n\t\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\n\t\t\t\treturn 1024;\n\n\t\t\t} else {\n\n\t\t\t\t// default for when object is not specified\n\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t\t//\n\t\t\t\t//  - leave some extra space for other uniforms\n\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t\t//    (up to 54 should be safe)\n\n\t\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\t\tvar maxBones = nVertexMatrices;\n\n\t\t\t\tif ( object !== undefined && (object && object.isSkinnedMesh) ) {\n\n\t\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\n\n\t\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\n\n\t\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn maxBones;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\n\t\t\tvar encoding;\n\n\t\t\tif ( ! map ) {\n\n\t\t\t\tencoding = LinearEncoding;\n\n\t\t\t} else if ( (map && map.isTexture) ) {\n\n\t\t\t\tencoding = map.encoding;\n\n\t\t\t} else if ( (map && map.isWebGLRenderTarget) ) {\n\n\t\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\tencoding = map.texture.encoding;\n\n\t\t\t}\n\n\t\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\t\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\n\n\t\t\t\tencoding = GammaEncoding;\n\n\t\t\t}\n\n\t\t\treturn encoding;\n\n\t\t}\n\n\t\tthis.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {\n\n\t\t\tvar shaderID = shaderIDs[ material.type ];\n\n\t\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t\t// (not to blow over maxLights budget)\n\n\t\t\tvar maxBones = allocateBones( object );\n\t\t\tvar precision = renderer.getPrecision();\n\n\t\t\tif ( material.precision !== null ) {\n\n\t\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\n\n\t\t\tvar parameters = {\n\n\t\t\t\tshaderID: shaderID,\n\n\t\t\t\tprecision: precision,\n\t\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\t\tmap: !! material.map,\n\t\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\t\tenvMap: !! material.envMap,\n\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\n\t\t\t\tlightMap: !! material.lightMap,\n\t\t\t\taoMap: !! material.aoMap,\n\t\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\t\tbumpMap: !! material.bumpMap,\n\t\t\t\tnormalMap: !! material.normalMap,\n\t\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\t\tspecularMap: !! material.specularMap,\n\t\t\t\talphaMap: !! material.alphaMap,\n\n\t\t\t\tcombine: material.combine,\n\n\t\t\t\tvertexColors: material.vertexColors,\n\n\t\t\t\tfog: !! fog,\n\t\t\t\tuseFog: material.fog,\n\t\t\t\tfogExp: (fog && fog.isFogExp2),\n\n\t\t\t\tflatShading: material.shading === FlatShading,\n\n\t\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\n\t\t\t\tskinning: material.skinning,\n\t\t\t\tmaxBones: maxBones,\n\t\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\n\t\t\t\tmorphTargets: material.morphTargets,\n\t\t\t\tmorphNormals: material.morphNormals,\n\t\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\n\t\t\t\tnumDirLights: lights.directional.length,\n\t\t\t\tnumPointLights: lights.point.length,\n\t\t\t\tnumSpotLights: lights.spot.length,\n\t\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\t\tnumClippingPlanes: nClipPlanes,\n\t\t\t\tnumClipIntersection: nClipIntersection,\n\n\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n\t\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\n\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\t\talphaTest: material.alphaTest,\n\t\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\t\tflipSided: material.side === BackSide,\n\n\t\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\n\t\t\t};\n\n\t\t\treturn parameters;\n\n\t\t};\n\n\t\tthis.getProgramCode = function ( material, parameters ) {\n\n\t\t\tvar array = [];\n\n\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\tarray.push( parameters.shaderID );\n\n\t\t\t} else {\n\n\t\t\t\tarray.push( material.fragmentShader );\n\t\t\t\tarray.push( material.vertexShader );\n\n\t\t\t}\n\n\t\t\tif ( material.defines !== undefined ) {\n\n\t\t\t\tfor ( var name in material.defines ) {\n\n\t\t\t\t\tarray.push( name );\n\t\t\t\t\tarray.push( material.defines[ name ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\n\t\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\n\t\t\t}\n\n\t\t\treturn array.join();\n\n\t\t};\n\n\t\tthis.acquireProgram = function ( material, parameters, code ) {\n\n\t\t\tvar program;\n\n\t\t\t// Check if code has been already compiled\n\t\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\t\tvar programInfo = programs[ p ];\n\n\t\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\t\tprogram = programInfo;\n\t\t\t\t\t++ program.usedTimes;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tprogram = new WebGLProgram( renderer, code, material, parameters );\n\t\t\t\tprograms.push( program );\n\n\t\t\t}\n\n\t\t\treturn program;\n\n\t\t};\n\n\t\tthis.releaseProgram = function( program ) {\n\n\t\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t\t// Remove from unordered set\n\t\t\t\tvar i = programs.indexOf( program );\n\t\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\t\tprograms.pop();\n\n\t\t\t\t// Free WebGL resources\n\t\t\t\tprogram.destroy();\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\tthis.programs = programs;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLGeometries( gl, properties, info ) {\n\n\t\tvar geometries = {};\n\n\t\tfunction onGeometryDispose( event ) {\n\n\t\t\tvar geometry = event.target;\n\t\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\t\tif ( buffergeometry.index !== null ) {\n\n\t\t\t\tdeleteAttribute( buffergeometry.index );\n\n\t\t\t}\n\n\t\t\tdeleteAttributes( buffergeometry.attributes );\n\n\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\t\tdelete geometries[ geometry.id ];\n\n\t\t\t// TODO\n\n\t\t\tvar property = properties.get( geometry );\n\n\t\t\tif ( property.wireframe ) {\n\n\t\t\t\tdeleteAttribute( property.wireframe );\n\n\t\t\t}\n\n\t\t\tproperties.delete( geometry );\n\n\t\t\tvar bufferproperty = properties.get( buffergeometry );\n\n\t\t\tif ( bufferproperty.wireframe ) {\n\n\t\t\t\tdeleteAttribute( bufferproperty.wireframe );\n\n\t\t\t}\n\n\t\t\tproperties.delete( buffergeometry );\n\n\t\t\t//\n\n\t\t\tinfo.memory.geometries --;\n\n\t\t}\n\n\t\tfunction getAttributeBuffer( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t\t}\n\n\t\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t\t}\n\n\t\tfunction deleteAttribute( attribute ) {\n\n\t\t\tvar buffer = getAttributeBuffer( attribute );\n\n\t\t\tif ( buffer !== undefined ) {\n\n\t\t\t\tgl.deleteBuffer( buffer );\n\t\t\t\tremoveAttributeBuffer( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction deleteAttributes( attributes ) {\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tdeleteAttribute( attributes[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeAttributeBuffer( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tproperties.delete( attribute.data );\n\n\t\t\t} else {\n\n\t\t\t\tproperties.delete( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tget: function ( object ) {\n\n\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\tif ( geometries[ geometry.id ] !== undefined ) {\n\n\t\t\t\t\treturn geometries[ geometry.id ];\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\t\t\tvar buffergeometry;\n\n\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\tbuffergeometry = geometry;\n\n\t\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\n\t\t\t\t\t\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbuffergeometry = geometry._bufferGeometry;\n\n\t\t\t\t}\n\n\t\t\t\tgeometries[ geometry.id ] = buffergeometry;\n\n\t\t\t\tinfo.memory.geometries ++;\n\n\t\t\t\treturn buffergeometry;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLObjects( gl, properties, info ) {\n\n\t\tvar geometries = new WebGLGeometries( gl, properties, info );\n\n\t\t//\n\n\t\tfunction update( object ) {\n\n\t\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\n\t\t\tvar geometry = geometries.get( object );\n\n\t\t\tif ( object.geometry.isGeometry ) {\n\n\t\t\t\tgeometry.updateFromObject( object );\n\n\t\t\t}\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t\t// morph targets\n\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\tfor ( var name in morphAttributes ) {\n\n\t\t\t\tvar array = morphAttributes[ name ];\n\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction updateAttribute( attribute, bufferType ) {\n\n\t\t\tvar data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;\n\n\t\t\tvar attributeProperties = properties.get( data );\n\n\t\t\tif ( attributeProperties.__webglBuffer === undefined ) {\n\n\t\t\t\tcreateBuffer( attributeProperties, data, bufferType );\n\n\t\t\t} else if ( attributeProperties.version !== data.version ) {\n\n\t\t\t\tupdateBuffer( attributeProperties, data, bufferType );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createBuffer( attributeProperties, data, bufferType ) {\n\n\t\t\tattributeProperties.__webglBuffer = gl.createBuffer();\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\n\t\t\tgl.bufferData( bufferType, data.array, usage );\n\n\t\t\tattributeProperties.version = data.version;\n\n\t\t}\n\n\t\tfunction updateBuffer( attributeProperties, data, bufferType ) {\n\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\t\tif ( data.dynamic === false ) {\n\n\t\t\t\tgl.bufferData( bufferType, data.array, gl.STATIC_DRAW );\n\n\t\t\t} else if ( data.updateRange.count === - 1 ) {\n\n\t\t\t\t// Not using update ranges\n\n\t\t\t\tgl.bufferSubData( bufferType, 0, data.array );\n\n\t\t\t} else if ( data.updateRange.count === 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\n\t\t\t} else {\n\n\t\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\n\t\t\t\tdata.updateRange.count = 0; // reset range\n\n\t\t\t}\n\n\t\t\tattributeProperties.version = data.version;\n\n\t\t}\n\n\t\tfunction getAttributeBuffer( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t\t}\n\n\t\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t\t}\n\n\t\tfunction getWireframeAttribute( geometry ) {\n\n\t\t\tvar property = properties.get( geometry );\n\n\t\t\tif ( property.wireframe !== undefined ) {\n\n\t\t\t\treturn property.wireframe;\n\n\t\t\t}\n\n\t\t\tvar indices = [];\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\t\t\tvar position = attributes.position;\n\n\t\t\t// console.time( 'wireframe' );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tvar edges = {};\n\t\t\t\tvar array = index.array;\n\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\t\tvar c = array[ i + 2 ];\n\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar array = attributes.position.array;\n\n\t\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = i + 0;\n\t\t\t\t\tvar b = i + 1;\n\t\t\t\t\tvar c = i + 2;\n\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// console.timeEnd( 'wireframe' );\n\n\t\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n\t\t\tvar attribute = new BufferAttribute( new TypeArray( indices ), 1 );\n\n\t\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t\tproperty.wireframe = attribute;\n\n\t\t\treturn attribute;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tgetAttributeBuffer: getAttributeBuffer,\n\t\t\tgetWireframeAttribute: getWireframeAttribute,\n\n\t\t\tupdate: update\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\n\t\tvar _infoMemory = info.memory;\n\t\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\n\t\t//\n\n\t\tfunction clampToMaxSize( image, maxSize ) {\n\n\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t\t// premultiplied alpha.\n\n\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\t\tcanvas.height = Math.floor( image.height * scale );\n\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\t\treturn canvas;\n\n\t\t\t}\n\n\t\t\treturn image;\n\n\t\t}\n\n\t\tfunction isPowerOfTwo( image ) {\n\n\t\t\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\n\n\t\t}\n\n\t\tfunction makePowerOfTwo( image ) {\n\n\t\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = _Math.nearestPowerOfTwo( image.width );\n\t\t\t\tcanvas.height = _Math.nearestPowerOfTwo( image.height );\n\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\t\treturn canvas;\n\n\t\t\t}\n\n\t\t\treturn image;\n\n\t\t}\n\n\t\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) return true;\n\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// Fallback filters for non-power-of-2 textures\n\n\t\tfunction filterFallback( f ) {\n\n\t\t\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\n\n\t\t\t\treturn _gl.NEAREST;\n\n\t\t\t}\n\n\t\t\treturn _gl.LINEAR;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction onTextureDispose( event ) {\n\n\t\t\tvar texture = event.target;\n\n\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\t\tdeallocateTexture( texture );\n\n\t\t\t_infoMemory.textures --;\n\n\n\t\t}\n\n\t\tfunction onRenderTargetDispose( event ) {\n\n\t\t\tvar renderTarget = event.target;\n\n\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\t\tdeallocateRenderTarget( renderTarget );\n\n\t\t\t_infoMemory.textures --;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction deallocateTexture( texture ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t// cube texture\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\n\t\t\t} else {\n\n\t\t\t\t// 2D texture\n\n\t\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t\t}\n\n\t\t\t// remove all webgl properties\n\t\t\tproperties.delete( texture );\n\n\t\t}\n\n\t\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\t\tif ( ! renderTarget ) return;\n\n\t\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t\t}\n\n\t\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t\t}\n\n\t\t\tif ( (renderTarget && renderTarget.isWebGLRenderTargetCube) ) {\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\n\t\t\t}\n\n\t\t\tproperties.delete( renderTarget.texture );\n\t\t\tproperties.delete( renderTarget );\n\n\t\t}\n\n\t\t//\n\n\n\n\t\tfunction setTexture2D( texture, slot ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\tvar image = texture.image;\n\n\t\t\t\tif ( image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\n\t\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t}\n\n\t\tfunction setTextureCube( texture, slot ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.image.length === 6 ) {\n\n\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t\t\t_infoMemory.textures ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n\t\t\t\t\tvar isCompressed = (texture && texture.isCompressedTexture);\n\t\t\t\t\tvar isDataTexture = (texture.image[ 0 ] && texture.image[ 0 ].isDataTexture);\n\n\t\t\t\t\tvar cubeImage = [];\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\n\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setTextureCubeDynamic( texture, slot ) {\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\n\t\t}\n\n\t\tfunction setTextureParameters( textureType, texture, isPowerOfTwoImage ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( isPowerOfTwoImage ) {\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\n\t\t\t\t}\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tif ( extension ) {\n\n\t\t\t\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\t\tif ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\n\t\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t\t_infoMemory.textures ++;\n\n\t\t\t}\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\n\t\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\n\t\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\n\t\t\t\timage = makePowerOfTwo( image );\n\n\t\t\t}\n\n\t\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\t\tif ( (texture && texture.isDepthTexture) ) {\n\n\t\t\t\t// populate depth texture with dummy data\n\n\t\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\n\t\t\t\tif ( texture.type === FloatType ) {\n\n\t\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t\t} else if ( _isWebGL2 ) {\n\n\t\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t\t}\n\n\t\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\tif ( texture.format === DepthStencilFormat ) {\n\n\t\t\t\t\tinternalFormat = _gl.DEPTH_STENCIL;\n\n\t\t\t\t}\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t\t} else if ( (texture && texture.isDataTexture) ) {\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( (texture && texture.isCompressedTexture) ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t}\n\n\t\t// Render targets\n\n\t\t// Setup storage for target texture and bind it to correct framebuffer\n\t\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\n\n\t\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\n\t\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\n\t\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t}\n\n\t\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\t\tfunction setupRenderBufferStorage( renderbuffer, renderTarget ) {\n\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t} else {\n\n\t\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t\t}\n\n\t\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\t\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\n\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\tif ( !( (renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture) ) ) {\n\n\t\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\n\t\t\t}\n\n\t\t\t// upload an empty depth texture with framebuffer size\n\t\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t\t}\n\n\t\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\n\t\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error('Unknown depthTexture format')\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Setup GL resources for a non-texture depth buffer\n\t\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\n\t\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\n\t\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t\t} else {\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t}\n\n\t\t// Set up GL resources for the render target\n\t\tfunction setupRenderTarget( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t_infoMemory.textures ++;\n\n\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\n\t\t\t// Setup framebuffer\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t\t// Setup color buffer\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t\t} else {\n\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t\t}\n\n\t\t\t// Setup depth and stencil buffers\n\n\t\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\t\tvar texture = renderTarget.texture;\n\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n\t\t\t\t\ttexture.minFilter !== NearestFilter &&\n\t\t\t\t\ttexture.minFilter !== LinearFilter ) {\n\n\t\t\t\tvar target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t\t_gl.generateMipmap( target );\n\t\t\t\tstate.bindTexture( target, null );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setTexture2D = setTexture2D;\n\t\tthis.setTextureCube = setTextureCube;\n\t\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\t\tthis.setupRenderTarget = setupRenderTarget;\n\t\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\n\t}\n\n\t/**\n\t * @author fordacious / fordacious.github.io\n\t */\n\n\tfunction WebGLProperties() {\n\n\t\tvar properties = {};\n\n\t\treturn {\n\n\t\t\tget: function ( object ) {\n\n\t\t\t\tvar uuid = object.uuid;\n\t\t\t\tvar map = properties[ uuid ];\n\n\t\t\t\tif ( map === undefined ) {\n\n\t\t\t\t\tmap = {};\n\t\t\t\t\tproperties[ uuid ] = map;\n\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\n\t\t\t},\n\n\t\t\tdelete: function ( object ) {\n\n\t\t\t\tdelete properties[ object.uuid ];\n\n\t\t\t},\n\n\t\t\tclear: function () {\n\n\t\t\t\tproperties = {};\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLState( gl, extensions, paramThreeToGL ) {\n\n\t\tfunction ColorBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar color = new Vector4();\n\t\t\tvar currentColorMask = null;\n\t\t\tvar currentColorClear = new Vector4();\n\n\t\t\treturn {\n\n\t\t\t\tsetMask: function ( colorMask ) {\n\n\t\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\t\tcurrentColorMask = colorMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( r, g, b, a ) {\n\n\t\t\t\t\tcolor.set( r, g, b, a );\n\n\t\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\t\tcurrentColorClear.copy( color );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentColorMask = null;\n\t\t\t\t\tcurrentColorClear.set( 0, 0, 0, 1 );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction DepthBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar currentDepthMask = null;\n\t\t\tvar currentDepthFunc = null;\n\t\t\tvar currentDepthClear = null;\n\n\t\t\treturn {\n\n\t\t\t\tsetTest: function ( depthTest ) {\n\n\t\t\t\t\tif ( depthTest ) {\n\n\t\t\t\t\t\tenable( gl.DEPTH_TEST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( gl.DEPTH_TEST );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetMask: function ( depthMask ) {\n\n\t\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\t\tcurrentDepthMask = depthMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetFunc: function ( depthFunc ) {\n\n\t\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\t\t\t\tif ( depthFunc ) {\n\n\t\t\t\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( depth ) {\n\n\t\t\t\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\t\tcurrentDepthClear = depth;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentDepthMask = null;\n\t\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\t\tcurrentDepthClear = null;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction StencilBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar currentStencilMask = null;\n\t\t\tvar currentStencilFunc = null;\n\t\t\tvar currentStencilRef = null;\n\t\t\tvar currentStencilFuncMask = null;\n\t\t\tvar currentStencilFail  = null;\n\t\t\tvar currentStencilZFail = null;\n\t\t\tvar currentStencilZPass = null;\n\t\t\tvar currentStencilClear = null;\n\n\t\t\treturn {\n\n\t\t\t\tsetTest: function ( stencilTest ) {\n\n\t\t\t\t\tif ( stencilTest ) {\n\n\t\t\t\t\t\tenable( gl.STENCIL_TEST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( gl.STENCIL_TEST );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetMask: function ( stencilMask ) {\n\n\t\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\t\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\n\n\t\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\t\tcurrentStencilRef  = stencilRef;\n\t\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\t\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\t\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\n\n\t\t\t\t\t\tcurrentStencilFail  = stencilFail;\n\t\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( stencil ) {\n\n\t\t\t\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\t\tcurrentStencilClear = stencil;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentStencilMask = null;\n\t\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\t\tcurrentStencilRef = null;\n\t\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\t\tcurrentStencilFail = null;\n\t\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\t\tcurrentStencilClear = null;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t//\n\n\t\tvar colorBuffer = new ColorBuffer();\n\t\tvar depthBuffer = new DepthBuffer();\n\t\tvar stencilBuffer = new StencilBuffer();\n\n\t\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\t\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\t\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\n\t\tvar capabilities = {};\n\n\t\tvar compressedTextureFormats = null;\n\n\t\tvar currentBlending = null;\n\t\tvar currentBlendEquation = null;\n\t\tvar currentBlendSrc = null;\n\t\tvar currentBlendDst = null;\n\t\tvar currentBlendEquationAlpha = null;\n\t\tvar currentBlendSrcAlpha = null;\n\t\tvar currentBlendDstAlpha = null;\n\t\tvar currentPremultipledAlpha = false;\n\n\t\tvar currentFlipSided = null;\n\t\tvar currentCullFace = null;\n\n\t\tvar currentLineWidth = null;\n\n\t\tvar currentPolygonOffsetFactor = null;\n\t\tvar currentPolygonOffsetUnits = null;\n\n\t\tvar currentScissorTest = null;\n\n\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\n\t\tvar currentTextureSlot = null;\n\t\tvar currentBoundTextures = {};\n\n\t\tvar currentScissor = new Vector4();\n\t\tvar currentViewport = new Vector4();\n\n\t\tfunction createTexture( type, target, count ) {\n\n\t\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\t\tvar texture = gl.createTexture();\n\n\t\t\tgl.bindTexture( type, texture );\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t\tvar emptyTextures = {};\n\t\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\t\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\n\t\t//\n\n\t\tfunction init() {\n\n\t\t\tclearColor( 0, 0, 0, 1 );\n\t\t\tclearDepth( 1 );\n\t\t\tclearStencil( 0 );\n\n\t\t\tenable( gl.DEPTH_TEST );\n\t\t\tsetDepthFunc( LessEqualDepth );\n\n\t\t\tsetFlipSided( false );\n\t\t\tsetCullFace( CullFaceBack );\n\t\t\tenable( gl.CULL_FACE );\n\n\t\t\tenable( gl.BLEND );\n\t\t\tsetBlending( NormalBlending );\n\n\t\t}\n\n\t\tfunction initAttributes() {\n\n\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\n\t\t\t\tnewAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enableAttribute( attribute ) {\n\n\t\t\tnewAttributes[ attribute ] = 1;\n\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t\t}\n\n\t\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\t\tattributeDivisors[ attribute ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {\n\n\t\t\tnewAttributes[ attribute ] = 1;\n\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t\t}\n\n\t\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction disableUnusedAttributes() {\n\n\t\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\n\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enable( id ) {\n\n\t\t\tif ( capabilities[ id ] !== true ) {\n\n\t\t\t\tgl.enable( id );\n\t\t\t\tcapabilities[ id ] = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction disable( id ) {\n\n\t\t\tif ( capabilities[ id ] !== false ) {\n\n\t\t\t\tgl.disable( id );\n\t\t\t\tcapabilities[ id ] = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getCompressedTextureFormats() {\n\n\t\t\tif ( compressedTextureFormats === null ) {\n\n\t\t\t\tcompressedTextureFormats = [];\n\n\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\n\t\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\n\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\n\t\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn compressedTextureFormats;\n\n\t\t}\n\n\t\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\t\tif ( blending !== NoBlending ) {\n\n\t\t\t\tenable( gl.BLEND );\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.BLEND );\n\n\t\t\t}\n\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\t\tif ( blending === AdditiveBlending ) {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( blending === SubtractiveBlending ) {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( blending === MultiplyBlending ) {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcurrentBlending = blending;\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\tif ( blending === CustomBlending ) {\n\n\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\n\t\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t\t\t}\n\n\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\n\t\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tcurrentBlendEquation = null;\n\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\tcurrentBlendDst = null;\n\t\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO Deprecate\n\n\t\tfunction setColorWrite( colorWrite ) {\n\n\t\t\tcolorBuffer.setMask( colorWrite );\n\n\t\t}\n\n\t\tfunction setDepthTest( depthTest ) {\n\n\t\t\tdepthBuffer.setTest( depthTest );\n\n\t\t}\n\n\t\tfunction setDepthWrite( depthWrite ) {\n\n\t\t\tdepthBuffer.setMask( depthWrite );\n\n\t\t}\n\n\t\tfunction setDepthFunc( depthFunc ) {\n\n\t\t\tdepthBuffer.setFunc( depthFunc );\n\n\t\t}\n\n\t\tfunction setStencilTest( stencilTest ) {\n\n\t\t\tstencilBuffer.setTest( stencilTest );\n\n\t\t}\n\n\t\tfunction setStencilWrite( stencilWrite ) {\n\n\t\t\tstencilBuffer.setMask( stencilWrite );\n\n\t\t}\n\n\t\tfunction setStencilFunc( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\tstencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t}\n\n\t\tfunction setStencilOp( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\tstencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction setFlipSided( flipSided ) {\n\n\t\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\t\tif ( flipSided ) {\n\n\t\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t\t}\n\n\t\t\t\tcurrentFlipSided = flipSided;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setCullFace( cullFace ) {\n\n\t\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\t\tenable( gl.CULL_FACE );\n\n\t\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.CULL_FACE );\n\n\t\t\t}\n\n\t\t\tcurrentCullFace = cullFace;\n\n\t\t}\n\n\t\tfunction setLineWidth( width ) {\n\n\t\t\tif ( width !== currentLineWidth ) {\n\n\t\t\t\tgl.lineWidth( width );\n\n\t\t\t\tcurrentLineWidth = width;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\n\t\t\tif ( polygonOffset ) {\n\n\t\t\t\tenable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getScissorTest() {\n\n\t\t\treturn currentScissorTest;\n\n\t\t}\n\n\t\tfunction setScissorTest( scissorTest ) {\n\n\t\t\tcurrentScissorTest = scissorTest;\n\n\t\t\tif ( scissorTest ) {\n\n\t\t\t\tenable( gl.SCISSOR_TEST );\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.SCISSOR_TEST );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// texture\n\n\t\tfunction activeTexture( webglSlot ) {\n\n\t\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction bindTexture( webglType, webglTexture ) {\n\n\t\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t\tactiveTexture();\n\n\t\t\t}\n\n\t\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\t\tif ( boundTexture === undefined ) {\n\n\t\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n\t\t\t}\n\n\t\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\t\tboundTexture.type = webglType;\n\t\t\t\tboundTexture.texture = webglTexture;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction compressedTexImage2D() {\n\n\t\t\ttry {\n\n\t\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.error( error );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction texImage2D() {\n\n\t\t\ttry {\n\n\t\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.error( error );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO Deprecate\n\n\t\tfunction clearColor( r, g, b, a ) {\n\n\t\t\tcolorBuffer.setClear( r, g, b, a );\n\n\t\t}\n\n\t\tfunction clearDepth( depth ) {\n\n\t\t\tdepthBuffer.setClear( depth );\n\n\t\t}\n\n\t\tfunction clearStencil( stencil ) {\n\n\t\t\tstencilBuffer.setClear( stencil );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction scissor( scissor ) {\n\n\t\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\t\tcurrentScissor.copy( scissor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction viewport( viewport ) {\n\n\t\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\t\tcurrentViewport.copy( viewport );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfunction reset() {\n\n\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\n\t\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\n\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcapabilities = {};\n\n\t\t\tcompressedTextureFormats = null;\n\n\t\t\tcurrentTextureSlot = null;\n\t\t\tcurrentBoundTextures = {};\n\n\t\t\tcurrentBlending = null;\n\n\t\t\tcurrentFlipSided = null;\n\t\t\tcurrentCullFace = null;\n\n\t\t\tcolorBuffer.reset();\n\t\t\tdepthBuffer.reset();\n\t\t\tstencilBuffer.reset();\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tbuffers: {\n\t\t\t\tcolor: colorBuffer,\n\t\t\t\tdepth: depthBuffer,\n\t\t\t\tstencil: stencilBuffer\n\t\t\t},\n\n\t\t\tinit: init,\n\t\t\tinitAttributes: initAttributes,\n\t\t\tenableAttribute: enableAttribute,\n\t\t\tenableAttributeAndDivisor: enableAttributeAndDivisor,\n\t\t\tdisableUnusedAttributes: disableUnusedAttributes,\n\t\t\tenable: enable,\n\t\t\tdisable: disable,\n\t\t\tgetCompressedTextureFormats: getCompressedTextureFormats,\n\n\t\t\tsetBlending: setBlending,\n\n\t\t\tsetColorWrite: setColorWrite,\n\t\t\tsetDepthTest: setDepthTest,\n\t\t\tsetDepthWrite: setDepthWrite,\n\t\t\tsetDepthFunc: setDepthFunc,\n\t\t\tsetStencilTest: setStencilTest,\n\t\t\tsetStencilWrite: setStencilWrite,\n\t\t\tsetStencilFunc: setStencilFunc,\n\t\t\tsetStencilOp: setStencilOp,\n\n\t\t\tsetFlipSided: setFlipSided,\n\t\t\tsetCullFace: setCullFace,\n\n\t\t\tsetLineWidth: setLineWidth,\n\t\t\tsetPolygonOffset: setPolygonOffset,\n\n\t\t\tgetScissorTest: getScissorTest,\n\t\t\tsetScissorTest: setScissorTest,\n\n\t\t\tactiveTexture: activeTexture,\n\t\t\tbindTexture: bindTexture,\n\t\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\t\ttexImage2D: texImage2D,\n\n\t\t\tclearColor: clearColor,\n\t\t\tclearDepth: clearDepth,\n\t\t\tclearStencil: clearStencil,\n\n\t\t\tscissor: scissor,\n\t\t\tviewport: viewport,\n\n\t\t\treset: reset\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLCapabilities( gl, extensions, parameters ) {\n\n\t\tvar maxAnisotropy;\n\n\t\tfunction getMaxAnisotropy() {\n\n\t\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t\t} else {\n\n\t\t\t\tmaxAnisotropy = 0;\n\n\t\t\t}\n\n\t\t\treturn maxAnisotropy;\n\n\t\t}\n\n\t\tfunction getMaxPrecision( precision ) {\n\n\t\t\tif ( precision === 'highp' ) {\n\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n\t\t\t\t\treturn 'highp';\n\n\t\t\t\t}\n\n\t\t\t\tprecision = 'mediump';\n\n\t\t\t}\n\n\t\t\tif ( precision === 'mediump' ) {\n\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n\t\t\t\t\treturn 'mediump';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn 'lowp';\n\n\t\t}\n\n\t\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\t\tvar maxPrecision = getMaxPrecision( precision );\n\n\t\tif ( maxPrecision !== precision ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\t\tprecision = maxPrecision;\n\n\t\t}\n\n\t\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );\n\n\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\tvar maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\t\tvar maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\t\tvar maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\t\tvar maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\tvar maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\tvar maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\t\tvar maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n\t\tvar vertexTextures = maxVertexTextures > 0;\n\t\tvar floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\t\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\n\n\t\treturn {\n\n\t\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\t\tgetMaxPrecision: getMaxPrecision,\n\n\t\t\tprecision: precision,\n\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\t\tmaxTextures: maxTextures,\n\t\t\tmaxVertexTextures: maxVertexTextures,\n\t\t\tmaxTextureSize: maxTextureSize,\n\t\t\tmaxCubemapSize: maxCubemapSize,\n\n\t\t\tmaxAttributes: maxAttributes,\n\t\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\t\tmaxVaryings: maxVaryings,\n\t\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\n\t\t\tvertexTextures: vertexTextures,\n\t\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\t\tfloatVertexTextures: floatVertexTextures\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLExtensions( gl ) {\n\n\t\tvar extensions = {};\n\n\t\treturn {\n\n\t\t\tget: function ( name ) {\n\n\t\t\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\t\t\treturn extensions[ name ];\n\n\t\t\t\t}\n\n\t\t\t\tvar extension;\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\textension = gl.getExtension( name );\n\n\t\t\t\t}\n\n\t\t\t\tif ( extension === null ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t\t\t}\n\n\t\t\t\textensions[ name ] = extension;\n\n\t\t\t\treturn extension;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author tschw\n\t */\n\n\tfunction WebGLClipping() {\n\n\t\tvar scope = this,\n\n\t\t\tglobalState = null,\n\t\t\tnumGlobalPlanes = 0,\n\t\t\tlocalClippingEnabled = false,\n\t\t\trenderingShadows = false,\n\n\t\t\tplane = new Plane(),\n\t\t\tviewNormalMatrix = new Matrix3(),\n\n\t\t\tuniform = { value: null, needsUpdate: false };\n\n\t\tthis.uniform = uniform;\n\t\tthis.numPlanes = 0;\n\t\tthis.numIntersection = 0;\n\n\t\tthis.init = function( planes, enableLocalClipping, camera ) {\n\n\t\t\tvar enabled =\n\t\t\t\tplanes.length !== 0 ||\n\t\t\t\tenableLocalClipping ||\n\t\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t\t// run another frame in order to reset the state:\n\t\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\t\tlocalClippingEnabled;\n\n\t\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\t\tnumGlobalPlanes = planes.length;\n\n\t\t\treturn enabled;\n\n\t\t};\n\n\t\tthis.beginShadows = function() {\n\n\t\t\trenderingShadows = true;\n\t\t\tprojectPlanes( null );\n\n\t\t};\n\n\t\tthis.endShadows = function() {\n\n\t\t\trenderingShadows = false;\n\t\t\tresetGlobalState();\n\n\t\t};\n\n\t\tthis.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\n\n\t\t\tif ( ! localClippingEnabled ||\n\t\t\t\t\tplanes === null || planes.length === 0 ||\n\t\t\t\t\trenderingShadows && ! clipShadows ) {\n\t\t\t\t// there's no local clipping\n\n\t\t\t\tif ( renderingShadows ) {\n\t\t\t\t\t// there's no global clipping\n\n\t\t\t\t\tprojectPlanes( null );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresetGlobalState();\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\t\tlGlobal = nGlobal * 4,\n\n\t\t\t\t\tdstArray = cache.clippingState || null;\n\n\t\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\n\t\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tcache.clippingState = dstArray;\n\t\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\t\tthis.numPlanes += nGlobal;\n\n\t\t\t}\n\n\n\t\t};\n\n\t\tfunction resetGlobalState() {\n\n\t\t\tif ( uniform.value !== globalState ) {\n\n\t\t\t\tuniform.value = globalState;\n\t\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t\t}\n\n\t\t\tscope.numPlanes = numGlobalPlanes;\n\t\t\tscope.numIntersection = 0;\n\n\t\t}\n\n\t\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\t\tdstArray = null;\n\n\t\t\tif ( nPlanes !== 0 ) {\n\n\t\t\t\tdstArray = uniform.value;\n\n\t\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0, i4 = dstOffset;\n\t\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\t\tplane.copy( planes[ i ] ).\n\t\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tuniform.value = dstArray;\n\t\t\t\tuniform.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tscope.numPlanes = nPlanes;\n\t\t\t\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t * @author tschw\n\t */\n\n\tfunction WebGLRenderer( parameters ) {\n\n\t\tconsole.log( 'THREE.WebGLRenderer', REVISION );\n\n\t\tparameters = parameters || {};\n\n\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\n\t\tvar lights = [];\n\n\t\tvar opaqueObjects = [];\n\t\tvar opaqueObjectsLastIndex = - 1;\n\t\tvar transparentObjects = [];\n\t\tvar transparentObjectsLastIndex = - 1;\n\n\t\tvar morphInfluences = new Float32Array( 8 );\n\n\t\tvar sprites = [];\n\t\tvar lensFlares = [];\n\n\t\t// public properties\n\n\t\tthis.domElement = _canvas;\n\t\tthis.context = null;\n\n\t\t// clearing\n\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true;\n\n\t\t// scene graph\n\n\t\tthis.sortObjects = true;\n\n\t\t// user-defined clipping\n\n\t\tthis.clippingPlanes = [];\n\t\tthis.localClippingEnabled = false;\n\n\t\t// physically based shading\n\n\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\t\tthis.gammaInput = false;\n\t\tthis.gammaOutput = false;\n\n\t\t// physical lights\n\n\t\tthis.physicallyCorrectLights = false;\n\n\t\t// tone mapping\n\n\t\tthis.toneMapping = LinearToneMapping;\n\t\tthis.toneMappingExposure = 1.0;\n\t\tthis.toneMappingWhitePoint = 1.0;\n\n\t\t// morphs\n\n\t\tthis.maxMorphTargets = 8;\n\t\tthis.maxMorphNormals = 4;\n\n\t\t// internal properties\n\n\t\tvar _this = this,\n\n\t\t// internal state cache\n\n\t\t_currentProgram = null,\n\t\t_currentRenderTarget = null,\n\t\t_currentFramebuffer = null,\n\t\t_currentMaterialId = - 1,\n\t\t_currentGeometryProgram = '',\n\t\t_currentCamera = null,\n\n\t\t_currentScissor = new Vector4(),\n\t\t_currentScissorTest = null,\n\n\t\t_currentViewport = new Vector4(),\n\n\t\t//\n\n\t\t_usedTextureUnits = 0,\n\n\t\t//\n\n\t\t_clearColor = new Color( 0x000000 ),\n\t\t_clearAlpha = 0,\n\n\t\t_width = _canvas.width,\n\t\t_height = _canvas.height,\n\n\t\t_pixelRatio = 1,\n\n\t\t_scissor = new Vector4( 0, 0, _width, _height ),\n\t\t_scissorTest = false,\n\n\t\t_viewport = new Vector4( 0, 0, _width, _height ),\n\n\t\t// frustum\n\n\t\t_frustum = new Frustum(),\n\n\t\t// clipping\n\n\t\t_clipping = new WebGLClipping(),\n\t\t_clippingEnabled = false,\n\t\t_localClippingEnabled = false,\n\n\t\t_sphere = new Sphere(),\n\n\t\t// camera matrices cache\n\n\t\t_projScreenMatrix = new Matrix4(),\n\n\t\t_vector3 = new Vector3(),\n\n\t\t// light arrays cache\n\n\t\t_lights = {\n\n\t\t\thash: '',\n\n\t\t\tambient: [ 0, 0, 0 ],\n\t\t\tdirectional: [],\n\t\t\tdirectionalShadowMap: [],\n\t\t\tdirectionalShadowMatrix: [],\n\t\t\tspot: [],\n\t\t\tspotShadowMap: [],\n\t\t\tspotShadowMatrix: [],\n\t\t\tpoint: [],\n\t\t\tpointShadowMap: [],\n\t\t\tpointShadowMatrix: [],\n\t\t\themi: [],\n\n\t\t\tshadows: []\n\n\t\t},\n\n\t\t// info\n\n\t\t_infoRender = {\n\n\t\t\tcalls: 0,\n\t\t\tvertices: 0,\n\t\t\tfaces: 0,\n\t\t\tpoints: 0\n\n\t\t};\n\n\t\tthis.info = {\n\n\t\t\trender: _infoRender,\n\t\t\tmemory: {\n\n\t\t\t\tgeometries: 0,\n\t\t\t\ttextures: 0\n\n\t\t\t},\n\t\t\tprograms: null\n\n\t\t};\n\n\n\t\t// initialize\n\n\t\tvar _gl;\n\n\t\ttry {\n\n\t\t\tvar attributes = {\n\t\t\t\talpha: _alpha,\n\t\t\t\tdepth: _depth,\n\t\t\t\tstencil: _stencil,\n\t\t\t\tantialias: _antialias,\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t\t};\n\n\t\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\n\t\t\tif ( _gl === null ) {\n\n\t\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\n\t\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow 'Error creating WebGL context.';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\n\n\t\t}\n\n\t\tvar extensions = new WebGLExtensions( _gl );\n\n\t\textensions.get( 'WEBGL_depth_texture' );\n\t\textensions.get( 'OES_texture_float' );\n\t\textensions.get( 'OES_texture_float_linear' );\n\t\textensions.get( 'OES_texture_half_float' );\n\t\textensions.get( 'OES_texture_half_float_linear' );\n\t\textensions.get( 'OES_standard_derivatives' );\n\t\textensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\t\tBufferGeometry.MaxIndex = 4294967296;\n\n\t\t}\n\n\t\tvar capabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\n\t\tvar state = new WebGLState( _gl, extensions, paramThreeToGL );\n\t\tvar properties = new WebGLProperties();\n\t\tvar textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n\t\tvar objects = new WebGLObjects( _gl, properties, this.info );\n\t\tvar programCache = new WebGLPrograms( this, capabilities );\n\t\tvar lightCache = new WebGLLights();\n\n\t\tthis.info.programs = programCache.programs;\n\n\t\tvar bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );\n\t\tvar indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\n\t\t//\n\n\t\tvar backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\tvar backgroundCamera2 = new PerspectiveCamera();\n\t\tvar backgroundPlaneMesh = new Mesh(\n\t\t\tnew PlaneBufferGeometry( 2, 2 ),\n\t\t\tnew MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\n\t\t);\n\t\tvar backgroundBoxShader = ShaderLib[ 'cube' ];\n\t\tvar backgroundBoxMesh = new Mesh(\n\t\t\tnew BoxBufferGeometry( 5, 5, 5 ),\n\t\t\tnew ShaderMaterial( {\n\t\t\t\tuniforms: backgroundBoxShader.uniforms,\n\t\t\t\tvertexShader: backgroundBoxShader.vertexShader,\n\t\t\t\tfragmentShader: backgroundBoxShader.fragmentShader,\n\t\t\t\tside: BackSide,\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tfog: false\n\t\t\t} )\n\t\t);\n\n\t\t//\n\n\t\tfunction getTargetPixelRatio() {\n\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t\t}\n\n\t\tfunction glClearColor( r, g, b, a ) {\n\n\t\t\tif ( _premultipliedAlpha === true ) {\n\n\t\t\t\tr *= a; g *= a; b *= a;\n\n\t\t\t}\n\n\t\t\tstate.clearColor( r, g, b, a );\n\n\t\t}\n\n\t\tfunction setDefaultGLState() {\n\n\t\t\tstate.init();\n\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t}\n\n\t\tfunction resetGLState() {\n\n\t\t\t_currentProgram = null;\n\t\t\t_currentCamera = null;\n\n\t\t\t_currentGeometryProgram = '';\n\t\t\t_currentMaterialId = - 1;\n\n\t\t\tstate.reset();\n\n\t\t}\n\n\t\tsetDefaultGLState();\n\n\t\tthis.context = _gl;\n\t\tthis.capabilities = capabilities;\n\t\tthis.extensions = extensions;\n\t\tthis.properties = properties;\n\t\tthis.state = state;\n\n\t\t// shadow map\n\n\t\tvar shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );\n\n\t\tthis.shadowMap = shadowMap;\n\n\n\t\t// Plugins\n\n\t\tvar spritePlugin = new SpritePlugin( this, sprites );\n\t\tvar lensFlarePlugin = new LensFlarePlugin( this, lensFlares );\n\n\t\t// API\n\n\t\tthis.getContext = function () {\n\n\t\t\treturn _gl;\n\n\t\t};\n\n\t\tthis.getContextAttributes = function () {\n\n\t\t\treturn _gl.getContextAttributes();\n\n\t\t};\n\n\t\tthis.forceContextLoss = function () {\n\n\t\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\n\n\t\t};\n\n\t\tthis.getMaxAnisotropy = function () {\n\n\t\t\treturn capabilities.getMaxAnisotropy();\n\n\t\t};\n\n\t\tthis.getPrecision = function () {\n\n\t\t\treturn capabilities.precision;\n\n\t\t};\n\n\t\tthis.getPixelRatio = function () {\n\n\t\t\treturn _pixelRatio;\n\n\t\t};\n\n\t\tthis.setPixelRatio = function ( value ) {\n\n\t\t\tif ( value === undefined ) return;\n\n\t\t\t_pixelRatio = value;\n\n\t\t\tthis.setSize( _viewport.z, _viewport.w, false );\n\n\t\t};\n\n\t\tthis.getSize = function () {\n\n\t\t\treturn {\n\t\t\t\twidth: _width,\n\t\t\t\theight: _height\n\t\t\t};\n\n\t\t};\n\n\t\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\t_canvas.width = width * _pixelRatio;\n\t\t\t_canvas.height = height * _pixelRatio;\n\n\t\t\tif ( updateStyle !== false ) {\n\n\t\t\t\t_canvas.style.width = width + 'px';\n\t\t\t\t_canvas.style.height = height + 'px';\n\n\t\t\t}\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t\tstate.viewport( _viewport.set( x, y, width, height ) );\n\n\t\t};\n\n\t\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t\tstate.scissor( _scissor.set( x, y, width, height ) );\n\n\t\t};\n\n\t\tthis.setScissorTest = function ( boolean ) {\n\n\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t\t};\n\n\t\t// Clearing\n\n\t\tthis.getClearColor = function () {\n\n\t\t\treturn _clearColor;\n\n\t\t};\n\n\t\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t\t_clearColor.set( color );\n\n\t\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t};\n\n\t\tthis.getClearAlpha = function () {\n\n\t\t\treturn _clearAlpha;\n\n\t\t};\n\n\t\tthis.setClearAlpha = function ( alpha ) {\n\n\t\t\t_clearAlpha = alpha;\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t};\n\n\t\tthis.clear = function ( color, depth, stencil ) {\n\n\t\t\tvar bits = 0;\n\n\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t\t_gl.clear( bits );\n\n\t\t};\n\n\t\tthis.clearColor = function () {\n\n\t\t\tthis.clear( true, false, false );\n\n\t\t};\n\n\t\tthis.clearDepth = function () {\n\n\t\t\tthis.clear( false, true, false );\n\n\t\t};\n\n\t\tthis.clearStencil = function () {\n\n\t\t\tthis.clear( false, false, true );\n\n\t\t};\n\n\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\t\t\tthis.clear( color, depth, stencil );\n\n\t\t};\n\n\t\t// Reset\n\n\t\tthis.resetGLState = resetGLState;\n\n\t\tthis.dispose = function() {\n\n\t\t\ttransparentObjects = [];\n\t\t\ttransparentObjectsLastIndex = -1;\n\t\t\topaqueObjects = [];\n\t\t\topaqueObjectsLastIndex = -1;\n\n\t\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\n\t\t};\n\n\t\t// Events\n\n\t\tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tresetGLState();\n\t\t\tsetDefaultGLState();\n\n\t\t\tproperties.clear();\n\n\t\t}\n\n\t\tfunction onMaterialDispose( event ) {\n\n\t\t\tvar material = event.target;\n\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\t\tdeallocateMaterial( material );\n\n\t\t}\n\n\t\t// Buffer deallocation\n\n\t\tfunction deallocateMaterial( material ) {\n\n\t\t\treleaseMaterialProgramReference( material );\n\n\t\t\tproperties.delete( material );\n\n\t\t}\n\n\n\t\tfunction releaseMaterialProgramReference( material ) {\n\n\t\t\tvar programInfo = properties.get( material ).program;\n\n\t\t\tmaterial.program = undefined;\n\n\t\t\tif ( programInfo !== undefined ) {\n\n\t\t\t\tprogramCache.releaseProgram( programInfo );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Buffer rendering\n\n\t\tthis.renderBufferImmediate = function ( object, program, material ) {\n\n\t\t\tstate.initAttributes();\n\n\t\t\tvar buffers = properties.get( object );\n\n\t\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n\t\t\tvar attributes = program.getAttributes();\n\n\t\t\tif ( object.hasPositions ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasNormals ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\n\t\t\t\tif ( ! material.isMeshPhongMaterial &&\n\t\t\t\t     ! material.isMeshStandardMaterial &&\n\t\t\t\t       material.shading === FlatShading ) {\n\n\t\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\n\t\t\t\t\t\tvar array = object.normalArray;\n\n\t\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\n\t\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\t\tarray[ i + 2 ] = nz;\n\n\t\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\t\tarray[ i + 5 ] = nz;\n\n\t\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\t\tarray[ i + 8 ] = nz;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.normal );\n\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasUvs && material.map ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.uv );\n\n\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasColors && material.vertexColors !== NoColors ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.color );\n\n\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n\t\t\tobject.count = 0;\n\n\t\t};\n\n\t\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\n\t\t\tsetMaterial( material );\n\n\t\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\t\tvar updateBuffers = false;\n\t\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\n\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\n\t\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t\t// morph targets\n\n\t\t\tvar morphTargetInfluences = object.morphTargetInfluences;\n\n\t\t\tif ( morphTargetInfluences !== undefined ) {\n\n\t\t\t\tvar activeInfluences = [];\n\n\t\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar influence = morphTargetInfluences[ i ];\n\t\t\t\t\tactiveInfluences.push( [ influence, i ] );\n\n\t\t\t\t}\n\n\t\t\t\tactiveInfluences.sort( absNumericalSort );\n\n\t\t\t\tif ( activeInfluences.length > 8 ) {\n\n\t\t\t\t\tactiveInfluences.length = 8;\n\n\t\t\t\t}\n\n\t\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar influence = activeInfluences[ i ];\n\t\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\n\n\t\t\t\t\tif ( influence[ 0 ] !== 0 ) {\n\n\t\t\t\t\t\tvar index = influence[ 1 ];\n\n\t\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n\t\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {\n\n\t\t\t\t\tmorphInfluences[ i ] = 0.0;\n\n\t\t\t\t}\n\n\t\t\t\tprogram.getUniforms().setValue(\n\t\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\n\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar position = geometry.attributes.position;\n\t\t\tvar rangeFactor = 1;\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tindex = objects.getWireframeAttribute( geometry );\n\t\t\t\trangeFactor = 2;\n\n\t\t\t}\n\n\t\t\tvar renderer;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\trenderer.setIndex( index );\n\n\t\t\t} else {\n\n\t\t\t\trenderer = bufferRenderer;\n\n\t\t\t}\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\tsetupVertexAttributes( material, program, geometry );\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar dataCount = 0;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tdataCount = index.count;\n\n\t\t\t} else if ( position !== undefined ) {\n\n\t\t\t\tdataCount = position.count;\n\n\t\t\t}\n\n\t\t\tvar rangeStart = geometry.drawRange.start * rangeFactor;\n\t\t\tvar rangeCount = geometry.drawRange.count * rangeFactor;\n\n\t\t\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\t\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\n\t\t\tvar drawStart = Math.max( rangeStart, groupStart );\n\t\t\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n\t\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n\t\t\tif ( drawCount === 0 ) return;\n\n\t\t\t//\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( object.drawMode ) {\n\n\t\t\t\t\t\tcase TrianglesDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TriangleStripDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TriangleFanDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t} else if ( object.isLine ) {\n\n\t\t\t\tvar lineWidth = material.linewidth;\n\n\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\t\tif ( object.isLineSegments ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isPoints ) {\n\n\t\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t\t}\n\n\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\n\t\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\t\tif ( extension === null ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( startIndex === undefined ) startIndex = 0;\n\n\t\t\tstate.initAttributes();\n\n\t\t\tvar geometryAttributes = geometry.attributes;\n\n\t\t\tvar programAttributes = program.getAttributes();\n\n\t\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\t\tfor ( var name in programAttributes ) {\n\n\t\t\t\tvar programAttribute = programAttributes[ name ];\n\n\t\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\t\tvar type = _gl.FLOAT;\n\t\t\t\t\t\tvar array = geometryAttribute.array;\n\t\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\n\t\t\t\t\t\tif ( array instanceof Float32Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.FLOAT;\n\n\t\t\t\t\t\t} else if ( array instanceof Float64Array ) {\n\n\t\t\t\t\t\t\tconsole.warn( \"Unsupported data buffer format: Float64Array\" );\n\n\t\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\n\t\t\t\t\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.SHORT;\n\n\t\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\n\n\t\t\t\t\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.INT;\n\n\t\t\t\t\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.BYTE;\n\n\t\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\n\n\t\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\n\t\t\t\t\t\t\tif ( data && data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t}\n\n\t\t// Sorting\n\n\t\tfunction absNumericalSort( a, b ) {\n\n\t\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\n\t\t}\n\n\t\tfunction painterSortStable( a, b ) {\n\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t\t} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {\n\n\t\t\t\treturn a.material.program.id - b.material.program.id;\n\n\t\t\t} else if ( a.material.id !== b.material.id ) {\n\n\t\t\t\treturn a.material.id - b.material.id;\n\n\t\t\t} else if ( a.z !== b.z ) {\n\n\t\t\t\treturn a.z - b.z;\n\n\t\t\t} else {\n\n\t\t\t\treturn a.id - b.id;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction reversePainterSortStable( a, b ) {\n\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t\t} if ( a.z !== b.z ) {\n\n\t\t\t\treturn b.z - a.z;\n\n\t\t\t} else {\n\n\t\t\t\treturn a.id - b.id;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Rendering\n\n\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\t\tif ( camera !== undefined && camera.isCamera !== true ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// reset caching for this frame\n\n\t\t\t_currentGeometryProgram = '';\n\t\t\t_currentMaterialId = - 1;\n\t\t\t_currentCamera = null;\n\n\t\t\t// update scene graph\n\n\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t\t// update camera matrices and frustum\n\n\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\tlights.length = 0;\n\n\t\t\topaqueObjectsLastIndex = - 1;\n\t\t\ttransparentObjectsLastIndex = - 1;\n\n\t\t\tsprites.length = 0;\n\t\t\tlensFlares.length = 0;\n\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\t\tprojectObject( scene, camera );\n\n\t\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\n\t\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\n\n\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\topaqueObjects.sort( painterSortStable );\n\t\t\t\ttransparentObjects.sort( reversePainterSortStable );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\n\t\t\tsetupShadows( lights );\n\n\t\t\tshadowMap.render( scene, camera );\n\n\t\t\tsetupLights( lights, camera );\n\n\t\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\n\t\t\t//\n\n\t\t\t_infoRender.calls = 0;\n\t\t\t_infoRender.vertices = 0;\n\t\t\t_infoRender.faces = 0;\n\t\t\t_infoRender.points = 0;\n\n\t\t\tif ( renderTarget === undefined ) {\n\n\t\t\t\trenderTarget = null;\n\n\t\t\t}\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\n\t\t\t//\n\n\t\t\tvar background = scene.background;\n\n\t\t\tif ( background === null ) {\n\n\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t\t} else if ( background && background.isColor ) {\n\n\t\t\t\tglClearColor( background.r, background.g, background.b, 1 );\n\t\t\t\tforceClear = true;\n\n\t\t\t}\n\n\t\t\tif ( this.autoClear || forceClear ) {\n\n\t\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\n\t\t\t}\n\n\t\t\tif ( background && background.isCubeTexture ) {\n\n\t\t\t\tbackgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t\tbackgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );\n\t\t\t\tbackgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );\n\n\t\t\t\tbackgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n\t\t\t\tbackgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\n\t\t\t\tobjects.update( backgroundBoxMesh );\n\n\t\t\t\t_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\n\t\t\t} else if ( background && background.isTexture ) {\n\n\t\t\t\tbackgroundPlaneMesh.material.map = background;\n\n\t\t\t\tobjects.update( backgroundPlaneMesh );\n\n\t\t\t\t_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( scene.overrideMaterial ) {\n\n\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\n\t\t\t\trenderObjects( opaqueObjects, scene, camera, overrideMaterial );\n\t\t\t\trenderObjects( transparentObjects, scene, camera, overrideMaterial );\n\n\t\t\t} else {\n\n\t\t\t\t// opaque pass (front-to-back order)\n\n\t\t\t\tstate.setBlending( NoBlending );\n\t\t\t\trenderObjects( opaqueObjects, scene, camera );\n\n\t\t\t\t// transparent pass (back-to-front order)\n\n\t\t\t\trenderObjects( transparentObjects, scene, camera );\n\n\t\t\t}\n\n\t\t\t// custom render plugins (post pass)\n\n\t\t\tspritePlugin.render( scene, camera );\n\t\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\n\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\n\t\t\t}\n\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\t\tstate.setDepthTest( true );\n\t\t\tstate.setDepthWrite( true );\n\t\t\tstate.setColorWrite( true );\n\n\t\t\t// _gl.finish();\n\n\t\t};\n\n\t\tfunction pushRenderItem( object, geometry, material, z, group ) {\n\n\t\t\tvar array, index;\n\n\t\t\t// allocate the next position in the appropriate array\n\n\t\t\tif ( material.transparent ) {\n\n\t\t\t\tarray = transparentObjects;\n\t\t\t\tindex = ++ transparentObjectsLastIndex;\n\n\t\t\t} else {\n\n\t\t\t\tarray = opaqueObjects;\n\t\t\t\tindex = ++ opaqueObjectsLastIndex;\n\n\t\t\t}\n\n\t\t\t// recycle existing render item or grow the array\n\n\t\t\tvar renderItem = array[ index ];\n\n\t\t\tif ( renderItem !== undefined ) {\n\n\t\t\t\trenderItem.id = object.id;\n\t\t\t\trenderItem.object = object;\n\t\t\t\trenderItem.geometry = geometry;\n\t\t\t\trenderItem.material = material;\n\t\t\t\trenderItem.z = _vector3.z;\n\t\t\t\trenderItem.group = group;\n\n\t\t\t} else {\n\n\t\t\t\trenderItem = {\n\t\t\t\t\tid: object.id,\n\t\t\t\t\tobject: object,\n\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\tmaterial: material,\n\t\t\t\t\tz: _vector3.z,\n\t\t\t\t\tgroup: group\n\t\t\t\t};\n\n\t\t\t\t// assert( index === array.length );\n\t\t\t\tarray.push( renderItem );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO Duplicated code (Frustum)\n\n\t\tfunction isObjectViewable( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\t\tapplyMatrix4( object.matrixWorld );\n\n\t\t\treturn isSphereViewable( _sphere );\n\n\t\t}\n\n\t\tfunction isSpriteViewable( sprite ) {\n\n\t\t\t_sphere.center.set( 0, 0, 0 );\n\t\t\t_sphere.radius = 0.7071067811865476;\n\t\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\treturn isSphereViewable( _sphere );\n\n\t\t}\n\n\t\tfunction isSphereViewable( sphere ) {\n\n\t\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\n\t\t\tvar numPlanes = _clipping.numPlanes;\n\n\t\t\tif ( numPlanes === 0 ) return true;\n\n\t\t\tvar planes = _this.clippingPlanes,\n\n\t\t\t\tcenter = sphere.center,\n\t\t\t\tnegRad = - sphere.radius,\n\t\t\t\ti = 0;\n\n\t\t\tdo {\n\n\t\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\n\t\t\t} while ( ++ i !== numPlanes );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction projectObject( object, camera ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tvar visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\n\t\t\tif ( visible ) {\n\n\t\t\t\tif ( object.isLight ) {\n\n\t\t\t\t\tlights.push( object );\n\n\t\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\n\t\t\t\t\t\tsprites.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isLensFlare ) {\n\n\t\t\t\t\tlensFlares.push( object );\n\n\t\t\t\t} else if ( object.isImmediateRenderObject ) {\n\n\t\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\n\n\t\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\tobject.skeleton.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\n\t\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar geometry = objects.update( object );\n\n\t\t\t\t\t\t\tif ( material.isMultiMaterial ) {\n\n\t\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tprojectObject( children[ i ], camera );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\n\n\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\t\tvar renderItem = renderList[ i ];\n\n\t\t\t\tvar object = renderItem.object;\n\t\t\t\tvar geometry = renderItem.geometry;\n\t\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\t\tvar group = renderItem.group;\n\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\n\t\t\t\tif ( object.isImmediateRenderObject ) {\n\n\t\t\t\t\tsetMaterial( material );\n\n\t\t\t\t\tvar program = setProgram( camera, scene.fog, material, object );\n\n\t\t\t\t\t_currentGeometryProgram = '';\n\n\t\t\t\t\tobject.render( function ( object ) {\n\n\t\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\n\n\t\t\t\t}\n\n\t\t\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction initMaterial( material, fog, object ) {\n\n\t\t\tvar materialProperties = properties.get( material );\n\n\t\t\tvar parameters = programCache.getParameters(\n\t\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );\n\n\t\t\tvar code = programCache.getProgramCode( material, parameters );\n\n\t\t\tvar program = materialProperties.program;\n\t\t\tvar programChange = true;\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\t// new material\n\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\t} else if ( program.code !== code ) {\n\n\t\t\t\t// changed glsl or parameters\n\t\t\t\treleaseMaterialProgramReference( material );\n\n\t\t\t} else if ( parameters.shaderID !== undefined ) {\n\n\t\t\t\t// same glsl and uniform list\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\t// only rebuild uniform list\n\t\t\t\tprogramChange = false;\n\n\t\t\t}\n\n\t\t\tif ( programChange ) {\n\n\t\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\t\tvar shader = ShaderLib[ parameters.shaderID ];\n\n\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\n\n\t\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\n\n\t\t\t\tmaterialProperties.program = program;\n\t\t\t\tmaterial.program = program;\n\n\t\t\t}\n\n\t\t\tvar attributes = program.getAttributes();\n\n\t\t\tif ( material.morphTargets ) {\n\n\t\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\n\t\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\n\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\n\t\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\n\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar uniforms = materialProperties.__webglShader.uniforms;\n\n\t\t\tif ( ! material.isShaderMaterial &&\n\t\t\t     ! material.isRawShaderMaterial ||\n\t\t\t       material.clipping === true ) {\n\n\t\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\t\tmaterialProperties.numIntersection = _clipping.numIntersection;\n\t\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\n\t\t\t}\n\n\t\t\tmaterialProperties.fog = fog;\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.lightsHash = _lights.hash;\n\n\t\t\tif ( material.lights ) {\n\n\t\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\n\t\t\t\tuniforms.directionalLights.value = _lights.directional;\n\t\t\t\tuniforms.spotLights.value = _lights.spot;\n\t\t\t\tuniforms.pointLights.value = _lights.point;\n\t\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\n\n\t\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n\t\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n\t\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\n\t\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n\t\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\n\t\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n\n\t\t\t}\n\n\t\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\t\tuniformsList =\n\t\t\t\t\t\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\t\tmaterialProperties.uniformsList = uniformsList;\n\n\t\t}\n\n\t\tfunction setMaterial( material ) {\n\n\t\t\tmaterial.side === DoubleSide\n\t\t\t\t? state.disable( _gl.CULL_FACE )\n\t\t\t\t: state.enable( _gl.CULL_FACE );\n\n\t\t\tstate.setFlipSided( material.side === BackSide );\n\n\t\t\tmaterial.transparent === true\n\t\t\t\t? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )\n\t\t\t\t: state.setBlending( NoBlending );\n\n\t\t\tstate.setDepthFunc( material.depthFunc );\n\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\tstate.setDepthWrite( material.depthWrite );\n\t\t\tstate.setColorWrite( material.colorWrite );\n\t\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t}\n\n\t\tfunction setProgram( camera, fog, material, object ) {\n\n\t\t\t_usedTextureUnits = 0;\n\n\t\t\tvar materialProperties = properties.get( material );\n\n\t\t\tif ( _clippingEnabled ) {\n\n\t\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\n\t\t\t\t\tvar useCache =\n\t\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\t_clipping.setState(\n\t\t\t\t\t\t\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\n\t\t\t\t\t\t\tcamera, materialProperties, useCache );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.needsUpdate === false ) {\n\n\t\t\t\tif ( materialProperties.program === undefined ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( material.fog && materialProperties.fog !== fog ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\t( materialProperties.numClippingPlanes !== _clipping.numPlanes || \n\t \t\t\t\t  materialProperties.numIntersection  !== _clipping.numIntersection ) ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.needsUpdate ) {\n\n\t\t\t\tinitMaterial( material, fog, object );\n\t\t\t\tmaterial.needsUpdate = false;\n\n\t\t\t}\n\n\t\t\tvar refreshProgram = false;\n\t\t\tvar refreshMaterial = false;\n\t\t\tvar refreshLights = false;\n\n\t\t\tvar program = materialProperties.program,\n\t\t\t\tp_uniforms = program.getUniforms(),\n\t\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\n\n\t\t\tif ( program.id !== _currentProgram ) {\n\n\t\t\t\t_gl.useProgram( program.program );\n\t\t\t\t_currentProgram = program.id;\n\n\t\t\t\trefreshProgram = true;\n\t\t\t\trefreshMaterial = true;\n\t\t\t\trefreshLights = true;\n\n\t\t\t}\n\n\t\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t\t_currentMaterialId = material.id;\n\n\t\t\t\trefreshMaterial = true;\n\n\t\t\t}\n\n\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\n\t\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\n\n\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( camera !== _currentCamera ) {\n\n\t\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t\t}\n\n\t\t\t\t// load material specific uniforms\n\t\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\t\tif ( material.isShaderMaterial ||\n\t\t\t\t     material.isMeshPhongMaterial ||\n\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t     material.envMap ) {\n\n\t\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\t     material.isMeshLambertMaterial ||\n\t\t\t\t     material.isMeshBasicMaterial ||\n\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t     material.isShaderMaterial ||\n\t\t\t\t     material.skinning ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t\t}\n\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\n\t\t\t}\n\n\t\t\t// skinning uniforms must be set even if material didn't change\n\t\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t\t// not sure why, but otherwise weird things happen\n\n\t\t\tif ( material.skinning ) {\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\t\tvar skeleton = object.skeleton;\n\n\t\t\t\tif ( skeleton ) {\n\n\t\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( refreshMaterial ) {\n\n\t\t\t\tif ( material.lights ) {\n\n\t\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t// values\n\t\t\t\t\t//\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t// the GL state when required\n\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t\t}\n\n\t\t\t\t// refresh uniforms common to several materials\n\n\t\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshBasicMaterial ||\n\t\t\t\t     material.isMeshLambertMaterial ||\n\t\t\t\t     material.isMeshPhongMaterial ||\n\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t     material.isMeshDepthMaterial ) {\n\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t\t}\n\n\t\t\t\t// refresh single material specific uniforms\n\n\t\t\t\tif ( material.isLineBasicMaterial ) {\n\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isLineDashedMaterial ) {\n\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isPointsMaterial ) {\n\n\t\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshLambertMaterial ) {\n\n\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshPhysicalMaterial ) {\n\n\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshStandardMaterial ) {\n\n\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshDepthMaterial ) {\n\n\t\t\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.isMeshNormalMaterial ) {\n\n\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t\t}\n\n\t\t\t\tWebGLUniforms.upload(\n\t\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\n\n\t\t\t}\n\n\n\t\t\t// common matrices\n\n\t\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\n\t\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\n\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\t// Uniforms (refresh uniforms objects)\n\n\t\tfunction refreshUniformsCommon( uniforms, material ) {\n\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t\tuniforms.diffuse.value = material.color;\n\n\t\t\tif ( material.emissive ) {\n\n\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t\t}\n\n\t\t\tuniforms.map.value = material.map;\n\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\tif ( material.aoMap ) {\n\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\t// uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. specular map\n\t\t\t// 3. normal map\n\t\t\t// 4. bump map\n\t\t\t// 5. alpha map\n\t\t\t// 6. emissive map\n\n\t\t\tvar uvScaleMap;\n\n\t\t\tif ( material.map ) {\n\n\t\t\t\tuvScaleMap = material.map;\n\n\t\t\t} else if ( material.specularMap ) {\n\n\t\t\t\tuvScaleMap = material.specularMap;\n\n\t\t\t} else if ( material.displacementMap ) {\n\n\t\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t\t} else if ( material.normalMap ) {\n\n\t\t\t\tuvScaleMap = material.normalMap;\n\n\t\t\t} else if ( material.bumpMap ) {\n\n\t\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t\t} else if ( material.roughnessMap ) {\n\n\t\t\t\tuvScaleMap = material.roughnessMap;\n\n\t\t\t} else if ( material.metalnessMap ) {\n\n\t\t\t\tuvScaleMap = material.metalnessMap;\n\n\t\t\t} else if ( material.alphaMap ) {\n\n\t\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t\t} else if ( material.emissiveMap ) {\n\n\t\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t\t// backwards compatibility\n\t\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\n\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t\t}\n\n\t\t\t\tvar offset = uvScaleMap.offset;\n\t\t\t\tvar repeat = uvScaleMap.repeat;\n\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t\t}\n\n\t\t\tuniforms.envMap.value = material.envMap;\n\n\t\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t}\n\n\t\tfunction refreshUniformsLine( uniforms, material ) {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t}\n\n\t\tfunction refreshUniformsDash( uniforms, material ) {\n\n\t\t\tuniforms.dashSize.value = material.dashSize;\n\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\t\tuniforms.scale.value = material.scale;\n\n\t\t}\n\n\t\tfunction refreshUniformsPoints( uniforms, material ) {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\t\tuniforms.scale.value = _height * 0.5;\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\tvar offset = material.map.offset;\n\t\t\t\tvar repeat = material.map.repeat;\n\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsFog( uniforms, fog ) {\n\n\t\t\tuniforms.fogColor.value = fog.color;\n\n\t\t\tif ( fog.isFog ) {\n\n\t\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t\t} else if ( fog.isFogExp2 ) {\n\n\t\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsLambert( uniforms, material ) {\n\n\t\t\tif ( material.lightMap ) {\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t}\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsPhong( uniforms, material ) {\n\n\t\t\tuniforms.specular.value = material.specular;\n\t\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\t\tif ( material.lightMap ) {\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t}\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( material.bumpMap ) {\n\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\t}\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\t}\n\n\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsStandard( uniforms, material ) {\n\n\t\t\tuniforms.roughness.value = material.roughness;\n\t\t\tuniforms.metalness.value = material.metalness;\n\n\t\t\tif ( material.roughnessMap ) {\n\n\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t\t}\n\n\t\t\tif ( material.metalnessMap ) {\n\n\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t\t}\n\n\t\t\tif ( material.lightMap ) {\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t}\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( material.bumpMap ) {\n\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\t}\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\t}\n\n\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t}\n\n\t\t\tif ( material.envMap ) {\n\n\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsPhysical( uniforms, material ) {\n\n\t\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\n\t\t\trefreshUniformsStandard( uniforms, material );\n\n\t\t}\n\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\t\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\n\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t\t}\n\n\t\t// Lighting\n\n\t\tfunction setupShadows( lights ) {\n\n\t\t\tvar lightShadowsLength = 0;\n\n\t\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\t\tvar light = lights[ i ];\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_lights.shadows.length = lightShadowsLength;\n\n\t\t}\n\n\t\tfunction setupLights( lights, camera ) {\n\n\t\t\tvar l, ll, light,\n\t\t\tr = 0, g = 0, b = 0,\n\t\t\tcolor,\n\t\t\tintensity,\n\t\t\tdistance,\n\t\t\tshadowMap,\n\n\t\t\tviewMatrix = camera.matrixWorldInverse,\n\n\t\t\tdirectionalLength = 0,\n\t\t\tpointLength = 0,\n\t\t\tspotLength = 0,\n\t\t\themiLength = 0;\n\n\t\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\t\tlight = lights[ l ];\n\n\t\t\t\tcolor = light.color;\n\t\t\t\tintensity = light.intensity;\n\t\t\t\tdistance = light.distance;\n\n\t\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\t\tif ( light.isAmbientLight ) {\n\n\t\t\t\t\tr += color.r * intensity;\n\t\t\t\t\tg += color.g * intensity;\n\t\t\t\t\tb += color.b * intensity;\n\n\t\t\t\t} else if ( light.isDirectionalLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\n\n\t\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\n\n\t\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\n\n\t\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\n\t\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new Matrix4();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t\t// equal to inverse of the light's position\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\n\t\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\n\n\t\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\t\tuniforms.direction.normalize();\n\n\t\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_lights.ambient[ 0 ] = r;\n\t\t\t_lights.ambient[ 1 ] = g;\n\t\t\t_lights.ambient[ 2 ] = b;\n\n\t\t\t_lights.directional.length = directionalLength;\n\t\t\t_lights.spot.length = spotLength;\n\t\t\t_lights.point.length = pointLength;\n\t\t\t_lights.hemi.length = hemiLength;\n\n\t\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\n\t\t}\n\n\t\t// GL state setting\n\n\t\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\n\t\t\tstate.setCullFace( cullFace );\n\t\t\tstate.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );\n\n\t\t};\n\n\t\t// Textures\n\n\t\tfunction allocTextureUnit() {\n\n\t\t\tvar textureUnit = _usedTextureUnits;\n\n\t\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t\t}\n\n\t\t\t_usedTextureUnits += 1;\n\n\t\t\treturn textureUnit;\n\n\t\t}\n\n\t\tthis.allocTextureUnit = allocTextureUnit;\n\n\t\t// this.setTexture2D = setTexture2D;\n\t\tthis.setTexture2D = ( function() {\n\n\t\t\tvar warned = false;\n\n\t\t\t// backwards compatibility: peel texture.texture\n\t\t\treturn function setTexture2D( texture, slot ) {\n\n\t\t\t\tif ( texture && texture.isWebGLRenderTarget ) {\n\n\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture = texture.texture;\n\n\t\t\t\t}\n\n\t\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.setTexture = ( function() {\n\n\t\t\tvar warned = false;\n\n\t\t\treturn function setTexture( texture, slot ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.setTextureCube = ( function() {\n\n\t\t\tvar warned = false;\n\n\t\t\treturn function setTextureCube( texture, slot ) {\n\n\t\t\t\t// backwards compatibility: peel texture.texture\n\t\t\t\tif ( texture && texture.isWebGLRenderTargetCube ) {\n\n\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture = texture.texture;\n\n\t\t\t\t}\n\n\t\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t\t// TODO: unify these code paths\n\t\t\t\tif ( ( texture && texture.isCubeTexture ) ||\n\t\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\n\t\t\t\t\t// CompressedTexture can have Array in image :/\n\n\t\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\t\ttextures.setTextureCube( texture, slot );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\n\t\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.getCurrentRenderTarget = function() {\n\n\t\t\treturn _currentRenderTarget;\n\n\t\t};\n\n\t\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\t\t_currentRenderTarget = renderTarget;\n\n\t\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t\t}\n\n\t\t\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\n\t\t\tvar framebuffer;\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\n\n\t\t\t\t}\n\n\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = null;\n\n\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\n\t\t\t}\n\n\t\t\tif ( _currentFramebuffer !== framebuffer ) {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t\t}\n\n\t\t\tstate.scissor( _currentScissor );\n\t\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\t\tstate.viewport( _currentViewport );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\n\t\t\tif ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\tif ( framebuffer ) {\n\n\t\t\t\tvar restore = false;\n\n\t\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\t\trestore = true;\n\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar texture = renderTarget.texture;\n\t\t\t\t\tvar textureFormat = texture.format;\n\t\t\t\t\tvar textureType = texture.type;\n\n\t\t\t\t\tif ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t     ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t     ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\n\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t} finally {\n\n\t\t\t\t\tif ( restore ) {\n\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Map three.js constants to WebGL constants\n\n\t\tfunction paramThreeToGL( p ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( p === RepeatWrapping ) return _gl.REPEAT;\n\t\t\tif ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\t\tif ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\n\t\t\tif ( p === NearestFilter ) return _gl.NEAREST;\n\t\t\tif ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\t\tif ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\n\t\t\tif ( p === LinearFilter ) return _gl.LINEAR;\n\t\t\tif ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\t\tif ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\n\t\t\tif ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\t\tif ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\tif ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\tif ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\n\t\t\tif ( p === ByteType ) return _gl.BYTE;\n\t\t\tif ( p === ShortType ) return _gl.SHORT;\n\t\t\tif ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\t\tif ( p === IntType ) return _gl.INT;\n\t\t\tif ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\t\tif ( p === FloatType ) return _gl.FLOAT;\n\n\t\t\tif ( p === HalfFloatType ) {\n\n\t\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\t\t\tif ( extension !== null ) return extension.HALF_FLOAT_OES;\n\n\t\t\t}\n\n\t\t\tif ( p === AlphaFormat ) return _gl.ALPHA;\n\t\t\tif ( p === RGBFormat ) return _gl.RGB;\n\t\t\tif ( p === RGBAFormat ) return _gl.RGBA;\n\t\t\tif ( p === LuminanceFormat ) return _gl.LUMINANCE;\n\t\t\tif ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\t\t\tif ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;\n\t\t\tif ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;\n\n\t\t\tif ( p === AddEquation ) return _gl.FUNC_ADD;\n\t\t\tif ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\t\tif ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\n\t\t\tif ( p === ZeroFactor ) return _gl.ZERO;\n\t\t\tif ( p === OneFactor ) return _gl.ONE;\n\t\t\tif ( p === SrcColorFactor ) return _gl.SRC_COLOR;\n\t\t\tif ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\t\tif ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\t\tif ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\t\tif ( p === DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\t\tif ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\n\t\t\tif ( p === DstColorFactor ) return _gl.DST_COLOR;\n\t\t\tif ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\t\tif ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\n\t\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\n\t\t\t\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\n\t\t\t\t p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === RGB_ETC1_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\t\t\tif ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t\t}\n\n\t\t\tif ( p === MinEquation || p === MaxEquation ) {\n\n\t\t\t\textension = extensions.get( 'EXT_blend_minmax' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === MinEquation ) return extension.MIN_EXT;\n\t\t\t\t\tif ( p === MaxEquation ) return extension.MAX_EXT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === UnsignedInt248Type ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_depth_texture' );\n\n\t\t\t\tif ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction FogExp2 ( color, density ) {\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n\t}\n\n\tFogExp2.prototype.isFogExp2 = true;\n\n\tFogExp2.prototype.clone = function () {\n\n\t\treturn new FogExp2( this.color.getHex(), this.density );\n\n\t};\n\n\tFogExp2.prototype.toJSON = function ( meta ) {\n\n\t\treturn {\n\t\t\ttype: 'FogExp2',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tdensity: this.density\n\t\t};\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Fog ( color, near, far ) {\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\n\t\tthis.near = ( near !== undefined ) ? near : 1;\n\t\tthis.far = ( far !== undefined ) ? far : 1000;\n\n\t}\n\n\tFog.prototype.isFog = true;\n\n\tFog.prototype.clone = function () {\n\n\t\treturn new Fog( this.color.getHex(), this.near, this.far );\n\n\t};\n\n\tFog.prototype.toJSON = function ( meta ) {\n\n\t\treturn {\n\t\t\ttype: 'Fog',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tnear: this.near,\n\t\t\tfar: this.far\n\t\t};\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Scene () {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Scene';\n\n\t\tthis.background = null;\n\t\tthis.fog = null;\n\t\tthis.overrideMaterial = null;\n\n\t\tthis.autoUpdate = true; // checked by the renderer\n\n\t}\n\n\tScene.prototype = Object.create( Object3D.prototype );\n\n\tScene.prototype.constructor = Scene;\n\n\tScene.prototype.copy = function ( source, recursive ) {\n\n\t\tObject3D.prototype.copy.call( this, source, recursive );\n\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\treturn this;\n\n\t};\n\n\tScene.prototype.toJSON = function ( meta ) {\n\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\n\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n\t\treturn data;\n\n\t};\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction LensFlare( texture, size, distance, blending, color ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.lensFlares = [];\n\n\t\tthis.positionScreen = new Vector3();\n\t\tthis.customUpdateCallback = undefined;\n\n\t\tif ( texture !== undefined ) {\n\n\t\t\tthis.add( texture, size, distance, blending, color );\n\n\t\t}\n\n\t}\n\n\tLensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: LensFlare,\n\n\t\tisLensFlare: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.positionScreen.copy( source.positionScreen );\n\t\t\tthis.customUpdateCallback = source.customUpdateCallback;\n\n\t\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\n\t\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( texture, size, distance, blending, color, opacity ) {\n\n\t\t\tif ( size === undefined ) size = - 1;\n\t\t\tif ( distance === undefined ) distance = 0;\n\t\t\tif ( opacity === undefined ) opacity = 1;\n\t\t\tif ( color === undefined ) color = new Color( 0xffffff );\n\t\t\tif ( blending === undefined ) blending = NormalBlending;\n\n\t\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\n\t\t\tthis.lensFlares.push( {\n\t\t\t\ttexture: texture,\t// THREE.Texture\n\t\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\n\t\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\n\t\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\n\t\t\t\tscale: 1, \t\t// scale\n\t\t\t\trotation: 0, \t\t// rotation\n\t\t\t\topacity: opacity,\t// opacity\n\t\t\t\tcolor: color,\t\t// color\n\t\t\t\tblending: blending\t// blending\n\t\t\t} );\n\n\t\t},\n\n\t\t/*\n\t\t * Update lens flares update positions on all flares based on the screen position\n\t\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t\t */\n\n\t\tupdateLensFlares: function () {\n\n\t\t\tvar f, fl = this.lensFlares.length;\n\t\t\tvar flare;\n\t\t\tvar vecX = - this.positionScreen.x * 2;\n\t\t\tvar vecY = - this.positionScreen.y * 2;\n\n\t\t\tfor ( f = 0; f < fl; f ++ ) {\n\n\t\t\t\tflare = this.lensFlares[ f ];\n\n\t\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\n\t\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *\tuvOffset: new THREE.Vector2(),\n\t *\tuvScale: new THREE.Vector2()\n\t * }\n\t */\n\n\tfunction SpriteMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'SpriteMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\t\tthis.map = null;\n\n\t\tthis.rotation = 0;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tSpriteMaterial.prototype = Object.create( Material.prototype );\n\tSpriteMaterial.prototype.constructor = SpriteMaterial;\n\n\tSpriteMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.map = source.map;\n\n\t\tthis.rotation = source.rotation;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Sprite( material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Sprite';\n\n\t\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\n\n\t}\n\n\tSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Sprite,\n\n\t\tisSprite: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar matrixPosition = new Vector3();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n\t\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\n\n\t\t\t\tif ( distanceSq > guessSizeSq ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tintersects.push( {\n\n\t\t\t\t\tdistance: Math.sqrt( distanceSq ),\n\t\t\t\t\tpoint: this.position,\n\t\t\t\t\tface: null,\n\t\t\t\t\tobject: this\n\n\t\t\t\t} );\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LOD() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'LOD';\n\n\t\tObject.defineProperties( this, {\n\t\t\tlevels: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: []\n\t\t\t}\n\t\t} );\n\n\t}\n\n\n\tLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: LOD,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source, false );\n\n\t\t\tvar levels = source.levels;\n\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tvar level = levels[ i ];\n\n\t\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddLevel: function ( object, distance ) {\n\n\t\t\tif ( distance === undefined ) distance = 0;\n\n\t\t\tdistance = Math.abs( distance );\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\n\t\t\tthis.add( object );\n\n\t\t},\n\n\t\tgetObjectForDistance: function ( distance ) {\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tif ( distance < levels[ i ].distance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn levels[ i - 1 ].object;\n\n\t\t},\n\n\t\traycast: ( function () {\n\n\t\t\tvar matrixPosition = new Vector3();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n\t\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tupdate: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\n\t\t\treturn function update( camera ) {\n\n\t\t\t\tvar levels = this.levels;\n\n\t\t\t\tif ( levels.length > 1 ) {\n\n\t\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\t\tvar distance = v1.distanceTo( v2 );\n\n\t\t\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\n\t\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.levels = [];\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tvar level = levels[ i ];\n\n\t\t\t\tdata.object.levels.push( {\n\t\t\t\t\tobject: level.object.uuid,\n\t\t\t\t\tdistance: level.distance\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.image = { data: data, width: width, height: height };\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.generateMipmaps  = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n\tDataTexture.prototype = Object.create( Texture.prototype );\n\tDataTexture.prototype.constructor = DataTexture;\n\n\tDataTexture.prototype.isDataTexture = true;\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author michael guerrero / http://realitymeltdown.com\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction Skeleton( bones, boneInverses, useVertexTexture ) {\n\n\t\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\n\t\tthis.identityMatrix = new Matrix4();\n\n\t\t// copy the bone array\n\n\t\tbones = bones || [];\n\n\t\tthis.bones = bones.slice( 0 );\n\n\t\t// create a bone texture or an array of floats\n\n\t\tif ( this.useVertexTexture ) {\n\n\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\n\t\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\t\tsize = _Math.nextPowerOfTwo( Math.ceil( size ) );\n\t\t\tsize = Math.max( size, 4 );\n\n\t\t\tthis.boneTextureWidth = size;\n\t\t\tthis.boneTextureHeight = size;\n\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\t\tthis.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\n\n\t\t}\n\n\t\t// use the supplied bone inverses or calculate the inverses\n\n\t\tif ( boneInverses === undefined ) {\n\n\t\t\tthis.calculateInverses();\n\n\t\t} else {\n\n\t\t\tif ( this.bones.length === boneInverses.length ) {\n\n\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\n\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tObject.assign( Skeleton.prototype, {\n\n\t\tcalculateInverses: function () {\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tvar inverse = new Matrix4();\n\n\t\t\t\tif ( this.bones[ b ] ) {\n\n\t\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boneInverses.push( inverse );\n\n\t\t\t}\n\n\t\t},\n\n\t\tpose: function () {\n\n\t\t\tvar bone;\n\n\t\t\t// recover the bind-time world matrices\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tbone = this.bones[ b ];\n\n\t\t\t\tif ( bone ) {\n\n\t\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// compute the local matrices, positions, rotations and scales\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tbone = this.bones[ b ];\n\n\t\t\t\tif ( bone ) {\n\n\t\t\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\n\t\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: ( function () {\n\n\t\t\tvar offsetMatrix = new Matrix4();\n\n\t\t\treturn function update() {\n\n\t\t\t\t// flatten bone matrices to array\n\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\t\t// compute the offset between the current and the original transform\n\n\t\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\n\t\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n\t\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.useVertexTexture ) {\n\n\t\t\t\t\tthis.boneTexture.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tclone: function () {\n\n\t\t\treturn new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction Bone( skin ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Bone';\n\n\t\tthis.skin = skin;\n\n\t}\n\n\tBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Bone,\n\n\t\tisBone: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.skin = source.skin;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction SkinnedMesh( geometry, material, useVertexTexture ) {\n\n\t\tMesh.call( this, geometry, material );\n\n\t\tthis.type = 'SkinnedMesh';\n\n\t\tthis.bindMode = \"attached\";\n\t\tthis.bindMatrix = new Matrix4();\n\t\tthis.bindMatrixInverse = new Matrix4();\n\n\t\t// init bones\n\n\t\t// TODO: remove bone creation as there is no reason (other than\n\t\t// convenience) for THREE.SkinnedMesh to do this.\n\n\t\tvar bones = [];\n\n\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\n\t\t\tvar bone, gbone;\n\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\t\tbone = new Bone( this );\n\t\t\t\tbones.push( bone );\n\n\t\t\t\tbone.name = gbone.name;\n\t\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n\t\t\t}\n\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\n\t\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\n\n\t\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.add( bones[ b ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.normalizeSkinWeights();\n\n\t\tthis.updateMatrixWorld( true );\n\t\tthis.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\n\t}\n\n\n\tSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\t\tconstructor: SkinnedMesh,\n\n\t\tisSkinnedMesh: true,\n\n\t\tbind: function( skeleton, bindMatrix ) {\n\n\t\t\tthis.skeleton = skeleton;\n\n\t\t\tif ( bindMatrix === undefined ) {\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t\t}\n\n\t\t\tthis.bindMatrix.copy( bindMatrix );\n\t\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\n\t\t},\n\n\t\tpose: function () {\n\n\t\t\tthis.skeleton.pose();\n\n\t\t},\n\n\t\tnormalizeSkinWeights: function () {\n\n\t\t\tif ( (this.geometry && this.geometry.isGeometry) ) {\n\n\t\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\n\t\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\n\t\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\n\t\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\t\tsw.multiplyScalar( scale );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( (this.geometry && this.geometry.isBufferGeometry) ) {\n\n\t\t\t\tvar vec = new Vector4();\n\n\t\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\n\t\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\n\n\t\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\t\tvec.w = skinWeight.getW( i );\n\n\t\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\n\n\t\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\t\tvec.multiplyScalar( scale );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t\t}\n\n\t\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdateMatrixWorld: function( force ) {\n\n\t\t\tMesh.prototype.updateMatrixWorld.call( this, true );\n\n\t\t\tif ( this.bindMode === \"attached\" ) {\n\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\n\t\t\t} else if ( this.bindMode === \"detached\" ) {\n\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function() {\n\n\t\t\treturn new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *  linecap: \"round\",\n\t *  linejoin: \"round\"\n\t * }\n\t */\n\n\tfunction LineBasicMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'LineBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.linewidth = 1;\n\t\tthis.linecap = 'round';\n\t\tthis.linejoin = 'round';\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tLineBasicMaterial.prototype = Object.create( Material.prototype );\n\tLineBasicMaterial.prototype.constructor = LineBasicMaterial;\n\n\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\n\tLineBasicMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.linewidth = source.linewidth;\n\t\tthis.linecap = source.linecap;\n\t\tthis.linejoin = source.linejoin;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Line( geometry, material, mode ) {\n\n\t\tif ( mode === 1 ) {\n\n\t\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\t\treturn new LineSegments( geometry, material );\n\n\t\t}\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Line';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\t}\n\n\tLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Line,\n\n\t\tisLine: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar precision = raycaster.linePrecision;\n\t\t\t\tvar precisionSq = precision * precision;\n\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\tvar vStart = new Vector3();\n\t\t\t\tvar vEnd = new Vector3();\n\t\t\t\tvar interSegment = new Vector3();\n\t\t\t\tvar interRay = new Vector3();\n\t\t\t\tvar step = (this && this.isLineSegments) ? 2 : 1;\n\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\n\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\n\t\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\n\t\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar nbVertices = vertices.length;\n\n\t\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LineSegments( geometry, material ) {\n\n\t\tLine.call( this, geometry, material );\n\n\t\tthis.type = 'LineSegments';\n\n\t}\n\n\tLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\n\n\t\tconstructor: LineSegments,\n\n\t\tisLineSegments: true\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  size: <float>,\n\t *  sizeAttenuation: <bool>\n\t * }\n\t */\n\n\tfunction PointsMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'PointsMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.size = 1;\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tPointsMaterial.prototype = Object.create( Material.prototype );\n\tPointsMaterial.prototype.constructor = PointsMaterial;\n\n\tPointsMaterial.prototype.isPointsMaterial = true;\n\n\tPointsMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.size = source.size;\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Points( geometry, material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Points';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\n\n\t}\n\n\tPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Points,\n\n\t\tisPoints: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar object = this;\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\t\tvar threshold = raycaster.params.Points.threshold;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\t\tvar position = new Vector3();\n\n\t\t\t\tfunction testPoint( point, index ) {\n\n\t\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\n\t\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tvar a = indices[ i ];\n\n\t\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\n\t\t\t\t\t\t\ttestPoint( position, a );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\n\t\t\t\t\t\t\ttestPoint( position, i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\ttestPoint( vertices[ i ], i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Group() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Group';\n\n\t}\n\n\tGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Group\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.generateMipmaps = false;\n\n\t\tvar scope = this;\n\n\t\tfunction update() {\n\n\t\t\trequestAnimationFrame( update );\n\n\t\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\t\tscope.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tupdate();\n\n\t}\n\n\tVideoTexture.prototype = Object.create( Texture.prototype );\n\tVideoTexture.prototype.constructor = VideoTexture;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.image = { width: width, height: height };\n\t\tthis.mipmaps = mipmaps;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\tthis.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n\tCompressedTexture.prototype = Object.create( Texture.prototype );\n\tCompressedTexture.prototype.constructor = CompressedTexture;\n\n\tCompressedTexture.prototype.isCompressedTexture = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tCanvasTexture.prototype = Object.create( Texture.prototype );\n\tCanvasTexture.prototype.constructor = CanvasTexture;\n\n\t/**\n\t * @author Matt DesLauriers / @mattdesl\n\t * @author atix / arthursilber.de\n\t */\n\n\tfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\n\t\tformat = format !== undefined ? format : DepthFormat;\n\n\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )\n\n\t\t}\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.image = { width: width, height: height };\n\n\t\tthis.type = type !== undefined ? type : UnsignedShortType;\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.flipY = false;\n\t\tthis.generateMipmaps\t= false;\n\n\t}\n\n\tDepthTexture.prototype = Object.create( Texture.prototype );\n\tDepthTexture.prototype.constructor = DepthTexture;\n\tDepthTexture.prototype.isDepthTexture = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WireframeGeometry( geometry ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tvar edge = [ 0, 0 ], hash = {};\n\n\t\tfunction sortFunction( a, b ) {\n\n\t\t\treturn a - b;\n\n\t\t}\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tif ( (geometry && geometry.isGeometry) ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar faces = geometry.faces;\n\t\t\tvar numEdges = 0;\n\n\t\t\t// allocate maximal size\n\t\t\tvar edges = new Uint32Array( 6 * faces.length );\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\n\n\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\n\t\t} else if ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// Indexed BufferGeometry\n\n\t\t\t\tvar indices = geometry.index.array;\n\t\t\t\tvar vertices = geometry.attributes.position;\n\t\t\t\tvar groups = geometry.groups;\n\t\t\t\tvar numEdges = 0;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tgeometry.addGroup( 0, indices.length );\n\n\t\t\t\t}\n\n\t\t\t\t// allocate maximal size\n\t\t\t\tvar edges = new Uint32Array( 2 * indices.length );\n\n\t\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\t\tvar group = groups[ o ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\n\t\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\n\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tvar vertices = geometry.attributes.position.array;\n\t\t\t\tvar numEdges = vertices.length / 3;\n\t\t\t\tvar numTris = numEdges / 3;\n\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tvar index = 18 * i + 6 * j;\n\n\t\t\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\n\t\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tWireframeGeometry.prototype.constructor = WireframeGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t */\n\n\tfunction ParametricBufferGeometry( func, slices, stacks ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'ParametricBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\n\t\t// generate vertices and uvs\n\n\t\tvar vertices = [];\n\t\tvar uvs = [];\n\n\t\tvar i, j, p;\n\t\tvar u, v;\n\n\t\tvar sliceCount = slices + 1;\n\n\t\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\t\tv = i / stacks;\n\n\t\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\t\tu = j / slices;\n\n\t\t\t\tp = func( u, v );\n\t\t\t\tvertices.push( p.x, p.y, p.z );\n\n\t\t\t\tuvs.push( u, v );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tvar indices = [];\n\t\tvar a, b, c, d;\n\n\t\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\t\ta = i * sliceCount + j;\n\t\t\t\tb = i * sliceCount + j + 1;\n\t\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\n\t\t\t\td = ( i + 1 ) * sliceCount + j;\n\n\t\t\t\t// faces one and two\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', Float32Attribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );\n\n\t\t// generate normals\n\n\t\tthis.computeVertexNormals();\n\n\t}\n\n\tParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\n\n\t/**\n\t * @author zz85 / https://github.com/zz85\n\t *\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t */\n\n\tfunction ParametricGeometry( func, slices, stacks ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ParametricGeometry';\n\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\n\t\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tParametricGeometry.prototype = Object.create( Geometry.prototype );\n\tParametricGeometry.prototype.constructor = ParametricGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'PolyhedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tradius = radius || 1;\n\t\tdetail = detail || 0;\n\n\t\t// default buffer data\n\n\t\tvar vertexBuffer = [];\n\t\tvar uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tappplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.addAttribute( 'position', Float32Attribute( vertexBuffer, 3 ) );\n\t\tthis.addAttribute( 'normal', Float32Attribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.addAttribute( 'uv', Float32Attribute( uvBuffer, 2 ) );\n\t\tthis.normalizeNormals();\n\n\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tvar a = new Vector3();\n\t\t\tvar b = new Vector3();\n\t\t\tvar c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivison with the given detail value\n\n\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tvar cols = Math.pow( 2, detail );\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tvar v = [];\n\n\t\t\tvar i, j;\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( i = 0 ; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tvar aj = a.clone().lerp( c, i / cols );\n\t\t\t\tvar bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tvar rows = cols - i;\n\n\t\t\t\tfor ( j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( i = 0; i < cols ; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction appplyRadius( radius ) {\n\n\t\t\tvar vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tvar v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tvar x0 = uvBuffer[ i + 0 ];\n\t\t\t\tvar x1 = uvBuffer[ i + 2 ];\n\t\t\t\tvar x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tvar max = Math.max( x0, x1, x2 );\n\t\t\t\tvar min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tvar stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tvar a = new Vector3();\n\t\t\tvar b = new Vector3();\n\t\t\tvar c = new Vector3();\n\n\t\t\tvar centroid = new Vector3();\n\n\t\t\tvar uvA = new Vector2();\n\t\t\tvar uvB = new Vector2();\n\t\t\tvar uvC = new Vector2();\n\n\t\t\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tvar azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth  ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] =  uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n\tPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction TetrahedronBufferGeometry( radius, detail ) {\n\n\t\tvar vertices = [\n\t\t\t1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'TetrahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\n\tfunction TetrahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TetrahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction OctahedronBufferGeometry( radius,detail ) {\n\n\t\tvar vertices = [\n\t\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'OctahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\n\tfunction OctahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'OctahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tOctahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tOctahedronGeometry.prototype.constructor = OctahedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction IcosahedronBufferGeometry( radius, detail ) {\n\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\t\tvar vertices = [\n\t\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n\t\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n\t\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n\t\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n\t\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n\t\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'IcosahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\n\tfunction IcosahedronGeometry( radius, detail ) {\n\n\t \tGeometry.call( this );\n\n\t\tthis.type = 'IcosahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction DodecahedronBufferGeometry( radius, detail ) {\n\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\tvar r = 1 / t;\n\n\t\tvar vertices = [\n\n\t\t\t// (±1, ±1, ±1)\n\t\t\t- 1, - 1, - 1,    - 1, - 1,  1,\n\t\t\t- 1,  1, - 1,    - 1,  1,  1,\n\t\t\t 1, - 1, - 1,     1, - 1,  1,\n\t\t\t 1,  1, - 1,     1,  1,  1,\n\n\t\t\t// (0, ±1/φ, ±φ)\n\t\t\t 0, - r, - t,     0, - r,  t,\n\t\t\t 0,  r, - t,     0,  r,  t,\n\n\t\t\t// (±1/φ, ±φ, 0)\n\t\t\t- r, - t,  0,    - r,  t,  0,\n\t\t\t r, - t,  0,     r,  t,  0,\n\n\t\t\t// (±φ, 0, ±1/φ)\n\t\t\t- t,  0, - r,     t,  0, - r,\n\t\t\t- t,  0,  r,     t,  0,  r\n\t\t];\n\n\t\tvar indices = [\n\t\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\n\t\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\n\t\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\n\t\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\n\t\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\n\t\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\n\t\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\n\t\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\n\t\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\n\t\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\n\t\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\n\t\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'DodecahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\n\n\t/**\n\t * @author Abe Pazos / https://hamoid.com\n\t */\n\n\tfunction DodecahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'DodecahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\n\n\t/**\n\t * @author clockworkgeek / https://github.com/clockworkgeek\n\t * @author timothypratley / https://github.com/timothypratley\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'PolyhedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\n\tPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Creates a tube which extrudes along a 3d spline.\n\t *\n\t */\n\n\tfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TubeBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\ttubularSegments = tubularSegments || 64;\n\t\tradius = radius || 1;\n\t\tradialSegments = radialSegments || 8;\n\t\tclosed = closed || false;\n\n\t\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\t\tvar uv = new Vector2();\n\n\t\tvar i, j;\n\n\t\t// buffer\n\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\t\tvar indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', Float32Attribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', Float32Attribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tvar P = path.getPointAt( i / tubularSegments );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tvar N = frames.normals[ i ];\n\t\t\tvar B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tvar sin =   Math.sin( v );\n\t\t\t\tvar cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode / https://github.com/oosmoxiecode\n\t * @author WestLangley / https://github.com/WestLangley\n\t * @author zz85 / https://github.com/zz85\n\t * @author miningold / https://github.com/miningold\n\t * @author jonobr1 / https://github.com/jonobr1\n\t *\n\t * Creates a tube which extrudes along a 3d spline.\n\t */\n\n\tfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TubeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\n\n\t\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = bufferGeometry.tangents;\n\t\tthis.normals = bufferGeometry.normals;\n\t\tthis.binormals = bufferGeometry.binormals;\n\n\t\t// create geometry\n\n\t\tthis.fromBufferGeometry( bufferGeometry );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTubeGeometry.prototype = Object.create( Geometry.prototype );\n\tTubeGeometry.prototype.constructor = TubeGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * see: http://www.blackpawn.com/texts/pqtorus/\n\t */\n\tfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TorusKnotBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\tradius = radius || 100;\n\t\ttube = tube || 40;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\tp = p || 2;\n\t\tq = q || 3;\n\n\t\t// used to calculate buffer length\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// helper variables\n\t\tvar i, j, index = 0, indexOffset = 0;\n\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\t\tvar uv = new Vector2();\n\n\t\tvar P1 = new Vector3();\n\t\tvar P2 = new Vector3();\n\n\t\tvar B = new Vector3();\n\t\tvar T = new Vector3();\n\t\tvar N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\t\tvar cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\t// vertex\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\tuv.y = j / radialSegments;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tvar cu = Math.cos( u );\n\t\t\tvar su = Math.sin( u );\n\t\t\tvar quOverP = q / p * u;\n\t\t\tvar cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n\tTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode\n\t */\n\n\tfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TorusKnotGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\n\t\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\n\tTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TorusBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tradius = radius || 100;\n\t\ttube = tube || 40;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\t\tarc = arc || Math.PI * 2;\n\n\t\t// used to calculate buffer length\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t\t// offset variables\n\t\tvar vertexBufferOffset = 0;\n\t\tvar uvBufferOffset = 0;\n\t\tvar indexBufferOffset = 0;\n\n\t\t// helper variables\n\t\tvar center = new Vector3();\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\n\t\tvar j, i;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tvar u = i / tubularSegments * arc;\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\n\n\t\t\t\t// this vector is used to calculate the normal\n\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\tcenter.y = radius * Math.sin( u );\n\n\t\t\t\t// normal\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\t\tnormals[ vertexBufferOffset ] = normal.x;\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\n\n\t\t\t\t// uv\n\t\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\n\n\t\t\t\t// update offsets\n\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\tuvBufferOffset += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t\t// indices\n\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t\t// face one\n\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t\t// face two\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t\t// update offset\n\t\t\t\tindexBufferOffset += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n\t */\n\n\tfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TorusGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\n\t}\n\n\tTorusGeometry.prototype = Object.create( Geometry.prototype );\n\tTorusGeometry.prototype.constructor = TorusGeometry;\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tvar ShapeUtils = {\n\n\t\t// calculate area of the contour polygon\n\n\t\tarea: function ( contour ) {\n\n\t\t\tvar n = contour.length;\n\t\t\tvar a = 0.0;\n\n\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t\t}\n\n\t\t\treturn a * 0.5;\n\n\t\t},\n\n\t\ttriangulate: ( function () {\n\n\t\t\t/**\n\t\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t\t * See original code and more information here:\n\t\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t\t *\n\t\t\t * ported to actionscript by Zevan Rosser\n\t\t\t * www.actionsnippet.com\n\t\t\t *\n\t\t\t * ported to javascript by Joshua Koo\n\t\t\t * http://www.lab4games.net/zz85/blog\n\t\t\t *\n\t\t\t */\n\n\t\t\tfunction snip( contour, u, v, w, n, verts ) {\n\n\t\t\t\tvar p;\n\t\t\t\tvar ax, ay, bx, by;\n\t\t\t\tvar cx, cy, px, py;\n\n\t\t\t\tax = contour[ verts[ u ] ].x;\n\t\t\t\tay = contour[ verts[ u ] ].y;\n\n\t\t\t\tbx = contour[ verts[ v ] ].x;\n\t\t\t\tby = contour[ verts[ v ] ].y;\n\n\t\t\t\tcx = contour[ verts[ w ] ].x;\n\t\t\t\tcy = contour[ verts[ w ] ].y;\n\n\t\t\t\tif ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;\n\n\t\t\t\tvar aX, aY, bX, bY, cX, cY;\n\t\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\n\t\t\t\taX = cx - bx;  aY = cy - by;\n\t\t\t\tbX = ax - cx;  bY = ay - cy;\n\t\t\t\tcX = bx - ax;  cY = by - ay;\n\n\t\t\t\tfor ( p = 0; p < n; p ++ ) {\n\n\t\t\t\t\tpx = contour[ verts[ p ] ].x;\n\t\t\t\t\tpy = contour[ verts[ p ] ].y;\n\n\t\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\n\t\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\n\t\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\n\n\t\t\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\t\t\tcpx = px - cx;  cpy = py - cy;\n\n\t\t\t\t\t// see if p is inside triangle abc\n\n\t\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\n\t\t\t\t\tcCROSSap = cX * apy - cY * apx;\n\t\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\n\n\t\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// takes in an contour array and returns\n\n\t\t\treturn function triangulate( contour, indices ) {\n\n\t\t\t\tvar n = contour.length;\n\n\t\t\t\tif ( n < 3 ) return null;\n\n\t\t\t\tvar result = [],\n\t\t\t\t\tverts = [],\n\t\t\t\t\tvertIndices = [];\n\n\t\t\t\t/* we want a counter-clockwise polygon in verts */\n\n\t\t\t\tvar u, v, w;\n\n\t\t\t\tif ( ShapeUtils.area( contour ) > 0.0 ) {\n\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\n\t\t\t\t}\n\n\t\t\t\tvar nv = n;\n\n\t\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\n\t\t\t\tvar count = 2 * nv;   /* error detection */\n\n\t\t\t\tfor ( v = nv - 1; nv > 2; ) {\n\n\t\t\t\t\t/* if we loop, it is probably a non-simple polygon */\n\n\t\t\t\t\tif ( ( count -- ) <= 0 ) {\n\n\t\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\n\t\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t\t\t//return null;\n\t\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\n\t\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\t\treturn result;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\n\t\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\n\t\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\n\t\t\t\t\t\tvar a, b, c, s, t;\n\n\t\t\t\t\t\t/* true names of the vertices */\n\n\t\t\t\t\t\ta = verts[ u ];\n\t\t\t\t\t\tb = verts[ v ];\n\t\t\t\t\t\tc = verts[ w ];\n\n\t\t\t\t\t\t/* output Triangle */\n\n\t\t\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\t\t\tcontour[ b ],\n\t\t\t\t\t\t\tcontour[ c ] ] );\n\n\n\t\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\n\t\t\t\t\t\t/* remove v from the remaining polygon */\n\n\t\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\n\t\t\t\t\t\t\tverts[ s ] = verts[ t ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnv --;\n\n\t\t\t\t\t\t/* reset error detection counter */\n\n\t\t\t\t\t\tcount = 2 * nv;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t} )(),\n\n\t\ttriangulateShape: function ( contour, holes ) {\n\n\t\t\tfunction removeDupEndPts(points) {\n\n\t\t\t\tvar l = points.length;\n\n\t\t\t\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\t\t\tpoints.pop();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tremoveDupEndPts( contour );\n\t\t\tholes.forEach( removeDupEndPts );\n\n\t\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\n\t\t\t\t// inOtherPt needs to be collinear to the inSegment\n\t\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\n\n\t\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\n\n\t\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\n\n\t\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\n\t\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n\t\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\n\t\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n\t\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\n\t\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\n\t\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\n\t\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\n\t\t\t\t\tvar perpSeg2;\n\t\t\t\t\tif ( limit > 0 ) {\n\n\t\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// i.e. to reduce rounding errors\n\t\t\t\t\t// intersection at endpoint of segment#1?\n\t\t\t\t\tif ( perpSeg2 === 0 ) {\n\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( perpSeg2 === limit ) {\n\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\treturn [ inSeg1Pt2 ];\n\n\t\t\t\t\t}\n\t\t\t\t\t// intersection at endpoint of segment#2?\n\t\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\n\t\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\n\n\t\t\t\t\t// return real intersection point\n\t\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\n\t\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n\t\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\n\t\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\n\n\t\t\t\t\t// they are collinear or degenerate\n\t\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\n\t\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\n\t\t\t\t\t// both segments are points\n\t\t\t\t\tif ( seg1Pt && seg2Pt ) {\n\n\t\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n\t\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\n\n\t\t\t\t\t}\n\t\t\t\t\t// segment#1  is a single point\n\t\t\t\t\tif ( seg1Pt ) {\n\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t\t}\n\t\t\t\t\t// segment#2  is a single point\n\t\t\t\t\tif ( seg2Pt ) {\n\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\n\t\t\t\t\t\treturn [ inSeg2Pt1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// they are collinear segments, which might overlap\n\t\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\n\t\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\n\t\t\t\t\tif ( seg1dx !== 0 ) {\n\n\t\t\t\t\t\t// the segments are NOT on a vertical line\n\t\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// the segments are on a vertical line\n\t\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1minVal <= seg2minVal ) {\n\n\t\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\n\t\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\n\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\treturn [ seg2min ];\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\n\t\t\t\t\t\treturn\t[ seg2min, seg2max ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\n\t\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\n\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\treturn [ seg1min ];\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\n\t\t\t\t\t\treturn\t[ seg1min, seg2max ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\n\t\t\t\t// The order of legs is important\n\n\t\t\t\t// translation of all points, so that Vertex is at (0,0)\n\t\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\n\t\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\n\t\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\n\n\t\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\t\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\n\t\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\n\n\t\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\n\t\t\t\t\t// angle != 180 deg.\n\n\t\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\n\t\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\n\t\t\t\t\tif ( from2toAngle > 0 ) {\n\n\t\t\t\t\t\t// main angle < 180 deg.\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// main angle > 180 deg.\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// angle == 180 deg.\n\t\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n\t\t\t\t\treturn\t( from2otherAngle > 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfunction removeHoles( contour, holes ) {\n\n\t\t\t\tvar shape = contour.concat(); // work on this shape\n\t\t\t\tvar hole;\n\n\t\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\n\t\t\t\t\t// Check if hole point lies within angle around shape point\n\t\t\t\t\tvar lastShapeIdx = shape.length - 1;\n\n\t\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\n\t\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\n\n\t\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\n\t\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\n\n\t\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n\t\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n\t\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if shape point lies within angle around hole point\n\t\t\t\t\tvar lastHoleIdx = hole.length - 1;\n\n\t\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\n\t\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\n\n\t\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\n\t\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\n\n\t\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n\t\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n\t\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\ttrue;\n\n\t\t\t\t}\n\n\t\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t\t// checks for intersections with shape edges\n\t\t\t\t\tvar sIdx, nextIdx, intersection;\n\t\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\n\t\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\tvar indepHoles = [];\n\n\t\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t\t// checks for intersections with hole edges\n\t\t\t\t\tvar ihIdx, chkHole,\n\t\t\t\t\t\thIdx, nextIdx, intersection;\n\t\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\n\t\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\n\t\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\n\t\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\n\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\tvar holeIndex, shapeIndex,\n\t\t\t\t\tshapePt, holePt,\n\t\t\t\t\tholeIdx, cutKey, failedCuts = [],\n\t\t\t\t\ttmpShape1, tmpShape2,\n\t\t\t\t\ttmpHole1, tmpHole2;\n\n\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tindepHoles.push( h );\n\n\t\t\t\t}\n\n\t\t\t\tvar minShapeIndex = 0;\n\t\t\t\tvar counter = indepHoles.length * 2;\n\t\t\t\twhile ( indepHoles.length > 0 ) {\n\n\t\t\t\t\tcounter --;\n\t\t\t\t\tif ( counter < 0 ) {\n\n\t\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// search for shape-vertex and hole-vertex,\n\t\t\t\t\t// which can be connected without intersections\n\t\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\n\t\t\t\t\t\tshapePt = shape[ shapeIndex ];\n\t\t\t\t\t\tholeIndex\t= - 1;\n\n\t\t\t\t\t\t// search for hole which can be reached without intersections\n\t\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\n\n\t\t\t\t\t\t\tholeIdx = indepHoles[ h ];\n\n\t\t\t\t\t\t\t// prevent multiple checks\n\t\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n\t\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\n\n\t\t\t\t\t\t\thole = holes[ holeIdx ];\n\t\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\n\t\t\t\t\t\t\t\tholePt = hole[ h2 ];\n\t\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\n\t\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\n\t\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\n\n\t\t\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\n\n\t\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\n\t\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\n\n\t\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\n\t\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\n\n\t\t\t\t\t\t\t\t// Debug only, to show the selected cuts\n\t\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn shape; \t\t\t/* shape with no holes */\n\n\t\t\t}\n\n\n\t\t\tvar i, il, f, face,\n\t\t\t\tkey, index,\n\t\t\t\tallPointsMap = {};\n\n\t\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n\t\t\tvar allpoints = contour.concat();\n\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\n\n\t\t\t}\n\n\t\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\n\t\t\t// prepare all points map\n\n\t\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\n\t\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\n\t\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.ShapeUtils: Duplicate point\", key, i );\n\n\t\t\t\t}\n\n\t\t\t\tallPointsMap[ key ] = i;\n\n\t\t\t}\n\n\t\t\t// remove holes by cutting paths to holes and adding them to the shape\n\t\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\n\n\t\t\tvar triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n\t\t\t//console.log( \"triangles\",triangles, triangles.length );\n\n\t\t\t// check all face vertices against all points map\n\n\t\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\n\t\t\t\tface = triangles[ i ];\n\n\t\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn triangles.concat();\n\n\t\t},\n\n\t\tisClockWise: function ( pts ) {\n\n\t\t\treturn ShapeUtils.area( pts ) < 0;\n\n\t\t},\n\n\t\t// Bezier Curves formulas obtained from\n\t\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n\t\t// Quad Bezier Functions\n\n\t\tb2: ( function () {\n\n\t\t\tfunction b2p0( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn k * k * p;\n\n\t\t\t}\n\n\t\t\tfunction b2p1( t, p ) {\n\n\t\t\t\treturn 2 * ( 1 - t ) * t * p;\n\n\t\t\t}\n\n\t\t\tfunction b2p2( t, p ) {\n\n\t\t\t\treturn t * t * p;\n\n\t\t\t}\n\n\t\t\treturn function b2( t, p0, p1, p2 ) {\n\n\t\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\t// Cubic Bezier Functions\n\n\t\tb3: ( function () {\n\n\t\t\tfunction b3p0( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn k * k * k * p;\n\n\t\t\t}\n\n\t\t\tfunction b3p1( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn 3 * k * k * t * p;\n\n\t\t\t}\n\n\t\t\tfunction b3p2( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn 3 * k * t * t * p;\n\n\t\t\t}\n\n\t\t\tfunction b3p3( t, p ) {\n\n\t\t\t\treturn t * t * t * p;\n\n\t\t\t}\n\n\t\t\treturn function b3( t, p0, p1, p2, p3 ) {\n\n\t\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\n\n\t\t\t};\n\n\t\t} )()\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t * Creates extruded geometry from a path shape.\n\t *\n\t * parameters = {\n\t *\n\t *  curveSegments: <int>, // number of points on the curves\n\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n\t *  amount: <int>, // Depth to extrude the shape\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\n\t *  bevelSize: <float>, // how far from shape outline is bevel\n\t *  bevelSegments: <int>, // number of bevel layers\n\t *\n\t *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n\t *  frames: <Object> // containing arrays of tangents, normals, binormals\n\t *\n\t *  uvGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t **/\n\n\tfunction ExtrudeGeometry( shapes, options ) {\n\n\t\tif ( typeof( shapes ) === \"undefined\" ) {\n\n\t\t\tshapes = [];\n\t\t\treturn;\n\n\t\t}\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tthis.addShapeList( shapes, options );\n\n\t\tthis.computeFaceNormals();\n\n\t\t// can't really use automatic vertex normals\n\t\t// as then front and back sides get smoothed too\n\t\t// should do separate smoothing just for sides\n\n\t\t//this.computeVertexNormals();\n\n\t\t//console.log( \"took\", ( Date.now() - startTime ) );\n\n\t}\n\n\tExtrudeGeometry.prototype = Object.create( Geometry.prototype );\n\tExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\n\n\tExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\t\tvar sl = shapes.length;\n\n\t\tfor ( var s = 0; s < sl; s ++ ) {\n\n\t\t\tvar shape = shapes[ s ];\n\t\t\tthis.addShape( shape, options );\n\n\t\t}\n\n\t};\n\n\tExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\n\t\tvar amount = options.amount !== undefined ? options.amount : 100;\n\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\n\n\t\tvar extrudePath = options.extrudePath;\n\t\tvar extrudePts, extrudeByPath = false;\n\n\t\t// Use default WorldUVGenerator if no UV generators are specified.\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;\n\n\t\tvar splineTube, binormal, normal, position2;\n\t\tif ( extrudePath ) {\n\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\textrudeByPath = true;\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t// SETUP TNB variables\n\n\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\tsplineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\tbinormal = new Vector3();\n\t\t\tnormal = new Vector3();\n\t\t\tposition2 = new Vector3();\n\n\t\t}\n\n\t\t// Safeguards if bevels are not enabled\n\n\t\tif ( ! bevelEnabled ) {\n\n\t\t\tbevelSegments = 0;\n\t\t\tbevelThickness = 0;\n\t\t\tbevelSize = 0;\n\n\t\t}\n\n\t\t// Variables initialization\n\n\t\tvar ahole, h, hl; // looping of holes\n\t\tvar scope = this;\n\n\t\tvar shapesOffset = this.vertices.length;\n\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\tif ( reverse ) {\n\n\t\t\tvertices = vertices.reverse();\n\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n\t\t}\n\n\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t/* Vertices */\n\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tvertices = vertices.concat( ahole );\n\n\t\t}\n\n\n\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t\t}\n\n\t\tvar b, bs, t, z,\n\t\t\tvert, vlen = vertices.length,\n\t\t\tface, flen = faces.length;\n\n\n\t\t// Find directions for point movement\n\n\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t//\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\n\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n\t\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t// check for collinear edges\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t// not collinear\n\n\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n\t\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t//  but prevent crazy spikes\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\treturn\tnew Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\tvar direction_eq = false;\t\t// assumes: opposite\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\tv_trans_y =  v_prev_x;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tnew Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t}\n\n\n\t\tvar contourMovements = [];\n\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t}\n\n\t\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\toneHoleMovements = [];\n\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t}\n\n\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t}\n\n\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tbs = bevelSize;\n\n\t\t// Back facing vertices\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add stepped vertices...\n\t\t// Including front facing vertices\n\n\t\tvar s;\n\n\t\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// Add bevel segments planes\n\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos ( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* Faces */\n\n\t\t// Top and bottom faces\n\n\t\tbuildLidFaces();\n\n\t\t// Sides faces\n\n\t\tbuildSideFaces();\n\n\n\t\t/////  Internal functions\n\n\t\tfunction buildLidFaces() {\n\n\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\tvar layer = 0; // steps + 1\n\t\t\t\tvar offset = vlen * layer;\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Create faces for the z-sides of the shape\n\n\t\tfunction buildSideFaces() {\n\n\t\t\tvar layeroffset = 0;\n\t\t\tsidewalls( contour, layeroffset );\n\t\t\tlayeroffset += contour.length;\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t//, true\n\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\tvar j, k;\n\t\t\ti = contour.length;\n\n\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\tj = i;\n\t\t\t\tk = i - 1;\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction v( x, y, z ) {\n\n\t\t\tscope.vertices.push( new Vector3( x, y, z ) );\n\n\t\t}\n\n\t\tfunction f3( a, b, c ) {\n\n\t\t\ta += shapesOffset;\n\t\t\tb += shapesOffset;\n\t\t\tc += shapesOffset;\n\n\t\t\tscope.faces.push( new Face3( a, b, c, null, null, 0 ) );\n\n\t\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\n\n\t\t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t\t}\n\n\t\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\n\t\t\ta += shapesOffset;\n\t\t\tb += shapesOffset;\n\t\t\tc += shapesOffset;\n\t\t\td += shapesOffset;\n\n\t\t\tscope.faces.push( new Face3( a, b, d, null, null, 1 ) );\n\t\t\tscope.faces.push( new Face3( b, c, d, null, null, 1 ) );\n\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\n\t\t}\n\n\t};\n\n\tExtrudeGeometry.WorldUVGenerator = {\n\n\t\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\n\t\t\tvar a = vertices[ indexA ];\n\t\t\tvar b = vertices[ indexB ];\n\t\t\tvar c = vertices[ indexC ];\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a.x, a.y ),\n\t\t\t\tnew Vector2( b.x, b.y ),\n\t\t\t\tnew Vector2( c.x, c.y )\n\t\t\t];\n\n\t\t},\n\n\t\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\n\t\t\tvar a = vertices[ indexA ];\n\t\t\tvar b = vertices[ indexB ];\n\t\t\tvar c = vertices[ indexC ];\n\t\t\tvar d = vertices[ indexD ];\n\n\t\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\n\n\t\t\t\treturn [\n\t\t\t\t\tnew Vector2( a.x, 1 - a.z ),\n\t\t\t\t\tnew Vector2( b.x, 1 - b.z ),\n\t\t\t\t\tnew Vector2( c.x, 1 - c.z ),\n\t\t\t\t\tnew Vector2( d.x, 1 - d.z )\n\t\t\t\t];\n\n\t\t\t} else {\n\n\t\t\t\treturn [\n\t\t\t\t\tnew Vector2( a.y, 1 - a.z ),\n\t\t\t\t\tnew Vector2( b.y, 1 - b.z ),\n\t\t\t\t\tnew Vector2( c.y, 1 - c.z ),\n\t\t\t\t\tnew Vector2( d.y, 1 - d.z )\n\t\t\t\t];\n\n\t\t\t}\n\n\t\t}\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Text = 3D Text\n\t *\n\t * parameters = {\n\t *  font: <THREE.Font>, // font\n\t *\n\t *  size: <float>, // size of the text\n\t *  height: <float>, // thickness to extrude text\n\t *  curveSegments: <int>, // number of points on the curves\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into text bevel goes\n\t *  bevelSize: <float> // how far from text outline is bevel\n\t * }\n\t */\n\n\tfunction TextGeometry( text, parameters ) {\n\n\t\tparameters = parameters || {};\n\n\t\tvar font = parameters.font;\n\n\t\tif ( (font && font.isFont) === false ) {\n\n\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\t\treturn new Geometry();\n\n\t\t}\n\n\t\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\n\t\t// translate parameters to ExtrudeGeometry API\n\n\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n\t\t// defaults\n\n\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\t\tExtrudeGeometry.call( this, shapes, parameters );\n\n\t\tthis.type = 'TextGeometry';\n\n\t}\n\n\tTextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );\n\tTextGeometry.prototype.constructor = TextGeometry;\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t * based on THREE.SphereGeometry\n\t */\n\n\tfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'SphereBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tradius = radius || 50;\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\t\tphiStart = phiStart !== undefined ? phiStart : 0;\n\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\t\tvar thetaEnd = thetaStart + thetaLength;\n\n\t\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\n\n\t\tvar positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\tvar index = 0, vertices = [], normal = new Vector3();\n\n\t\tfor ( var y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\tvar verticesRow = [];\n\n\t\t\tvar v = y / heightSegments;\n\n\t\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\n\n\t\t\t\tvar u = x / widthSegments;\n\n\t\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tnormal.set( px, py, pz ).normalize();\n\n\t\t\t\tpositions.setXYZ( index, px, py, pz );\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\t\tverticesRow.push( index );\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvertices.push( verticesRow );\n\n\t\t}\n\n\t\tvar indices = [];\n\n\t\tfor ( var y = 0; y < heightSegments; y ++ ) {\n\n\t\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\n\n\t\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\n\t\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\n\t\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( new ( positions.count > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', positions );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\n\t}\n\n\tSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'SphereGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\n\t}\n\n\tSphereGeometry.prototype = Object.create( Geometry.prototype );\n\tSphereGeometry.prototype.constructor = SphereGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'RingBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tinnerRadius = innerRadius || 20;\n\t\touterRadius = outerRadius || 50;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\n\t\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// some helper variables\n\t\tvar index = 0, indexOffset = 0, segment;\n\t\tvar radius = innerRadius;\n\t\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tvar vertex = new Vector3();\n\t\tvar uv = new Vector2();\n\t\tvar j, i;\n\n\t\t// generate vertices, normals and uvs\n\n\t\t// values are generate from the inside of the ring to the outside\n\n\t\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, 0, 1 );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex++;\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tsegment = i + thetaSegmentLevel;\n\n\t\t\t\t// indices\n\t\t\t\tvar a = segment;\n\t\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\t\tvar d = segment + 1;\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t}\n\n\tRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tRingBufferGeometry.prototype.constructor = RingBufferGeometry;\n\n\t/**\n\t * @author Kaleb Murphy\n\t */\n\n\tfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'RingGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\n\t}\n\n\tRingGeometry.prototype = Object.create( Geometry.prototype );\n\tRingGeometry.prototype.constructor = RingGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t */\n\n\tfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'PlaneGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\n\t}\n\n\tPlaneGeometry.prototype = Object.create( Geometry.prototype );\n\tPlaneGeometry.prototype.constructor = PlaneGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t // points - to create a closed torus, one must use a set of points\n\t //    like so: [ a, b, c, d, a ], see first is the same as last.\n\t // segments - the number of circumference segments to create\n\t // phiStart - the starting radian\n\t // phiLength - the radian (0 to 2PI) range of the lathed section\n\t //    2PI is a closed lathe, less than 2PI is a portion.\n\n\tfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'LatheBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments ) || 12;\n\t\tphiStart = phiStart || 0;\n\t\tphiLength = phiLength || Math.PI * 2;\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\t\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\n\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = ( segments + 1 ) * points.length;\n\t\tvar indexCount = segments * points.length * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// helper variables\n\t\tvar index = 0, indexOffset = 0, base;\n\t\tvar inverseSegments = 1.0 / segments;\n\t\tvar vertex = new Vector3();\n\t\tvar uv = new Vector2();\n\t\tvar i, j;\n\n\t\t// generate vertices and uvs\n\n\t\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tvar sin = Math.sin( phi );\n\t\t\tvar cos = Math.cos( phi );\n\n\t\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tbase = j + i * points.length;\n\n\t\t\t\t// indices\n\t\t\t\tvar a = base;\n\t\t\t\tvar b = base + points.length;\n\t\t\t\tvar c = base + points.length + 1;\n\t\t\t\tvar d = base + 1;\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\t// generate normals\n\n\t\tthis.computeVertexNormals();\n\n\t\t// if the geometry is closed, we need to average the normals along the seam.\n\t\t// because the corresponding vertices are identical (but still have different UVs).\n\n\t\tif( phiLength === Math.PI * 2 ) {\n\n\t\t\tvar normals = this.attributes.normal.array;\n\t\t\tvar n1 = new Vector3();\n\t\t\tvar n2 = new Vector3();\n\t\t\tvar n = new Vector3();\n\n\t\t\t// this is the buffer offset for the last line of vertices\n\t\t\tbase = segments * points.length * 3;\n\n\t\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t\t// select the normal of the vertex in the first line\n\t\t\t\tn1.x = normals[ j + 0 ];\n\t\t\t\tn1.y = normals[ j + 1 ];\n\t\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t\t// select the normal of the vertex in the last line\n\t\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t\t// average normals\n\t\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t\t// assign the new values to both normals\n\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t\t} // next row\n\n\t\t}\n\n\t}\n\n\tLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\n\n\t/**\n\t * @author astrodud / http://astrodud.isgreat.org/\n\t * @author zz85 / https://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t */\n\n\t// points - to create a closed torus, one must use a set of points\n\t//    like so: [ a, b, c, d, a ], see first is the same as last.\n\t// segments - the number of circumference segments to create\n\t// phiStart - the starting radian\n\t// phiLength - the radian (0 to 2PI) range of the lathed section\n\t//    2PI is a closed lathe, less than 2PI is a portion.\n\n\tfunction LatheGeometry( points, segments, phiStart, phiLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tLatheGeometry.prototype = Object.create( Geometry.prototype );\n\tLatheGeometry.prototype.constructor = LatheGeometry;\n\n\t/**\n\t * @author jonobr1 / http://jonobr1.com\n\t *\n\t * Creates a one-sided polygonal geometry from a path shape. Similar to\n\t * ExtrudeGeometry.\n\t *\n\t * parameters = {\n\t *\n\t *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n\t *\n\t *\tmaterial: <int> // material index for front and back faces\n\t *\tuvGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t **/\n\n\tfunction ShapeGeometry( shapes, options ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ShapeGeometry';\n\n\t\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\n\n\t\tthis.addShapeList( shapes, options );\n\n\t\tthis.computeFaceNormals();\n\n\t}\n\n\tShapeGeometry.prototype = Object.create( Geometry.prototype );\n\tShapeGeometry.prototype.constructor = ShapeGeometry;\n\n\t/**\n\t * Add an array of shapes to THREE.ShapeGeometry.\n\t */\n\tShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tthis.addShape( shapes[ i ], options );\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n\t */\n\tShapeGeometry.prototype.addShape = function ( shape, options ) {\n\n\t\tif ( options === undefined ) options = {};\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\t\tvar material = options.material;\n\t\tvar uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\n\t\t//\n\n\t\tvar i, l, hole;\n\n\t\tvar shapesOffset = this.vertices.length;\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\tif ( reverse ) {\n\n\t\t\tvertices = vertices.reverse();\n\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\n\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\t\t\thole = holes[ i ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( hole ) ) {\n\n\t\t\t\t\tholes[ i ] = hole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treverse = false;\n\n\t\t}\n\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t// Vertices\n\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\t\thole = holes[ i ];\n\t\t\tvertices = vertices.concat( hole );\n\n\t\t}\n\n\t\t//\n\n\t\tvar vert, vlen = vertices.length;\n\t\tvar face, flen = faces.length;\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = vertices[ i ];\n\n\t\t\tthis.vertices.push( new Vector3( vert.x, vert.y, 0 ) );\n\n\t\t}\n\n\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\tface = faces[ i ];\n\n\t\t\tvar a = face[ 0 ] + shapesOffset;\n\t\t\tvar b = face[ 1 ] + shapesOffset;\n\t\t\tvar c = face[ 2 ] + shapesOffset;\n\n\t\t\tthis.faces.push( new Face3( a, b, c, null, null, material ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction EdgesGeometry( geometry, thresholdAngle ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\t\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\n\n\t\tvar edge = [ 0, 0 ], hash = {};\n\n\t\tfunction sortFunction( a, b ) {\n\n\t\t\treturn a - b;\n\n\t\t}\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tvar geometry2;\n\n\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\tgeometry2 = new Geometry();\n\t\t\tgeometry2.fromBufferGeometry( geometry );\n\n\t\t} else {\n\n\t\t\tgeometry2 = geometry.clone();\n\n\t\t}\n\n\t\tgeometry2.mergeVertices();\n\t\tgeometry2.computeFaceNormals();\n\n\t\tvar vertices = geometry2.vertices;\n\t\tvar faces = geometry2.faces;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\tvar key = edge.toString();\n\n\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\n\t\t\t\t} else {\n\n\t\t\t\t\thash[ key ].face2 = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar coords = [];\n\n\t\tfor ( var key in hash ) {\n\n\t\t\tvar h = hash[ key ];\n\n\t\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\n\n\t\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\t\tcoords.push( vertex.x );\n\t\t\t\tcoords.push( vertex.y );\n\t\t\t\tcoords.push( vertex.z );\n\n\t\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\t\tcoords.push( vertex.x );\n\t\t\t\tcoords.push( vertex.y );\n\t\t\t\tcoords.push( vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addAttribute( 'position', new BufferAttribute( new Float32Array( coords ), 3 ) );\n\n\t}\n\n\tEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tEdgesGeometry.prototype.constructor = EdgesGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'CylinderBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tvar scope = this;\n\n\t\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\t\theight = height !== undefined ? height : 100;\n\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\n\t\topenEnded = openEnded !== undefined ? openEnded : false;\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\n\t\t// used to calculate buffer length\n\n\t\tvar nbCap = 0;\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) nbCap ++;\n\t\t\tif ( radiusBottom > 0 ) nbCap ++;\n\n\t\t}\n\n\t\tvar vertexCount = calculateVertexCount();\n\t\tvar indexCount = calculateIndexCount();\n\n\t\t// buffers\n\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// helper variables\n\n\t\tvar index = 0,\n\t\t    indexOffset = 0,\n\t\t    indexArray = [],\n\t\t    halfHeight = height / 2;\n\n\t\t// group variables\n\t\tvar groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\t// helper functions\n\n\t\tfunction calculateVertexCount() {\n\n\t\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\n\n\t\t\tif ( openEnded === false ) {\n\n\t\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\n\n\t\t\t}\n\n\t\t\treturn count;\n\n\t\t}\n\n\t\tfunction calculateIndexCount() {\n\n\t\t\tvar count = radialSegments * heightSegments * 2 * 3;\n\n\t\t\tif ( openEnded === false ) {\n\n\t\t\t\tcount += radialSegments * nbCap * 3;\n\n\t\t\t}\n\n\t\t\treturn count;\n\n\t\t}\n\n\t\tfunction generateTorso() {\n\n\t\t\tvar x, y;\n\t\t\tvar normal = new Vector3();\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tvar groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tvar slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tvar indexRow = [];\n\n\t\t\t\tvar v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\t\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tvar u = x / radialSegments;\n\n\t\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\t\t\t\tvar cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\t\t\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\t\t\t\t\tindexRow.push( index );\n\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\t\tvar i1 = indexArray[ y ][ x ];\n\t\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// face one\n\t\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t\t// face two\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t\t// update counters\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\tvar x, centerIndexStart, centerIndexEnd;\n\n\t\t\tvar uv = new Vector2();\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tvar groupCount = 0;\n\n\t\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tvar sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// save the index of the first center vertex\n\t\t\tcenterIndexStart = index;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\t\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = 0.5;\n\t\t\t\tuv.y = 0.5;\n\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\t\t\tcenterIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tvar u = x / radialSegments;\n\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\t\tvar sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tvar c = centerIndexStart + x;\n\t\t\t\tvar i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t\t}\n\n\t\t\t\t// update counters\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n\tCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'CylinderGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tCylinderGeometry.prototype = Object.create( Geometry.prototype );\n\tCylinderGeometry.prototype.constructor = CylinderGeometry;\n\n\t/**\n\t * @author abelnation / http://github.com/abelnation\n\t */\n\n\tfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\n\tConeGeometry.prototype.constructor = ConeGeometry;\n\n\t/**\n\t * @author: abelnation / http://github.com/abelnation\n\t */\n\n\tfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\n\tConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'CircleBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tradius = radius || 50;\n\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\tvar vertices = segments + 2;\n\n\t\tvar positions = new Float32Array( vertices * 3 );\n\t\tvar normals = new Float32Array( vertices * 3 );\n\t\tvar uvs = new Float32Array( vertices * 2 );\n\n\t\t// center data is already zero, but need to set a few extras\n\t\tnormals[ 2 ] = 1.0;\n\t\tuvs[ 0 ] = 0.5;\n\t\tuvs[ 1 ] = 0.5;\n\n\t\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\n\n\t\t\tvar segment = thetaStart + s / segments * thetaLength;\n\n\t\t\tpositions[ i ] = radius * Math.cos( segment );\n\t\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\n\n\t\t\tnormals[ i + 2 ] = 1; // normal z\n\n\t\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\n\t\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t}\n\n\t\tvar indices = [];\n\n\t\tfor ( var i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\tthis.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\n\t}\n\n\tCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\n\n\t/**\n\t * @author hughes\n\t */\n\n\tfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'CircleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\n\t}\n\n\tCircleGeometry.prototype = Object.create( Geometry.prototype );\n\tCircleGeometry.prototype.constructor = CircleGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n\t */\n\n\tfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tBoxGeometry.prototype = Object.create( Geometry.prototype );\n\tBoxGeometry.prototype.constructor = BoxGeometry;\n\n\n\n\tvar Geometries = Object.freeze({\n\t\tWireframeGeometry: WireframeGeometry,\n\t\tParametricGeometry: ParametricGeometry,\n\t\tParametricBufferGeometry: ParametricBufferGeometry,\n\t\tTetrahedronGeometry: TetrahedronGeometry,\n\t\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\n\t\tOctahedronGeometry: OctahedronGeometry,\n\t\tOctahedronBufferGeometry: OctahedronBufferGeometry,\n\t\tIcosahedronGeometry: IcosahedronGeometry,\n\t\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\n\t\tDodecahedronGeometry: DodecahedronGeometry,\n\t\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\n\t\tPolyhedronGeometry: PolyhedronGeometry,\n\t\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\n\t\tTubeGeometry: TubeGeometry,\n\t\tTubeBufferGeometry: TubeBufferGeometry,\n\t\tTorusKnotGeometry: TorusKnotGeometry,\n\t\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\n\t\tTorusGeometry: TorusGeometry,\n\t\tTorusBufferGeometry: TorusBufferGeometry,\n\t\tTextGeometry: TextGeometry,\n\t\tSphereBufferGeometry: SphereBufferGeometry,\n\t\tSphereGeometry: SphereGeometry,\n\t\tRingGeometry: RingGeometry,\n\t\tRingBufferGeometry: RingBufferGeometry,\n\t\tPlaneBufferGeometry: PlaneBufferGeometry,\n\t\tPlaneGeometry: PlaneGeometry,\n\t\tLatheGeometry: LatheGeometry,\n\t\tLatheBufferGeometry: LatheBufferGeometry,\n\t\tShapeGeometry: ShapeGeometry,\n\t\tExtrudeGeometry: ExtrudeGeometry,\n\t\tEdgesGeometry: EdgesGeometry,\n\t\tConeGeometry: ConeGeometry,\n\t\tConeBufferGeometry: ConeBufferGeometry,\n\t\tCylinderGeometry: CylinderGeometry,\n\t\tCylinderBufferGeometry: CylinderBufferGeometry,\n\t\tCircleBufferGeometry: CircleBufferGeometry,\n\t\tCircleGeometry: CircleGeometry,\n\t\tBoxBufferGeometry: BoxBufferGeometry,\n\t\tBoxGeometry: BoxGeometry\n\t});\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ShadowMaterial() {\n\n\t\tShaderMaterial.call( this, {\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib[ \"lights\" ],\n\t\t\t\t{\n\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t}\n\t\t\t] ),\n\t\t\tvertexShader: ShaderChunk[ 'shadow_vert' ],\n\t\t\tfragmentShader: ShaderChunk[ 'shadow_frag' ]\n\t\t} );\n\n\t\tthis.lights = true;\n\t\tthis.transparent = true;\n\n\t\tObject.defineProperties( this, {\n\t\t\topacity: {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t}\n\n\tShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\tShadowMaterial.prototype.constructor = ShadowMaterial;\n\n\tShadowMaterial.prototype.isShadowMaterial = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction RawShaderMaterial( parameters ) {\n\n\t\tShaderMaterial.call( this, parameters );\n\n\t\tthis.type = 'RawShaderMaterial';\n\n\t}\n\n\tRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\tRawShaderMaterial.prototype.constructor = RawShaderMaterial;\n\n\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction MultiMaterial( materials ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.type = 'MultiMaterial';\n\n\t\tthis.materials = materials instanceof Array ? materials : [];\n\n\t\tthis.visible = true;\n\n\t}\n\n\tMultiMaterial.prototype = {\n\n\t\tconstructor: MultiMaterial,\n\n\t\tisMultiMaterial: true,\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.2,\n\t\t\t\t\ttype: 'material',\n\t\t\t\t\tgenerator: 'MaterialExporter'\n\t\t\t\t},\n\t\t\t\tuuid: this.uuid,\n\t\t\t\ttype: this.type,\n\t\t\t\tmaterials: []\n\t\t\t};\n\n\t\t\tvar materials = this.materials;\n\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tvar material = materials[ i ].toJSON( meta );\n\t\t\t\tdelete material.metadata;\n\n\t\t\t\toutput.materials.push( material );\n\n\t\t\t}\n\n\t\t\toutput.visible = this.visible;\n\n\t\t\treturn output;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\tvar material = new this.constructor();\n\n\t\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\n\t\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tmaterial.visible = this.visible;\n\n\t\t\treturn material;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  roughness: <float>,\n\t *  metalness: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  roughnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  metalnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *  envMapIntensity: <float>\n\t *\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshStandardMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.type = 'MeshStandardMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.roughness = 0.5;\n\t\tthis.metalness = 0.5;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.roughnessMap = null;\n\n\t\tthis.metalnessMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapIntensity = 1.0;\n\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshStandardMaterial.prototype = Object.create( Material.prototype );\n\tMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\n\n\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\n\tMeshStandardMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.color.copy( source.color );\n\t\tthis.roughness = source.roughness;\n\t\tthis.metalness = source.metalness;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.roughnessMap = source.roughnessMap;\n\n\t\tthis.metalnessMap = source.metalnessMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapIntensity = source.envMapIntensity;\n\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  reflectivity: <float>\n\t * }\n\t */\n\n\tfunction MeshPhysicalMaterial( parameters ) {\n\n\t\tMeshStandardMaterial.call( this );\n\n\t\tthis.defines = { 'PHYSICAL': '' };\n\n\t\tthis.type = 'MeshPhysicalMaterial';\n\n\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\t\tthis.clearCoat = 0.0;\n\t\tthis.clearCoatRoughness = 0.0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\n\tMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\n\n\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\n\tMeshPhysicalMaterial.prototype.copy = function ( source ) {\n\n\t\tMeshStandardMaterial.prototype.copy.call( this, source );\n\n\t\tthis.defines = { 'PHYSICAL': '' };\n\n\t\tthis.reflectivity = source.reflectivity;\n\n\t\tthis.clearCoat = source.clearCoat;\n\t\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  specular: <hex>,\n\t *  shininess: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshPhongMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshPhongMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.specular = new Color( 0x111111 );\n\t\tthis.shininess = 30;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshPhongMaterial.prototype = Object.create( Material.prototype );\n\tMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\n\n\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\n\tMeshPhongMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.specular.copy( source.specular );\n\t\tthis.shininess = source.shininess;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * parameters = {\n\t *  opacity: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t * }\n\t */\n\n\tfunction MeshNormalMaterial( parameters ) {\n\n\t\tMaterial.call( this, parameters );\n\n\t\tthis.type = 'MeshNormalMaterial';\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshNormalMaterial.prototype = Object.create( Material.prototype );\n\tMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\n\n\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\n\tMeshNormalMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshLambertMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshLambertMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshLambertMaterial.prototype = Object.create( Material.prototype );\n\tMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\n\n\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\n\tMeshLambertMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *\n\t *  scale: <float>,\n\t *  dashSize: <float>,\n\t *  gapSize: <float>\n\t * }\n\t */\n\n\tfunction LineDashedMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'LineDashedMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.scale = 1;\n\t\tthis.dashSize = 3;\n\t\tthis.gapSize = 1;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tLineDashedMaterial.prototype = Object.create( Material.prototype );\n\tLineDashedMaterial.prototype.constructor = LineDashedMaterial;\n\n\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\n\tLineDashedMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.linewidth = source.linewidth;\n\n\t\tthis.scale = source.scale;\n\t\tthis.dashSize = source.dashSize;\n\t\tthis.gapSize = source.gapSize;\n\n\t\treturn this;\n\n\t};\n\n\n\n\tvar Materials = Object.freeze({\n\t\tShadowMaterial: ShadowMaterial,\n\t\tSpriteMaterial: SpriteMaterial,\n\t\tRawShaderMaterial: RawShaderMaterial,\n\t\tShaderMaterial: ShaderMaterial,\n\t\tPointsMaterial: PointsMaterial,\n\t\tMultiMaterial: MultiMaterial,\n\t\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\t\tMeshStandardMaterial: MeshStandardMaterial,\n\t\tMeshPhongMaterial: MeshPhongMaterial,\n\t\tMeshNormalMaterial: MeshNormalMaterial,\n\t\tMeshLambertMaterial: MeshLambertMaterial,\n\t\tMeshDepthMaterial: MeshDepthMaterial,\n\t\tMeshBasicMaterial: MeshBasicMaterial,\n\t\tLineDashedMaterial: LineDashedMaterial,\n\t\tLineBasicMaterial: LineBasicMaterial,\n\t\tMaterial: Material\n\t});\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar Cache = {\n\n\t\tenabled: false,\n\n\t\tfiles: {},\n\n\t\tadd: function ( key, file ) {\n\n\t\t\tif ( this.enabled === false ) return;\n\n\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\t\tthis.files[ key ] = file;\n\n\t\t},\n\n\t\tget: function ( key ) {\n\n\t\t\tif ( this.enabled === false ) return;\n\n\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\t\treturn this.files[ key ];\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete this.files[ key ];\n\n\t\t},\n\n\t\tclear: function () {\n\n\t\t\tthis.files = {};\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LoadingManager( onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\n\t\tthis.onStart = undefined;\n\t\tthis.onLoad = onLoad;\n\t\tthis.onProgress = onProgress;\n\t\tthis.onError = onError;\n\n\t\tthis.itemStart = function ( url ) {\n\n\t\t\titemsTotal ++;\n\n\t\t\tif ( isLoading === false ) {\n\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tisLoading = true;\n\n\t\t};\n\n\t\tthis.itemEnd = function ( url ) {\n\n\t\t\titemsLoaded ++;\n\n\t\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\t\tisLoading = false;\n\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\t\tscope.onLoad();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.itemError = function ( url ) {\n\n\t\t\tif ( scope.onError !== undefined ) {\n\n\t\t\t\tscope.onError( url );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tvar DefaultLoadingManager = new LoadingManager();\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction XHRLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( XHRLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tif ( url === undefined ) url = '';\n\n\t\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\t\tvar scope = this;\n\n\t\t\tvar cached = Cache.get( url );\n\n\t\t\tif ( cached !== undefined ) {\n\n\t\t\t\tscope.manager.itemStart( url );\n\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t\treturn cached;\n\n\t\t\t}\n\n\t\t\t// Check for data: URI\n\t\t\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\t\tvar dataUriRegexResult = url.match( dataUriRegex );\n\n\t\t\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\n\t\t\tif ( dataUriRegexResult ) {\n\n\t\t\t\tvar mimeType = dataUriRegexResult[1];\n\t\t\t\tvar isBase64 = !!dataUriRegexResult[2];\n\t\t\t\tvar data = dataUriRegexResult[3];\n\n\t\t\t\tdata = window.decodeURIComponent(data);\n\n\t\t\t\tif( isBase64 ) {\n\t\t\t\t\tdata = window.atob(data);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar response;\n\t\t\t\t\tvar responseType = ( this.responseType || '' ).toLowerCase();\n\n\t\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\t \tresponse = new ArrayBuffer( data.length );\n\t\t\t\t\t\t\tvar view = new Uint8Array( response );\n\t\t\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tview[ i ] = data.charCodeAt( i );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( responseType === 'blob' ) {\n\n\t\t\t\t\t\t\t\tresponse = new Blob( [ response ], { \"type\" : mimeType } );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\t\tvar parser = new DOMParser();\n\t\t\t\t\t\t\tresponse = parser.parseFromString( data, mimeType );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\t\tresponse = JSON.parse( data );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault: // 'text' or other\n\n\t\t\t\t\t\t\tresponse = data;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Wait for next browser tick\n\t\t\t\t\twindow.setTimeout( function() {\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t}, 0);\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t// Wait for next browser tick\n\t\t\t\t\twindow.setTimeout( function() {\n\n\t\t\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t\t}, 0);\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar request = new XMLHttpRequest();\n\t\t\t\trequest.open( 'GET', url, true );\n\n\t\t\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\t\t\tvar response = event.target.response;\n\n\t\t\t\t\tCache.add( url, response );\n\n\t\t\t\t\tif ( this.status === 200 ) {\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t} else if ( this.status === 0 ) {\n\n\t\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, false );\n\n\t\t\t\tif ( onProgress !== undefined ) {\n\n\t\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\t\t\tonProgress( event );\n\n\t\t\t\t\t}, false );\n\n\t\t\t\t}\n\n\t\t\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t}, false );\n\n\t\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\t\t\tif ( request.overrideMimeType ) request.overrideMimeType( 'text/plain' );\n\n\t\t\t\trequest.send( null );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn request;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetResponseType: function ( value ) {\n\n\t\t\tthis.responseType = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWithCredentials: function ( value ) {\n\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\n\t */\n\n\tfunction CompressedTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\t// override in sub classes\n\t\tthis._parser = null;\n\n\t}\n\n\tObject.assign( CompressedTextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar images = [];\n\n\t\t\tvar texture = new CompressedTexture();\n\t\t\ttexture.image = images;\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tfunction loadTexture( i ) {\n\n\t\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\t\timages[ i ] = {\n\t\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t\t};\n\n\t\t\t\t\tloaded += 1;\n\n\t\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\tvar loaded = 0;\n\n\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\t\tloadTexture( i );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\n\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author Nikos M. / https://github.com/foo123/\n\t *\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n\t */\n\n\tvar DataTextureLoader = BinaryTextureLoader;\n\tfunction BinaryTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\t// override in sub classes\n\t\tthis._parser = null;\n\n\t}\n\n\tObject.assign( BinaryTextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar texture = new DataTexture();\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar texData = scope._parser( buffer );\n\n\t\t\t\tif ( ! texData ) return;\n\n\t\t\t\tif ( undefined !== texData.image ) {\n\n\t\t\t\t\ttexture.image = texData.image;\n\n\t\t\t\t} else if ( undefined !== texData.data ) {\n\n\t\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;\n\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;\n\n\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\n\t\t\t\tif ( undefined !== texData.format ) {\n\n\t\t\t\t\ttexture.format = texData.format;\n\n\t\t\t\t}\n\t\t\t\tif ( undefined !== texData.type ) {\n\n\t\t\t\t\ttexture.type = texData.type;\n\n\t\t\t\t}\n\n\t\t\t\tif ( undefined !== texData.mipmaps ) {\n\n\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( 1 === texData.mipmapCount ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t\t}, onProgress, onError );\n\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ImageLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( ImageLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\t\timage.onload = function () {\n\n\t\t\t\timage.onload = null;\n\n\t\t\t\tURL.revokeObjectURL( image.src );\n\n\t\t\t\tif ( onLoad ) onLoad( image );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t};\n\t\t\timage.onerror = onError;\n\n\t\t\tif ( url.indexOf( 'data:' ) === 0 ) {\n\n\t\t\t\timage.src = url;\n\n\t\t\t} else {\n\n\t\t\t\tvar loader = new XHRLoader();\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.setResponseType( 'blob' );\n\t\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\t\tloader.load( url, function ( blob ) {\n\n\t\t\t\t\timage.src = URL.createObjectURL( blob );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn image;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWithCredentials: function ( value ) {\n\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CubeTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( CubeTextureLoader.prototype, {\n\n\t\tload: function ( urls, onLoad, onProgress, onError ) {\n\n\t\t\tvar texture = new CubeTexture();\n\n\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\tloader.setPath( this.path );\n\n\t\t\tvar loaded = 0;\n\n\t\t\tfunction loadTexture( i ) {\n\n\t\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\t\tloaded ++;\n\n\t\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, undefined, onError );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction TextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( TextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar texture = new Texture();\n\n\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.load( url, function ( image ) {\n\n\t\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\t\tvar isJPEG = url.search( /\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\n\t\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\t\ttexture.image = image;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\t\tonLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWithCredentials: function ( value ) {\n\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Light( color, intensity ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Light';\n\n\t\tthis.color = new Color( color );\n\t\tthis.intensity = intensity !== undefined ? intensity : 1;\n\n\t\tthis.receiveShadow = undefined;\n\n\t}\n\n\tLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Light,\n\n\t\tisLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.intensity = source.intensity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.color = this.color.getHex();\n\t\t\tdata.object.intensity = this.intensity;\n\n\t\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction HemisphereLight( skyColor, groundColor, intensity ) {\n\n\t\tLight.call( this, skyColor, intensity );\n\n\t\tthis.type = 'HemisphereLight';\n\n\t\tthis.castShadow = undefined;\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.groundColor = new Color( groundColor );\n\n\t}\n\n\tHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: HemisphereLight,\n\n\t\tisHemisphereLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.groundColor.copy( source.groundColor );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LightShadow( camera ) {\n\n\t\tthis.camera = camera;\n\n\t\tthis.bias = 0;\n\t\tthis.radius = 1;\n\n\t\tthis.mapSize = new Vector2( 512, 512 );\n\n\t\tthis.map = null;\n\t\tthis.matrix = new Matrix4();\n\n\t}\n\n\tObject.assign( LightShadow.prototype, {\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.camera = source.camera.clone();\n\n\t\t\tthis.bias = source.bias;\n\t\t\tthis.radius = source.radius;\n\n\t\t\tthis.mapSize.copy( source.mapSize );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar object = {};\n\n\t\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\t\tdelete object.camera.matrix;\n\n\t\t\treturn object;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction SpotLightShadow() {\n\n\t\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n\t}\n\n\tSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n\t\tconstructor: SpotLightShadow,\n\n\t\tisSpotLightShadow: true,\n\n\t\tupdate: function ( light ) {\n\n\t\t\tvar fov = _Math.RAD2DEG * 2 * light.angle;\n\t\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\t\tvar far = light.distance || 500;\n\n\t\t\tvar camera = this.camera;\n\n\t\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\t\tcamera.fov = fov;\n\t\t\t\tcamera.aspect = aspect;\n\t\t\t\tcamera.far = far;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'SpotLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tObject.defineProperty( this, 'power', {\n\t\t\tget: function () {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\treturn this.intensity * Math.PI;\n\t\t\t},\n\t\t\tset: function ( power ) {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\tthis.intensity = power / Math.PI;\n\t\t\t}\n\t\t} );\n\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\t\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\t\tthis.shadow = new SpotLightShadow();\n\n\t}\n\n\tSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: SpotLight,\n\n\t\tisSpotLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.angle = source.angle;\n\t\t\tthis.penumbra = source.penumbra;\n\t\t\tthis.decay = source.decay;\n\n\t\t\tthis.target = source.target.clone();\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\n\tfunction PointLight( color, intensity, distance, decay ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'PointLight';\n\n\t\tObject.defineProperty( this, 'power', {\n\t\t\tget: function () {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\treturn this.intensity * 4 * Math.PI;\n\n\t\t\t},\n\t\t\tset: function ( power ) {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\t\t}\n\t\t} );\n\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\t\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n\t}\n\n\tPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: PointLight,\n\n\t\tisPointLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.decay = source.decay;\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction DirectionalLightShadow( light ) {\n\n\t\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n\t}\n\n\tDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n\t\tconstructor: DirectionalLightShadow\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction DirectionalLight( color, intensity ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'DirectionalLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.shadow = new DirectionalLightShadow();\n\n\t}\n\n\tDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: DirectionalLight,\n\n\t\tisDirectionalLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.target = source.target.clone();\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AmbientLight( color, intensity ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'AmbientLight';\n\n\t\tthis.castShadow = undefined;\n\n\t}\n\n\tAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: AmbientLight,\n\n\t\tisAmbientLight: true,\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\n\tvar AnimationUtils = {\n\n\t\t// same as Array.prototype.slice, but also works on typed arrays\n\t\tarraySlice: function( array, from, to ) {\n\n\t\t\tif ( AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\n\t\t\t}\n\n\t\t\treturn array.slice( from, to );\n\n\t\t},\n\n\t\t// converts an array to a specific type\n\t\tconvertArray: function( array, type, forceClone ) {\n\n\t\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\t\treturn new type( array ); // create typed array\n\n\t\t\t}\n\n\t\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t\t},\n\n\t\tisTypedArray: function( object ) {\n\n\t\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t\t! ( object instanceof DataView );\n\n\t\t},\n\n\t\t// returns an array by which times and values can be sorted\n\t\tgetKeyframeOrder: function( times ) {\n\n\t\t\tfunction compareTime( i, j ) {\n\n\t\t\t\treturn times[ i ] - times[ j ];\n\n\t\t\t}\n\n\t\t\tvar n = times.length;\n\t\t\tvar result = new Array( n );\n\t\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\t\tresult.sort( compareTime );\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\t\tsortedArray: function( values, stride, order ) {\n\n\t\t\tvar nValues = values.length;\n\t\t\tvar result = new values.constructor( nValues );\n\n\t\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\t\tvar srcOffset = order[ i ] * stride;\n\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// function for parsing AOS keyframe formats\n\t\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\n\t\t\tvar i = 1, key = jsonKeys[ 0 ];\n\n\t\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t}\n\n\t\t\tif ( key === undefined ) return; // no data\n\n\t\t\tvar value = key[ valuePropertyName ];\n\t\t\tif ( value === undefined ) return; // no data\n\n\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t} else if ( value.toArray !== undefined ) {\n\t\t\t\t// ...assume THREE.Math-ish\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t} else {\n\t\t\t\t// otherwise push as-is\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Abstract base class of interpolants over parametric samples.\n\t *\n\t * The parameter domain is one dimensional, typically the time or a path\n\t * along a curve defined by the data.\n\t *\n\t * The sample values can have any dimensionality and derived classes may\n\t * apply special interpretations to the data.\n\t *\n\t * This class provides the interval seek in a Template Method, deferring\n\t * the actual interpolation to derived classes.\n\t *\n\t * Time complexity is O(1) for linear access crossing at most two points\n\t * and O(log N) for random access, where N is the number of positions.\n\t *\n\t * References:\n\t *\n\t * \t\thttp://www.oodesign.com/template-method-pattern.html\n\t *\n\t * @author tschw\n\t */\n\n\tfunction Interpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\n\t}\n\n\tInterpolant.prototype = {\n\n\t\tconstructor: Interpolant,\n\n\t\tevaluate: function( t ) {\n\n\t\t\tvar pp = this.parameterPositions,\n\t\t\t\ti1 = this._cachedIndex,\n\n\t\t\t\tt1 = pp[   i1   ],\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\tvalidate_interval: {\n\n\t\t\t\tseek: {\n\n\t\t\t\t\tvar right;\n\n\t\t\t\t\tlinear_scan: {\n\t//- See http://jsperf.com/comparison-to-undefined/3\n\t//- slower code:\n\t//-\n\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\n\n\t\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t\t}\n\n\t//- slower code:\n\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\n\t\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\n\n\t\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t\t} // linear scan\n\n\t\t\t\t\t// binary search\n\n\t\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tt1 = pp[   i1   ];\n\t\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t\t// check boundary cases, again\n\n\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t\t}\n\n\t\t\t\t} // seek\n\n\t\t\t\tthis._cachedIndex = i1;\n\n\t\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t\t} // validate_interval\n\n\t\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t\t},\n\n\t\tsettings: null, // optional, subclass-specific settings structure\n\t\t// Note: The indirection allows central control of many interpolants.\n\n\t\t// --- Protected interface\n\n\t\tDefaultSettings_: {},\n\n\t\tgetSettings_: function() {\n\n\t\t\treturn this.settings || this.DefaultSettings_;\n\n\t\t},\n\n\t\tcopySampleValue_: function( index ) {\n\n\t\t\t// copies a sample value to the result buffer\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\t\t\t\toffset = index * stride;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// Template methods for derived classes:\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tthrow new Error( \"call to abstract method\" );\n\t\t\t// implementations shall return this.resultBuffer\n\n\t\t},\n\n\t\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\t\t// empty\n\n\t\t}\n\n\t};\n\n\tObject.assign( Interpolant.prototype, {\n\n\t\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\n\t\t\tInterpolant.prototype.copySampleValue_,\n\n\t\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\n\t\t\tInterpolant.prototype.copySampleValue_\n\n\t} );\n\n\t/**\n\t * Fast and simple cubic spline interpolant.\n\t *\n\t * It was derived from a Hermitian construction setting the first derivative\n\t * at each sample position to the linear slope between neighboring positions\n\t * over their parameter interval.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction CubicInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\tthis._weightPrev = -0;\n\t\tthis._offsetPrev = -0;\n\t\tthis._weightNext = -0;\n\t\tthis._offsetNext = -0;\n\n\t}\n\n\tCubicInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: CubicInterpolant,\n\n\t\tDefaultSettings_: {\n\n\t\t\tendingStart: \tZeroCurvatureEnding,\n\t\t\tendingEnd:\t\tZeroCurvatureEnding\n\n\t\t},\n\n\t\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\t\tvar pp = this.parameterPositions,\n\t\t\t\tiPrev = i1 - 2,\n\t\t\t\tiNext = i1 + 1,\n\n\t\t\t\ttPrev = pp[ iPrev ],\n\t\t\t\ttNext = pp[ iNext ];\n\n\t\t\tif ( tPrev === undefined ) {\n\n\t\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = t1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( tNext === undefined ) {\n\n\t\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\t\tiNext = i1;\n\t\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiNext = 1;\n\t\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\t\ttNext = t0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\t\tstride = this.valueSize;\n\n\t\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\t\tthis._offsetPrev = iPrev * stride;\n\t\t\tthis._offsetNext = iNext * stride;\n\n\t\t},\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\tpp = p * p,\n\t\t\t\tppp = pp * p;\n\n\t\t\t// evaluate polynomials\n\n\t\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n\t\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n\t\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n\t\t\tvar sN =       wN   * ppp   -           wN      * pp;\n\n\t\t\t// combine data linearly\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] =\n\t\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t */\n\n\tfunction LinearInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tLinearInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: LinearInterpolant,\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toffset1 = i1 * stride,\n\t\t\t\toffset0 = offset1 - stride,\n\n\t\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\tweight0 = 1 - weight1;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] =\n\t\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Interpolant that evaluates to the sample value at the position preceeding\n\t * the parameter.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction DiscreteInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tDiscreteInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: DiscreteInterpolant,\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t}\n\n\t} );\n\n\tvar KeyframeTrackPrototype;\n\n\tKeyframeTrackPrototype = {\n\n\t\tTimeBufferType: Float32Array,\n\t\tValueBufferType: Float32Array,\n\n\t\tDefaultInterpolation: InterpolateLinear,\n\n\t\tInterpolantFactoryMethodDiscrete: function( result ) {\n\n\t\t\treturn new DiscreteInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\t\treturn new LinearInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodSmooth: function( result ) {\n\n\t\t\treturn new CubicInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tsetInterpolation: function( interpolation ) {\n\n\t\t\tvar factoryMethod;\n\n\t\t\tswitch ( interpolation ) {\n\n\t\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateLinear:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateSmooth:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( factoryMethod === undefined ) {\n\n\t\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\n\t\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( message );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.createInterpolant = factoryMethod;\n\n\t\t},\n\n\t\tgetInterpolation: function() {\n\n\t\t\tswitch ( this.createInterpolant ) {\n\n\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\t\treturn InterpolateLinear;\n\n\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\t\treturn InterpolateSmooth;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetValueSize: function() {\n\n\t\t\treturn this.values.length / this.times.length;\n\n\t\t},\n\n\t\t// move all keyframes either forwards or backwards in time\n\t\tshift: function( timeOffset ) {\n\n\t\t\tif( timeOffset !== 0.0 ) {\n\n\t\t\t\tvar times = this.times;\n\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\t\tscale: function( timeScale ) {\n\n\t\t\tif( timeScale !== 1.0 ) {\n\n\t\t\t\tvar times = this.times;\n\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\t\ttrim: function( startTime, endTime ) {\n\n\t\t\tvar times = this.times,\n\t\t\t\tnKeys = times.length,\n\t\t\t\tfrom = 0,\n\t\t\t\tto = nKeys - 1;\n\n\t\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\n\t\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\n\n\t\t\t++ to; // inclusive -> exclusive bound\n\n\t\t\tif( from !== 0 || to !== nKeys ) {\n\n\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\n\n\t\t\t\tvar stride = this.getValueSize();\n\t\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\t\tthis.values = AnimationUtils.\n\t\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\t\tvalidate: function() {\n\n\t\t\tvar valid = true;\n\n\t\t\tvar valueSize = this.getValueSize();\n\t\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\t\tconsole.error( \"invalid value size in track\", this );\n\t\t\t\tvalid = false;\n\n\t\t\t}\n\n\t\t\tvar times = this.times,\n\t\t\t\tvalues = this.values,\n\n\t\t\t\tnKeys = times.length;\n\n\t\t\tif( nKeys === 0 ) {\n\n\t\t\t\tconsole.error( \"track is empty\", this );\n\t\t\t\tvalid = false;\n\n\t\t\t}\n\n\t\t\tvar prevTime = null;\n\n\t\t\tfor( var i = 0; i !== nKeys; i ++ ) {\n\n\t\t\t\tvar currTime = times[ i ];\n\n\t\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tprevTime = currTime;\n\n\t\t\t}\n\n\t\t\tif ( values !== undefined ) {\n\n\t\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tvar value = values[ i ];\n\n\t\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\n\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn valid;\n\n\t\t},\n\n\t\t// removes equivalent sequential keys as common in morph target sequences\n\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\t\toptimize: function() {\n\n\t\t\tvar times = this.times,\n\t\t\t\tvalues = this.values,\n\t\t\t\tstride = this.getValueSize(),\n\n\t\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\t\twriteIndex = 1,\n\t\t\t\tlastIndex = times.length - 1;\n\n\t\t\tfor( var i = 1; i < lastIndex; ++ i ) {\n\n\t\t\t\tvar keep = false;\n\n\t\t\t\tvar time = times[ i ];\n\t\t\t\tvar timeNext = times[ i + 1 ];\n\n\t\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n\t\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\t\tvar offset = i * stride,\n\t\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\t\tvar value = values[ offset + j ];\n\n\t\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else keep = true;\n\n\t\t\t\t}\n\n\t\t\t\t// in-place compaction\n\n\t\t\t\tif ( keep ) {\n\n\t\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j )\n\n\t\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t++ writeIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// flush last keyframe (compaction looks ahead)\n\n\t\t\tif ( lastIndex > 0 ) {\n\n\t\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\t\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )\n\n\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t\tif ( writeIndex !== times.length ) {\n\n\t\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\tfunction KeyframeTrackConstructor( name, times, values, interpolation ) {\n\n\t\tif( name === undefined ) throw new Error( \"track name is undefined\" );\n\n\t\tif( times === undefined || times.length === 0 ) {\n\n\t\t\tthrow new Error( \"no keyframes in track named \" + name );\n\n\t\t}\n\n\t\tthis.name = name;\n\n\t\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\t\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t\tthis.validate();\n\t\tthis.optimize();\n\n\t}\n\n\t/**\n\t *\n\t * A Track of vectored keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction VectorKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tVectorKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: VectorKeyframeTrack,\n\n\t\tValueTypeName: 'vector'\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\t} );\n\n\t/**\n\t * Spherical linear unit quaternion interpolant.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction QuaternionLinearInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tQuaternionLinearInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: QuaternionLinearInterpolant,\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toffset = i1 * stride,\n\n\t\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\t\tQuaternion.slerpFlat( result, 0,\n\t\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of quaternion keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tQuaternionKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: QuaternionKeyframeTrack,\n\n\t\tValueTypeName: 'quaternion',\n\n\t\t// ValueBufferType is inherited\n\n\t\tDefaultInterpolation: InterpolateLinear,\n\n\t\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\t\treturn new QuaternionLinearInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of numeric keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction NumberKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tNumberKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: NumberKeyframeTrack,\n\n\t\tValueTypeName: 'number',\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\t} );\n\n\t/**\n\t *\n\t * A Track that interpolates Strings\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction StringKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tStringKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: StringKeyframeTrack,\n\n\t\tValueTypeName: 'string',\n\t\tValueBufferType: Array,\n\n\t\tDefaultInterpolation: InterpolateDiscrete,\n\n\t\tInterpolantFactoryMethodLinear: undefined,\n\n\t\tInterpolantFactoryMethodSmooth: undefined\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of Boolean keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction BooleanKeyframeTrack( name, times, values ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values );\n\n\t}\n\n\tBooleanKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: BooleanKeyframeTrack,\n\n\t\tValueTypeName: 'bool',\n\t\tValueBufferType: Array,\n\n\t\tDefaultInterpolation: InterpolateDiscrete,\n\n\t\tInterpolantFactoryMethodLinear: undefined,\n\t\tInterpolantFactoryMethodSmooth: undefined\n\n\t\t// Note: Actually this track could have a optimized / compressed\n\t\t// representation of a single value and a custom interpolant that\n\t\t// computes \"firstValue ^ isOdd( index )\".\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of keyframe values that represent color.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction ColorKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tColorKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: ColorKeyframeTrack,\n\n\t\tValueTypeName: 'color'\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\n\t\t// Note: Very basic implementation and nothing special yet.\n\t\t// However, this is the place for color space parameterization.\n\n\t} );\n\n\t/**\n\t *\n\t * A timed sequence of keyframes for a specific property.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction KeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.apply( this, arguments );\n\n\t}\n\n\tKeyframeTrack.prototype = KeyframeTrackPrototype;\n\tKeyframeTrackPrototype.constructor = KeyframeTrack;\n\n\t// Static methods:\n\n\tObject.assign( KeyframeTrack, {\n\n\t\t// Serialization (in static context, because of constructor invocation\n\t\t// and automatic invocation of .toJSON):\n\n\t\tparse: function( json ) {\n\n\t\t\tif( json.type === undefined ) {\n\n\t\t\t\tthrow new Error( \"track type undefined, can not parse\" );\n\n\t\t\t}\n\n\t\t\tvar trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\n\t\t\tif ( json.times === undefined ) {\n\n\t\t\t\tvar times = [], values = [];\n\n\t\t\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\t\t\tjson.times = times;\n\t\t\t\tjson.values = values;\n\n\t\t\t}\n\n\t\t\t// derived classes can define a static parse method\n\t\t\tif ( trackType.parse !== undefined ) {\n\n\t\t\t\treturn trackType.parse( json );\n\n\t\t\t} else {\n\n\t\t\t\t// by default, we asssume a constructor compatible with the base\n\t\t\t\treturn new trackType(\n\t\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function( track ) {\n\n\t\t\tvar trackType = track.constructor;\n\n\t\t\tvar json;\n\n\t\t\t// derived classes can define a static toJSON method\n\t\t\tif ( trackType.toJSON !== undefined ) {\n\n\t\t\t\tjson = trackType.toJSON( track );\n\n\t\t\t} else {\n\n\t\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\t\tjson = {\n\n\t\t\t\t\t'name': track.name,\n\t\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t\t};\n\n\t\t\t\tvar interpolation = track.getInterpolation();\n\n\t\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\t\treturn json;\n\n\t\t},\n\n\t\t_getTrackTypeForValueTypeName: function( typeName ) {\n\n\t\t\tswitch( typeName.toLowerCase() ) {\n\n\t\t\t\tcase \"scalar\":\n\t\t\t\tcase \"double\":\n\t\t\t\tcase \"float\":\n\t\t\t\tcase \"number\":\n\t\t\t\tcase \"integer\":\n\n\t\t\t\t\treturn NumberKeyframeTrack;\n\n\t\t\t\tcase \"vector\":\n\t\t\t\tcase \"vector2\":\n\t\t\t\tcase \"vector3\":\n\t\t\t\tcase \"vector4\":\n\n\t\t\t\t\treturn VectorKeyframeTrack;\n\n\t\t\t\tcase \"color\":\n\n\t\t\t\t\treturn ColorKeyframeTrack;\n\n\t\t\t\tcase \"quaternion\":\n\n\t\t\t\t\treturn QuaternionKeyframeTrack;\n\n\t\t\t\tcase \"bool\":\n\t\t\t\tcase \"boolean\":\n\n\t\t\t\t\treturn BooleanKeyframeTrack;\n\n\t\t\t\tcase \"string\":\n\n\t\t\t\t\treturn StringKeyframeTrack;\n\n\t\t\t}\n\n\t\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Reusable set of Tracks that represent an animation.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\n\tfunction AnimationClip( name, duration, tracks ) {\n\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = ( duration !== undefined ) ? duration : -1;\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t\tthis.optimize();\n\n\t}\n\n\tAnimationClip.prototype = {\n\n\t\tconstructor: AnimationClip,\n\n\t\tresetDuration: function() {\n\n\t\t\tvar tracks = this.tracks,\n\t\t\t\tduration = 0;\n\n\t\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\t\tvar track = this.tracks[ i ];\n\n\t\t\t\tduration = Math.max(\n\t\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tthis.duration = duration;\n\n\t\t},\n\n\t\ttrim: function() {\n\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\toptimize: function() {\n\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\t\tthis.tracks[ i ].optimize();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t// Static methods:\n\n\tObject.assign( AnimationClip, {\n\n\t\tparse: function( json ) {\n\n\t\t\tvar tracks = [],\n\t\t\t\tjsonTracks = json.tracks,\n\t\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\t\ttracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( json.name, json.duration, tracks );\n\n\t\t},\n\n\n\t\ttoJSON: function( clip ) {\n\n\t\t\tvar tracks = [],\n\t\t\t\tclipTracks = clip.tracks;\n\n\t\t\tvar json = {\n\n\t\t\t\t'name': clip.name,\n\t\t\t\t'duration': clip.duration,\n\t\t\t\t'tracks': tracks\n\n\t\t\t};\n\n\t\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t\t}\n\n\t\t\treturn json;\n\n\t\t},\n\n\n\t\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\n\n\t\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\t\tvar tracks = [];\n\n\t\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\n\t\t\t\ttimes.push(\n\t\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\t\tvar order = AnimationUtils.getKeyframeOrder( times );\n\t\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t\t// last frame as well for perfect loop.\n\t\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\ttracks.push(\n\t\t\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\t\ttimes, values\n\t\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\t\t}\n\n\t\t\treturn new AnimationClip( name, -1, tracks );\n\n\t\t},\n\n\t\tfindByName: function( objectOrClipArray, name ) {\n\n\t\t\tvar clipArray = objectOrClipArray;\n\n\t\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\t\tvar o = objectOrClipArray;\n\t\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\t\treturn clipArray[ i ];\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\n\n\t\t\tvar animationToMorphTargets = {};\n\n\t\t\t// tested with https://regex101.com/ on trick sequences\n\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t\t// sort morph target names into animation groups based\n\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\t\tvar parts = morphTarget.name.match( pattern );\n\n\t\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\t\tvar name = parts[ 1 ];\n\n\t\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar clips = [];\n\n\t\t\tfor ( var name in animationToMorphTargets ) {\n\n\t\t\t\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t\t}\n\n\t\t\treturn clips;\n\n\t\t},\n\n\t\t// parse the animation.hierarchy format\n\t\tparseAnimation: function( animation, bones ) {\n\n\t\t\tif ( ! animation ) {\n\n\t\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar addNonemptyTrack = function(\n\t\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t\t// only return track if there are actually keys.\n\t\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\n\t\t\t\t\tAnimationUtils.flattenJSON(\n\t\t\t\t\t\t\tanimationKeys, times, values, propertyName );\n\n\t\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar clipName = animation.name || 'default';\n\t\t\t// automatic length determination in AnimationClip.\n\t\t\tvar duration = animation.length || -1;\n\t\t\tvar fps = animation.fps || 30;\n\n\t\t\tvar hierarchyTracks = animation.hierarchy || [];\n\n\t\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t\t// skip empty tracks\n\t\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t\t// process morph targets in a way exactly compatible\n\t\t\t\t// with AnimationHandler.init( animation )\n\t\t\t\tif ( animationKeys[0].morphTargets ) {\n\n\t\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\t\tvar morphTargetNames = {};\n\t\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\n\n\t\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t\t// the morphTarget is named.\n\t\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\t\tvar times = [];\n\t\t\t\t\t\tvar values = [];\n\n\t\t\t\t\t\tfor ( var m = 0;\n\t\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\t\tvar animationKey = animationKeys[k];\n\n\t\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttracks.push( new NumberKeyframeTrack(\n\t\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t\t} else {\n\t\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( tracks.length === 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar clip = new AnimationClip( clipName, duration, tracks );\n\n\t\t\treturn clip;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction MaterialLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\tthis.textures = {};\n\n\t}\n\n\tObject.assign( MaterialLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTextures: function ( value ) {\n\n\t\t\tthis.textures = value;\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\tvar textures = this.textures;\n\n\t\t\tfunction getTexture( name ) {\n\n\t\t\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn textures[ name ];\n\n\t\t\t}\n\n\t\t\tvar material = new Materials[ json.type ]();\n\n\t\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\t\tif ( json.shading !== undefined ) material.shading = json.shading;\n\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\t\t\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\n\t\t\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\n\n\t\t\t// for PointsMaterial\n\n\t\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t\t// maps\n\n\t\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\n\t\t\tif ( json.alphaMap !== undefined ) {\n\n\t\t\t\tmaterial.alphaMap = getTexture( json.alphaMap );\n\t\t\t\tmaterial.transparent = true;\n\n\t\t\t}\n\n\t\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\t\tvar normalScale = json.normalScale;\n\n\t\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\n\t\t\t}\n\n\t\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n\t\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\n\t\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\n\t\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\n\t\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\t\t// MultiMaterial\n\n\t\t\tif ( json.materials !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\n\t\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferGeometryLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( BufferGeometryLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\tvar geometry = new BufferGeometry();\n\n\t\t\tvar index = json.data.index;\n\n\t\t\tvar TYPED_ARRAYS = {\n\t\t\t\t'Int8Array': Int8Array,\n\t\t\t\t'Uint8Array': Uint8Array,\n\t\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\n\t\t\t\t'Int16Array': Int16Array,\n\t\t\t\t'Uint16Array': Uint16Array,\n\t\t\t\t'Int32Array': Int32Array,\n\t\t\t\t'Uint32Array': Uint32Array,\n\t\t\t\t'Float32Array': Float32Array,\n\t\t\t\t'Float64Array': Float64Array\n\t\t\t};\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t\t}\n\n\t\t\tvar attributes = json.data.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ key ];\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\n\t\t\t\tgeometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\n\t\t\t}\n\n\t\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\t\tif ( groups !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar boundingSphere = json.data.boundingSphere;\n\n\t\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\t\tvar center = new Vector3();\n\n\t\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Loader() {\n\n\t\tthis.onLoadStart = function () {};\n\t\tthis.onLoadProgress = function () {};\n\t\tthis.onLoadComplete = function () {};\n\n\t}\n\n\tLoader.prototype = {\n\n\t\tconstructor: Loader,\n\n\t\tcrossOrigin: undefined,\n\n\t\textractUrlBase: function ( url ) {\n\n\t\t\tvar parts = url.split( '/' );\n\n\t\t\tif ( parts.length === 1 ) return './';\n\n\t\t\tparts.pop();\n\n\t\t\treturn parts.join( '/' ) + '/';\n\n\t\t},\n\n\t\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\n\t\t\tvar array = [];\n\n\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tcreateMaterial: ( function () {\n\n\t\t\tvar color, textureLoader, materialLoader;\n\n\t\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\n\t\t\t\tif ( color === undefined ) color = new Color();\n\t\t\t\tif ( textureLoader === undefined ) textureLoader = new TextureLoader();\n\t\t\t\tif ( materialLoader === undefined ) materialLoader = new MaterialLoader();\n\n\t\t\t\t// convert from old material format\n\n\t\t\t\tvar textures = {};\n\n\t\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\n\t\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\t\tvar loader = Loader.Handlers.get( fullPath );\n\n\t\t\t\t\tvar texture;\n\n\t\t\t\t\tif ( loader !== null ) {\n\n\t\t\t\t\t\ttexture = loader.load( fullPath );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( repeat !== undefined ) {\n\n\t\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\n\t\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\t\t\ttexture.offset.fromArray( offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( wrap !== undefined ) {\n\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\n\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( anisotropy !== undefined ) {\n\n\t\t\t\t\t\ttexture.anisotropy = anisotropy;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar uuid = _Math.generateUUID();\n\n\t\t\t\t\ttextures[ uuid ] = texture;\n\n\t\t\t\t\treturn uuid;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar json = {\n\t\t\t\t\tuuid: _Math.generateUUID(),\n\t\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t\t};\n\n\t\t\t\tfor ( var name in m ) {\n\n\t\t\t\t\tvar value = m[ name ];\n\n\t\t\t\t\tswitch ( name ) {\n\t\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\t\tjson.blending = BlendingMode[ value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\t\tjson.side = BackSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\t\tjson.side = DoubleSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\t\tcase 'opacity':\n\t\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tcase 'visible':\n\t\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\t\tif ( value === true ) json.vertexColors = VertexColors;\n\t\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = FaceColors;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\n\t\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\n\t\t\t\tmaterialLoader.setTextures( textures );\n\n\t\t\t\treturn materialLoader.parse( json );\n\n\t\t\t};\n\n\t\t} )()\n\n\t};\n\n\tLoader.Handlers = {\n\n\t\thandlers: [],\n\n\t\tadd: function ( regex, loader ) {\n\n\t\t\tthis.handlers.push( regex, loader );\n\n\t\t},\n\n\t\tget: function ( file ) {\n\n\t\t\tvar handlers = this.handlers;\n\n\t\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\t\tvar regex = handlers[ i ];\n\t\t\t\tvar loader  = handlers[ i + 1 ];\n\n\t\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\t\treturn loader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction JSONLoader( manager ) {\n\n\t\tif ( typeof manager === 'boolean' ) {\n\n\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\t\tmanager = undefined;\n\n\t\t}\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\tthis.withCredentials = false;\n\n\t}\n\n\tObject.assign( JSONLoader.prototype, {\n\n\t\tload: function( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tvar json = JSON.parse( text );\n\t\t\t\tvar metadata = json.metadata;\n\n\t\t\t\tif ( metadata !== undefined ) {\n\n\t\t\t\t\tvar type = metadata.type;\n\n\t\t\t\t\tif ( type !== undefined ) {\n\n\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\t\tonLoad( object.geometry, object.materials );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTexturePath: function ( value ) {\n\n\t\t\tthis.texturePath = value;\n\n\t\t},\n\n\t\tparse: function ( json, texturePath ) {\n\n\t\t\tvar geometry = new Geometry(),\n\t\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\n\t\t\tparseModel( scale );\n\n\t\t\tparseSkin();\n\t\t\tparseMorphing( scale );\n\t\t\tparseAnimations();\n\n\t\t\tgeometry.computeFaceNormals();\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\tfunction parseModel( scale ) {\n\n\t\t\t\tfunction isBitSet( value, position ) {\n\n\t\t\t\t\treturn value & ( 1 << position );\n\n\t\t\t\t}\n\n\t\t\t\tvar i, j, fi,\n\n\t\t\t\toffset, zLength,\n\n\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\n\t\t\t\ttype,\n\t\t\t\tisQuad,\n\t\t\t\thasMaterial,\n\t\t\t\thasFaceVertexUv,\n\t\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\t\thasFaceColor, hasFaceVertexColor,\n\n\t\t\tvertex, face, faceA, faceB, hex, normal,\n\n\t\t\t\tuvLayer, uv, u, v,\n\n\t\t\t\tfaces = json.faces,\n\t\t\t\tvertices = json.vertices,\n\t\t\t\tnormals = json.normals,\n\t\t\t\tcolors = json.colors,\n\n\t\t\t\tnUvLayers = 0;\n\n\t\t\t\tif ( json.uvs !== undefined ) {\n\n\t\t\t\t\t// disregard empty arrays\n\n\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\n\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = vertices.length;\n\n\t\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\t\tvertex = new Vector3();\n\n\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\t\t\tgeometry.vertices.push( vertex );\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = faces.length;\n\n\t\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\t\ttype = faces[ offset ++ ];\n\n\n\t\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\n\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\t\t\tif ( isQuad ) {\n\n\t\t\t\t\t\tfaceA = new Face3();\n\t\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\n\t\t\t\t\t\tfaceB = new Face3();\n\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\n\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\n\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\t\tfaceB.color.setHex( hex );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\t\tgeometry.faces.push( faceB );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tface = new Face3();\n\t\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.vertexColors.push( new Color( colors[ colorIndex ] ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.faces.push( face );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseSkin() {\n\n\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\n\t\t\t\tif ( json.skinWeights ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\n\t\t\t\t\t\tgeometry.skinWeights.push( new Vector4( x, y, z, w ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.skinIndices ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\n\t\t\t\t\t\tgeometry.skinIndices.push( new Vector4( a, b, c, d ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.bones = json.bones;\n\n\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\n\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseMorphing( scale ) {\n\n\t\t\t\tif ( json.morphTargets !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\n\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\t\t\tvar vertex = new Vector3();\n\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseAnimations() {\n\n\t\t\t\tvar outputAnimations = [];\n\n\t\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\t\tvar animations = [];\n\n\t\t\t\tif ( json.animation !== undefined ) {\n\n\t\t\t\t\tanimations.push( json.animation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.animations !== undefined ) {\n\n\t\t\t\t\tif ( json.animations.length ) {\n\n\t\t\t\t\t\tanimations = animations.concat( json.animations );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tanimations.push( json.animations );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\t\tvar clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\n\t\t\t\t}\n\n\t\t\t\t// parse implicit morph animations\n\t\t\t\tif ( geometry.morphTargets ) {\n\n\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\t\tvar morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\n\t\t\t\t}\n\n\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\n\t\t\t}\n\n\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\n\t\t\t\treturn { geometry: geometry };\n\n\t\t\t} else {\n\n\t\t\t\tvar materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\n\t\t\t\treturn { geometry: geometry, materials: materials };\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ObjectLoader ( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\tthis.texturePath = '';\n\n\t}\n\n\tObject.assign( ObjectLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tif ( this.texturePath === '' ) {\n\n\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\n\t\t\t}\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tscope.parse( JSON.parse( text ), onLoad );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTexturePath: function ( value ) {\n\n\t\t\tthis.texturePath = value;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\n\t\t},\n\n\t\tparse: function ( json, onLoad ) {\n\n\t\t\tvar geometries = this.parseGeometries( json.geometries );\n\n\t\t\tvar images = this.parseImages( json.images, function () {\n\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t\t} );\n\n\t\t\tvar textures  = this.parseTextures( json.textures, images );\n\t\t\tvar materials = this.parseMaterials( json.materials, textures );\n\n\t\t\tvar object = this.parseObject( json.object, geometries, materials );\n\n\t\t\tif ( json.animations ) {\n\n\t\t\t\tobject.animations = this.parseAnimations( json.animations );\n\n\t\t\t}\n\n\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t},\n\n\t\tparseGeometries: function ( json ) {\n\n\t\t\tvar geometries = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tvar geometryLoader = new JSONLoader();\n\t\t\t\tvar bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar geometry;\n\t\t\t\t\tvar data = json[ i ];\n\n\t\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\t\tcase 'PlaneBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\t\tcase 'CircleBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\t\tcase 'CylinderBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\t\tcase 'ConeBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\t\tcase 'SphereBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\t\tcase 'TetrahedronGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\t\tcase 'RingBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\t\tcase 'TorusBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\t\tcase 'LatheBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\n\t\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometries;\n\n\t\t},\n\n\t\tparseMaterials: function ( json, textures ) {\n\n\t\t\tvar materials = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tvar loader = new MaterialLoader();\n\t\t\t\tloader.setTextures( textures );\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar material = loader.parse( json[ i ] );\n\t\t\t\t\tmaterials[ material.uuid ] = material;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materials;\n\n\t\t},\n\n\t\tparseAnimations: function ( json ) {\n\n\t\t\tvar animations = [];\n\n\t\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\n\t\t\t\tvar clip = AnimationClip.parse( json[ i ] );\n\n\t\t\t\tanimations.push( clip );\n\n\t\t\t}\n\n\t\t\treturn animations;\n\n\t\t},\n\n\t\tparseImages: function ( json, onLoad ) {\n\n\t\t\tvar scope = this;\n\t\t\tvar images = {};\n\n\t\t\tfunction loadImage( url ) {\n\n\t\t\t\tscope.manager.itemStart( url );\n\n\t\t\t\treturn loader.load( url, function () {\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, undefined, function () {\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\t\tvar manager = new LoadingManager( onLoad );\n\n\t\t\t\tvar loader = new ImageLoader( manager );\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar image = json[ i ];\n\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\n\t\t\t\t\timages[ image.uuid ] = loadImage( path );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn images;\n\n\t\t},\n\n\t\tparseTextures: function ( json, images ) {\n\n\t\t\tfunction parseConstant( value, type ) {\n\n\t\t\t\tif ( typeof( value ) === 'number' ) return value;\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\t\treturn type[ value ];\n\n\t\t\t}\n\n\t\t\tvar textures = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar data = json[ i ];\n\n\t\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar texture = new Texture( images[ data.image ] );\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );\n\n\t\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );\n\t\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );\n\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );\n\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn textures;\n\n\t\t},\n\n\t\tparseObject: function () {\n\n\t\t\tvar matrix = new Matrix4();\n\n\t\t\treturn function parseObject( data, geometries, materials ) {\n\n\t\t\t\tvar object;\n\n\t\t\t\tfunction getGeometry( name ) {\n\n\t\t\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn geometries[ name ];\n\n\t\t\t\t}\n\n\t\t\t\tfunction getMaterial( name ) {\n\n\t\t\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn materials[ name ];\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'Scene':\n\n\t\t\t\t\t\tobject = new Scene();\n\n\t\t\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'AmbientLight':\n\n\t\t\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DirectionalLight':\n\n\t\t\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\n\t\t\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'HemisphereLight':\n\n\t\t\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Mesh':\n\n\t\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\t\tvar material = getMaterial( data.material );\n\n\t\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\n\t\t\t\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LOD':\n\n\t\t\t\t\t\tobject = new LOD();\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Line':\n\n\t\t\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LineSegments':\n\n\t\t\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointCloud':\n\t\t\t\t\tcase 'Points':\n\n\t\t\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Sprite':\n\n\t\t\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Group':\n\n\t\t\t\t\t\tobject = new Group();\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tobject = new Object3D();\n\n\t\t\t\t}\n\n\t\t\t\tobject.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\t\tif ( data.matrix !== undefined ) {\n\n\t\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\t\t\tif ( data.shadow ) {\n\n\t\t\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\n\t\t\t\tif ( data.children !== undefined ) {\n\n\t\t\t\t\tfor ( var child in data.children ) {\n\n\t\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.type === 'LOD' ) {\n\n\t\t\t\t\tvar levels = data.levels;\n\n\t\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn object;\n\n\t\t\t};\n\n\t\t}()\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Extensible curve object\n\t *\n\t * Some common of Curve methods\n\t * .getPoint(t), getTangent(t)\n\t * .getPointAt(u), getTangentAt(u)\n\t * .getPoints(), .getSpacedPoints()\n\t * .getLength()\n\t * .updateArcLengths()\n\t *\n\t * This following classes subclasses THREE.Curve:\n\t *\n\t * -- 2d classes --\n\t * THREE.LineCurve\n\t * THREE.QuadraticBezierCurve\n\t * THREE.CubicBezierCurve\n\t * THREE.SplineCurve\n\t * THREE.ArcCurve\n\t * THREE.EllipseCurve\n\t *\n\t * -- 3d classes --\n\t * THREE.LineCurve3\n\t * THREE.QuadraticBezierCurve3\n\t * THREE.CubicBezierCurve3\n\t * THREE.SplineCurve3\n\t *\n\t * A series of curves can be represented as a THREE.CurvePath\n\t *\n\t **/\n\n\t/**************************************************************\n\t *\tAbstract Curve base class\n\t **************************************************************/\n\n\tfunction Curve() {}\n\n\tCurve.prototype = {\n\n\t\tconstructor: Curve,\n\n\t\t// Virtual base class method to overwrite and implement in subclasses\n\t\t//\t- t [0 .. 1]\n\n\t\tgetPoint: function ( t ) {\n\n\t\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n\t\t\treturn null;\n\n\t\t},\n\n\t\t// Get point at relative position in curve according to arc length\n\t\t// - u [0 .. 1]\n\n\t\tgetPointAt: function ( u ) {\n\n\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\treturn this.getPoint( t );\n\n\t\t},\n\n\t\t// Get sequence of points using getPoint( t )\n\n\t\tgetPoints: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = 5;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t// Get sequence of points using getPointAt( u )\n\n\t\tgetSpacedPoints: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = 5;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t// Get total curve arc length\n\n\t\tgetLength: function () {\n\n\t\t\tvar lengths = this.getLengths();\n\t\t\treturn lengths[ lengths.length - 1 ];\n\n\t\t},\n\n\t\t// Get list of cumulative segment lengths\n\n\t\tgetLengths: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\n\t\t\tif ( this.cacheArcLengths\n\t\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\n\t\t\t\t&& ! this.needsUpdate ) {\n\n\t\t\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\t\t\treturn this.cacheArcLengths;\n\n\t\t\t}\n\n\t\t\tthis.needsUpdate = false;\n\n\t\t\tvar cache = [];\n\t\t\tvar current, last = this.getPoint( 0 );\n\t\t\tvar p, sum = 0;\n\n\t\t\tcache.push( 0 );\n\n\t\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\t\t\tcurrent = this.getPoint ( p / divisions );\n\t\t\t\tsum += current.distanceTo( last );\n\t\t\t\tcache.push( sum );\n\t\t\t\tlast = current;\n\n\t\t\t}\n\n\t\t\tthis.cacheArcLengths = cache;\n\n\t\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\n\t\t},\n\n\t\tupdateArcLengths: function() {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.getLengths();\n\n\t\t},\n\n\t\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\t\tgetUtoTmapping: function ( u, distance ) {\n\n\t\t\tvar arcLengths = this.getLengths();\n\n\t\t\tvar i = 0, il = arcLengths.length;\n\n\t\t\tvar targetArcLength; // The targeted u distance value to get\n\n\t\t\tif ( distance ) {\n\n\t\t\t\ttargetArcLength = distance;\n\n\t\t\t} else {\n\n\t\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t\t}\n\n\t\t\t//var time = Date.now();\n\n\t\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\t\tvar low = 0, high = il - 1, comparison;\n\n\t\t\twhile ( low <= high ) {\n\n\t\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\t\tlow = i + 1;\n\n\t\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\t\thigh = i - 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\thigh = i;\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// DONE\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ti = high;\n\n\t\t\t//console.log('b' , i, low, high, Date.now()- time);\n\n\t\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\t\tvar t = i / ( il - 1 );\n\t\t\t\treturn t;\n\n\t\t\t}\n\n\t\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\t\tvar lengthBefore = arcLengths[ i ];\n\t\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\n\t\t\tvar segmentLength = lengthAfter - lengthBefore;\n\n\t\t\t// determine where we are between the 'before' and 'after' points\n\n\t\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t\t// add that fractional amount to t\n\n\t\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\t\treturn t;\n\n\t\t},\n\n\t\t// Returns a unit vector tangent at t\n\t\t// In case any sub curve does not implement its tangent derivation,\n\t\t// 2 points a small delta apart will be used to find its gradient\n\t\t// which seems to give a reasonable approximation\n\n\t\tgetTangent: function( t ) {\n\n\t\t\tvar delta = 0.0001;\n\t\t\tvar t1 = t - delta;\n\t\t\tvar t2 = t + delta;\n\n\t\t\t// Capping in case of danger\n\n\t\t\tif ( t1 < 0 ) t1 = 0;\n\t\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\t\tvar pt1 = this.getPoint( t1 );\n\t\t\tvar pt2 = this.getPoint( t2 );\n\n\t\t\tvar vec = pt2.clone().sub( pt1 );\n\t\t\treturn vec.normalize();\n\n\t\t},\n\n\t\tgetTangentAt: function ( u ) {\n\n\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\treturn this.getTangent( t );\n\n\t\t},\n\n\t\tcomputeFrenetFrames: function ( segments, closed ) {\n\n\t\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\t\tvar normal = new Vector3();\n\n\t\t\tvar tangents = [];\n\t\t\tvar normals = [];\n\t\t\tvar binormals = [];\n\n\t\t\tvar vec = new Vector3();\n\t\t\tvar mat = new Matrix4();\n\n\t\t\tvar i, u, theta;\n\n\t\t\t// compute the tangent vectors for each segment on the curve\n\n\t\t\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\t\t\tu = i / segments;\n\n\t\t\t\ttangents[ i ] = this.getTangentAt( u );\n\t\t\t\ttangents[ i ].normalize();\n\n\t\t\t}\n\n\t\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t\t// and in the direction of the minimum tangent xyz component\n\n\t\t\tnormals[ 0 ] = new Vector3();\n\t\t\tbinormals[ 0 ] = new Vector3();\n\t\t\tvar min = Number.MAX_VALUE;\n\t\t\tvar tx = Math.abs( tangents[ 0 ].x );\n\t\t\tvar ty = Math.abs( tangents[ 0 ].y );\n\t\t\tvar tz = Math.abs( tangents[ 0 ].z );\n\n\t\t\tif ( tx <= min ) {\n\n\t\t\t\tmin = tx;\n\t\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( ty <= min ) {\n\n\t\t\t\tmin = ty;\n\t\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t\t}\n\n\t\t\tif ( tz <= min ) {\n\n\t\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t\t}\n\n\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\t\tvec.normalize();\n\n\t\t\t\t\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t\t}\n\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\t\tif ( closed === true ) {\n\n\t\t\t\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\t\ttheta /= segments;\n\n\t\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\t\ttheta = - theta;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t\t// twist a little...\n\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttangents: tangents,\n\t\t\t\tnormals: normals,\n\t\t\t\tbinormals: binormals\n\t\t\t};\n\n\t\t}\n\n\t};\n\n\t// TODO: Transformation for Curves?\n\n\t/**************************************************************\n\t *\t3D Curves\n\t **************************************************************/\n\n\t// A Factory method for creating new curve subclasses\n\n\tCurve.create = function ( constructor, getPointFunc ) {\n\n\t\tconstructor.prototype = Object.create( Curve.prototype );\n\t\tconstructor.prototype.constructor = constructor;\n\t\tconstructor.prototype.getPoint = getPointFunc;\n\n\t\treturn constructor;\n\n\t};\n\n\t/**************************************************************\n\t *\tLine\n\t **************************************************************/\n\n\tfunction LineCurve( v1, v2 ) {\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tLineCurve.prototype = Object.create( Curve.prototype );\n\tLineCurve.prototype.constructor = LineCurve;\n\n\tLineCurve.prototype.isLineCurve = true;\n\n\tLineCurve.prototype.getPoint = function ( t ) {\n\n\t\tif ( t === 1 ) {\n\n\t\t\treturn this.v2.clone();\n\n\t\t}\n\n\t\tvar point = this.v2.clone().sub( this.v1 );\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\treturn point;\n\n\t};\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\n\tLineCurve.prototype.getPointAt = function ( u ) {\n\n\t\treturn this.getPoint( u );\n\n\t};\n\n\tLineCurve.prototype.getTangent = function( t ) {\n\n\t\tvar tangent = this.v2.clone().sub( this.v1 );\n\n\t\treturn tangent.normalize();\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t **/\n\n\t/**************************************************************\n\t *\tCurved Path - a curve path is simply a array of connected\n\t *  curves, but retains the api of a curve\n\t **************************************************************/\n\n\tfunction CurvePath() {\n\n\t\tthis.curves = [];\n\n\t\tthis.autoClose = false; // Automatically closes the path\n\n\t}\n\n\tCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\n\n\t\tconstructor: CurvePath,\n\n\t\tadd: function ( curve ) {\n\n\t\t\tthis.curves.push( curve );\n\n\t\t},\n\n\t\tclosePath: function () {\n\n\t\t\t// Add a line curve if start and end of lines are not connected\n\t\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// To get accurate point with reference to\n\t\t// entire path distance at time t,\n\t\t// following has to be done:\n\n\t\t// 1. Length of each sub path have to be known\n\t\t// 2. Locate and identify type of curve\n\t\t// 3. Get t for the curve\n\t\t// 4. Return curve.getPointAt(t')\n\n\t\tgetPoint: function ( t ) {\n\n\t\t\tvar d = t * this.getLength();\n\t\t\tvar curveLengths = this.getCurveLengths();\n\t\t\tvar i = 0;\n\n\t\t\t// To think about boundaries points.\n\n\t\t\twhile ( i < curveLengths.length ) {\n\n\t\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\t\tvar curve = this.curves[ i ];\n\n\t\t\t\t\tvar segmentLength = curve.getLength();\n\t\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t\t},\n\n\t\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t// getPoint() depends on getLength\n\n\t\tgetLength: function () {\n\n\t\t\tvar lens = this.getCurveLengths();\n\t\t\treturn lens[ lens.length - 1 ];\n\n\t\t},\n\n\t\t// cacheLengths must be recalculated.\n\t\tupdateArcLengths: function () {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.cacheLengths = null;\n\t\t\tthis.getLengths();\n\n\t\t},\n\n\t\t// Compute lengths and cache them\n\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\t\tgetCurveLengths: function () {\n\n\t\t\t// We use cache values if curves and cache array are same length\n\n\t\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\t\treturn this.cacheLengths;\n\n\t\t\t}\n\n\t\t\t// Get length of sub-curve\n\t\t\t// Push sums into cached array\n\n\t\t\tvar lengths = [], sums = 0;\n\n\t\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\t\tsums += this.curves[ i ].getLength();\n\t\t\t\tlengths.push( sums );\n\n\t\t\t}\n\n\t\t\tthis.cacheLengths = lengths;\n\n\t\t\treturn lengths;\n\n\t\t},\n\n\t\tgetSpacedPoints: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = 40;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var i = 0; i <= divisions; i ++ ) {\n\n\t\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t\t}\n\n\t\t\tif ( this.autoClose ) {\n\n\t\t\t\tpoints.push( points[ 0 ] );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\tgetPoints: function ( divisions ) {\n\n\t\t\tdivisions = divisions || 12;\n\n\t\t\tvar points = [], last;\n\n\t\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\t\tvar curve = curves[ i ];\n\t\t\t\tvar resolution = (curve && curve.isEllipseCurve) ? divisions * 2\n\t\t\t\t\t: (curve && curve.isLineCurve) ? 1\n\t\t\t\t\t: (curve && curve.isSplineCurve) ? divisions * curve.points.length\n\t\t\t\t\t: divisions;\n\n\t\t\t\tvar pts = curve.getPoints( resolution );\n\n\t\t\t\tfor ( var j = 0; j < pts.length; j++ ) {\n\n\t\t\t\t\tvar point = pts[ j ];\n\n\t\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\t\tpoints.push( point );\n\t\t\t\t\tlast = point;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\t\tpoints.push( points[ 0 ] );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t/**************************************************************\n\t\t *\tCreate Geometries Helpers\n\t\t **************************************************************/\n\n\t\t/// Generate geometry from path points (for Line or Points objects)\n\n\t\tcreatePointsGeometry: function ( divisions ) {\n\n\t\t\tvar pts = this.getPoints( divisions );\n\t\t\treturn this.createGeometry( pts );\n\n\t\t},\n\n\t\t// Generate geometry from equidistant sampling along the path\n\n\t\tcreateSpacedPointsGeometry: function ( divisions ) {\n\n\t\t\tvar pts = this.getSpacedPoints( divisions );\n\t\t\treturn this.createGeometry( pts );\n\n\t\t},\n\n\t\tcreateGeometry: function ( points ) {\n\n\t\t\tvar geometry = new Geometry();\n\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tvar point = points[ i ];\n\t\t\t\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t} );\n\n\t/**************************************************************\n\t *\tEllipse curve\n\t **************************************************************/\n\n\tfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tthis.aX = aX;\n\t\tthis.aY = aY;\n\n\t\tthis.xRadius = xRadius;\n\t\tthis.yRadius = yRadius;\n\n\t\tthis.aStartAngle = aStartAngle;\n\t\tthis.aEndAngle = aEndAngle;\n\n\t\tthis.aClockwise = aClockwise;\n\n\t\tthis.aRotation = aRotation || 0;\n\n\t}\n\n\tEllipseCurve.prototype = Object.create( Curve.prototype );\n\tEllipseCurve.prototype.constructor = EllipseCurve;\n\n\tEllipseCurve.prototype.isEllipseCurve = true;\n\n\tEllipseCurve.prototype.getPoint = function( t ) {\n\n\t\tvar twoPi = Math.PI * 2;\n\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\t\tif ( samePoints ) {\n\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\t\tdeltaAngle = - twoPi;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar angle = this.aStartAngle + t * deltaAngle;\n\t\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\t\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\n\t\tif ( this.aRotation !== 0 ) {\n\n\t\t\tvar cos = Math.cos( this.aRotation );\n\t\t\tvar sin = Math.sin( this.aRotation );\n\n\t\t\tvar tx = x - this.aX;\n\t\t\tvar ty = y - this.aY;\n\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\n\t\t}\n\n\t\treturn new Vector2( x, y );\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tvar CurveUtils = {\n\n\t\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\n\t\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\n\t\t},\n\n\t\t// Puay Bing, thanks for helping with this derivative!\n\n\t\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\n\n\t\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\n\t\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\n\t\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\n\t\t\t\t3 * t * t * p3;\n\n\t\t},\n\n\t\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\n\t\t\t// To check if my formulas are correct\n\n\t\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\n\t\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\n\t\t\tvar h01 = - 6 * t * t + 6 * t; \t// − 2t3 + 3t2\n\t\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\n\n\t\t\treturn h00 + h10 + h01 + h11;\n\n\t\t},\n\n\t\t// Catmull-Rom\n\n\t\tinterpolate: function( p0, p1, p2, p3, t ) {\n\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t * t2;\n\t\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t\t}\n\n\t};\n\n\t/**************************************************************\n\t *\tSpline curve\n\t **************************************************************/\n\n\tfunction SplineCurve( points /* array of Vector2 */ ) {\n\n\t\tthis.points = ( points === undefined ) ? [] : points;\n\n\t}\n\n\tSplineCurve.prototype = Object.create( Curve.prototype );\n\tSplineCurve.prototype.constructor = SplineCurve;\n\n\tSplineCurve.prototype.isSplineCurve = true;\n\n\tSplineCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar points = this.points;\n\t\tvar point = ( points.length - 1 ) * t;\n\n\t\tvar intPoint = Math.floor( point );\n\t\tvar weight = point - intPoint;\n\n\t\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tvar point1 = points[ intPoint ];\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tvar interpolate = CurveUtils.interpolate;\n\n\t\treturn new Vector2(\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\n\t\t);\n\n\t};\n\n\t/**************************************************************\n\t *\tCubic Bezier curve\n\t **************************************************************/\n\n\tfunction CubicBezierCurve( v0, v1, v2, v3 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tCubicBezierCurve.prototype = Object.create( Curve.prototype );\n\tCubicBezierCurve.prototype.constructor = CubicBezierCurve;\n\n\tCubicBezierCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar b3 = ShapeUtils.b3;\n\n\t\treturn new Vector2(\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t);\n\n\t};\n\n\tCubicBezierCurve.prototype.getTangent = function( t ) {\n\n\t\tvar tangentCubicBezier = CurveUtils.tangentCubicBezier;\n\n\t\treturn new Vector2(\n\t\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t).normalize();\n\n\t};\n\n\t/**************************************************************\n\t *\tQuadratic Bezier curve\n\t **************************************************************/\n\n\n\tfunction QuadraticBezierCurve( v0, v1, v2 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\n\tQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\n\n\n\tQuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar b2 = ShapeUtils.b2;\n\n\t\treturn new Vector2(\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t);\n\n\t};\n\n\n\tQuadraticBezierCurve.prototype.getTangent = function( t ) {\n\n\t\tvar tangentQuadraticBezier = CurveUtils.tangentQuadraticBezier;\n\n\t\treturn new Vector2(\n\t\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t).normalize();\n\n\t};\n\n\tvar PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {\n\n\t\tfromPoints: function ( vectors ) {\n\n\t\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\n\t\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\n\n\t\t\t}\n\n\t\t},\n\n\t\tmoveTo: function ( x, y ) {\n\n\t\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\t},\n\n\t\tlineTo: function ( x, y ) {\n\n\t\t\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( x, y );\n\n\t\t},\n\n\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\t\tvar curve = new QuadraticBezierCurve(\n\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\t\tnew Vector2( aX, aY )\n\t\t\t);\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( aX, aY );\n\n\t\t},\n\n\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\t\tvar curve = new CubicBezierCurve(\n\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\t\tnew Vector2( aX, aY )\n\t\t\t);\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( aX, aY );\n\n\t\t},\n\n\t\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\n\t\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\t\tvar curve = new SplineCurve( npts );\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\t},\n\n\t\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\t\tvar x0 = this.currentPoint.x;\n\t\t\tvar y0 = this.currentPoint.y;\n\n\t\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\t},\n\n\t\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\t},\n\n\t\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\t\tvar x0 = this.currentPoint.x;\n\t\t\tvar y0 = this.currentPoint.y;\n\n\t\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\t},\n\n\t\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\t\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t\t// if a previous curve is present, attempt to join\n\t\t\t\tvar firstPoint = curve.getPoint( 0 );\n\n\t\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tvar lastPoint = curve.getPoint( 1 );\n\t\t\tthis.currentPoint.copy( lastPoint );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Defines a 2d shape plane using paths.\n\t **/\n\n\t// STEP 1 Create a path.\n\t// STEP 2 Turn path into shape.\n\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n\t// STEP 3a - Extract points from each shape, turn to vertices\n\t// STEP 3b - Triangulate each shape, add faces.\n\n\tfunction Shape() {\n\n\t\tPath.apply( this, arguments );\n\n\t\tthis.holes = [];\n\n\t}\n\n\tShape.prototype = Object.assign( Object.create( PathPrototype ), {\n\n\t\tconstructor: Shape,\n\n\t\tgetPointsHoles: function ( divisions ) {\n\n\t\t\tvar holesPts = [];\n\n\t\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t\t}\n\n\t\t\treturn holesPts;\n\n\t\t},\n\n\t\t// Get points of shape and holes (keypoints based on segments parameter)\n\n\t\textractAllPoints: function ( divisions ) {\n\n\t\t\treturn {\n\n\t\t\t\tshape: this.getPoints( divisions ),\n\t\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t\t};\n\n\t\t},\n\n\t\textractPoints: function ( divisions ) {\n\n\t\t\treturn this.extractAllPoints( divisions );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Creates free form 2d path using series of points, lines or curves.\n\t *\n\t **/\n\n\tfunction Path( points ) {\n\n\t\tCurvePath.call( this );\n\t\tthis.currentPoint = new Vector2();\n\n\t\tif ( points ) {\n\n\t\t\tthis.fromPoints( points );\n\n\t\t}\n\n\t}\n\n\tPath.prototype = PathPrototype;\n\tPathPrototype.constructor = Path;\n\n\n\t// minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n\tfunction ShapePath() {\n\t\tthis.subPaths = [];\n\t\tthis.currentPath = null;\n\t}\n\n\tShapePath.prototype = {\n\t\tmoveTo: function ( x, y ) {\n\t\t\tthis.currentPath = new Path();\n\t\t\tthis.subPaths.push(this.currentPath);\n\t\t\tthis.currentPath.moveTo( x, y );\n\t\t},\n\t\tlineTo: function ( x, y ) {\n\t\t\tthis.currentPath.lineTo( x, y );\n\t\t},\n\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\t\t},\n\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\t\t},\n\t\tsplineThru: function ( pts ) {\n\t\t\tthis.currentPath.splineThru( pts );\n\t\t},\n\n\t\ttoShapes: function ( isCCW, noHoles ) {\n\n\t\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\t\tvar shapes = [];\n\n\t\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\n\t\t\t\t\tvar tmpShape = new Shape();\n\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t\t}\n\n\t\t\t\treturn shapes;\n\n\t\t\t}\n\n\t\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\t\tvar polyLen = inPolygon.length;\n\n\t\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\t\tvar inside = false;\n\t\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\n\t\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\n\t\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t\t// not parallel\n\t\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t\t// continue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn\tinside;\n\n\t\t\t}\n\n\t\t\tvar isClockWise = ShapeUtils.isClockWise;\n\n\t\t\tvar subPaths = this.subPaths;\n\t\t\tif ( subPaths.length === 0 ) return [];\n\n\t\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\t\t\tif ( subPaths.length === 1 ) {\n\n\t\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\t\ttmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\treturn shapes;\n\n\t\t\t}\n\n\t\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\t\tvar betterShapeHoles = [];\n\t\t\tvar newShapes = [];\n\t\t\tvar newShapeHoles = [];\n\t\t\tvar mainIdx = 0;\n\t\t\tvar tmpPoints;\n\n\t\t\tnewShapes[ mainIdx ] = undefined;\n\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\t\ttmpPath = subPaths[ i ];\n\t\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\t\tif ( solid ) {\n\n\t\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t\t//console.log('cw', i);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t\t//console.log('ccw', i);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\t\tif ( newShapes.length > 1 ) {\n\n\t\t\t\tvar ambiguous = false;\n\t\t\t\tvar toChange = [];\n\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\n\t\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\t\tvar hole_unassigned = true;\n\n\t\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar tmpHoles;\n\n\t\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//console.log(\"shape\", shapes);\n\n\t\t\treturn shapes;\n\n\t\t}\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Font( data ) {\n\n\t\tthis.data = data;\n\n\t}\n\n\tObject.assign( Font.prototype, {\n\n\t\tisFont: true,\n\n\t\tgenerateShapes: function ( text, size, divisions ) {\n\n\t\t\tfunction createPaths( text ) {\n\n\t\t\t\tvar chars = String( text ).split( '' );\n\t\t\t\tvar scale = size / data.resolution;\n\t\t\t\tvar offset = 0;\n\n\t\t\t\tvar paths = [];\n\n\t\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\n\t\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\n\t\t\t\t\toffset += ret.offset;\n\n\t\t\t\t\tpaths.push( ret.path );\n\n\t\t\t\t}\n\n\t\t\t\treturn paths;\n\n\t\t\t}\n\n\t\t\tfunction createPath( c, scale, offset ) {\n\n\t\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\n\t\t\t\tif ( ! glyph ) return;\n\n\t\t\t\tvar path = new ShapePath();\n\n\t\t\t\tvar pts = [], b2 = ShapeUtils.b2, b3 = ShapeUtils.b3;\n\t\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\n\t\t\t\tif ( glyph.o ) {\n\n\t\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\n\t\t\t\t\t\tvar action = outline[ i ++ ];\n\n\t\t\t\t\t\tswitch ( action ) {\n\n\t\t\t\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn { offset: glyph.ha * scale, path: path };\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( size === undefined ) size = 100;\n\t\t\tif ( divisions === undefined ) divisions = 4;\n\n\t\t\tvar data = this.data;\n\n\t\t\tvar paths = createPaths( text );\n\t\t\tvar shapes = [];\n\n\t\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction FontLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( FontLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tvar json;\n\n\t\t\t\ttry {\n\n\t\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n\t\t\t\t}\n\n\t\t\t\tvar font = scope.parse( json );\n\n\t\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\treturn new Font( json );\n\n\t\t}\n\n\t} );\n\n\tvar context;\n\n\tfunction getAudioContext() {\n\n\t\tif ( context === undefined ) {\n\n\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t}\n\n\t\treturn context;\n\n\t}\n\n\t/**\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\n\tfunction AudioLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( AudioLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar context = getAudioContext();\n\n\t\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\n\t\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t\t} );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction StereoCamera() {\n\n\t\tthis.type = 'StereoCamera';\n\n\t\tthis.aspect = 1;\n\n\t\tthis.eyeSep = 0.064;\n\n\t\tthis.cameraL = new PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\n\t\tthis.cameraR = new PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\n\t}\n\n\tObject.assign( StereoCamera.prototype, {\n\n\t\tupdate: ( function () {\n\n\t\t\tvar instance, focus, fov, aspect, near, far, zoom;\n\n\t\t\tvar eyeRight = new Matrix4();\n\t\t\tvar eyeLeft = new Matrix4();\n\n\t\t\treturn function update( camera ) {\n\n\t\t\t\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far || zoom !== camera.zoom;\n\n\t\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t\tinstance = this;\n\t\t\t\t\tfocus = camera.focus;\n\t\t\t\t\tfov = camera.fov;\n\t\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\t\tnear = camera.near;\n\t\t\t\t\tfar = camera.far;\n\t\t\t\t\tzoom = camera.zoom;\n\n\t\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\t\tvar eyeSep = this.eyeSep / 2;\n\t\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\t\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\n\t\t\t\t\tvar xmin, xmax;\n\n\t\t\t\t\t// translate xOffset\n\n\t\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\n\t\t\t\t\t// for left eye\n\n\t\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t\t// for right eye\n\n\t\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\n\t\t\t};\n\n\t\t} )()\n\n\t} );\n\n\t/**\n\t * Camera for rendering cube maps\n\t *\t- renders scene into axis-aligned cube\n\t *\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction CubeCamera( near, far, cubeResolution ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'CubeCamera';\n\n\t\tvar fov = 90, aspect = 1;\n\n\t\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\n\t\tthis.add( cameraPX );\n\n\t\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\n\t\tthis.add( cameraNX );\n\n\t\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.up.set( 0, 0, 1 );\n\t\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\n\t\tthis.add( cameraPY );\n\n\t\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\n\t\tthis.add( cameraNY );\n\n\t\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\n\t\tthis.add( cameraPZ );\n\n\t\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\n\t\tthis.add( cameraNZ );\n\n\t\tvar options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\n\n\t\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\n\t\tthis.updateCubeMap = function ( renderer, scene ) {\n\n\t\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\t\tvar renderTarget = this.renderTarget;\n\t\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\t\trenderTarget.activeCubeFace = 0;\n\t\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 1;\n\t\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 2;\n\t\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 3;\n\t\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 4;\n\t\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\t\trenderTarget.activeCubeFace = 5;\n\t\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t\t\trenderer.setRenderTarget( null );\n\n\t\t};\n\n\t}\n\n\tCubeCamera.prototype = Object.create( Object3D.prototype );\n\tCubeCamera.prototype.constructor = CubeCamera;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AudioListener() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'AudioListener';\n\n\t\tthis.context = getAudioContext();\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( this.context.destination );\n\n\t\tthis.filter = null;\n\n\t}\n\n\tAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: AudioListener,\n\n\t\tgetInput: function () {\n\n\t\t\treturn this.gain;\n\n\t\t},\n\n\t\tremoveFilter: function ( ) {\n\n\t\t\tif ( this.filter !== null ) {\n\n\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\t\tthis.gain.connect( this.context.destination );\n\t\t\t\tthis.filter = null;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetFilter: function () {\n\n\t\t\treturn this.filter;\n\n\t\t},\n\n\t\tsetFilter: function ( value ) {\n\n\t\t\tif ( this.filter !== null ) {\n\n\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t\t} else {\n\n\t\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t\t}\n\n\t\t\tthis.filter = value;\n\t\t\tthis.gain.connect( this.filter );\n\t\t\tthis.filter.connect( this.context.destination );\n\n\t\t},\n\n\t\tgetMasterVolume: function () {\n\n\t\t\treturn this.gain.gain.value;\n\n\t\t},\n\n\t\tsetMasterVolume: function ( value ) {\n\n\t\t\tthis.gain.gain.value = value;\n\n\t\t},\n\n\t\tupdateMatrixWorld: ( function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar quaternion = new Quaternion();\n\t\t\tvar scale = new Vector3();\n\n\t\t\tvar orientation = new Vector3();\n\n\t\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\t\tvar listener = this.context.listener;\n\t\t\t\tvar up = this.up;\n\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\n\t\t\t};\n\n\t\t} )()\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\n\tfunction Audio( listener ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Audio';\n\n\t\tthis.context = listener.context;\n\t\tthis.source = this.context.createBufferSource();\n\t\tthis.source.onended = this.onEnded.bind( this );\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.getInput() );\n\n\t\tthis.autoplay = false;\n\n\t\tthis.startTime = 0;\n\t\tthis.playbackRate = 1;\n\t\tthis.isPlaying = false;\n\t\tthis.hasPlaybackControl = true;\n\t\tthis.sourceType = 'empty';\n\n\t\tthis.filters = [];\n\n\t}\n\n\tAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Audio,\n\n\t\tgetOutput: function () {\n\n\t\t\treturn this.gain;\n\n\t\t},\n\n\t\tsetNodeSource: function ( audioNode ) {\n\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'audioNode';\n\t\t\tthis.source = audioNode;\n\t\t\tthis.connect();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetBuffer: function ( audioBuffer ) {\n\n\t\t\tthis.source.buffer = audioBuffer;\n\t\t\tthis.sourceType = 'buffer';\n\n\t\t\tif ( this.autoplay ) this.play();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tplay: function () {\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar source = this.context.createBufferSource();\n\n\t\t\tsource.buffer = this.source.buffer;\n\t\t\tsource.loop = this.source.loop;\n\t\t\tsource.onended = this.source.onended;\n\t\t\tsource.start( 0, this.startTime );\n\t\t\tsource.playbackRate.value = this.playbackRate;\n\n\t\t\tthis.isPlaying = true;\n\n\t\t\tthis.source = source;\n\n\t\t\treturn this.connect();\n\n\t\t},\n\n\t\tpause: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.startTime = this.context.currentTime;\n\t\t\tthis.isPlaying = false;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.startTime = 0;\n\t\t\tthis.isPlaying = false;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconnect: function () {\n\n\t\t\tif ( this.filters.length > 0 ) {\n\n\t\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t\t} else {\n\n\t\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdisconnect: function () {\n\n\t\t\tif ( this.filters.length > 0 ) {\n\n\t\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t\t} else {\n\n\t\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetFilters: function () {\n\n\t\t\treturn this.filters;\n\n\t\t},\n\n\t\tsetFilters: function ( value ) {\n\n\t\t\tif ( ! value ) value = [];\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tthis.disconnect();\n\t\t\t\tthis.filters = value;\n\t\t\t\tthis.connect();\n\n\t\t\t} else {\n\n\t\t\t\tthis.filters = value;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetFilter: function () {\n\n\t\t\treturn this.getFilters()[ 0 ];\n\n\t\t},\n\n\t\tsetFilter: function ( filter ) {\n\n\t\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t\t},\n\n\t\tsetPlaybackRate: function ( value ) {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.playbackRate = value;\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tthis.source.playbackRate.value = this.playbackRate;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetPlaybackRate: function () {\n\n\t\t\treturn this.playbackRate;\n\n\t\t},\n\n\t\tonEnded: function () {\n\n\t\t\tthis.isPlaying = false;\n\n\t\t},\n\n\t\tgetLoop: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn this.source.loop;\n\n\t\t},\n\n\t\tsetLoop: function ( value ) {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.source.loop = value;\n\n\t\t},\n\n\t\tgetVolume: function () {\n\n\t\t\treturn this.gain.gain.value;\n\n\t\t},\n\n\n\t\tsetVolume: function ( value ) {\n\n\t\t\tthis.gain.gain.value = value;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction PositionalAudio( listener ) {\n\n\t\tAudio.call( this, listener );\n\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\n\n\t\tconstructor: PositionalAudio,\n\n\t\tgetOutput: function () {\n\n\t\t\treturn this.panner;\n\n\t\t},\n\n\t\tgetRefDistance: function () {\n\n\t\t\treturn this.panner.refDistance;\n\n\t\t},\n\n\t\tsetRefDistance: function ( value ) {\n\n\t\t\tthis.panner.refDistance = value;\n\n\t\t},\n\n\t\tgetRolloffFactor: function () {\n\n\t\t\treturn this.panner.rolloffFactor;\n\n\t\t},\n\n\t\tsetRolloffFactor: function ( value ) {\n\n\t\t\tthis.panner.rolloffFactor = value;\n\n\t\t},\n\n\t\tgetDistanceModel: function () {\n\n\t\t\treturn this.panner.distanceModel;\n\n\t\t},\n\n\t\tsetDistanceModel: function ( value ) {\n\n\t\t\tthis.panner.distanceModel = value;\n\n\t\t},\n\n\t\tgetMaxDistance: function () {\n\n\t\t\treturn this.panner.maxDistance;\n\n\t\t},\n\n\t\tsetMaxDistance: function ( value ) {\n\n\t\t\tthis.panner.maxDistance = value;\n\n\t\t},\n\n\t\tupdateMatrixWorld: ( function () {\n\n\t\t\tvar position = new Vector3();\n\n\t\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\n\t\t\t};\n\n\t\t} )()\n\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AudioAnalyser( audio, fftSize ) {\n\n\t\tthis.analyser = audio.context.createAnalyser();\n\t\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\t\taudio.getOutput().connect( this.analyser );\n\n\t}\n\n\tObject.assign( AudioAnalyser.prototype, {\n\n\t\tgetFrequencyData: function () {\n\n\t\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\t\treturn this.data;\n\n\t\t},\n\n\t\tgetAverageFrequency: function () {\n\n\t\t\tvar value = 0, data = this.getFrequencyData();\n\n\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tvalue += data[ i ];\n\n\t\t\t}\n\n\t\t\treturn value / data.length;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Buffered scene graph property that allows weighted accumulation.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction PropertyMixer( binding, typeName, valueSize ) {\n\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\n\t\tvar bufferType = Float64Array,\n\t\t\tmixFunction;\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\n\t\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\n\n\t\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\n\n\t\t}\n\n\t\tthis.buffer = new bufferType( valueSize * 4 );\n\t\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\n\t\tthis._mixBufferRegion = mixFunction;\n\n\t\tthis.cumulativeWeight = 0;\n\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\tPropertyMixer.prototype = {\n\n\t\tconstructor: PropertyMixer,\n\n\t\t// accumulate data in the 'incoming' region into 'accu<i>'\n\t\taccumulate: function( accuIndex, weight ) {\n\n\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t\t// the weight and shouldn't have made the call in the first place\n\n\t\t\tvar buffer = this.buffer,\n\t\t\t\tstride = this.valueSize,\n\t\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\t\tcurrentWeight = this.cumulativeWeight;\n\n\t\t\tif ( currentWeight === 0 ) {\n\n\t\t\t\t// accuN := incoming * weight\n\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tcurrentWeight = weight;\n\n\t\t\t} else {\n\n\t\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\t\tcurrentWeight += weight;\n\t\t\t\tvar mix = weight / currentWeight;\n\t\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t\t}\n\n\t\t\tthis.cumulativeWeight = currentWeight;\n\n\t\t},\n\n\t\t// apply the state of 'accu<i>' to the binding when accus differ\n\t\tapply: function( accuIndex ) {\n\n\t\t\tvar stride = this.valueSize,\n\t\t\t\tbuffer = this.buffer,\n\t\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\t\tweight = this.cumulativeWeight,\n\n\t\t\t\tbinding = this.binding;\n\n\t\t\tthis.cumulativeWeight = 0;\n\n\t\t\tif ( weight < 1 ) {\n\n\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\t\tvar originalValueOffset = stride * 3;\n\n\t\t\t\tthis._mixBufferRegion(\n\t\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t\t}\n\n\t\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t// remember the state of the bound property and copy it to both accus\n\t\tsaveOriginalState: function() {\n\n\t\t\tvar binding = this.binding;\n\n\t\t\tvar buffer = this.buffer,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toriginalValueOffset = stride * 3;\n\n\t\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t\t}\n\n\t\t\tthis.cumulativeWeight = 0;\n\n\t\t},\n\n\t\t// apply the state previously taken via 'saveOriginalState' to the binding\n\t\trestoreOriginalState: function() {\n\n\t\t\tvar originalValueOffset = this.valueSize * 3;\n\t\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t\t},\n\n\n\t\t// mix functions\n\n\t\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tif ( t >= 0.5 ) {\n\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tQuaternion.slerpFlat( buffer, dstOffset,\n\t\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\n\n\t\t},\n\n\t\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tvar s = 1 - t;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tvar j = dstOffset + i;\n\n\t\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t *\n\t * A reference to a real property in the scene graph.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction PropertyBinding( rootNode, path, parsedPath ) {\n\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath ||\n\t\t\t\tPropertyBinding.parseTrackName( path );\n\n\t\tthis.node = PropertyBinding.findNode(\n\t\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\n\n\t\tthis.rootNode = rootNode;\n\n\t}\n\n\tPropertyBinding.prototype = {\n\n\t\tconstructor: PropertyBinding,\n\n\t\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\t\tthis.bind();\n\t\t\tthis.getValue( targetArray, offset );\n\n\t\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t\t// prototype version of these methods with one that represents\n\t\t\t// the bound state. When the property is not found, the methods\n\t\t\t// become no-ops.\n\n\t\t},\n\n\t\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\t\tthis.bind();\n\t\t\tthis.setValue( sourceArray, offset );\n\n\t\t},\n\n\t\t// create getter / setter pair for a property in the scene graph\n\t\tbind: function() {\n\n\t\t\tvar targetObject = this.node,\n\t\t\t\tparsedPath = this.parsedPath,\n\n\t\t\t\tobjectName = parsedPath.objectName,\n\t\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\n\t\t\tif ( ! targetObject ) {\n\n\t\t\t\ttargetObject = PropertyBinding.findNode(\n\t\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\t\tthis.node = targetObject;\n\n\t\t\t}\n\n\t\t\t// set fail state so we can just 'return' on error\n\t\t\tthis.getValue = this._getValue_unavailable;\n\t\t\tthis.setValue = this._setValue_unavailable;\n\n\t \t\t// ensure there is a value node\n\t\t\tif ( ! targetObject ) {\n\n\t\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( objectName ) {\n\n\t\t\t\tvar objectIndex = parsedPath.objectIndex;\n\n\t\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\t\tswitch ( objectName ) {\n\n\t\t\t\t\tcase 'materials':\n\n\t\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bones':\n\n\t\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// resolve property\n\t\t\tvar nodeProperty = targetObject[ propertyName ];\n\n\t\t\tif ( nodeProperty === undefined ) {\n\n\t\t\t\tvar nodeName = parsedPath.nodeName;\n\n\t\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\n\t\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// determine versioning scheme\n\t\t\tvar versioning = this.Versioning.None;\n\n\t\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\t\tthis.targetObject = targetObject;\n\n\t\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\t\tthis.targetObject = targetObject;\n\n\t\t\t}\n\n\t\t\t// determine how the property gets bound\n\t\t\tvar bindingType = this.BindingType.Direct;\n\n\t\t\tif ( propertyIndex !== undefined ) {\n\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t\t} else if ( nodeProperty.length !== undefined ) {\n\n\t\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t\t} else {\n\n\t\t\t\tthis.propertyName = propertyName;\n\n\t\t\t}\n\n\t\t\t// select getter / setter\n\t\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t\t},\n\n\t\tunbind: function() {\n\n\t\t\tthis.node = null;\n\n\t\t\t// back to the prototype version of getValue / setValue\n\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\tthis.setValue = this._setValue_unbound;\n\n\t\t}\n\n\t};\n\n\tObject.assign( PropertyBinding.prototype, { // prototype, continued\n\n\t\t// these are used to \"bind\" a nonexistent property\n\t\t_getValue_unavailable: function() {},\n\t\t_setValue_unavailable: function() {},\n\n\t\t// initial state of these methods that calls 'bind'\n\t\t_getValue_unbound: PropertyBinding.prototype.getValue,\n\t\t_setValue_unbound: PropertyBinding.prototype.setValue,\n\n\t\tBindingType: {\n\t\t\tDirect: 0,\n\t\t\tEntireArray: 1,\n\t\t\tArrayElement: 2,\n\t\t\tHasFromToArray: 3\n\t\t},\n\n\t\tVersioning: {\n\t\t\tNone: 0,\n\t\t\tNeedsUpdate: 1,\n\t\t\tMatrixWorldNeedsUpdate: 2\n\t\t},\n\n\t\tGetterByBindingType: [\n\n\t\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t\t},\n\n\t\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\t\tvar source = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t\t},\n\n\t\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t\t}\n\n\t\t],\n\n\t\tSetterByBindingTypeAndVersioning: [\n\n\t\t\t[\n\t\t\t\t// Direct\n\n\t\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// EntireArray\n\n\t\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// ArrayElement\n\n\t\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// HasToFromArray\n\n\t\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t]\n\n\t\t]\n\n\t} );\n\n\tPropertyBinding.Composite =\n\t\t\tfunction( targetGroup, path, optionalParsedPath ) {\n\n\t\tvar parsedPath = optionalParsedPath ||\n\t\t\t\tPropertyBinding.parseTrackName( path );\n\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n\t};\n\n\tPropertyBinding.Composite.prototype = {\n\n\t\tconstructor: PropertyBinding.Composite,\n\n\t\tgetValue: function( array, offset ) {\n\n\t\t\tthis.bind(); // bind all binding\n\n\t\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t\t// and only call .getValue on the first\n\t\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t\t},\n\n\t\tsetValue: function( array, offset ) {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t\t}\n\n\t\t},\n\n\t\tbind: function() {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].bind();\n\n\t\t\t}\n\n\t\t},\n\n\t\tunbind: function() {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].unbind();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tPropertyBinding.create = function( root, path, parsedPath ) {\n\n\t\tif ( ! ( (root && root.isAnimationObjectGroup) ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t};\n\n\tPropertyBinding.parseTrackName = function( trackName ) {\n\n\t\t// matches strings in the form of:\n\t\t//    nodeName.property\n\t\t//    nodeName.property[accessor]\n\t\t//    nodeName.material.property[accessor]\n\t\t//    uuid.property[accessor]\n\t\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t\t//    parentName/nodeName.property\n\t\t//    parentName/parentName/nodeName.property[index]\n\t\t//    .bone[Armature.DEF_cog].position\n\t\t//    scene:helium_balloon_model:helium_balloon_model.position\n\t\t// created and tested via https://regex101.com/#javascript\n\n\t\tvar re = /^((?:\\w+[\\/:])*)(\\w+)?(?:\\.(\\w+)(?:\\[(.+)\\])?)?\\.(\\w+)(?:\\[(.+)\\])?$/;\n\t\tvar matches = re.exec( trackName );\n\n\t\tif ( ! matches ) {\n\n\t\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\n\n\t\t}\n\n\t\tvar results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ], \t// allowed to be null, specified root node.\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ],\n\t\t\tpropertyIndex: matches[ 6 ]\t// allowed to be null, specifies that the whole property is set.\n\t\t};\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t};\n\n\tPropertyBinding.findNode = function( root, nodeName ) {\n\n\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tvar searchSkeleton = function( skeleton ) {\n\n\t\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\n\n\t\t\t\t\tvar bone = skeleton.bones[ i ];\n\n\t\t\t\t\tif ( bone.name === nodeName ) {\n\n\t\t\t\t\t\treturn bone;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tvar bone = searchSkeleton( root.skeleton );\n\n\t\t\tif ( bone ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tvar searchNodeSubtree = function( children ) {\n\n\t\t\t\tfor( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tvar childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\t/**\n\t *\n\t * A group of objects that receives a shared animation state.\n\t *\n\t * Usage:\n\t *\n\t * \t-\tAdd objects you would otherwise pass as 'root' to the\n\t * \t\tconstructor or the .clipAction method of AnimationMixer.\n\t *\n\t * \t-\tInstead pass this object as 'root'.\n\t *\n\t * \t-\tYou can also add and remove objects later when the mixer\n\t * \t\tis running.\n\t *\n\t * Note:\n\t *\n\t *  \tObjects of this class appear as one object to the mixer,\n\t *  \tso cache control of the individual objects must be done\n\t *  \ton the group.\n\t *\n\t * Limitation:\n\t *\n\t * \t- \tThe animated properties must be compatible among the\n\t * \t\tall objects in the group.\n\t *\n\t *  -\tA single property can either be controlled through a\n\t *  \ttarget group or directly, but not both.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction AnimationObjectGroup( var_args ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\n\t\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t\t// note: read by PropertyBinding.Composite\n\n\t\tvar indices = {};\n\t\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t\t}\n\n\t\tthis._paths = [];\t\t\t\t\t// inside: string\n\t\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\t\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\n\t\tvar scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tobjects: {\n\t\t\t\tget total() { return scope._objects.length; },\n\t\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\n\t\t\t},\n\n\t\t\tget bindingsPerObject() { return scope._bindings.length; }\n\n\t\t};\n\n\t}\n\n\tAnimationObjectGroup.prototype = {\n\n\t\tconstructor: AnimationObjectGroup,\n\n\t\tisAnimationObjectGroup: true,\n\n\t\tadd: function( var_args ) {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tpaths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index === undefined ) {\n\n\t\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\t\tindex = nObjects ++;\n\t\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tbindings[ j ].push(\n\t\t\t\t\t\t\t\tnew PropertyBinding(\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\t\tvar knownObject = objects[ index ];\n\n\t\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\t\tbinding = new PropertyBinding(\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( objects[ index ] !== knownObject) {\n\n\t\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\n\t\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\n\t\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\n\n\t\t\t\t} // else the object is already where we want it to be\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\tremove: function( var_args ) {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\t// remove & forget\n\t\tuncache: function( var_args ) {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // cached or active\n\n\t\t\t\t} // if object is known\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\t\tsubscribe_: function( path, parsedPath ) {\n\t\t\t// returns an array of bindings for the given path that is changed\n\t\t\t// according to the contained objects in the group\n\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\tindex = indicesByPath[ path ],\n\t\t\t\tbindings = this._bindings;\n\n\t\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tobjects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\t\tindex = bindings.length;\n\n\t\t\tindicesByPath[ path ] = index;\n\n\t\t\tpaths.push( path );\n\t\t\tparsedPaths.push( parsedPath );\n\t\t\tbindings.push( bindingsForPath );\n\n\t\t\tfor ( var i = nCachedObjects,\n\t\t\t\t\tn = objects.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = objects[ i ];\n\n\t\t\t\tbindingsForPath[ i ] =\n\t\t\t\t\t\tnew PropertyBinding( object, path, parsedPath );\n\n\t\t\t}\n\n\t\t\treturn bindingsForPath;\n\n\t\t},\n\n\t\tunsubscribe_: function( path ) {\n\t\t\t// tells the group to forget about a property path and no longer\n\t\t\t// update the array previously obtained with 'subscribe_'\n\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\tindex = indicesByPath[ path ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tvar paths = this._paths,\n\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\t\tbindings[ index ] = lastBindings;\n\t\t\t\tbindings.pop();\n\n\t\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\t\tparsedPaths.pop();\n\n\t\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\t\tpaths.pop();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t *\n\t * Action provided by AnimationMixer for scheduling clip playback on specific\n\t * objects.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t *\n\t */\n\n\tfunction AnimationAction( mixer, clip, localRoot ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot || null;\n\n\t\tvar tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tvar interpolantSettings = {\n\t\t\t\tendingStart: \tZeroCurvatureEnding,\n\t\t\t\tendingEnd:\t\tZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants;\t// bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\t\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = -1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\n\t\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\n\t\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\n\n\t\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\n\t}\n\n\tAnimationAction.prototype = {\n\n\t\tconstructor: AnimationAction,\n\n\t\t// State & Scheduling\n\n\t\tplay: function() {\n\n\t\t\tthis._mixer._activateAction( this );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstop: function() {\n\n\t\t\tthis._mixer._deactivateAction( this );\n\n\t\t\treturn this.reset();\n\n\t\t},\n\n\t\treset: function() {\n\n\t\t\tthis.paused = false;\n\t\t\tthis.enabled = true;\n\n\t\t\tthis.time = 0;\t\t\t// restart clip\n\t\t\tthis._loopCount = -1;\t// forget previous loops\n\t\t\tthis._startTime = null;\t// forget scheduling\n\n\t\t\treturn this.stopFading().stopWarping();\n\n\t\t},\n\n\t\tisRunning: function() {\n\n\t\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t\t},\n\n\t\t// return true when play has been called\n\t\tisScheduled: function() {\n\n\t\t\treturn this._mixer._isActiveAction( this );\n\n\t\t},\n\n\t\tstartAt: function( time ) {\n\n\t\t\tthis._startTime = time;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetLoop: function( mode, repetitions ) {\n\n\t\t\tthis.loop = mode;\n\t\t\tthis.repetitions = repetitions;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Weight\n\n\t\t// set the weight stopping any scheduled fading\n\t\t// although .enabled = false yields an effective weight of zero, this\n\t\t// method does *not* change .enabled, because it would be confusing\n\t\tsetEffectiveWeight: function( weight ) {\n\n\t\t\tthis.weight = weight;\n\n\t\t\t// note: same logic as when updated at runtime\n\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\t\treturn this.stopFading();\n\n\t\t},\n\n\t\t// return the weight considering fading and .enabled\n\t\tgetEffectiveWeight: function() {\n\n\t\t\treturn this._effectiveWeight;\n\n\t\t},\n\n\t\tfadeIn: function( duration ) {\n\n\t\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t\t},\n\n\t\tfadeOut: function( duration ) {\n\n\t\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t\t},\n\n\t\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\n\n\t\t\tfadeOutAction.fadeOut( duration );\n\t\t\tthis.fadeIn( duration );\n\n\t\t\tif( warp ) {\n\n\t\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcrossFadeTo: function( fadeInAction, duration, warp ) {\n\n\t\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t\t},\n\n\t\tstopFading: function() {\n\n\t\t\tvar weightInterpolant = this._weightInterpolant;\n\n\t\t\tif ( weightInterpolant !== null ) {\n\n\t\t\t\tthis._weightInterpolant = null;\n\t\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Time Scale Control\n\n\t\t// set the weight stopping any scheduled warping\n\t\t// although .paused = true yields an effective time scale of zero, this\n\t\t// method does *not* change .paused, because it would be confusing\n\t\tsetEffectiveTimeScale: function( timeScale ) {\n\n\t\t\tthis.timeScale = timeScale;\n\t\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\t// return the time scale considering warping and .paused\n\t\tgetEffectiveTimeScale: function() {\n\n\t\t\treturn this._effectiveTimeScale;\n\n\t\t},\n\n\t\tsetDuration: function( duration ) {\n\n\t\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\tsyncWith: function( action ) {\n\n\t\t\tthis.time = action.time;\n\t\t\tthis.timeScale = action.timeScale;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\thalt: function( duration ) {\n\n\t\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t\t},\n\n\t\twarp: function( startTimeScale, endTimeScale, duration ) {\n\n\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\tinterpolant = this._timeScaleInterpolant,\n\n\t\t\t\ttimeScale = this.timeScale;\n\n\t\t\tif ( interpolant === null ) {\n\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t\t}\n\n\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\tvalues = interpolant.sampleValues;\n\n\t\t\ttimes[ 0 ] = now;\n\t\t\ttimes[ 1 ] = now + duration;\n\n\t\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstopWarping: function() {\n\n\t\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\t\tthis._timeScaleInterpolant = null;\n\t\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Object Accessors\n\n\t\tgetMixer: function() {\n\n\t\t\treturn this._mixer;\n\n\t\t},\n\n\t\tgetClip: function() {\n\n\t\t\treturn this._clip;\n\n\t\t},\n\n\t\tgetRoot: function() {\n\n\t\t\treturn this._localRoot || this._mixer._root;\n\n\t\t},\n\n\t\t// Interna\n\n\t\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\n\t\t\t// called by the mixer\n\n\t\t\tvar startTime = this._startTime;\n\n\t\t\tif ( startTime !== null ) {\n\n\t\t\t\t// check for scheduled start of action\n\n\t\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t\t}\n\n\t\t\t\t// start\n\n\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t\t}\n\n\t\t\t// apply time scale and advance time\n\n\t\t\tdeltaTime *= this._updateTimeScale( time );\n\t\t\tvar clipTime = this._updateTime( deltaTime );\n\n\t\t\t// note: _updateTime may disable the action resulting in\n\t\t\t// an effective weight of 0\n\n\t\t\tvar weight = this._updateWeight( time );\n\n\t\t\tif ( weight > 0 ) {\n\n\t\t\t\tvar interpolants = this._interpolants;\n\t\t\t\tvar propertyMixers = this._propertyBindings;\n\n\t\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_updateWeight: function( time ) {\n\n\t\t\tvar weight = 0;\n\n\t\t\tif ( this.enabled ) {\n\n\t\t\t\tweight = this.weight;\n\t\t\t\tvar interpolant = this._weightInterpolant;\n\n\t\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._effectiveWeight = weight;\n\t\t\treturn weight;\n\n\t\t},\n\n\t\t_updateTimeScale: function( time ) {\n\n\t\t\tvar timeScale = 0;\n\n\t\t\tif ( ! this.paused ) {\n\n\t\t\t\ttimeScale = this.timeScale;\n\n\t\t\t\tvar interpolant = this._timeScaleInterpolant;\n\n\t\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._effectiveTimeScale = timeScale;\n\t\t\treturn timeScale;\n\n\t\t},\n\n\t\t_updateTime: function( deltaTime ) {\n\n\t\t\tvar time = this.time + deltaTime;\n\n\t\t\tif ( deltaTime === 0 ) return time;\n\n\t\t\tvar duration = this._clip.duration,\n\n\t\t\t\tloop = this.loop,\n\t\t\t\tloopCount = this._loopCount;\n\n\t\t\tif ( loop === LoopOnce ) {\n\n\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t// just started\n\n\t\t\t\t\tthis.loopCount = 0;\n\t\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t\t}\n\n\t\t\t\thandle_stop: {\n\n\t\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\t\ttime = duration;\n\n\t\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\t\ttime = 0;\n\n\t\t\t\t\t} else break handle_stop;\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\t\tvar pingPong = ( loop === LoopPingPong );\n\n\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t// just started\n\n\t\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( time >= duration || time < 0 ) {\n\t\t\t\t\t// wrap around\n\n\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\t\tvar pending = this.repetitions - loopCount;\n\n\t\t\t\t\tif ( pending < 0 ) {\n\t\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// keep running\n\n\t\t\t\t\t\tif ( pending === 0 ) {\n\t\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\t\tthis.time = time;\n\t\t\t\t\treturn duration - time;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.time = time;\n\t\t\treturn time;\n\n\t\t},\n\n\t\t_setEndings: function( atStart, atEnd, pingPong ) {\n\n\t\t\tvar settings = this._interpolantSettings;\n\n\t\t\tif ( pingPong ) {\n\n\t\t\t\tsettings.endingStart \t= ZeroSlopeEnding;\n\t\t\t\tsettings.endingEnd\t\t= ZeroSlopeEnding;\n\n\t\t\t} else {\n\n\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\t\tif ( atStart ) {\n\n\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\n\t\t\t\t\t\t\tZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t\t}\n\n\t\t\t\tif ( atEnd ) {\n\n\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\n\t\t\t\t\t\t\tZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_scheduleFading: function( duration, weightNow, weightThen ) {\n\n\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\tinterpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant === null ) {\n\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t\t}\n\n\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\tvalues = interpolant.sampleValues;\n\n\t\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t *\n\t * Player for AnimationClips.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction AnimationMixer( root ) {\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\tObject.assign( AnimationMixer.prototype, EventDispatcher.prototype, {\n\n\t\t// return an action for a clip optionally using a custom root target\n\t\t// object (this method allocates a lot of dynamic memory in case a\n\t\t// previously unknown clip/root combination is specified)\n\t\tclipAction: function( clip, optionalRoot ) {\n\n\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\trootUuid = root.uuid,\n\n\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\t\tprototypeAction = null;\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\tvar existingAction =\n\t\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\t\tif ( existingAction !== undefined ) {\n\n\t\t\t\t\treturn existingAction;\n\n\t\t\t\t}\n\n\t\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t\t// the bindings again but can just copy\n\t\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t\t// also, take the clip from the prototype action\n\t\t\t\tif ( clipObject === null )\n\t\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t\t}\n\n\t\t\t// clip must be known when specified via string\n\t\t\tif ( clipObject === null ) return null;\n\n\t\t\t// allocate all resources required to run it\n\t\t\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\n\n\t\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t\t// and make the action known to the memory manager\n\t\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\t\treturn newAction;\n\n\t\t},\n\n\t\t// get an existing action\n\t\texistingAction: function( clip, optionalRoot ) {\n\n\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\trootUuid = root.uuid,\n\n\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\t// deactivates all previously scheduled actions\n\t\tstopAllAction: function() {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tnActions = this._nActiveActions,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = this._nActiveBindings;\n\n\t\t\tthis._nActiveActions = 0;\n\t\t\tthis._nActiveBindings = 0;\n\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\t\tactions[ i ].reset();\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\t\tbindings[ i ].useCount = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// advance the time and update apply the animation\n\t\tupdate: function( deltaTime ) {\n\n\t\t\tdeltaTime *= this.timeScale;\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tnActions = this._nActiveActions,\n\n\t\t\t\ttime = this.time += deltaTime,\n\t\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t\t// run active actions\n\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\t\tvar action = actions[ i ];\n\n\t\t\t\tif ( action.enabled ) {\n\n\t\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update scene graph\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tnBindings = this._nActiveBindings;\n\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// return this mixer's root target object\n\t\tgetRoot: function() {\n\n\t\t\treturn this._root;\n\n\t\t},\n\n\t\t// free all resources specific to a particular clip\n\t\tuncacheClip: function( clip ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tclipUuid = clip.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t\t// iteration state and also require updating the state we can\n\t\t\t\t// just throw away\n\n\t\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\n\t\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar action = actionsToRemove[ i ];\n\n\t\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\t\taction._cacheIndex = null;\n\t\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\t\tactions.pop();\n\n\t\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t\t}\n\n\t\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t\t}\n\n\t\t},\n\n\t\t// free all resources specific to a particular root target object\n\t\tuncacheRoot: function( root ) {\n\n\t\t\tvar rootUuid = root.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip;\n\n\t\t\tfor ( var clipUuid in actionsByClip ) {\n\n\t\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\t\tif ( action !== undefined ) {\n\n\t\t\t\t\tthis._deactivateAction( action );\n\t\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\t\tif ( bindingByName !== undefined ) {\n\n\t\t\t\tfor ( var trackName in bindingByName ) {\n\n\t\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t// remove a targeted clip from the cache\n\t\tuncacheAction: function( clip, optionalRoot ) {\n\n\t\t\tvar action = this.existingAction( clip, optionalRoot );\n\n\t\t\tif ( action !== null ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t// Implementation details:\n\n\tObject.assign( AnimationMixer.prototype, {\n\n\t\t_bindAction: function( action, prototypeAction ) {\n\n\t\t\tvar root = action._localRoot || this._root,\n\t\t\t\ttracks = action._clip.tracks,\n\t\t\t\tnTracks = tracks.length,\n\t\t\t\tbindings = action._propertyBindings,\n\t\t\t\tinterpolants = action._interpolants,\n\t\t\t\trootUuid = root.uuid,\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\t\tif ( bindingsByName === undefined ) {\n\n\t\t\t\tbindingsByName = {};\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\t\tvar track = tracks[ i ],\n\t\t\t\t\ttrackName = track.name,\n\t\t\t\t\tbinding = bindingsByName[ trackName ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t\t}\n\n\t\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t\t}\n\n\t\t},\n\n\t\t_activateAction: function( action ) {\n\n\t\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t\t}\n\n\t\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t\t// increment reference counts / sort out state\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis._lendAction( action );\n\n\t\t\t}\n\n\t\t},\n\n\t\t_deactivateAction: function( action ) {\n\n\t\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t\t// decrement reference counts / sort out state\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis._takeBackAction( action );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Memory manager\n\n\t\t_initMemoryManager: function() {\n\n\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\t\tthis._nActiveActions = 0;\n\n\t\t\tthis._actionsByClip = {};\n\t\t\t// inside:\n\t\t\t// {\n\t\t\t// \t\tknownActions: Array< AnimationAction >\t- used as prototypes\n\t\t\t// \t\tactionByRoot: AnimationAction\t\t\t- lookup\n\t\t\t// }\n\n\n\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\t\tthis._nActiveBindings = 0;\n\n\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\t\tthis._controlInterpolants = []; // same game as above\n\t\t\tthis._nActiveControlInterpolants = 0;\n\n\t\t\tvar scope = this;\n\n\t\t\tthis.stats = {\n\n\t\t\t\tactions: {\n\t\t\t\t\tget total() { return scope._actions.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveActions; }\n\t\t\t\t},\n\t\t\t\tbindings: {\n\t\t\t\t\tget total() { return scope._bindings.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveBindings; }\n\t\t\t\t},\n\t\t\t\tcontrolInterpolants: {\n\t\t\t\t\tget total() { return scope._controlInterpolants.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t},\n\n\t\t// Memory management for AnimationAction objects\n\n\t\t_isActiveAction: function( action ) {\n\n\t\t\tvar index = action._cacheIndex;\n\t\t\treturn index !== null && index < this._nActiveActions;\n\n\t\t},\n\n\t\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip === undefined ) {\n\n\t\t\t\tactionsForClip = {\n\n\t\t\t\t\tknownActions: [ action ],\n\t\t\t\t\tactionByRoot: {}\n\n\t\t\t\t};\n\n\t\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t\t} else {\n\n\t\t\t\tvar knownActions = actionsForClip.knownActions;\n\n\t\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\t\tknownActions.push( action );\n\n\t\t\t}\n\n\t\t\taction._cacheIndex = actions.length;\n\t\t\tactions.push( action );\n\n\t\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t\t},\n\n\t\t_removeInactiveAction: function( action ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\t\tcacheIndex = action._cacheIndex;\n\n\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\tactions.pop();\n\n\t\t\taction._cacheIndex = null;\n\n\n\t\t\tvar clipUuid = action._clip.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\t\tlastKnownAction =\n\t\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\t\tknownActionsForClip.pop();\n\n\t\t\taction._byClipCacheIndex = null;\n\n\n\t\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\n\n\t\t\tdelete actionByRoot[ rootUuid ];\n\n\t\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t\t}\n\n\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t},\n\n\t\t_removeInactiveBindingsForAction: function( action ) {\n\n\t\t\tvar bindings = action._propertyBindings;\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_lendAction: function( action ) {\n\n\t\t\t// [ active actions |  inactive actions  ]\n\t\t\t// [  active actions >| inactive actions ]\n\t\t\t//                 s        a\n\t\t\t//                  <-swap->\n\t\t\t//                 a        s\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\t\taction._cacheIndex = lastActiveIndex;\n\t\t\tactions[ lastActiveIndex ] = action;\n\n\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t\t},\n\n\t\t_takeBackAction: function( action ) {\n\n\t\t\t// [  active actions  | inactive actions ]\n\t\t\t// [ active actions |< inactive actions  ]\n\t\t\t//        a        s\n\t\t\t//         <-swap->\n\t\t\t//        s        a\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\t\taction._cacheIndex = firstInactiveIndex;\n\t\t\tactions[ firstInactiveIndex ] = action;\n\n\t\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t\t},\n\n\t\t// Memory management for PropertyMixer objects\n\n\t\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\n\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\t\tbindings = this._bindings;\n\n\t\t\tif ( bindingByName === undefined ) {\n\n\t\t\t\tbindingByName = {};\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t\t}\n\n\t\t\tbindingByName[ trackName ] = binding;\n\n\t\t\tbinding._cacheIndex = bindings.length;\n\t\t\tbindings.push( binding );\n\n\t\t},\n\n\t\t_removeInactiveBinding: function( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tpropBinding = binding.binding,\n\t\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\t\ttrackName = propBinding.path,\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\t\tbindings.pop();\n\n\t\t\tdelete bindingByName[ trackName ];\n\n\t\t\tremove_empty_map: {\n\n\t\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\n\n\t\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t\t}\n\n\t\t},\n\n\t\t_lendBinding: function( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\t\tbinding._cacheIndex = lastActiveIndex;\n\t\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t\t},\n\n\t\t_takeBackBinding: function( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t\t},\n\n\n\t\t// Memory management of Interpolants for weight and time scale\n\n\t\t_lendControlInterpolant: function() {\n\n\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\n\t\t\tif ( interpolant === undefined ) {\n\n\t\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t\t}\n\n\t\t\treturn interpolant;\n\n\t\t},\n\n\t\t_takeBackControlInterpolant: function( interpolant ) {\n\n\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t\t},\n\n\t\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Uniform( value ) {\n\n\t\tif ( typeof value === 'string' ) {\n\n\t\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\t\tvalue = arguments[ 1 ];\n\n\t\t}\n\n\t\tthis.value = value;\n\n\t}\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedBufferGeometry() {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'InstancedBufferGeometry';\n\t\tthis.maxInstancedCount = undefined;\n\n\t}\n\n\tInstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tInstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;\n\n\tInstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;\n\n\tInstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t};\n\n\tInstancedBufferGeometry.prototype.copy = function ( source ) {\n\n\t\tvar index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\tvar attributes = source.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t}\n\n\t\tvar groups = source.groups;\n\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.data = interleavedBuffer;\n\t\tthis.itemSize = itemSize;\n\t\tthis.offset = offset;\n\n\t\tthis.normalized = normalized === true;\n\n\t}\n\n\n\tInterleavedBufferAttribute.prototype = {\n\n\t\tconstructor: InterleavedBufferAttribute,\n\n\t\tisInterleavedBufferAttribute: true,\n\n\t\tget count() {\n\n\t\t\treturn this.data.count;\n\n\t\t},\n\n\t\tget array() {\n\n\t\t\treturn this.data.array;\n\n\t\t},\n\n\t\tsetX: function ( index, x ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( index, y ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( index, z ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetW: function ( index, w ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetX: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\n\t\t},\n\n\t\tgetY: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t\t},\n\n\t\tgetZ: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t\t},\n\n\t\tgetW: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t\t},\n\n\t\tsetXY: function ( index, x, y ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZ: function ( index, x, y, z ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\tthis.data.array[ index + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\tthis.data.array[ index + 2 ] = z;\n\t\t\tthis.data.array[ index + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InterleavedBuffer( array, stride ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.array = array;\n\t\tthis.stride = stride;\n\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\t\tthis.dynamic = false;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\n\t\tthis.version = 0;\n\n\t}\n\n\tInterleavedBuffer.prototype = {\n\n\t\tconstructor: InterleavedBuffer,\n\n\t\tisInterleavedBuffer: true,\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t},\n\n\t\tsetArray: function ( array ) {\n\n\t\t\tif ( Array.isArray( array ) ) {\n\n\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t\t}\n\n\t\t\tthis.count = array !== undefined ? array.length / this.stride : 0;\n\t\t\tthis.array = array;\n\n\t\t},\n\n\t\tsetDynamic: function ( value ) {\n\n\t\t\tthis.dynamic = value;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\tthis.count = source.count;\n\t\t\tthis.stride = source.stride;\n\t\t\tthis.dynamic = source.dynamic;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\t\tindex1 *= this.stride;\n\t\t\tindex2 *= attribute.stride;\n\n\t\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tset: function ( value, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.array.set( value, offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\n\n\t\tInterleavedBuffer.call( this, array, stride );\n\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n\t}\n\n\tInstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );\n\tInstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;\n\n\tInstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;\n\n\tInstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\n\t\tInterleavedBuffer.prototype.copy.call( this, source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {\n\n\t\tBufferAttribute.call( this, array, itemSize );\n\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n\t}\n\n\tInstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\tInstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;\n\n\tInstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;\n\n\tInstancedBufferAttribute.prototype.copy = function ( source ) {\n\n\t\tBufferAttribute.prototype.copy.call( this, source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author bhouston / http://clara.io/\n\t * @author stephomi / http://stephaneginier.com/\n\t */\n\n\tfunction Raycaster( origin, direction, near, far ) {\n\n\t\tthis.ray = new Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near || 0;\n\t\tthis.far = far || Infinity;\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: {},\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t\tObject.defineProperties( this.params, {\n\t\t\tPointCloud: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\treturn this.Points;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t}\n\n\tfunction ascSort( a, b ) {\n\n\t\treturn a.distance - b.distance;\n\n\t}\n\n\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tRaycaster.prototype = {\n\n\t\tconstructor: Raycaster,\n\n\t\tlinePrecision: 1,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\t\tthis.ray.set( origin, direction );\n\n\t\t},\n\n\t\tsetFromCamera: function ( coords, camera ) {\n\n\t\t\tif ( (camera && camera.isPerspectiveCamera) ) {\n\n\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\n\t\t\t} else if ( (camera && camera.isOrthographicCamera) ) {\n\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n\t\t\t}\n\n\t\t},\n\n\t\tintersectObject: function ( object, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tintersectObject( object, this, intersects, recursive );\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t},\n\n\t\tintersectObjects: function ( objects, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tif ( Array.isArray( objects ) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t\t}\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Clock( autoStart ) {\n\n\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\t\tthis.startTime = 0;\n\t\tthis.oldTime = 0;\n\t\tthis.elapsedTime = 0;\n\n\t\tthis.running = false;\n\n\t}\n\n\tClock.prototype = {\n\n\t\tconstructor: Clock,\n\n\t\tstart: function () {\n\n\t\t\tthis.startTime = ( performance || Date ).now();\n\n\t\t\tthis.oldTime = this.startTime;\n\t\t\tthis.elapsedTime = 0;\n\t\t\tthis.running = true;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tthis.getElapsedTime();\n\t\t\tthis.running = false;\n\n\t\t},\n\n\t\tgetElapsedTime: function () {\n\n\t\t\tthis.getDelta();\n\t\t\treturn this.elapsedTime;\n\n\t\t},\n\n\t\tgetDelta: function () {\n\n\t\t\tvar diff = 0;\n\n\t\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\t\tthis.start();\n\n\t\t\t}\n\n\t\t\tif ( this.running ) {\n\n\t\t\t\tvar newTime = ( performance || Date ).now();\n\n\t\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\t\tthis.oldTime = newTime;\n\n\t\t\t\tthis.elapsedTime += diff;\n\n\t\t\t}\n\n\t\t\treturn diff;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Spline from Tween.js, slightly optimized (and trashed)\n\t * http://sole.github.com/tween.js/examples/05_spline.html\n\t *\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Spline( points ) {\n\n\t\tthis.points = points;\n\n\t\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\t\tpoint, intPoint, weight, w2, w3,\n\t\tpa, pb, pc, pd;\n\n\t\tthis.initFromArray = function ( a ) {\n\n\t\t\tthis.points = [];\n\n\t\t\tfor ( var i = 0; i < a.length; i ++ ) {\n\n\t\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getPoint = function ( k ) {\n\n\t\t\tpoint = ( this.points.length - 1 ) * k;\n\t\t\tintPoint = Math.floor( point );\n\t\t\tweight = point - intPoint;\n\n\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\t\tc[ 1 ] = intPoint;\n\t\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\n\t\t\tpa = this.points[ c[ 0 ] ];\n\t\t\tpb = this.points[ c[ 1 ] ];\n\t\t\tpc = this.points[ c[ 2 ] ];\n\t\t\tpd = this.points[ c[ 3 ] ];\n\n\t\t\tw2 = weight * weight;\n\t\t\tw3 = weight * w2;\n\n\t\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\n\t\t\treturn v3;\n\n\t\t};\n\n\t\tthis.getControlPointsArray = function () {\n\n\t\t\tvar i, p, l = this.points.length,\n\t\t\t\tcoords = [];\n\n\t\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\t\tp = this.points[ i ];\n\t\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\n\t\t\t}\n\n\t\t\treturn coords;\n\n\t\t};\n\n\t\t// approximate length by summing linear segments\n\n\t\tthis.getLength = function ( nSubDivisions ) {\n\n\t\t\tvar i, index, nSamples, position,\n\t\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\t\toldPosition = new Vector3(),\n\t\t\t\ttmpVec = new Vector3(),\n\t\t\t\tchunkLengths = [],\n\t\t\t\ttotalLength = 0;\n\n\t\t\t// first point has 0 length\n\n\t\t\tchunkLengths[ 0 ] = 0;\n\n\t\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\n\n\t\t\tnSamples = this.points.length * nSubDivisions;\n\n\t\t\toldPosition.copy( this.points[ 0 ] );\n\n\t\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\n\t\t\t\tindex = i / nSamples;\n\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\ttmpVec.copy( position );\n\n\t\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\n\t\t\t\toldPosition.copy( position );\n\n\t\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\t\tintPoint = Math.floor( point );\n\n\t\t\t\tif ( intPoint !== oldIntPoint ) {\n\n\t\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\t\toldIntPoint = intPoint;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// last point ends with total length\n\n\t\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\n\t\t\treturn { chunks: chunkLengths, total: totalLength };\n\n\t\t};\n\n\t\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\n\t\t\tvar i, j,\n\t\t\t\tindex, indexCurrent, indexNext,\n\t\t\t\trealDistance,\n\t\t\t\tsampling, position,\n\t\t\t\tnewpoints = [],\n\t\t\t\ttmpVec = new Vector3(),\n\t\t\t\tsl = this.getLength();\n\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\n\t\t\tfor ( i = 1; i < this.points.length; i ++ ) {\n\n\t\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\n\t\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\n\t\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\n\t\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\t\tindexNext = i / ( this.points.length - 1 );\n\n\t\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\n\n\t\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\n\t\t\t\t\tposition = this.getPoint( index );\n\t\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\n\t\t\t\t}\n\n\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\n\t\t\t}\n\n\t\t\tthis.points = newpoints;\n\n\t\t};\n\n\t\t// Catmull-Rom\n\n\t\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n\t *\n\t * The poles (phi) are at the positive and negative y axis.\n\t * The equator starts at positive z.\n\t */\n\n\tfunction Spherical( radius, phi, theta ) {\n\n\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\t\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\n\t\treturn this;\n\n\t}\n\n\tSpherical.prototype = {\n\n\t\tconstructor: Spherical,\n\n\t\tset: function ( radius, phi, theta ) {\n\n\t\t\tthis.radius = radius;\n\t\t\tthis.phi = phi;\n\t\t\tthis.theta = theta;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( other ) {\n\n\t\t\tthis.radius = other.radius;\n\t\t\tthis.phi = other.phi;\n\t\t\tthis.theta = other.theta;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\tmakeSafe: function() {\n\n\t\t\tvar EPS = 0.000001;\n\t\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromVector3: function( vec3 ) {\n\n\t\t\tthis.radius = vec3.length();\n\n\t\t\tif ( this.radius === 0 ) {\n\n\t\t\t\tthis.theta = 0;\n\t\t\t\tthis.phi = 0;\n\n\t\t\t} else {\n\n\t\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\t\tthis.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t};\n\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\r\n\tfunction MorphBlendMesh( geometry, material ) {\n\r\n\t\tMesh.call( this, geometry, material );\r\n\r\n\t\tthis.animationsMap = {};\r\n\t\tthis.animationsList = [];\r\n\r\n\t\t// prepare default animation\r\n\t\t// (all frames played together in 1 second)\r\n\r\n\t\tvar numFrames = this.geometry.morphTargets.length;\r\n\r\n\t\tvar name = \"__default\";\r\n\r\n\t\tvar startFrame = 0;\r\n\t\tvar endFrame = numFrames - 1;\r\n\r\n\t\tvar fps = numFrames / 1;\r\n\r\n\t\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\t\tthis.setAnimationWeight( name, 1 );\r\n\r\n\t}\r\n\r\n\tMorphBlendMesh.prototype = Object.create( Mesh.prototype );\r\n\tMorphBlendMesh.prototype.constructor = MorphBlendMesh;\r\n\r\n\tMorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n\t\tvar animation = {\r\n\r\n\t\t\tstart: start,\r\n\t\t\tend: end,\r\n\r\n\t\t\tlength: end - start + 1,\r\n\r\n\t\t\tfps: fps,\r\n\t\t\tduration: ( end - start ) / fps,\r\n\r\n\t\t\tlastFrame: 0,\r\n\t\t\tcurrentFrame: 0,\r\n\r\n\t\t\tactive: false,\r\n\r\n\t\t\ttime: 0,\r\n\t\t\tdirection: 1,\r\n\t\t\tweight: 1,\r\n\r\n\t\t\tdirectionBackwards: false,\r\n\t\t\tmirroredLoop: false\r\n\r\n\t\t};\r\n\r\n\t\tthis.animationsMap[ name ] = animation;\r\n\t\tthis.animationsList.push( animation );\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n\t\tvar pattern = /([a-z]+)_?(\\d+)/i;\r\n\r\n\t\tvar firstAnimation, frameRanges = {};\r\n\r\n\t\tvar geometry = this.geometry;\r\n\r\n\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\t\tvar chunks = morph.name.match( pattern );\r\n\r\n\t\t\tif ( chunks && chunks.length > 1 ) {\r\n\r\n\t\t\t\tvar name = chunks[ 1 ];\r\n\r\n\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\r\n\t\t\t\tvar range = frameRanges[ name ];\r\n\r\n\t\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\t\tif ( i > range.end ) range.end = i;\r\n\r\n\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var name in frameRanges ) {\r\n\r\n\t\t\tvar range = frameRanges[ name ];\r\n\t\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\r\n\t\t}\r\n\r\n\t\tthis.firstAnimation = firstAnimation;\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.direction = 1;\r\n\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.direction = - 1;\r\n\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.fps = fps;\r\n\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.duration = duration;\r\n\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.weight = weight;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.time = time;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n\t\tvar time = 0;\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\ttime = animation.time;\r\n\r\n\t\t}\r\n\r\n\t\treturn time;\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n\t\tvar duration = - 1;\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tduration = animation.duration;\r\n\r\n\t\t}\r\n\r\n\t\treturn duration;\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.time = 0;\r\n\t\t\tanimation.active = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.active = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar animation = this.animationsList[ i ];\r\n\r\n\t\t\tif ( ! animation.active ) continue;\r\n\r\n\t\t\tvar frameTime = animation.duration / animation.length;\r\n\r\n\t\t\tanimation.time += animation.direction * delta;\r\n\r\n\t\t\tif ( animation.mirroredLoop ) {\r\n\r\n\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n\t\t\t\t\tanimation.direction *= - 1;\r\n\r\n\t\t\t\t\tif ( animation.time > animation.duration ) {\r\n\r\n\t\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( animation.time < 0 ) {\r\n\r\n\t\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tanimation.time = animation.time % animation.duration;\r\n\r\n\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\t\tvar weight = animation.weight;\r\n\r\n\t\t\tif ( keyframe !== animation.currentFrame ) {\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\t\tanimation.currentFrame = keyframe;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n\t\t\tif ( animation.currentFrame !== animation.lastFrame ) {\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction ImmediateRenderObject( material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.material = material;\n\t\tthis.render = function ( renderCallback ) {};\n\n\t}\n\n\tImmediateRenderObject.prototype = Object.create( Object3D.prototype );\n\tImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\n\n\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction VertexNormalsHelper( object, size, hex, linewidth ) {\n\n\t\tthis.object = object;\n\n\t\tthis.size = ( size !== undefined ) ? size : 1;\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t\t//\n\n\t\tvar nNormals = 0;\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\n\t\t\tnNormals = objGeometry.faces.length * 3;\n\n\t\t} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {\n\n\t\t\tnNormals = objGeometry.attributes.normal.count;\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = new Float32Attribute( nNormals * 2 * 3, 3 );\n\n\t\tgeometry.addAttribute( 'position', positions );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t\t//\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\tVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\tVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\n\n\tVertexNormalsHelper.prototype.update = ( function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar normalMatrix = new Matrix3();\n\n\t\treturn function update() {\n\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\t\tthis.object.updateMatrixWorld( true );\n\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\t\tvar position = this.geometry.attributes.position;\n\n\t\t\t//\n\n\t\t\tvar objGeometry = this.object.geometry;\n\n\t\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\n\t\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\t\tvar faces = objGeometry.faces;\n\n\t\t\t\tvar idx = 0;\n\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\n\t\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\n\t\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {\n\n\t\t\t\tvar objPos = objGeometry.attributes.position;\n\n\t\t\t\tvar objNorm = objGeometry.attributes.normal;\n\n\t\t\t\tvar idx = 0;\n\n\t\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\n\t\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n\t\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\n\t\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction SpotLightHelper( light ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = [\n\t\t\t0, 0, 0,   0,   0,   1,\n\t\t\t0, 0, 0,   1,   0,   1,\n\t\t\t0, 0, 0, - 1,   0,   1,\n\t\t\t0, 0, 0,   0,   1,   1,\n\t\t\t0, 0, 0,   0, - 1,   1\n\t\t];\n\n\t\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\n\t\t}\n\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( positions, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { fog: false } );\n\n\t\tthis.cone = new LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\n\t\tthis.update();\n\n\t}\n\n\tSpotLightHelper.prototype = Object.create( Object3D.prototype );\n\tSpotLightHelper.prototype.constructor = SpotLightHelper;\n\n\tSpotLightHelper.prototype.dispose = function () {\n\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t};\n\n\tSpotLightHelper.prototype.update = function () {\n\n\t\tvar vector = new Vector3();\n\t\tvar vector2 = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\n\t\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author Sean Griffin / http://twitter.com/sgrif\n\t * @author Michael Guerrero / http://realitymeltdown.com\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction SkeletonHelper( object ) {\n\n\t\tthis.bones = this.getBoneList( object );\n\n\t\tvar geometry = new Geometry();\n\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\t\tvar bone = this.bones[ i ];\n\n\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\n\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\tgeometry.colors.push( new Color( 0, 0, 1 ) );\n\t\t\t\tgeometry.colors.push( new Color( 0, 1, 0 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.dynamic = true;\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t\tthis.root = object;\n\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\n\tSkeletonHelper.prototype = Object.create( LineSegments.prototype );\n\tSkeletonHelper.prototype.constructor = SkeletonHelper;\n\n\tSkeletonHelper.prototype.getBoneList = function( object ) {\n\n\t\tvar boneList = [];\n\n\t\tif ( (object && object.isBone) ) {\n\n\t\t\tboneList.push( object );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\n\t\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\n\t\t}\n\n\t\treturn boneList;\n\n\t};\n\n\tSkeletonHelper.prototype.update = function () {\n\n\t\tvar geometry = this.geometry;\n\n\t\tvar matrixWorldInv = new Matrix4().getInverse( this.root.matrixWorld );\n\n\t\tvar boneMatrix = new Matrix4();\n\n\t\tvar j = 0;\n\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\t\tvar bone = this.bones[ i ];\n\n\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\n\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\n\n\t\t\t\tj += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t\tgeometry.computeBoundingSphere();\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction PointLightHelper( light, sphereSize ) {\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\n\t\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\tMesh.call( this, geometry, material );\n\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\t/*\n\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\t\tvar d = light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\n\t\tthis.add( this.lightDistance );\n\t\t*/\n\n\t}\n\n\tPointLightHelper.prototype = Object.create( Mesh.prototype );\n\tPointLightHelper.prototype.constructor = PointLightHelper;\n\n\tPointLightHelper.prototype.dispose = function () {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t};\n\n\tPointLightHelper.prototype.update = function () {\n\n\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t/*\n\t\tvar d = this.light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\t\t*/\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction HemisphereLightHelper( light, sphereSize ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.colors = [ new Color(), new Color() ];\n\n\t\tvar geometry = new SphereGeometry( sphereSize, 4, 2 );\n\t\tgeometry.rotateX( - Math.PI / 2 );\n\n\t\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\n\t\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\n\t\t}\n\n\t\tvar material = new MeshBasicMaterial( { vertexColors: FaceColors, wireframe: true } );\n\n\t\tthis.lightSphere = new Mesh( geometry, material );\n\t\tthis.add( this.lightSphere );\n\n\t\tthis.update();\n\n\t}\n\n\tHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\n\tHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\n\n\tHemisphereLightHelper.prototype.dispose = function () {\n\n\t\tthis.lightSphere.geometry.dispose();\n\t\tthis.lightSphere.material.dispose();\n\n\t};\n\n\tHemisphereLightHelper.prototype.update = function () {\n\n\t\tvar vector = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\n\t\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction GridHelper( size, divisions, color1, color2 ) {\n\n\t\tdivisions = divisions || 1;\n\t\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n\t\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\n\t\tvar center = divisions / 2;\n\t\tvar step = ( size * 2 ) / divisions;\n\t\tvar vertices = [], colors = [];\n\n\t\tfor ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {\n\n\t\t\tvertices.push( - size, 0, k, size, 0, k );\n\t\t\tvertices.push( k, 0, - size, k, 0, size );\n\n\t\t\tvar color = i === center ? color1 : color2;\n\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\n\t\t}\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new Float32Attribute( colors, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t}\n\n\tGridHelper.prototype = Object.create( LineSegments.prototype );\n\tGridHelper.prototype.constructor = GridHelper;\n\n\tGridHelper.prototype.setColors = function () {\n\n\t\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction FaceNormalsHelper( object, size, hex, linewidth ) {\n\n\t\t// FaceNormalsHelper only supports THREE.Geometry\n\n\t\tthis.object = object;\n\n\t\tthis.size = ( size !== undefined ) ? size : 1;\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t\t//\n\n\t\tvar nNormals = 0;\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\n\t\t\tnNormals = objGeometry.faces.length;\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = new Float32Attribute( nNormals * 2 * 3, 3 );\n\n\t\tgeometry.addAttribute( 'position', positions );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t\t//\n\n\t\tthis.matrixAutoUpdate = false;\n\t\tthis.update();\n\n\t}\n\n\tFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\tFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\n\n\tFaceNormalsHelper.prototype.update = ( function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar normalMatrix = new Matrix3();\n\n\t\treturn function update() {\n\n\t\t\tthis.object.updateMatrixWorld( true );\n\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\t\tvar position = this.geometry.attributes.position;\n\n\t\t\t//\n\n\t\t\tvar objGeometry = this.object.geometry;\n\n\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\tvar faces = objGeometry.faces;\n\n\t\t\tvar idx = 0;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tvar normal = face.normal;\n\n\t\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t\t.divideScalar( 3 )\n\t\t\t\t\t.applyMatrix4( matrixWorld );\n\n\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction DirectionalLightHelper( light, size ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tif ( size === undefined ) size = 1;\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( [\n\t\t\t- size,   size, 0,\n\t\t\t  size,   size, 0,\n\t\t\t  size, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size,   size, 0\n\t\t], 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { fog: false } );\n\n\t\tthis.add( new Line( geometry, material ) );\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\t\tthis.add( new Line( geometry, material ));\n\n\t\tthis.update();\n\n\t}\n\n\tDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\n\tDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\n\n\tDirectionalLightHelper.prototype.dispose = function () {\n\n\t\tvar lightPlane = this.children[ 0 ];\n\t\tvar targetLine = this.children[ 1 ];\n\n\t\tlightPlane.geometry.dispose();\n\t\tlightPlane.material.dispose();\n\t\ttargetLine.geometry.dispose();\n\t\ttargetLine.material.dispose();\n\n\t};\n\n\tDirectionalLightHelper.prototype.update = function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar v3 = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t\tv3.subVectors( v2, v1 );\n\n\t\t\tvar lightPlane = this.children[ 0 ];\n\t\t\tvar targetLine = this.children[ 1 ];\n\n\t\t\tlightPlane.lookAt( v3 );\n\t\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t\ttargetLine.lookAt( v3 );\n\t\t\ttargetLine.scale.z = v3.length();\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t *\t- shows frustum, line of sight and up of the camera\n\t *\t- suitable for fast updates\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\t */\n\n\tfunction CameraHelper( camera ) {\n\n\t\tvar geometry = new Geometry();\n\t\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\n\n\t\tvar pointMap = {};\n\n\t\t// colors\n\n\t\tvar hexFrustum = 0xffaa00;\n\t\tvar hexCone = 0xff0000;\n\t\tvar hexUp = 0x00aaff;\n\t\tvar hexTarget = 0xffffff;\n\t\tvar hexCross = 0x333333;\n\n\t\t// near\n\n\t\taddLine( \"n1\", \"n2\", hexFrustum );\n\t\taddLine( \"n2\", \"n4\", hexFrustum );\n\t\taddLine( \"n4\", \"n3\", hexFrustum );\n\t\taddLine( \"n3\", \"n1\", hexFrustum );\n\n\t\t// far\n\n\t\taddLine( \"f1\", \"f2\", hexFrustum );\n\t\taddLine( \"f2\", \"f4\", hexFrustum );\n\t\taddLine( \"f4\", \"f3\", hexFrustum );\n\t\taddLine( \"f3\", \"f1\", hexFrustum );\n\n\t\t// sides\n\n\t\taddLine( \"n1\", \"f1\", hexFrustum );\n\t\taddLine( \"n2\", \"f2\", hexFrustum );\n\t\taddLine( \"n3\", \"f3\", hexFrustum );\n\t\taddLine( \"n4\", \"f4\", hexFrustum );\n\n\t\t// cone\n\n\t\taddLine( \"p\", \"n1\", hexCone );\n\t\taddLine( \"p\", \"n2\", hexCone );\n\t\taddLine( \"p\", \"n3\", hexCone );\n\t\taddLine( \"p\", \"n4\", hexCone );\n\n\t\t// up\n\n\t\taddLine( \"u1\", \"u2\", hexUp );\n\t\taddLine( \"u2\", \"u3\", hexUp );\n\t\taddLine( \"u3\", \"u1\", hexUp );\n\n\t\t// target\n\n\t\taddLine( \"c\", \"t\", hexTarget );\n\t\taddLine( \"p\", \"c\", hexCross );\n\n\t\t// cross\n\n\t\taddLine( \"cn1\", \"cn2\", hexCross );\n\t\taddLine( \"cn3\", \"cn4\", hexCross );\n\n\t\taddLine( \"cf1\", \"cf2\", hexCross );\n\t\taddLine( \"cf3\", \"cf4\", hexCross );\n\n\t\tfunction addLine( a, b, hex ) {\n\n\t\t\taddPoint( a, hex );\n\t\t\taddPoint( b, hex );\n\n\t\t}\n\n\t\tfunction addPoint( id, hex ) {\n\n\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\tgeometry.colors.push( new Color( hex ) );\n\n\t\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\t\tpointMap[ id ] = [];\n\n\t\t\t}\n\n\t\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\n\t\t}\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t\tthis.camera = camera;\n\t\tif( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\t\tthis.matrix = camera.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.pointMap = pointMap;\n\n\t\tthis.update();\n\n\t}\n\n\tCameraHelper.prototype = Object.create( LineSegments.prototype );\n\tCameraHelper.prototype.constructor = CameraHelper;\n\n\tCameraHelper.prototype.update = function () {\n\n\t\tvar geometry, pointMap;\n\n\t\tvar vector = new Vector3();\n\t\tvar camera = new Camera();\n\n\t\tfunction setPoint( point, x, y, z ) {\n\n\t\t\tvector.set( x, y, z ).unproject( camera );\n\n\t\t\tvar points = pointMap[ point ];\n\n\t\t\tif ( points !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn function update() {\n\n\t\t\tgeometry = this.geometry;\n\t\t\tpointMap = this.pointMap;\n\n\t\t\tvar w = 1, h = 1;\n\n\t\t\t// we need just camera projection matrix\n\t\t\t// world matrix must be identity\n\n\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\t\t// center / target\n\n\t\t\tsetPoint( \"c\", 0, 0, - 1 );\n\t\t\tsetPoint( \"t\", 0, 0,  1 );\n\n\t\t\t// near\n\n\t\t\tsetPoint( \"n1\", - w, - h, - 1 );\n\t\t\tsetPoint( \"n2\",   w, - h, - 1 );\n\t\t\tsetPoint( \"n3\", - w,   h, - 1 );\n\t\t\tsetPoint( \"n4\",   w,   h, - 1 );\n\n\t\t\t// far\n\n\t\t\tsetPoint( \"f1\", - w, - h, 1 );\n\t\t\tsetPoint( \"f2\",   w, - h, 1 );\n\t\t\tsetPoint( \"f3\", - w,   h, 1 );\n\t\t\tsetPoint( \"f4\",   w,   h, 1 );\n\n\t\t\t// up\n\n\t\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n\t\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n\t\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\n\n\t\t\t// cross\n\n\t\t\tsetPoint( \"cf1\", - w,   0, 1 );\n\t\t\tsetPoint( \"cf2\",   w,   0, 1 );\n\t\t\tsetPoint( \"cf3\",   0, - h, 1 );\n\t\t\tsetPoint( \"cf4\",   0,   h, 1 );\n\n\t\t\tsetPoint( \"cn1\", - w,   0, - 1 );\n\t\t\tsetPoint( \"cn2\",   w,   0, - 1 );\n\t\t\tsetPoint( \"cn3\",   0, - h, - 1 );\n\t\t\tsetPoint( \"cn4\",   0,   h, - 1 );\n\n\t\t\tgeometry.verticesNeedUpdate = true;\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\t// a helper to show the world-axis-aligned bounding box for an object\n\n\tfunction BoundingBoxHelper( object, hex ) {\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\n\t\tthis.object = object;\n\n\t\tthis.box = new Box3();\n\n\t\tMesh.call( this, new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( { color: color, wireframe: true } ) );\n\n\t}\n\n\tBoundingBoxHelper.prototype = Object.create( Mesh.prototype );\n\tBoundingBoxHelper.prototype.constructor = BoundingBoxHelper;\n\n\tBoundingBoxHelper.prototype.update = function () {\n\n\t\tthis.box.setFromObject( this.object );\n\n\t\tthis.box.getSize( this.scale );\n\n\t\tthis.box.getCenter( this.position );\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BoxHelper( object, color ) {\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\n\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\tvar positions = new Float32Array( 8 * 3 );\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\n\t\tif ( object !== undefined ) {\n\n\t\t\tthis.update( object );\n\n\t\t}\n\n\t}\n\n\tBoxHelper.prototype = Object.create( LineSegments.prototype );\n\tBoxHelper.prototype.constructor = BoxHelper;\n\n\tBoxHelper.prototype.update = ( function () {\n\n\t\tvar box = new Box3();\n\n\t\treturn function update( object ) {\n\n\t\t\tif ( (object && object.isBox3) ) {\n\n\t\t\t\tbox.copy( object );\n\n\t\t\t} else {\n\n\t\t\t\tbox.setFromObject( object );\n\n\t\t\t}\n\n\t\t\tif ( box.isEmpty() ) return;\n\n\t\t\tvar min = box.min;\n\t\t\tvar max = box.max;\n\n\t\t\t/*\n\t\t\t  5____4\n\t\t\t1/___0/|\n\t\t\t| 6__|_7\n\t\t\t2/___3/\n\n\t\t\t0: max.x, max.y, max.z\n\t\t\t1: min.x, max.y, max.z\n\t\t\t2: min.x, min.y, max.z\n\t\t\t3: max.x, min.y, max.z\n\t\t\t4: max.x, max.y, min.z\n\t\t\t5: min.x, max.y, min.z\n\t\t\t6: min.x, min.y, min.z\n\t\t\t7: max.x, min.y, min.z\n\t\t\t*/\n\n\t\t\tvar position = this.geometry.attributes.position;\n\t\t\tvar array = position.array;\n\n\t\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n\t\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n\t\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n\t\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t\tthis.geometry.computeBoundingSphere();\n\n\t\t};\n\n\t} )();\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author zz85 / http://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t *\n\t * Creates an arrow for visualizing directions\n\t *\n\t * Parameters:\n\t *  dir - Vector3\n\t *  origin - Vector3\n\t *  length - Number\n\t *  color - color in hex value\n\t *  headLength - Number\n\t *  headWidth - Number\n\t */\n\n\tvar lineGeometry = new BufferGeometry();\n\tlineGeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\tvar coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\tconeGeometry.translate( 0, - 0.5, 0 );\n\n\tfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tObject3D.call( this );\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\t\tif ( length === undefined ) length = 1;\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t}\n\n\tArrowHelper.prototype = Object.create( Object3D.prototype );\n\tArrowHelper.prototype.constructor = ArrowHelper;\n\n\tArrowHelper.prototype.setDirection = ( function () {\n\n\t\tvar axis = new Vector3();\n\t\tvar radians;\n\n\t\treturn function setDirection( dir ) {\n\n\t\t\t// dir is assumed to be normalized\n\n\t\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\t\tradians = Math.acos( dir.y );\n\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\n\t\t\t}\n\n\t\t};\n\n\t}() );\n\n\tArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\t\tthis.line.updateMatrix();\n\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\tthis.cone.position.y = length;\n\t\tthis.cone.updateMatrix();\n\n\t};\n\n\tArrowHelper.prototype.setColor = function ( color ) {\n\n\t\tthis.line.material.color.copy( color );\n\t\tthis.cone.material.color.copy( color );\n\n\t};\n\n\t/**\n\t * @author sroucheray / http://sroucheray.org/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AxisHelper( size ) {\n\n\t\tsize = size || 1;\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t0, 0, 0,  size, 0, 0,\n\t\t\t0, 0, 0,  0, size, 0,\n\t\t\t0, 0, 0,  0, 0, size\n\t\t] );\n\n\t\tvar colors = new Float32Array( [\n\t\t\t1, 0, 0,  1, 0.6, 0,\n\t\t\t0, 1, 0,  0.6, 1, 0,\n\t\t\t0, 0, 1,  0, 0.6, 1\n\t\t] );\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t}\n\n\tAxisHelper.prototype = Object.create( LineSegments.prototype );\n\tAxisHelper.prototype.constructor = AxisHelper;\n\n\t/**\n\t * @author zz85 https://github.com/zz85\n\t *\n\t * Centripetal CatmullRom Curve - which is useful for avoiding\n\t * cusps and self-intersections in non-uniform catmull rom curves.\n\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\t *\n\t * curve.type accepts centripetal(default), chordal and catmullrom\n\t * curve.tension is used for catmullrom which defaults to 0.5\n\t */\n\n\tvar CatmullRomCurve3 = ( function() {\n\n\t\tvar\n\t\t\ttmp = new Vector3(),\n\t\t\tpx = new CubicPoly(),\n\t\t\tpy = new CubicPoly(),\n\t\t\tpz = new CubicPoly();\n\n\t\t/*\n\t\tBased on an optimized c++ solution in\n\t\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t\t - http://ideone.com/NoEbVM\n\n\t\tThis CubicPoly class could be used for reusing some variables and calculations,\n\t\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\t\twhich can be placed in CurveUtils.\n\t\t*/\n\n\t\tfunction CubicPoly() {}\n\n\t\t/*\n\t\t * Compute coefficients for a cubic polynomial\n\t\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t\t * such that\n\t\t *   p(0) = x0, p(1) = x1\n\t\t *  and\n\t\t *   p'(0) = t0, p'(1) = t1.\n\t\t */\n\t\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\n\n\t\t\tthis.c0 = x0;\n\t\t\tthis.c1 = t0;\n\t\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t\t};\n\n\t\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\t// initCubicPoly\n\t\t\tthis.init( x1, x2, t1, t2 );\n\n\t\t};\n\n\t\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\t\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\n\n\t\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t};\n\n\t\tCubicPoly.prototype.calc = function( t ) {\n\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t2 * t;\n\t\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n\n\t\t};\n\n\t\t// Subclass Three.js curve\n\t\treturn Curve.create(\n\n\t\t\tfunction ( p /* array of Vector3 */ ) {\n\n\t\t\t\tthis.points = p || [];\n\t\t\t\tthis.closed = false;\n\n\t\t\t},\n\n\t\t\tfunction ( t ) {\n\n\t\t\t\tvar points = this.points,\n\t\t\t\t\tpoint, intPoint, weight, l;\n\n\t\t\t\tl = points.length;\n\n\t\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\n\t\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\t\tintPoint = Math.floor( point );\n\t\t\t\tweight = point - intPoint;\n\n\t\t\t\tif ( this.closed ) {\n\n\t\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\n\t\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\t\t\tintPoint = l - 2;\n\t\t\t\t\tweight = 1;\n\n\t\t\t\t}\n\n\t\t\t\tvar p0, p1, p2, p3; // 4 points\n\n\t\t\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// extrapolate first point\n\t\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\t\tp0 = tmp;\n\n\t\t\t\t}\n\n\t\t\t\tp1 = points[ intPoint % l ];\n\t\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\n\t\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// extrapolate last point\n\t\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\t\tp3 = tmp;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\n\t\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\n\t\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t\t\t// safety check for repeated points\n\t\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t\t\t} else if ( this.type === 'catmullrom' ) {\n\n\t\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\n\t\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n\t\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n\t\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\n\t\t\t\t}\n\n\t\t\t\tvar v = new Vector3(\n\t\t\t\t\tpx.calc( weight ),\n\t\t\t\t\tpy.calc( weight ),\n\t\t\t\t\tpz.calc( weight )\n\t\t\t\t);\n\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t);\n\n\t} )();\n\n\t/**************************************************************\n\t *\tClosed Spline 3D curve\n\t **************************************************************/\n\n\n\tfunction ClosedSplineCurve3( points ) {\n\n\t\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\n\n\t\tCatmullRomCurve3.call( this, points );\n\t\tthis.type = 'catmullrom';\n\t\tthis.closed = true;\n\n\t}\n\n\tClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\n\t/**************************************************************\n\t *\tSpline 3D curve\n\t **************************************************************/\n\n\n\tvar SplineCurve3 = Curve.create(\n\n\t\tfunction ( points /* array of Vector3 */ ) {\n\n\t\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\n\t\t\tthis.points = ( points === undefined ) ? [] : points;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar points = this.points;\n\t\t\tvar point = ( points.length - 1 ) * t;\n\n\t\t\tvar intPoint = Math.floor( point );\n\t\t\tvar weight = point - intPoint;\n\n\t\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\n\t\t\tvar point1 = points[ intPoint ];\n\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\t\tvar interpolate = CurveUtils.interpolate;\n\n\t\t\treturn new Vector3(\n\t\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\n\t\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\n\t\t\t);\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tCubic Bezier 3D curve\n\t **************************************************************/\n\n\tvar CubicBezierCurve3 = Curve.create(\n\n\t\tfunction ( v0, v1, v2, v3 ) {\n\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar b3 = ShapeUtils.b3;\n\n\t\t\treturn new Vector3(\n\t\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\n\t\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\n\t\t\t);\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tQuadratic Bezier 3D curve\n\t **************************************************************/\n\n\tvar QuadraticBezierCurve3 = Curve.create(\n\n\t\tfunction ( v0, v1, v2 ) {\n\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar b2 = ShapeUtils.b2;\n\n\t\t\treturn new Vector3(\n\t\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\n\t\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\n\t\t\t);\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tLine3D\n\t **************************************************************/\n\n\tvar LineCurve3 = Curve.create(\n\n\t\tfunction ( v1, v2 ) {\n\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tif ( t === 1 ) {\n\n\t\t\t\treturn this.v2.clone();\n\n\t\t\t}\n\n\t\t\tvar vector = new Vector3();\n\n\t\t\tvector.subVectors( this.v2, this.v1 ); // diff\n\t\t\tvector.multiplyScalar( t );\n\t\t\tvector.add( this.v1 );\n\n\t\t\treturn vector;\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tArc curve\n\t **************************************************************/\n\n\tfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t}\n\n\tArcCurve.prototype = Object.create( EllipseCurve.prototype );\n\tArcCurve.prototype.constructor = ArcCurve;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tvar SceneUtils = {\n\n\t\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\n\t\t\tvar group = new Group();\n\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tgroup.add( new Mesh( geometry, materials[ i ] ) );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t},\n\n\t\tdetach: function ( child, parent, scene ) {\n\n\t\t\tchild.applyMatrix( parent.matrixWorld );\n\t\t\tparent.remove( child );\n\t\t\tscene.add( child );\n\n\t\t},\n\n\t\tattach: function ( child, scene, parent ) {\n\n\t\t\tvar matrixWorldInverse = new Matrix4();\n\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\t\tchild.applyMatrix( matrixWorldInverse );\n\n\t\t\tscene.remove( child );\n\t\t\tparent.add( child );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Face4 ( a, b, c, d, normal, color, materialIndex ) {\n\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\treturn new Face3( a, b, c, normal, color, materialIndex );\n\t}\n\n\tvar LineStrip = 0;\n\n\tvar LinePieces = 1;\n\n\tfunction PointCloud ( geometry, material ) {\n\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\treturn new Points( geometry, material );\n\t}\n\n\tfunction ParticleSystem ( geometry, material ) {\n\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\treturn new Points( geometry, material );\n\t}\n\n\tfunction PointCloudMaterial ( parameters ) {\n\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\t}\n\n\tfunction ParticleBasicMaterial ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\t}\n\n\tfunction ParticleSystemMaterial ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\t}\n\n\tfunction Vertex ( x, y, z ) {\n\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\treturn new Vector3( x, y, z );\n\t}\n\n\t//\n\n\tfunction EdgesHelper( object, hex ) {\n\t\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\n\t\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t}\n\n\tfunction WireframeHelper( object, hex ) {\n\t\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\n\t\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t}\n\n\t//\n\n\tObject.assign( Box2.prototype, {\n\t\tcenter: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\t\t},\n\t\tempty: function () {\n\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\t\treturn this.isEmpty();\n\t\t},\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tsize: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\n\t\t\treturn this.getSize( optionalTarget );\n\t\t}\n\t} );\n\n\tObject.assign( Box3.prototype, {\n\t\tcenter: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\t\t},\n\t\tempty: function () {\n\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\t\treturn this.isEmpty();\n\t\t},\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\treturn this.intersectsSphere( sphere );\n\t\t},\n\t\tsize: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\n\t\t\treturn this.getSize( optionalTarget );\n\t\t}\n\t} );\n\n\tObject.assign( Line3.prototype, {\n\t\tcenter: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\t\t}\n\t} );\n\n\tObject.assign( Matrix3.prototype, {\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix3( this );\n\t\t},\n\t\tmultiplyVector3Array: function ( a ) {\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\treturn this.applyToVector3Array( a );\n\t\t}\n\t} );\n\n\tObject.assign( Matrix4.prototype, {\n\t\textractPosition: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\t\treturn this.copyPosition( m );\n\t\t},\n\t\tsetRotationFromQuaternion: function ( q ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\t\treturn this.makeRotationFromQuaternion( q );\n\t\t},\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\t\treturn vector.applyProjection( this );\n\t\t},\n\t\tmultiplyVector4: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\t\t},\n\t\tmultiplyVector3Array: function ( a ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\treturn this.applyToVector3Array( a );\n\t\t},\n\t\trotateAxis: function ( v ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\t\tv.transformDirection( this );\n\t\t},\n\t\tcrossVector: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\t\t},\n\t\ttranslate: function ( v ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t\t},\n\t\trotateX: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t\t},\n\t\trotateY: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t\t},\n\t\trotateZ: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t\t},\n\t\trotateByAxis: function ( axis, angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t\t}\n\t} );\n\n\tObject.assign( Plane.prototype, {\n\t\tisIntersectionLine: function ( line ) {\n\t\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\t\treturn this.intersectsLine( line );\n\t\t}\n\t} );\n\n\tObject.assign( Quaternion.prototype, {\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\t\treturn vector.applyQuaternion( this );\n\t\t}\n\t} );\n\n\tObject.assign( Ray.prototype, {\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tisIntersectionPlane: function ( plane ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\t\treturn this.intersectsPlane( plane );\n\t\t},\n\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\treturn this.intersectsSphere( sphere );\n\t\t}\n\t} );\n\n\tObject.assign( Shape.prototype, {\n\t\textrude: function ( options ) {\n\t\t\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\n\t\t\treturn new ExtrudeGeometry( this, options );\n\t\t},\n\t\tmakeGeometry: function ( options ) {\n\t\t\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\n\t\t\treturn new ShapeGeometry( this, options );\n\t\t}\n\t} );\n\n\tObject.assign( Vector3.prototype, {\n\t\tsetEulerFromRotationMatrix: function () {\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t\t},\n\t\tsetEulerFromQuaternion: function () {\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t\t},\n\t\tgetPositionFromMatrix: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\t\treturn this.setFromMatrixPosition( m );\n\t\t},\n\t\tgetScaleFromMatrix: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\t\treturn this.setFromMatrixScale( m );\n\t\t},\n\t\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\t\treturn this.setFromMatrixColumn( matrix, index );\n\t\t}\n\t} );\n\n\t//\n\n\tObject.assign( Object3D.prototype, {\n\t\tgetChildByName: function ( name ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\t\treturn this.getObjectByName( name );\n\t\t},\n\t\trenderDepth: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t\t},\n\t\ttranslate: function ( distance, axis ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\t\treturn this.translateOnAxis( axis, distance );\n\t\t}\n\t} );\n\n\tObject.defineProperties( Object3D.prototype, {\n\t\teulerOrder: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\treturn this.rotation.order;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\tthis.rotation.order = value;\n\t\t\t}\n\t\t},\n\t\tuseQuaternion: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( LOD.prototype, {\n\t\tobjects: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\t\treturn this.levels;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\t\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\n\t\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\t\tthis.setFocalLength( focalLength );\n\n\t};\n\n\t//\n\n\tObject.defineProperties( Light.prototype, {\n\t\tonlyShadow: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\t\t}\n\t\t},\n\t\tshadowCameraFov: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\t\tthis.shadow.camera.fov = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraLeft: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\t\tthis.shadow.camera.left = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraRight: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\t\tthis.shadow.camera.right = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraTop: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\t\tthis.shadow.camera.top = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraBottom: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\t\tthis.shadow.camera.bottom = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraNear: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\t\tthis.shadow.camera.near = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraFar: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\t\tthis.shadow.camera.far = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraVisible: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\t\t}\n\t\t},\n\t\tshadowBias: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\t\tthis.shadow.bias = value;\n\t\t\t}\n\t\t},\n\t\tshadowDarkness: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\t\t}\n\t\t},\n\t\tshadowMapWidth: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\t\tthis.shadow.mapSize.width = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapHeight: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\t\tthis.shadow.mapSize.height = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.defineProperties( BufferAttribute.prototype, {\n\t\tlength: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\t\treturn this.array.length;\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.assign( BufferGeometry.prototype, {\n\t\taddIndex: function ( index ) {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\t\tthis.setIndex( index );\n\t\t},\n\t\taddDrawCall: function ( start, count, indexOffset ) {\n\t\t\tif ( indexOffset !== undefined ) {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\t\t}\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\t\tthis.addGroup( start, count );\n\t\t},\n\t\tclearDrawCalls: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\t\tthis.clearGroups();\n\t\t},\n\t\tcomputeTangents: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t\t},\n\t\tcomputeOffsets: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t\t}\n\t} );\n\n\tObject.defineProperties( BufferGeometry.prototype, {\n\t\tdrawcalls: {\n\t\t\tget: function () {\n\t\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t},\n\t\toffsets: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.defineProperties( Material.prototype, {\n\t\twrapAround: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t}\n\t\t},\n\t\twrapRGB: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n\t\t\t\treturn new Color();\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( MeshPhongMaterial.prototype, {\n\t\tmetal: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( ShaderMaterial.prototype, {\n\t\tderivatives: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\treturn this.extensions.derivatives;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\tthis.extensions.derivatives = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tEventDispatcher.prototype = Object.assign( Object.create( {\n\n\t\t// Note: Extra base ensures these properties are not 'assign'ed.\n\n\t\tconstructor: EventDispatcher,\n\n\t\tapply: function ( target ) {\n\n\t\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\n\t\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\n\n\t\t\tObject.assign( target, this );\n\n\t\t}\n\n\t} ), EventDispatcher.prototype );\n\n\t//\n\n\tObject.defineProperties( Uniform.prototype, {\n\t\tdynamic: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t}\n\t\t},\n\t\tonUpdate: {\n\t\t\tvalue: function () {\n\t\t\t\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.assign( WebGLRenderer.prototype, {\n\t\tsupportsFloatTextures: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_texture_float' );\n\t\t},\n\t\tsupportsHalfFloatTextures: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t\t},\n\t\tsupportsStandardDerivatives: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t\t},\n\t\tsupportsCompressedTextureS3TC: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\t},\n\t\tsupportsCompressedTexturePVRTC: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\t},\n\t\tsupportsBlendMinMax: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t\t},\n\t\tsupportsVertexTextures: function () {\n\t\t\treturn this.capabilities.vertexTextures;\n\t\t},\n\t\tsupportsInstancedArrays: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t\t},\n\t\tenableScissorTest: function ( boolean ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\t\tthis.setScissorTest( boolean );\n\t\t},\n\t\tinitMaterial: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t\t},\n\t\taddPrePlugin: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t\t},\n\t\taddPostPlugin: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t\t},\n\t\tupdateShadowMap: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t\t}\n\t} );\n\n\tObject.defineProperties( WebGLRenderer.prototype, {\n\t\tshadowMapEnabled: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.enabled;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\t\tthis.shadowMap.enabled = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapType: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.type;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\t\tthis.shadowMap.type = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapCullFace: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.cullFace;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n\t\t\t\tthis.shadowMap.cullFace = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( WebGLShadowMap.prototype, {\n\t\tcullFace: {\n\t\t\tget: function () {\n\t\t\t\treturn this.renderReverseSided ? CullFaceFront : CullFaceBack;\n\t\t\t},\n\t\t\tset: function ( cullFace ) {\n\t\t\t\tvar value = ( cullFace !== CullFaceBack );\n\t\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n\t\t\t\tthis.renderReverseSided = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.defineProperties( WebGLRenderTarget.prototype, {\n\t\twrapS: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\treturn this.texture.wrapS;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\tthis.texture.wrapS = value;\n\t\t\t}\n\t\t},\n\t\twrapT: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\treturn this.texture.wrapT;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\tthis.texture.wrapT = value;\n\t\t\t}\n\t\t},\n\t\tmagFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\treturn this.texture.magFilter;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\tthis.texture.magFilter = value;\n\t\t\t}\n\t\t},\n\t\tminFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\treturn this.texture.minFilter;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\tthis.texture.minFilter = value;\n\t\t\t}\n\t\t},\n\t\tanisotropy: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\treturn this.texture.anisotropy;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\tthis.texture.anisotropy = value;\n\t\t\t}\n\t\t},\n\t\toffset: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\treturn this.texture.offset;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\tthis.texture.offset = value;\n\t\t\t}\n\t\t},\n\t\trepeat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\treturn this.texture.repeat;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\tthis.texture.repeat = value;\n\t\t\t}\n\t\t},\n\t\tformat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\treturn this.texture.format;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\tthis.texture.format = value;\n\t\t\t}\n\t\t},\n\t\ttype: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\treturn this.texture.type;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\tthis.texture.type = value;\n\t\t\t}\n\t\t},\n\t\tgenerateMipmaps: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\treturn this.texture.generateMipmaps;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\tthis.texture.generateMipmaps = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.assign( Audio.prototype, {\n\t\tload: function ( file ) {\n\t\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\n\t\t\tvar scope = this;\n\t\t\tvar audioLoader = new AudioLoader();\n\t\t\taudioLoader.load( file, function ( buffer ) {\n\t\t\t\tscope.setBuffer( buffer );\n\t\t\t} );\n\t\t\treturn this;\n\t\t}\n\t} );\n\n\tObject.assign( AudioAnalyser.prototype, {\n\t\tgetData: function ( file ) {\n\t\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\t\treturn this.getFrequencyData();\n\t\t}\n\t} );\n\n\t//\n\n\tvar GeometryUtils = {\n\n\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\n\t\t\tvar matrix;\n\n\t\t\tif ( geometry2.isMesh ) {\n\n\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n\t\t\t\tmatrix = geometry2.matrix;\n\t\t\t\tgeometry2 = geometry2.geometry;\n\n\t\t\t}\n\n\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\n\t\t},\n\n\t\tcenter: function ( geometry ) {\n\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\t\treturn geometry.center();\n\n\t\t}\n\n\t};\n\n\tvar ImageUtils = {\n\n\t\tcrossOrigin: undefined,\n\n\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n\t\t\tvar loader = new TextureLoader();\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\n\t\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n\t\t\tvar loader = new CubeTextureLoader();\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\n\t\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tloadCompressedTexture: function () {\n\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n\t\t},\n\n\t\tloadCompressedTextureCube: function () {\n\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tfunction Projector () {\n\n\t\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\n\t\tthis.projectVector = function ( vector, camera ) {\n\n\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\t\tvector.project( camera );\n\n\t\t};\n\n\t\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\t\tvector.unproject( camera );\n\n\t\t};\n\n\t\tthis.pickingRay = function ( vector, camera ) {\n\n\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t\t};\n\n\t}\n\n\t//\n\n\tfunction CanvasRenderer () {\n\n\t\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\n\t\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\tthis.clear = function () {};\n\t\tthis.render = function () {};\n\t\tthis.setClearColor = function () {};\n\t\tthis.setSize = function () {};\n\n\t}\n\n\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\n\texports.WebGLRenderTarget = WebGLRenderTarget;\n\texports.WebGLRenderer = WebGLRenderer;\n\texports.ShaderLib = ShaderLib;\n\texports.UniformsLib = UniformsLib;\n\texports.UniformsUtils = UniformsUtils;\n\texports.ShaderChunk = ShaderChunk;\n\texports.FogExp2 = FogExp2;\n\texports.Fog = Fog;\n\texports.Scene = Scene;\n\texports.LensFlare = LensFlare;\n\texports.Sprite = Sprite;\n\texports.LOD = LOD;\n\texports.SkinnedMesh = SkinnedMesh;\n\texports.Skeleton = Skeleton;\n\texports.Bone = Bone;\n\texports.Mesh = Mesh;\n\texports.LineSegments = LineSegments;\n\texports.Line = Line;\n\texports.Points = Points;\n\texports.Group = Group;\n\texports.VideoTexture = VideoTexture;\n\texports.DataTexture = DataTexture;\n\texports.CompressedTexture = CompressedTexture;\n\texports.CubeTexture = CubeTexture;\n\texports.CanvasTexture = CanvasTexture;\n\texports.DepthTexture = DepthTexture;\n\texports.TextureIdCount = TextureIdCount;\n\texports.Texture = Texture;\n\texports.MaterialIdCount = MaterialIdCount;\n\texports.CompressedTextureLoader = CompressedTextureLoader;\n\texports.BinaryTextureLoader = BinaryTextureLoader;\n\texports.DataTextureLoader = DataTextureLoader;\n\texports.CubeTextureLoader = CubeTextureLoader;\n\texports.TextureLoader = TextureLoader;\n\texports.ObjectLoader = ObjectLoader;\n\texports.MaterialLoader = MaterialLoader;\n\texports.BufferGeometryLoader = BufferGeometryLoader;\n\texports.DefaultLoadingManager = DefaultLoadingManager;\n\texports.LoadingManager = LoadingManager;\n\texports.JSONLoader = JSONLoader;\n\texports.ImageLoader = ImageLoader;\n\texports.FontLoader = FontLoader;\n\texports.XHRLoader = XHRLoader;\n\texports.Loader = Loader;\n\texports.Cache = Cache;\n\texports.AudioLoader = AudioLoader;\n\texports.SpotLightShadow = SpotLightShadow;\n\texports.SpotLight = SpotLight;\n\texports.PointLight = PointLight;\n\texports.HemisphereLight = HemisphereLight;\n\texports.DirectionalLightShadow = DirectionalLightShadow;\n\texports.DirectionalLight = DirectionalLight;\n\texports.AmbientLight = AmbientLight;\n\texports.LightShadow = LightShadow;\n\texports.Light = Light;\n\texports.StereoCamera = StereoCamera;\n\texports.PerspectiveCamera = PerspectiveCamera;\n\texports.OrthographicCamera = OrthographicCamera;\n\texports.CubeCamera = CubeCamera;\n\texports.Camera = Camera;\n\texports.AudioListener = AudioListener;\n\texports.PositionalAudio = PositionalAudio;\n\texports.getAudioContext = getAudioContext;\n\texports.AudioAnalyser = AudioAnalyser;\n\texports.Audio = Audio;\n\texports.VectorKeyframeTrack = VectorKeyframeTrack;\n\texports.StringKeyframeTrack = StringKeyframeTrack;\n\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\n\texports.NumberKeyframeTrack = NumberKeyframeTrack;\n\texports.ColorKeyframeTrack = ColorKeyframeTrack;\n\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\n\texports.PropertyMixer = PropertyMixer;\n\texports.PropertyBinding = PropertyBinding;\n\texports.KeyframeTrack = KeyframeTrack;\n\texports.AnimationUtils = AnimationUtils;\n\texports.AnimationObjectGroup = AnimationObjectGroup;\n\texports.AnimationMixer = AnimationMixer;\n\texports.AnimationClip = AnimationClip;\n\texports.Uniform = Uniform;\n\texports.InstancedBufferGeometry = InstancedBufferGeometry;\n\texports.BufferGeometry = BufferGeometry;\n\texports.GeometryIdCount = GeometryIdCount;\n\texports.Geometry = Geometry;\n\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\n\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\n\texports.InterleavedBuffer = InterleavedBuffer;\n\texports.InstancedBufferAttribute = InstancedBufferAttribute;\n\texports.DynamicBufferAttribute = DynamicBufferAttribute;\n\texports.Float64Attribute = Float64Attribute;\n\texports.Float32Attribute = Float32Attribute;\n\texports.Uint32Attribute = Uint32Attribute;\n\texports.Int32Attribute = Int32Attribute;\n\texports.Uint16Attribute = Uint16Attribute;\n\texports.Int16Attribute = Int16Attribute;\n\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\n\texports.Uint8Attribute = Uint8Attribute;\n\texports.Int8Attribute = Int8Attribute;\n\texports.BufferAttribute = BufferAttribute;\n\texports.Face3 = Face3;\n\texports.Object3DIdCount = Object3DIdCount;\n\texports.Object3D = Object3D;\n\texports.Raycaster = Raycaster;\n\texports.Layers = Layers;\n\texports.EventDispatcher = EventDispatcher;\n\texports.Clock = Clock;\n\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\n\texports.LinearInterpolant = LinearInterpolant;\n\texports.DiscreteInterpolant = DiscreteInterpolant;\n\texports.CubicInterpolant = CubicInterpolant;\n\texports.Interpolant = Interpolant;\n\texports.Triangle = Triangle;\n\texports.Spline = Spline;\n\texports.Math = _Math;\n\texports.Spherical = Spherical;\n\texports.Plane = Plane;\n\texports.Frustum = Frustum;\n\texports.Sphere = Sphere;\n\texports.Ray = Ray;\n\texports.Matrix4 = Matrix4;\n\texports.Matrix3 = Matrix3;\n\texports.Box3 = Box3;\n\texports.Box2 = Box2;\n\texports.Line3 = Line3;\n\texports.Euler = Euler;\n\texports.Vector4 = Vector4;\n\texports.Vector3 = Vector3;\n\texports.Vector2 = Vector2;\n\texports.Quaternion = Quaternion;\n\texports.ColorKeywords = ColorKeywords;\n\texports.Color = Color;\n\texports.MorphBlendMesh = MorphBlendMesh;\n\texports.ImmediateRenderObject = ImmediateRenderObject;\n\texports.VertexNormalsHelper = VertexNormalsHelper;\n\texports.SpotLightHelper = SpotLightHelper;\n\texports.SkeletonHelper = SkeletonHelper;\n\texports.PointLightHelper = PointLightHelper;\n\texports.HemisphereLightHelper = HemisphereLightHelper;\n\texports.GridHelper = GridHelper;\n\texports.FaceNormalsHelper = FaceNormalsHelper;\n\texports.DirectionalLightHelper = DirectionalLightHelper;\n\texports.CameraHelper = CameraHelper;\n\texports.BoundingBoxHelper = BoundingBoxHelper;\n\texports.BoxHelper = BoxHelper;\n\texports.ArrowHelper = ArrowHelper;\n\texports.AxisHelper = AxisHelper;\n\texports.ClosedSplineCurve3 = ClosedSplineCurve3;\n\texports.CatmullRomCurve3 = CatmullRomCurve3;\n\texports.SplineCurve3 = SplineCurve3;\n\texports.CubicBezierCurve3 = CubicBezierCurve3;\n\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\n\texports.LineCurve3 = LineCurve3;\n\texports.ArcCurve = ArcCurve;\n\texports.EllipseCurve = EllipseCurve;\n\texports.SplineCurve = SplineCurve;\n\texports.CubicBezierCurve = CubicBezierCurve;\n\texports.QuadraticBezierCurve = QuadraticBezierCurve;\n\texports.LineCurve = LineCurve;\n\texports.Shape = Shape;\n\texports.ShapePath = ShapePath;\n\texports.Path = Path;\n\texports.Font = Font;\n\texports.CurvePath = CurvePath;\n\texports.Curve = Curve;\n\texports.ShapeUtils = ShapeUtils;\n\texports.SceneUtils = SceneUtils;\n\texports.CurveUtils = CurveUtils;\n\texports.WireframeGeometry = WireframeGeometry;\n\texports.ParametricGeometry = ParametricGeometry;\n\texports.ParametricBufferGeometry = ParametricBufferGeometry;\n\texports.TetrahedronGeometry = TetrahedronGeometry;\n\texports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;\n\texports.OctahedronGeometry = OctahedronGeometry;\n\texports.OctahedronBufferGeometry = OctahedronBufferGeometry;\n\texports.IcosahedronGeometry = IcosahedronGeometry;\n\texports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;\n\texports.DodecahedronGeometry = DodecahedronGeometry;\n\texports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;\n\texports.PolyhedronGeometry = PolyhedronGeometry;\n\texports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;\n\texports.TubeGeometry = TubeGeometry;\n\texports.TubeBufferGeometry = TubeBufferGeometry;\n\texports.TorusKnotGeometry = TorusKnotGeometry;\n\texports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;\n\texports.TorusGeometry = TorusGeometry;\n\texports.TorusBufferGeometry = TorusBufferGeometry;\n\texports.TextGeometry = TextGeometry;\n\texports.SphereBufferGeometry = SphereBufferGeometry;\n\texports.SphereGeometry = SphereGeometry;\n\texports.RingGeometry = RingGeometry;\n\texports.RingBufferGeometry = RingBufferGeometry;\n\texports.PlaneBufferGeometry = PlaneBufferGeometry;\n\texports.PlaneGeometry = PlaneGeometry;\n\texports.LatheGeometry = LatheGeometry;\n\texports.LatheBufferGeometry = LatheBufferGeometry;\n\texports.ShapeGeometry = ShapeGeometry;\n\texports.ExtrudeGeometry = ExtrudeGeometry;\n\texports.EdgesGeometry = EdgesGeometry;\n\texports.ConeGeometry = ConeGeometry;\n\texports.ConeBufferGeometry = ConeBufferGeometry;\n\texports.CylinderGeometry = CylinderGeometry;\n\texports.CylinderBufferGeometry = CylinderBufferGeometry;\n\texports.CircleBufferGeometry = CircleBufferGeometry;\n\texports.CircleGeometry = CircleGeometry;\n\texports.BoxBufferGeometry = BoxBufferGeometry;\n\texports.BoxGeometry = BoxGeometry;\n\texports.ShadowMaterial = ShadowMaterial;\n\texports.SpriteMaterial = SpriteMaterial;\n\texports.RawShaderMaterial = RawShaderMaterial;\n\texports.ShaderMaterial = ShaderMaterial;\n\texports.PointsMaterial = PointsMaterial;\n\texports.MultiMaterial = MultiMaterial;\n\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\n\texports.MeshStandardMaterial = MeshStandardMaterial;\n\texports.MeshPhongMaterial = MeshPhongMaterial;\n\texports.MeshNormalMaterial = MeshNormalMaterial;\n\texports.MeshLambertMaterial = MeshLambertMaterial;\n\texports.MeshDepthMaterial = MeshDepthMaterial;\n\texports.MeshBasicMaterial = MeshBasicMaterial;\n\texports.LineDashedMaterial = LineDashedMaterial;\n\texports.LineBasicMaterial = LineBasicMaterial;\n\texports.Material = Material;\n\texports.REVISION = REVISION;\n\texports.MOUSE = MOUSE;\n\texports.CullFaceNone = CullFaceNone;\n\texports.CullFaceBack = CullFaceBack;\n\texports.CullFaceFront = CullFaceFront;\n\texports.CullFaceFrontBack = CullFaceFrontBack;\n\texports.FrontFaceDirectionCW = FrontFaceDirectionCW;\n\texports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;\n\texports.BasicShadowMap = BasicShadowMap;\n\texports.PCFShadowMap = PCFShadowMap;\n\texports.PCFSoftShadowMap = PCFSoftShadowMap;\n\texports.FrontSide = FrontSide;\n\texports.BackSide = BackSide;\n\texports.DoubleSide = DoubleSide;\n\texports.FlatShading = FlatShading;\n\texports.SmoothShading = SmoothShading;\n\texports.NoColors = NoColors;\n\texports.FaceColors = FaceColors;\n\texports.VertexColors = VertexColors;\n\texports.NoBlending = NoBlending;\n\texports.NormalBlending = NormalBlending;\n\texports.AdditiveBlending = AdditiveBlending;\n\texports.SubtractiveBlending = SubtractiveBlending;\n\texports.MultiplyBlending = MultiplyBlending;\n\texports.CustomBlending = CustomBlending;\n\texports.BlendingMode = BlendingMode;\n\texports.AddEquation = AddEquation;\n\texports.SubtractEquation = SubtractEquation;\n\texports.ReverseSubtractEquation = ReverseSubtractEquation;\n\texports.MinEquation = MinEquation;\n\texports.MaxEquation = MaxEquation;\n\texports.ZeroFactor = ZeroFactor;\n\texports.OneFactor = OneFactor;\n\texports.SrcColorFactor = SrcColorFactor;\n\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\n\texports.SrcAlphaFactor = SrcAlphaFactor;\n\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\n\texports.DstAlphaFactor = DstAlphaFactor;\n\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\n\texports.DstColorFactor = DstColorFactor;\n\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\n\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\n\texports.NeverDepth = NeverDepth;\n\texports.AlwaysDepth = AlwaysDepth;\n\texports.LessDepth = LessDepth;\n\texports.LessEqualDepth = LessEqualDepth;\n\texports.EqualDepth = EqualDepth;\n\texports.GreaterEqualDepth = GreaterEqualDepth;\n\texports.GreaterDepth = GreaterDepth;\n\texports.NotEqualDepth = NotEqualDepth;\n\texports.MultiplyOperation = MultiplyOperation;\n\texports.MixOperation = MixOperation;\n\texports.AddOperation = AddOperation;\n\texports.NoToneMapping = NoToneMapping;\n\texports.LinearToneMapping = LinearToneMapping;\n\texports.ReinhardToneMapping = ReinhardToneMapping;\n\texports.Uncharted2ToneMapping = Uncharted2ToneMapping;\n\texports.CineonToneMapping = CineonToneMapping;\n\texports.UVMapping = UVMapping;\n\texports.CubeReflectionMapping = CubeReflectionMapping;\n\texports.CubeRefractionMapping = CubeRefractionMapping;\n\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\n\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\n\texports.SphericalReflectionMapping = SphericalReflectionMapping;\n\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\n\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\n\texports.TextureMapping = TextureMapping;\n\texports.RepeatWrapping = RepeatWrapping;\n\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\n\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\n\texports.TextureWrapping = TextureWrapping;\n\texports.NearestFilter = NearestFilter;\n\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\n\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\n\texports.LinearFilter = LinearFilter;\n\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\n\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\n\texports.TextureFilter = TextureFilter;\n\texports.UnsignedByteType = UnsignedByteType;\n\texports.ByteType = ByteType;\n\texports.ShortType = ShortType;\n\texports.UnsignedShortType = UnsignedShortType;\n\texports.IntType = IntType;\n\texports.UnsignedIntType = UnsignedIntType;\n\texports.FloatType = FloatType;\n\texports.HalfFloatType = HalfFloatType;\n\texports.UnsignedShort4444Type = UnsignedShort4444Type;\n\texports.UnsignedShort5551Type = UnsignedShort5551Type;\n\texports.UnsignedShort565Type = UnsignedShort565Type;\n\texports.UnsignedInt248Type = UnsignedInt248Type;\n\texports.AlphaFormat = AlphaFormat;\n\texports.RGBFormat = RGBFormat;\n\texports.RGBAFormat = RGBAFormat;\n\texports.LuminanceFormat = LuminanceFormat;\n\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\n\texports.RGBEFormat = RGBEFormat;\n\texports.DepthFormat = DepthFormat;\n\texports.DepthStencilFormat = DepthStencilFormat;\n\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\n\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\n\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\n\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\n\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\n\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\n\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\n\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\n\texports.RGB_ETC1_Format = RGB_ETC1_Format;\n\texports.LoopOnce = LoopOnce;\n\texports.LoopRepeat = LoopRepeat;\n\texports.LoopPingPong = LoopPingPong;\n\texports.InterpolateDiscrete = InterpolateDiscrete;\n\texports.InterpolateLinear = InterpolateLinear;\n\texports.InterpolateSmooth = InterpolateSmooth;\n\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\n\texports.ZeroSlopeEnding = ZeroSlopeEnding;\n\texports.WrapAroundEnding = WrapAroundEnding;\n\texports.TrianglesDrawMode = TrianglesDrawMode;\n\texports.TriangleStripDrawMode = TriangleStripDrawMode;\n\texports.TriangleFanDrawMode = TriangleFanDrawMode;\n\texports.LinearEncoding = LinearEncoding;\n\texports.sRGBEncoding = sRGBEncoding;\n\texports.GammaEncoding = GammaEncoding;\n\texports.RGBEEncoding = RGBEEncoding;\n\texports.LogLuvEncoding = LogLuvEncoding;\n\texports.RGBM7Encoding = RGBM7Encoding;\n\texports.RGBM16Encoding = RGBM16Encoding;\n\texports.RGBDEncoding = RGBDEncoding;\n\texports.BasicDepthPacking = BasicDepthPacking;\n\texports.RGBADepthPacking = RGBADepthPacking;\n\texports.CubeGeometry = BoxGeometry;\n\texports.Face4 = Face4;\n\texports.LineStrip = LineStrip;\n\texports.LinePieces = LinePieces;\n\texports.MeshFaceMaterial = MultiMaterial;\n\texports.PointCloud = PointCloud;\n\texports.Particle = Sprite;\n\texports.ParticleSystem = ParticleSystem;\n\texports.PointCloudMaterial = PointCloudMaterial;\n\texports.ParticleBasicMaterial = ParticleBasicMaterial;\n\texports.ParticleSystemMaterial = ParticleSystemMaterial;\n\texports.Vertex = Vertex;\n\texports.EdgesHelper = EdgesHelper;\n\texports.WireframeHelper = WireframeHelper;\n\texports.GeometryUtils = GeometryUtils;\n\texports.ImageUtils = ImageUtils;\n\texports.Projector = Projector;\n\texports.CanvasRenderer = CanvasRenderer;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n\tObject.defineProperty( exports, 'AudioContext', {\n\t\tget: function () {\n\t\t\treturn exports.getAudioContext();\n\t\t}\n\t});\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/three/build/three.js\n// module id = 3\n// module chunks = 0","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar Stats = function () {\n\n\tvar mode = 0;\n\n\tvar container = document.createElement( 'div' );\n\tcontainer.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';\n\tcontainer.addEventListener( 'click', function ( event ) {\n\n\t\tevent.preventDefault();\n\t\tshowPanel( ++ mode % container.children.length );\n\n\t}, false );\n\n\t//\n\n\tfunction addPanel( panel ) {\n\n\t\tcontainer.appendChild( panel.dom );\n\t\treturn panel;\n\n\t}\n\n\tfunction showPanel( id ) {\n\n\t\tfor ( var i = 0; i < container.children.length; i ++ ) {\n\n\t\t\tcontainer.children[ i ].style.display = i === id ? 'block' : 'none';\n\n\t\t}\n\n\t\tmode = id;\n\n\t}\n\n\t//\n\n\tvar beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0;\n\n\tvar fpsPanel = addPanel( new Stats.Panel( 'FPS', '#0ff', '#002' ) );\n\tvar msPanel = addPanel( new Stats.Panel( 'MS', '#0f0', '#020' ) );\n\n\tif ( self.performance && self.performance.memory ) {\n\n\t\tvar memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) );\n\n\t}\n\n\tshowPanel( 0 );\n\n\treturn {\n\n\t\tREVISION: 16,\n\n\t\tdom: container,\n\n\t\taddPanel: addPanel,\n\t\tshowPanel: showPanel,\n\n\t\tbegin: function () {\n\n\t\t\tbeginTime = ( performance || Date ).now();\n\n\t\t},\n\n\t\tend: function () {\n\n\t\t\tframes ++;\n\n\t\t\tvar time = ( performance || Date ).now();\n\n\t\t\tmsPanel.update( time - beginTime, 200 );\n\n\t\t\tif ( time > prevTime + 1000 ) {\n\n\t\t\t\tfpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 );\n\n\t\t\t\tprevTime = time;\n\t\t\t\tframes = 0;\n\n\t\t\t\tif ( memPanel ) {\n\n\t\t\t\t\tvar memory = performance.memory;\n\t\t\t\t\tmemPanel.update( memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn time;\n\n\t\t},\n\n\t\tupdate: function () {\n\n\t\t\tbeginTime = this.end();\n\n\t\t},\n\n\t\t// Backwards Compatibility\n\n\t\tdomElement: container,\n\t\tsetMode: showPanel\n\n\t};\n\n};\n\nStats.Panel = function ( name, fg, bg ) {\n\n\tvar min = Infinity, max = 0, round = Math.round;\n\tvar PR = round( window.devicePixelRatio || 1 );\n\n\tvar WIDTH = 80 * PR, HEIGHT = 48 * PR,\n\t\t\tTEXT_X = 3 * PR, TEXT_Y = 2 * PR,\n\t\t\tGRAPH_X = 3 * PR, GRAPH_Y = 15 * PR,\n\t\t\tGRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;\n\n\tvar canvas = document.createElement( 'canvas' );\n\tcanvas.width = WIDTH;\n\tcanvas.height = HEIGHT;\n\tcanvas.style.cssText = 'width:80px;height:48px';\n\n\tvar context = canvas.getContext( '2d' );\n\tcontext.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif';\n\tcontext.textBaseline = 'top';\n\n\tcontext.fillStyle = bg;\n\tcontext.fillRect( 0, 0, WIDTH, HEIGHT );\n\n\tcontext.fillStyle = fg;\n\tcontext.fillText( name, TEXT_X, TEXT_Y );\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\tcontext.fillStyle = bg;\n\tcontext.globalAlpha = 0.9;\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\treturn {\n\n\t\tdom: canvas,\n\n\t\tupdate: function ( value, maxValue ) {\n\n\t\t\tmin = Math.min( min, value );\n\t\t\tmax = Math.max( max, value );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 1;\n\t\t\tcontext.fillRect( 0, 0, WIDTH, GRAPH_Y );\n\t\t\tcontext.fillStyle = fg;\n\t\t\tcontext.fillText( round( value ) + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y );\n\n\t\t\tcontext.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 0.9;\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) );\n\n\t\t}\n\n\t};\n\n};\n\nif ( typeof module === 'object' ) {\n\n\tmodule.exports = Stats;\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/libs/stats.js","module.exports = require('./vendor/dat.gui')\nmodule.exports.color = require('./vendor/dat.color')\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/dat-gui/index.js\n// module id = 5\n// module chunks = 0","/**\n * dat-gui JavaScript Controller Library\n * http://code.google.com/p/dat-gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\n/** @namespace */\nvar dat = module.exports = dat || {};\n\n/** @namespace */\ndat.gui = dat.gui || {};\n\n/** @namespace */\ndat.utils = dat.utils || {};\n\n/** @namespace */\ndat.controllers = dat.controllers || {};\n\n/** @namespace */\ndat.dom = dat.dom || {};\n\n/** @namespace */\ndat.color = dat.color || {};\n\ndat.utils.css = (function () {\n  return {\n    load: function (url, doc) {\n      doc = doc || document;\n      var link = doc.createElement('link');\n      link.type = 'text/css';\n      link.rel = 'stylesheet';\n      link.href = url;\n      doc.getElementsByTagName('head')[0].appendChild(link);\n    },\n    inject: function(css, doc) {\n      doc = doc || document;\n      var injected = document.createElement('style');\n      injected.type = 'text/css';\n      injected.innerHTML = css;\n      doc.getElementsByTagName('head')[0].appendChild(injected);\n    }\n  }\n})();\n\n\ndat.utils.common = (function () {\n  \n  var ARR_EACH = Array.prototype.forEach;\n  var ARR_SLICE = Array.prototype.slice;\n\n  /**\n   * Band-aid methods for things that should be a lot easier in JavaScript.\n   * Implementation and structure inspired by underscore.js\n   * http://documentcloud.github.com/underscore/\n   */\n\n  return { \n    \n    BREAK: {},\n  \n    extend: function(target) {\n      \n      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n        \n        for (var key in obj)\n          if (!this.isUndefined(obj[key])) \n            target[key] = obj[key];\n        \n      }, this);\n      \n      return target;\n      \n    },\n    \n    defaults: function(target) {\n      \n      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n        \n        for (var key in obj)\n          if (this.isUndefined(target[key])) \n            target[key] = obj[key];\n        \n      }, this);\n      \n      return target;\n    \n    },\n    \n    compose: function() {\n      var toCall = ARR_SLICE.call(arguments);\n            return function() {\n              var args = ARR_SLICE.call(arguments);\n              for (var i = toCall.length -1; i >= 0; i--) {\n                args = [toCall[i].apply(this, args)];\n              }\n              return args[0];\n            }\n    },\n    \n    each: function(obj, itr, scope) {\n\n      \n      if (ARR_EACH && obj.forEach === ARR_EACH) { \n        \n        obj.forEach(itr, scope);\n        \n      } else if (obj.length === obj.length + 0) { // Is number but not NaN\n        \n        for (var key = 0, l = obj.length; key < l; key++)\n          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) \n            return;\n            \n      } else {\n\n        for (var key in obj) \n          if (itr.call(scope, obj[key], key) === this.BREAK)\n            return;\n            \n      }\n            \n    },\n    \n    defer: function(fnc) {\n      setTimeout(fnc, 0);\n    },\n    \n    toArray: function(obj) {\n      if (obj.toArray) return obj.toArray();\n      return ARR_SLICE.call(obj);\n    },\n\n    isUndefined: function(obj) {\n      return obj === undefined;\n    },\n    \n    isNull: function(obj) {\n      return obj === null;\n    },\n    \n    isNaN: function(obj) {\n      return obj !== obj;\n    },\n    \n    isArray: Array.isArray || function(obj) {\n      return obj.constructor === Array;\n    },\n    \n    isObject: function(obj) {\n      return obj === Object(obj);\n    },\n    \n    isNumber: function(obj) {\n      return obj === obj+0;\n    },\n    \n    isString: function(obj) {\n      return obj === obj+'';\n    },\n    \n    isBoolean: function(obj) {\n      return obj === false || obj === true;\n    },\n    \n    isFunction: function(obj) {\n      return Object.prototype.toString.call(obj) === '[object Function]';\n    }\n  \n  };\n    \n})();\n\n\ndat.controllers.Controller = (function (common) {\n\n  /**\n   * @class An \"abstract\" class that represents a given property of an object.\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   *\n   * @member dat.controllers\n   */\n  var Controller = function(object, property) {\n\n    this.initialValue = object[property];\n\n    /**\n     * Those who extend this class will put their DOM elements in here.\n     * @type {DOMElement}\n     */\n    this.domElement = document.createElement('div');\n\n    /**\n     * The object to manipulate\n     * @type {Object}\n     */\n    this.object = object;\n\n    /**\n     * The name of the property to manipulate\n     * @type {String}\n     */\n    this.property = property;\n\n    /**\n     * The function to be called on change.\n     * @type {Function}\n     * @ignore\n     */\n    this.__onChange = undefined;\n\n    /**\n     * The function to be called on finishing change.\n     * @type {Function}\n     * @ignore\n     */\n    this.__onFinishChange = undefined;\n\n  };\n\n  common.extend(\n\n      Controller.prototype,\n\n      /** @lends dat.controllers.Controller.prototype */\n      {\n\n        /**\n         * Specify that a function fire every time someone changes the value with\n         * this Controller.\n         *\n         * @param {Function} fnc This function will be called whenever the value\n         * is modified via this Controller.\n         * @returns {dat.controllers.Controller} this\n         */\n        onChange: function(fnc) {\n          this.__onChange = fnc;\n          return this;\n        },\n\n        /**\n         * Specify that a function fire every time someone \"finishes\" changing\n         * the value wih this Controller. Useful for values that change\n         * incrementally like numbers or strings.\n         *\n         * @param {Function} fnc This function will be called whenever\n         * someone \"finishes\" changing the value via this Controller.\n         * @returns {dat.controllers.Controller} this\n         */\n        onFinishChange: function(fnc) {\n          this.__onFinishChange = fnc;\n          return this;\n        },\n\n        /**\n         * Change the value of <code>object[property]</code>\n         *\n         * @param {Object} newValue The new value of <code>object[property]</code>\n         */\n        setValue: function(newValue) {\n          this.object[this.property] = newValue;\n          if (this.__onChange) {\n            this.__onChange.call(this, newValue);\n          }\n          this.updateDisplay();\n          return this;\n        },\n\n        /**\n         * Gets the value of <code>object[property]</code>\n         *\n         * @returns {Object} The current value of <code>object[property]</code>\n         */\n        getValue: function() {\n          return this.object[this.property];\n        },\n\n        /**\n         * Refreshes the visual display of a Controller in order to keep sync\n         * with the object's current value.\n         * @returns {dat.controllers.Controller} this\n         */\n        updateDisplay: function() {\n          return this;\n        },\n\n        /**\n         * @returns {Boolean} true if the value has deviated from initialValue\n         */\n        isModified: function() {\n          return this.initialValue !== this.getValue()\n        }\n\n      }\n\n  );\n\n  return Controller;\n\n\n})(dat.utils.common);\n\n\ndat.dom.dom = (function (common) {\n\n  var EVENT_MAP = {\n    'HTMLEvents': ['change'],\n    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],\n    'KeyboardEvents': ['keydown']\n  };\n\n  var EVENT_MAP_INV = {};\n  common.each(EVENT_MAP, function(v, k) {\n    common.each(v, function(e) {\n      EVENT_MAP_INV[e] = k;\n    });\n  });\n\n  var CSS_VALUE_PIXELS = /(\\d+(\\.\\d+)?)px/;\n\n  function cssValueToPixels(val) {\n\n    if (val === '0' || common.isUndefined(val)) return 0;\n\n    var match = val.match(CSS_VALUE_PIXELS);\n\n    if (!common.isNull(match)) {\n      return parseFloat(match[1]);\n    }\n\n    // TODO ...ems? %?\n\n    return 0;\n\n  }\n\n  /**\n   * @namespace\n   * @member dat.dom\n   */\n  var dom = {\n\n    /**\n     * \n     * @param elem\n     * @param selectable\n     */\n    makeSelectable: function(elem, selectable) {\n\n      if (elem === undefined || elem.style === undefined) return;\n\n      elem.onselectstart = selectable ? function() {\n        return false;\n      } : function() {\n      };\n\n      elem.style.MozUserSelect = selectable ? 'auto' : 'none';\n      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';\n      elem.unselectable = selectable ? 'on' : 'off';\n\n    },\n\n    /**\n     *\n     * @param elem\n     * @param horizontal\n     * @param vertical\n     */\n    makeFullscreen: function(elem, horizontal, vertical) {\n\n      if (common.isUndefined(horizontal)) horizontal = true;\n      if (common.isUndefined(vertical)) vertical = true;\n\n      elem.style.position = 'absolute';\n\n      if (horizontal) {\n        elem.style.left = 0;\n        elem.style.right = 0;\n      }\n      if (vertical) {\n        elem.style.top = 0;\n        elem.style.bottom = 0;\n      }\n\n    },\n\n    /**\n     *\n     * @param elem\n     * @param eventType\n     * @param params\n     */\n    fakeEvent: function(elem, eventType, params, aux) {\n      params = params || {};\n      var className = EVENT_MAP_INV[eventType];\n      if (!className) {\n        throw new Error('Event type ' + eventType + ' not supported.');\n      }\n      var evt = document.createEvent(className);\n      switch (className) {\n        case 'MouseEvents':\n          var clientX = params.x || params.clientX || 0;\n          var clientY = params.y || params.clientY || 0;\n          evt.initMouseEvent(eventType, params.bubbles || false,\n              params.cancelable || true, window, params.clickCount || 1,\n              0, //screen X\n              0, //screen Y\n              clientX, //client X\n              clientY, //client Y\n              false, false, false, false, 0, null);\n          break;\n        case 'KeyboardEvents':\n          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz\n          common.defaults(params, {\n            cancelable: true,\n            ctrlKey: false,\n            altKey: false,\n            shiftKey: false,\n            metaKey: false,\n            keyCode: undefined,\n            charCode: undefined\n          });\n          init(eventType, params.bubbles || false,\n              params.cancelable, window,\n              params.ctrlKey, params.altKey,\n              params.shiftKey, params.metaKey,\n              params.keyCode, params.charCode);\n          break;\n        default:\n          evt.initEvent(eventType, params.bubbles || false,\n              params.cancelable || true);\n          break;\n      }\n      common.defaults(evt, aux);\n      elem.dispatchEvent(evt);\n    },\n\n    /**\n     *\n     * @param elem\n     * @param event\n     * @param func\n     * @param bool\n     */\n    bind: function(elem, event, func, bool) {\n      bool = bool || false;\n      if (elem.addEventListener)\n        elem.addEventListener(event, func, bool);\n      else if (elem.attachEvent)\n        elem.attachEvent('on' + event, func);\n      return dom;\n    },\n\n    /**\n     *\n     * @param elem\n     * @param event\n     * @param func\n     * @param bool\n     */\n    unbind: function(elem, event, func, bool) {\n      bool = bool || false;\n      if (elem.removeEventListener)\n        elem.removeEventListener(event, func, bool);\n      else if (elem.detachEvent)\n        elem.detachEvent('on' + event, func);\n      return dom;\n    },\n\n    /**\n     *\n     * @param elem\n     * @param className\n     */\n    addClass: function(elem, className) {\n      if (elem.className === undefined) {\n        elem.className = className;\n      } else if (elem.className !== className) {\n        var classes = elem.className.split(/ +/);\n        if (classes.indexOf(className) == -1) {\n          classes.push(className);\n          elem.className = classes.join(' ').replace(/^\\s+/, '').replace(/\\s+$/, '');\n        }\n      }\n      return dom;\n    },\n\n    /**\n     *\n     * @param elem\n     * @param className\n     */\n    removeClass: function(elem, className) {\n      if (className) {\n        if (elem.className === undefined) {\n          // elem.className = className;\n        } else if (elem.className === className) {\n          elem.removeAttribute('class');\n        } else {\n          var classes = elem.className.split(/ +/);\n          var index = classes.indexOf(className);\n          if (index != -1) {\n            classes.splice(index, 1);\n            elem.className = classes.join(' ');\n          }\n        }\n      } else {\n        elem.className = undefined;\n      }\n      return dom;\n    },\n\n    hasClass: function(elem, className) {\n      return new RegExp('(?:^|\\\\s+)' + className + '(?:\\\\s+|$)').test(elem.className) || false;\n    },\n\n    /**\n     *\n     * @param elem\n     */\n    getWidth: function(elem) {\n\n      var style = getComputedStyle(elem);\n\n      return cssValueToPixels(style['border-left-width']) +\n          cssValueToPixels(style['border-right-width']) +\n          cssValueToPixels(style['padding-left']) +\n          cssValueToPixels(style['padding-right']) +\n          cssValueToPixels(style['width']);\n    },\n\n    /**\n     *\n     * @param elem\n     */\n    getHeight: function(elem) {\n\n      var style = getComputedStyle(elem);\n\n      return cssValueToPixels(style['border-top-width']) +\n          cssValueToPixels(style['border-bottom-width']) +\n          cssValueToPixels(style['padding-top']) +\n          cssValueToPixels(style['padding-bottom']) +\n          cssValueToPixels(style['height']);\n    },\n\n    /**\n     *\n     * @param elem\n     */\n    getOffset: function(elem) {\n      var offset = {left: 0, top:0};\n      if (elem.offsetParent) {\n        do {\n          offset.left += elem.offsetLeft;\n          offset.top += elem.offsetTop;\n        } while (elem = elem.offsetParent);\n      }\n      return offset;\n    },\n\n    // http://stackoverflow.com/posts/2684561/revisions\n    /**\n     * \n     * @param elem\n     */\n    isActive: function(elem) {\n      return elem === document.activeElement && ( elem.type || elem.href );\n    }\n\n  };\n\n  return dom;\n\n})(dat.utils.common);\n\n\ndat.controllers.OptionController = (function (Controller, dom, common) {\n\n  /**\n   * @class Provides a select input to alter the property of an object, using a\n   * list of accepted values.\n   *\n   * @extends dat.controllers.Controller\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   * @param {Object|string[]} options A map of labels to acceptable values, or\n   * a list of acceptable string values.\n   *\n   * @member dat.controllers\n   */\n  var OptionController = function(object, property, options) {\n\n    OptionController.superclass.call(this, object, property);\n\n    var _this = this;\n\n    /**\n     * The drop down menu\n     * @ignore\n     */\n    this.__select = document.createElement('select');\n\n    if (common.isArray(options)) {\n      var map = {};\n      common.each(options, function(element) {\n        map[element] = element;\n      });\n      options = map;\n    }\n\n    common.each(options, function(value, key) {\n\n      var opt = document.createElement('option');\n      opt.innerHTML = key;\n      opt.setAttribute('value', value);\n      _this.__select.appendChild(opt);\n\n    });\n\n    // Acknowledge original value\n    this.updateDisplay();\n\n    dom.bind(this.__select, 'change', function() {\n      var desiredValue = this.options[this.selectedIndex].value;\n      _this.setValue(desiredValue);\n    });\n\n    this.domElement.appendChild(this.__select);\n\n  };\n\n  OptionController.superclass = Controller;\n\n  common.extend(\n\n      OptionController.prototype,\n      Controller.prototype,\n\n      {\n\n        setValue: function(v) {\n          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);\n          if (this.__onFinishChange) {\n            this.__onFinishChange.call(this, this.getValue());\n          }\n          return toReturn;\n        },\n\n        updateDisplay: function() {\n          this.__select.value = this.getValue();\n          return OptionController.superclass.prototype.updateDisplay.call(this);\n        }\n\n      }\n\n  );\n\n  return OptionController;\n\n})(dat.controllers.Controller,\ndat.dom.dom,\ndat.utils.common);\n\n\ndat.controllers.NumberController = (function (Controller, common) {\n\n  /**\n   * @class Represents a given property of an object that is a number.\n   *\n   * @extends dat.controllers.Controller\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   * @param {Object} [params] Optional parameters\n   * @param {Number} [params.min] Minimum allowed value\n   * @param {Number} [params.max] Maximum allowed value\n   * @param {Number} [params.step] Increment by which to change value\n   *\n   * @member dat.controllers\n   */\n  var NumberController = function(object, property, params) {\n\n    NumberController.superclass.call(this, object, property);\n\n    params = params || {};\n\n    this.__min = params.min;\n    this.__max = params.max;\n    this.__step = params.step;\n\n    if (common.isUndefined(this.__step)) {\n\n      if (this.initialValue == 0) {\n        this.__impliedStep = 1; // What are we, psychics?\n      } else {\n        // Hey Doug, check this out.\n        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;\n      }\n\n    } else {\n\n      this.__impliedStep = this.__step;\n\n    }\n\n    this.__precision = numDecimals(this.__impliedStep);\n\n\n  };\n\n  NumberController.superclass = Controller;\n\n  common.extend(\n\n      NumberController.prototype,\n      Controller.prototype,\n\n      /** @lends dat.controllers.NumberController.prototype */\n      {\n\n        setValue: function(v) {\n\n          if (this.__min !== undefined && v < this.__min) {\n            v = this.__min;\n          } else if (this.__max !== undefined && v > this.__max) {\n            v = this.__max;\n          }\n\n          if (this.__step !== undefined && v % this.__step != 0) {\n            v = Math.round(v / this.__step) * this.__step;\n          }\n\n          return NumberController.superclass.prototype.setValue.call(this, v);\n\n        },\n\n        /**\n         * Specify a minimum value for <code>object[property]</code>.\n         *\n         * @param {Number} minValue The minimum value for\n         * <code>object[property]</code>\n         * @returns {dat.controllers.NumberController} this\n         */\n        min: function(v) {\n          this.__min = v;\n          return this;\n        },\n\n        /**\n         * Specify a maximum value for <code>object[property]</code>.\n         *\n         * @param {Number} maxValue The maximum value for\n         * <code>object[property]</code>\n         * @returns {dat.controllers.NumberController} this\n         */\n        max: function(v) {\n          this.__max = v;\n          return this;\n        },\n\n        /**\n         * Specify a step value that dat.controllers.NumberController\n         * increments by.\n         *\n         * @param {Number} stepValue The step value for\n         * dat.controllers.NumberController\n         * @default if minimum and maximum specified increment is 1% of the\n         * difference otherwise stepValue is 1\n         * @returns {dat.controllers.NumberController} this\n         */\n        step: function(v) {\n          this.__step = v;\n          return this;\n        }\n\n      }\n\n  );\n\n  function numDecimals(x) {\n    x = x.toString();\n    if (x.indexOf('.') > -1) {\n      return x.length - x.indexOf('.') - 1;\n    } else {\n      return 0;\n    }\n  }\n\n  return NumberController;\n\n})(dat.controllers.Controller,\ndat.utils.common);\n\n\ndat.controllers.NumberControllerBox = (function (NumberController, dom, common) {\n\n  /**\n   * @class Represents a given property of an object that is a number and\n   * provides an input element with which to manipulate it.\n   *\n   * @extends dat.controllers.Controller\n   * @extends dat.controllers.NumberController\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   * @param {Object} [params] Optional parameters\n   * @param {Number} [params.min] Minimum allowed value\n   * @param {Number} [params.max] Maximum allowed value\n   * @param {Number} [params.step] Increment by which to change value\n   *\n   * @member dat.controllers\n   */\n  var NumberControllerBox = function(object, property, params) {\n\n    this.__truncationSuspended = false;\n\n    NumberControllerBox.superclass.call(this, object, property, params);\n\n    var _this = this;\n\n    /**\n     * {Number} Previous mouse y position\n     * @ignore\n     */\n    var prev_y;\n\n    this.__input = document.createElement('input');\n    this.__input.setAttribute('type', 'text');\n\n    // Makes it so manually specified values are not truncated.\n\n    dom.bind(this.__input, 'change', onChange);\n    dom.bind(this.__input, 'blur', onBlur);\n    dom.bind(this.__input, 'mousedown', onMouseDown);\n    dom.bind(this.__input, 'keydown', function(e) {\n\n      // When pressing entire, you can be as precise as you want.\n      if (e.keyCode === 13) {\n        _this.__truncationSuspended = true;\n        this.blur();\n        _this.__truncationSuspended = false;\n      }\n\n    });\n\n    function onChange() {\n      var attempted = parseFloat(_this.__input.value);\n      if (!common.isNaN(attempted)) _this.setValue(attempted);\n    }\n\n    function onBlur() {\n      onChange();\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n\n    function onMouseDown(e) {\n      dom.bind(window, 'mousemove', onMouseDrag);\n      dom.bind(window, 'mouseup', onMouseUp);\n      prev_y = e.clientY;\n    }\n\n    function onMouseDrag(e) {\n\n      var diff = prev_y - e.clientY;\n      _this.setValue(_this.getValue() + diff * _this.__impliedStep);\n\n      prev_y = e.clientY;\n\n    }\n\n    function onMouseUp() {\n      dom.unbind(window, 'mousemove', onMouseDrag);\n      dom.unbind(window, 'mouseup', onMouseUp);\n    }\n\n    this.updateDisplay();\n\n    this.domElement.appendChild(this.__input);\n\n  };\n\n  NumberControllerBox.superclass = NumberController;\n\n  common.extend(\n\n      NumberControllerBox.prototype,\n      NumberController.prototype,\n\n      {\n\n        updateDisplay: function() {\n\n          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);\n          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);\n        }\n\n      }\n\n  );\n\n  function roundToDecimal(value, decimals) {\n    var tenTo = Math.pow(10, decimals);\n    return Math.round(value * tenTo) / tenTo;\n  }\n\n  return NumberControllerBox;\n\n})(dat.controllers.NumberController,\ndat.dom.dom,\ndat.utils.common);\n\n\ndat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {\n\n  /**\n   * @class Represents a given property of an object that is a number, contains\n   * a minimum and maximum, and provides a slider element with which to\n   * manipulate it. It should be noted that the slider element is made up of\n   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5\n   * <code>&lt;slider&gt;</code> element.\n   *\n   * @extends dat.controllers.Controller\n   * @extends dat.controllers.NumberController\n   * \n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   * @param {Number} minValue Minimum allowed value\n   * @param {Number} maxValue Maximum allowed value\n   * @param {Number} stepValue Increment by which to change value\n   *\n   * @member dat.controllers\n   */\n  var NumberControllerSlider = function(object, property, min, max, step) {\n\n    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });\n\n    var _this = this;\n\n    this.__background = document.createElement('div');\n    this.__foreground = document.createElement('div');\n    \n\n\n    dom.bind(this.__background, 'mousedown', onMouseDown);\n    \n    dom.addClass(this.__background, 'slider');\n    dom.addClass(this.__foreground, 'slider-fg');\n\n    function onMouseDown(e) {\n\n      dom.bind(window, 'mousemove', onMouseDrag);\n      dom.bind(window, 'mouseup', onMouseUp);\n\n      onMouseDrag(e);\n    }\n\n    function onMouseDrag(e) {\n\n      e.preventDefault();\n\n      var offset = dom.getOffset(_this.__background);\n      var width = dom.getWidth(_this.__background);\n      \n      _this.setValue(\n        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)\n      );\n\n      return false;\n\n    }\n\n    function onMouseUp() {\n      dom.unbind(window, 'mousemove', onMouseDrag);\n      dom.unbind(window, 'mouseup', onMouseUp);\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n\n    this.updateDisplay();\n\n    this.__background.appendChild(this.__foreground);\n    this.domElement.appendChild(this.__background);\n\n  };\n\n  NumberControllerSlider.superclass = NumberController;\n\n  /**\n   * Injects default stylesheet for slider elements.\n   */\n  NumberControllerSlider.useDefaultStyles = function() {\n    css.inject(styleSheet);\n  };\n\n  common.extend(\n\n      NumberControllerSlider.prototype,\n      NumberController.prototype,\n\n      {\n\n        updateDisplay: function() {\n          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);\n          this.__foreground.style.width = pct*100+'%';\n          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);\n        }\n\n      }\n\n\n\n  );\n\n  function map(v, i1, i2, o1, o2) {\n    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));\n  }\n\n  return NumberControllerSlider;\n  \n})(dat.controllers.NumberController,\ndat.dom.dom,\ndat.utils.css,\ndat.utils.common,\n\".slider {\\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\\n  height: 1em;\\n  border-radius: 1em;\\n  background-color: #eee;\\n  padding: 0 0.5em;\\n  overflow: hidden;\\n}\\n\\n.slider-fg {\\n  padding: 1px 0 2px 0;\\n  background-color: #aaa;\\n  height: 1em;\\n  margin-left: -0.5em;\\n  padding-right: 0.5em;\\n  border-radius: 1em 0 0 1em;\\n}\\n\\n.slider-fg:after {\\n  display: inline-block;\\n  border-radius: 1em;\\n  background-color: #fff;\\n  border:  1px solid #aaa;\\n  content: '';\\n  float: right;\\n  margin-right: -1em;\\n  margin-top: -1px;\\n  height: 0.9em;\\n  width: 0.9em;\\n}\");\n\n\ndat.controllers.FunctionController = (function (Controller, dom, common) {\n\n  /**\n   * @class Provides a GUI interface to fire a specified method, a property of an object.\n   *\n   * @extends dat.controllers.Controller\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   *\n   * @member dat.controllers\n   */\n  var FunctionController = function(object, property, text) {\n\n    FunctionController.superclass.call(this, object, property);\n\n    var _this = this;\n\n    this.__button = document.createElement('div');\n    this.__button.innerHTML = text === undefined ? 'Fire' : text;\n    dom.bind(this.__button, 'click', function(e) {\n      e.preventDefault();\n      _this.fire();\n      return false;\n    });\n\n    dom.addClass(this.__button, 'button');\n\n    this.domElement.appendChild(this.__button);\n\n\n  };\n\n  FunctionController.superclass = Controller;\n\n  common.extend(\n\n      FunctionController.prototype,\n      Controller.prototype,\n      {\n        \n        fire: function() {\n          if (this.__onChange) {\n            this.__onChange.call(this);\n          }\n          if (this.__onFinishChange) {\n            this.__onFinishChange.call(this, this.getValue());\n          }\n          this.getValue().call(this.object);\n        }\n      }\n\n  );\n\n  return FunctionController;\n\n})(dat.controllers.Controller,\ndat.dom.dom,\ndat.utils.common);\n\n\ndat.controllers.BooleanController = (function (Controller, dom, common) {\n\n  /**\n   * @class Provides a checkbox input to alter the boolean property of an object.\n   * @extends dat.controllers.Controller\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   *\n   * @member dat.controllers\n   */\n  var BooleanController = function(object, property) {\n\n    BooleanController.superclass.call(this, object, property);\n\n    var _this = this;\n    this.__prev = this.getValue();\n\n    this.__checkbox = document.createElement('input');\n    this.__checkbox.setAttribute('type', 'checkbox');\n\n\n    dom.bind(this.__checkbox, 'change', onChange, false);\n\n    this.domElement.appendChild(this.__checkbox);\n\n    // Match original value\n    this.updateDisplay();\n\n    function onChange() {\n      _this.setValue(!_this.__prev);\n    }\n\n  };\n\n  BooleanController.superclass = Controller;\n\n  common.extend(\n\n      BooleanController.prototype,\n      Controller.prototype,\n\n      {\n\n        setValue: function(v) {\n          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);\n          if (this.__onFinishChange) {\n            this.__onFinishChange.call(this, this.getValue());\n          }\n          this.__prev = this.getValue();\n          return toReturn;\n        },\n\n        updateDisplay: function() {\n          \n          if (this.getValue() === true) {\n            this.__checkbox.setAttribute('checked', 'checked');\n            this.__checkbox.checked = true;    \n          } else {\n              this.__checkbox.checked = false;\n          }\n\n          return BooleanController.superclass.prototype.updateDisplay.call(this);\n\n        }\n\n\n      }\n\n  );\n\n  return BooleanController;\n\n})(dat.controllers.Controller,\ndat.dom.dom,\ndat.utils.common);\n\n\ndat.color.toString = (function (common) {\n\n  return function(color) {\n\n    if (color.a == 1 || common.isUndefined(color.a)) {\n\n      var s = color.hex.toString(16);\n      while (s.length < 6) {\n        s = '0' + s;\n      }\n\n      return '#' + s;\n\n    } else {\n\n      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';\n\n    }\n\n  }\n\n})(dat.utils.common);\n\n\ndat.color.interpret = (function (toString, common) {\n\n  var result, toReturn;\n\n  var interpret = function() {\n\n    toReturn = false;\n\n    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];\n\n    common.each(INTERPRETATIONS, function(family) {\n\n      if (family.litmus(original)) {\n\n        common.each(family.conversions, function(conversion, conversionName) {\n\n          result = conversion.read(original);\n\n          if (toReturn === false && result !== false) {\n            toReturn = result;\n            result.conversionName = conversionName;\n            result.conversion = conversion;\n            return common.BREAK;\n\n          }\n\n        });\n\n        return common.BREAK;\n\n      }\n\n    });\n\n    return toReturn;\n\n  };\n\n  var INTERPRETATIONS = [\n\n    // Strings\n    {\n\n      litmus: common.isString,\n\n      conversions: {\n\n        THREE_CHAR_HEX: {\n\n          read: function(original) {\n\n            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);\n            if (test === null) return false;\n\n            return {\n              space: 'HEX',\n              hex: parseInt(\n                  '0x' +\n                      test[1].toString() + test[1].toString() +\n                      test[2].toString() + test[2].toString() +\n                      test[3].toString() + test[3].toString())\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        SIX_CHAR_HEX: {\n\n          read: function(original) {\n\n            var test = original.match(/^#([A-F0-9]{6})$/i);\n            if (test === null) return false;\n\n            return {\n              space: 'HEX',\n              hex: parseInt('0x' + test[1].toString())\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        CSS_RGB: {\n\n          read: function(original) {\n\n            var test = original.match(/^rgb\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);\n            if (test === null) return false;\n\n            return {\n              space: 'RGB',\n              r: parseFloat(test[1]),\n              g: parseFloat(test[2]),\n              b: parseFloat(test[3])\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        CSS_RGBA: {\n\n          read: function(original) {\n\n            var test = original.match(/^rgba\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\,\\s*(.+)\\s*\\)/);\n            if (test === null) return false;\n\n            return {\n              space: 'RGB',\n              r: parseFloat(test[1]),\n              g: parseFloat(test[2]),\n              b: parseFloat(test[3]),\n              a: parseFloat(test[4])\n            };\n\n          },\n\n          write: toString\n\n        }\n\n      }\n\n    },\n\n    // Numbers\n    {\n\n      litmus: common.isNumber,\n\n      conversions: {\n\n        HEX: {\n          read: function(original) {\n            return {\n              space: 'HEX',\n              hex: original,\n              conversionName: 'HEX'\n            }\n          },\n\n          write: function(color) {\n            return color.hex;\n          }\n        }\n\n      }\n\n    },\n\n    // Arrays\n    {\n\n      litmus: common.isArray,\n\n      conversions: {\n\n        RGB_ARRAY: {\n          read: function(original) {\n            if (original.length != 3) return false;\n            return {\n              space: 'RGB',\n              r: original[0],\n              g: original[1],\n              b: original[2]\n            };\n          },\n\n          write: function(color) {\n            return [color.r, color.g, color.b];\n          }\n\n        },\n\n        RGBA_ARRAY: {\n          read: function(original) {\n            if (original.length != 4) return false;\n            return {\n              space: 'RGB',\n              r: original[0],\n              g: original[1],\n              b: original[2],\n              a: original[3]\n            };\n          },\n\n          write: function(color) {\n            return [color.r, color.g, color.b, color.a];\n          }\n\n        }\n\n      }\n\n    },\n\n    // Objects\n    {\n\n      litmus: common.isObject,\n\n      conversions: {\n\n        RGBA_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.r) &&\n                common.isNumber(original.g) &&\n                common.isNumber(original.b) &&\n                common.isNumber(original.a)) {\n              return {\n                space: 'RGB',\n                r: original.r,\n                g: original.g,\n                b: original.b,\n                a: original.a\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              r: color.r,\n              g: color.g,\n              b: color.b,\n              a: color.a\n            }\n          }\n        },\n\n        RGB_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.r) &&\n                common.isNumber(original.g) &&\n                common.isNumber(original.b)) {\n              return {\n                space: 'RGB',\n                r: original.r,\n                g: original.g,\n                b: original.b\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              r: color.r,\n              g: color.g,\n              b: color.b\n            }\n          }\n        },\n\n        HSVA_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.h) &&\n                common.isNumber(original.s) &&\n                common.isNumber(original.v) &&\n                common.isNumber(original.a)) {\n              return {\n                space: 'HSV',\n                h: original.h,\n                s: original.s,\n                v: original.v,\n                a: original.a\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              h: color.h,\n              s: color.s,\n              v: color.v,\n              a: color.a\n            }\n          }\n        },\n\n        HSV_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.h) &&\n                common.isNumber(original.s) &&\n                common.isNumber(original.v)) {\n              return {\n                space: 'HSV',\n                h: original.h,\n                s: original.s,\n                v: original.v\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              h: color.h,\n              s: color.s,\n              v: color.v\n            }\n          }\n\n        }\n\n      }\n\n    }\n\n\n  ];\n\n  return interpret;\n\n\n})(dat.color.toString,\ndat.utils.common);\n\n\ndat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {\n\n  css.inject(styleSheet);\n\n  /** Outer-most className for GUI's */\n  var CSS_NAMESPACE = 'dg';\n\n  var HIDE_KEY_CODE = 72;\n\n  /** The only value shared between the JS and SCSS. Use caution. */\n  var CLOSE_BUTTON_HEIGHT = 20;\n\n  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';\n\n  var SUPPORTS_LOCAL_STORAGE = (function() {\n    try {\n      return 'localStorage' in window && window['localStorage'] !== null;\n    } catch (e) {\n      return false;\n    }\n  })();\n\n  var SAVE_DIALOGUE;\n\n  /** Have we yet to create an autoPlace GUI? */\n  var auto_place_virgin = true;\n\n  /** Fixed position div that auto place GUI's go inside */\n  var auto_place_container;\n\n  /** Are we hiding the GUI's ? */\n  var hide = false;\n\n  /** GUI's which should be hidden */\n  var hideable_guis = [];\n\n  /**\n   * A lightweight controller library for JavaScript. It allows you to easily\n   * manipulate variables and fire functions on the fly.\n   * @class\n   *\n   * @member dat.gui\n   *\n   * @param {Object} [params]\n   * @param {String} [params.name] The name of this GUI.\n   * @param {Object} [params.load] JSON object representing the saved state of\n   * this GUI.\n   * @param {Boolean} [params.auto=true]\n   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.\n   * @param {Boolean} [params.closed] If true, starts closed\n   */\n  var GUI = function(params) {\n\n    var _this = this;\n\n    /**\n     * Outermost DOM Element\n     * @type DOMElement\n     */\n    this.domElement = document.createElement('div');\n    this.__ul = document.createElement('ul');\n    this.domElement.appendChild(this.__ul);\n\n    dom.addClass(this.domElement, CSS_NAMESPACE);\n\n    /**\n     * Nested GUI's by name\n     * @ignore\n     */\n    this.__folders = {};\n\n    this.__controllers = [];\n\n    /**\n     * List of objects I'm remembering for save, only used in top level GUI\n     * @ignore\n     */\n    this.__rememberedObjects = [];\n\n    /**\n     * Maps the index of remembered objects to a map of controllers, only used\n     * in top level GUI.\n     *\n     * @private\n     * @ignore\n     *\n     * @example\n     * [\n     *  {\n     *    propertyName: Controller,\n     *    anotherPropertyName: Controller\n     *  },\n     *  {\n     *    propertyName: Controller\n     *  }\n     * ]\n     */\n    this.__rememberedObjectIndecesToControllers = [];\n\n    this.__listening = [];\n\n    params = params || {};\n\n    // Default parameters\n    params = common.defaults(params, {\n      autoPlace: true,\n      width: GUI.DEFAULT_WIDTH\n    });\n\n    params = common.defaults(params, {\n      resizable: params.autoPlace,\n      hideable: params.autoPlace\n    });\n\n\n    if (!common.isUndefined(params.load)) {\n\n      // Explicit preset\n      if (params.preset) params.load.preset = params.preset;\n\n    } else {\n\n      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };\n\n    }\n\n    if (common.isUndefined(params.parent) && params.hideable) {\n      hideable_guis.push(this);\n    }\n\n    // Only root level GUI's are resizable.\n    params.resizable = common.isUndefined(params.parent) && params.resizable;\n\n\n    if (params.autoPlace && common.isUndefined(params.scrollable)) {\n      params.scrollable = true;\n    }\n//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;\n\n    // Not part of params because I don't want people passing this in via\n    // constructor. Should be a 'remembered' value.\n    var use_local_storage =\n        SUPPORTS_LOCAL_STORAGE &&\n            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';\n\n    Object.defineProperties(this,\n\n        /** @lends dat.gui.GUI.prototype */\n        {\n\n          /**\n           * The parent <code>GUI</code>\n           * @type dat.gui.GUI\n           */\n          parent: {\n            get: function() {\n              return params.parent;\n            }\n          },\n\n          scrollable: {\n            get: function() {\n              return params.scrollable;\n            }\n          },\n\n          /**\n           * Handles <code>GUI</code>'s element placement for you\n           * @type Boolean\n           */\n          autoPlace: {\n            get: function() {\n              return params.autoPlace;\n            }\n          },\n\n          /**\n           * The identifier for a set of saved values\n           * @type String\n           */\n          preset: {\n\n            get: function() {\n              if (_this.parent) {\n                return _this.getRoot().preset;\n              } else {\n                return params.load.preset;\n              }\n            },\n\n            set: function(v) {\n              if (_this.parent) {\n                _this.getRoot().preset = v;\n              } else {\n                params.load.preset = v;\n              }\n              setPresetSelectIndex(this);\n              _this.revert();\n            }\n\n          },\n\n          /**\n           * The width of <code>GUI</code> element\n           * @type Number\n           */\n          width: {\n            get: function() {\n              return params.width;\n            },\n            set: function(v) {\n              params.width = v;\n              setWidth(_this, v);\n            }\n          },\n\n          /**\n           * The name of <code>GUI</code>. Used for folders. i.e\n           * a folder's name\n           * @type String\n           */\n          name: {\n            get: function() {\n              return params.name;\n            },\n            set: function(v) {\n              // TODO Check for collisions among sibling folders\n              params.name = v;\n              if (title_row_name) {\n                title_row_name.innerHTML = params.name;\n              }\n            }\n          },\n\n          /**\n           * Whether the <code>GUI</code> is collapsed or not\n           * @type Boolean\n           */\n          closed: {\n            get: function() {\n              return params.closed;\n            },\n            set: function(v) {\n              params.closed = v;\n              if (params.closed) {\n                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);\n              } else {\n                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);\n              }\n              // For browsers that aren't going to respect the CSS transition,\n              // Lets just check our height against the window height right off\n              // the bat.\n              this.onResize();\n\n              if (_this.__closeButton) {\n                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;\n              }\n            }\n          },\n\n          /**\n           * Contains all presets\n           * @type Object\n           */\n          load: {\n            get: function() {\n              return params.load;\n            }\n          },\n\n          /**\n           * Determines whether or not to use <a href=\"https://developer.mozilla.org/en/DOM/Storage#localStorage\">localStorage</a> as the means for\n           * <code>remember</code>ing\n           * @type Boolean\n           */\n          useLocalStorage: {\n\n            get: function() {\n              return use_local_storage;\n            },\n            set: function(bool) {\n              if (SUPPORTS_LOCAL_STORAGE) {\n                use_local_storage = bool;\n                if (bool) {\n                  dom.bind(window, 'unload', saveToLocalStorage);\n                } else {\n                  dom.unbind(window, 'unload', saveToLocalStorage);\n                }\n                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);\n              }\n            }\n\n          }\n\n        });\n\n    // Are we a root level GUI?\n    if (common.isUndefined(params.parent)) {\n\n      params.closed = false;\n\n      dom.addClass(this.domElement, GUI.CLASS_MAIN);\n      dom.makeSelectable(this.domElement, false);\n\n      // Are we supposed to be loading locally?\n      if (SUPPORTS_LOCAL_STORAGE) {\n\n        if (use_local_storage) {\n\n          _this.useLocalStorage = true;\n\n          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));\n\n          if (saved_gui) {\n            params.load = JSON.parse(saved_gui);\n          }\n\n        }\n\n      }\n\n      this.__closeButton = document.createElement('div');\n      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;\n      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);\n      this.domElement.appendChild(this.__closeButton);\n\n      dom.bind(this.__closeButton, 'click', function() {\n\n        _this.closed = !_this.closed;\n\n\n      });\n\n\n      // Oh, you're a nested GUI!\n    } else {\n\n      if (params.closed === undefined) {\n        params.closed = true;\n      }\n\n      var title_row_name = document.createTextNode(params.name);\n      dom.addClass(title_row_name, 'controller-name');\n\n      var title_row = addRow(_this, title_row_name);\n\n      var on_click_title = function(e) {\n        e.preventDefault();\n        _this.closed = !_this.closed;\n        return false;\n      };\n\n      dom.addClass(this.__ul, GUI.CLASS_CLOSED);\n\n      dom.addClass(title_row, 'title');\n      dom.bind(title_row, 'click', on_click_title);\n\n      if (!params.closed) {\n        this.closed = false;\n      }\n\n    }\n\n    if (params.autoPlace) {\n\n      if (common.isUndefined(params.parent)) {\n\n        if (auto_place_virgin) {\n          auto_place_container = document.createElement('div');\n          dom.addClass(auto_place_container, CSS_NAMESPACE);\n          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);\n          document.body.appendChild(auto_place_container);\n          auto_place_virgin = false;\n        }\n\n        // Put it in the dom for you.\n        auto_place_container.appendChild(this.domElement);\n\n        // Apply the auto styles\n        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);\n\n      }\n\n\n      // Make it not elastic.\n      if (!this.parent) setWidth(_this, params.width);\n\n    }\n\n    dom.bind(window, 'resize', function() { _this.onResize() });\n    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });\n    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });\n    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });\n    this.onResize();\n\n\n    if (params.resizable) {\n      addResizeHandle(this);\n    }\n\n    function saveToLocalStorage() {\n      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));\n    }\n\n    var root = _this.getRoot();\n    function resetWidth() {\n        var root = _this.getRoot();\n        root.width += 1;\n        common.defer(function() {\n          root.width -= 1;\n        });\n      }\n\n      if (!params.parent) {\n        resetWidth();\n      }\n\n  };\n\n  GUI.toggleHide = function() {\n\n    hide = !hide;\n    common.each(hideable_guis, function(gui) {\n      gui.domElement.style.zIndex = hide ? -999 : 999;\n      gui.domElement.style.opacity = hide ? 0 : 1;\n    });\n  };\n\n  GUI.CLASS_AUTO_PLACE = 'a';\n  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';\n  GUI.CLASS_MAIN = 'main';\n  GUI.CLASS_CONTROLLER_ROW = 'cr';\n  GUI.CLASS_TOO_TALL = 'taller-than-window';\n  GUI.CLASS_CLOSED = 'closed';\n  GUI.CLASS_CLOSE_BUTTON = 'close-button';\n  GUI.CLASS_DRAG = 'drag';\n\n  GUI.DEFAULT_WIDTH = 245;\n  GUI.TEXT_CLOSED = 'Close Controls';\n  GUI.TEXT_OPEN = 'Open Controls';\n\n  dom.bind(window, 'keydown', function(e) {\n\n    if (document.activeElement.type !== 'text' &&\n        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {\n      GUI.toggleHide();\n    }\n\n  }, false);\n\n  common.extend(\n\n      GUI.prototype,\n\n      /** @lends dat.gui.GUI */\n      {\n\n        /**\n         * @param object\n         * @param property\n         * @returns {dat.controllers.Controller} The new controller that was added.\n         * @instance\n         */\n        add: function(object, property) {\n\n          return add(\n              this,\n              object,\n              property,\n              {\n                factoryArgs: Array.prototype.slice.call(arguments, 2)\n              }\n          );\n\n        },\n\n        /**\n         * @param object\n         * @param property\n         * @returns {dat.controllers.ColorController} The new controller that was added.\n         * @instance\n         */\n        addColor: function(object, property) {\n\n          return add(\n              this,\n              object,\n              property,\n              {\n                color: true\n              }\n          );\n\n        },\n\n        /**\n         * @param controller\n         * @instance\n         */\n        remove: function(controller) {\n\n          // TODO listening?\n          this.__ul.removeChild(controller.__li);\n          this.__controllers.slice(this.__controllers.indexOf(controller), 1);\n          var _this = this;\n          common.defer(function() {\n            _this.onResize();\n          });\n\n        },\n\n        destroy: function() {\n\n          if (this.autoPlace) {\n            auto_place_container.removeChild(this.domElement);\n          }\n\n        },\n\n        /**\n         * @param name\n         * @returns {dat.gui.GUI} The new folder.\n         * @throws {Error} if this GUI already has a folder by the specified\n         * name\n         * @instance\n         */\n        addFolder: function(name) {\n\n          // We have to prevent collisions on names in order to have a key\n          // by which to remember saved values\n          if (this.__folders[name] !== undefined) {\n            throw new Error('You already have a folder in this GUI by the' +\n                ' name \"' + name + '\"');\n          }\n\n          var new_gui_params = { name: name, parent: this };\n\n          // We need to pass down the autoPlace trait so that we can\n          // attach event listeners to open/close folder actions to\n          // ensure that a scrollbar appears if the window is too short.\n          new_gui_params.autoPlace = this.autoPlace;\n\n          // Do we have saved appearance data for this folder?\n\n          if (this.load && // Anything loaded?\n              this.load.folders && // Was my parent a dead-end?\n              this.load.folders[name]) { // Did daddy remember me?\n\n            // Start me closed if I was closed\n            new_gui_params.closed = this.load.folders[name].closed;\n\n            // Pass down the loaded data\n            new_gui_params.load = this.load.folders[name];\n\n          }\n\n          var gui = new GUI(new_gui_params);\n          this.__folders[name] = gui;\n\n          var li = addRow(this, gui.domElement);\n          dom.addClass(li, 'folder');\n          return gui;\n\n        },\n\n        open: function() {\n          this.closed = false;\n        },\n\n        close: function() {\n          this.closed = true;\n        },\n\n        onResize: function() {\n\n          var root = this.getRoot();\n\n          if (root.scrollable) {\n\n            var top = dom.getOffset(root.__ul).top;\n            var h = 0;\n\n            common.each(root.__ul.childNodes, function(node) {\n              if (! (root.autoPlace && node === root.__save_row))\n                h += dom.getHeight(node);\n            });\n\n            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {\n              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);\n              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';\n            } else {\n              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);\n              root.__ul.style.height = 'auto';\n            }\n\n          }\n\n          if (root.__resize_handle) {\n            common.defer(function() {\n              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';\n            });\n          }\n\n          if (root.__closeButton) {\n            root.__closeButton.style.width = root.width + 'px';\n          }\n\n        },\n\n        /**\n         * Mark objects for saving. The order of these objects cannot change as\n         * the GUI grows. When remembering new objects, append them to the end\n         * of the list.\n         *\n         * @param {Object...} objects\n         * @throws {Error} if not called on a top level GUI.\n         * @instance\n         */\n        remember: function() {\n\n          if (common.isUndefined(SAVE_DIALOGUE)) {\n            SAVE_DIALOGUE = new CenteredDiv();\n            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;\n          }\n\n          if (this.parent) {\n            throw new Error(\"You can only call remember on a top level GUI.\");\n          }\n\n          var _this = this;\n\n          common.each(Array.prototype.slice.call(arguments), function(object) {\n            if (_this.__rememberedObjects.length == 0) {\n              addSaveMenu(_this);\n            }\n            if (_this.__rememberedObjects.indexOf(object) == -1) {\n              _this.__rememberedObjects.push(object);\n            }\n          });\n\n          if (this.autoPlace) {\n            // Set save row width\n            setWidth(this, this.width);\n          }\n\n        },\n\n        /**\n         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.\n         * @instance\n         */\n        getRoot: function() {\n          var gui = this;\n          while (gui.parent) {\n            gui = gui.parent;\n          }\n          return gui;\n        },\n\n        /**\n         * @returns {Object} a JSON object representing the current state of\n         * this GUI as well as its remembered properties.\n         * @instance\n         */\n        getSaveObject: function() {\n\n          var toReturn = this.load;\n\n          toReturn.closed = this.closed;\n\n          // Am I remembering any values?\n          if (this.__rememberedObjects.length > 0) {\n\n            toReturn.preset = this.preset;\n\n            if (!toReturn.remembered) {\n              toReturn.remembered = {};\n            }\n\n            toReturn.remembered[this.preset] = getCurrentPreset(this);\n\n          }\n\n          toReturn.folders = {};\n          common.each(this.__folders, function(element, key) {\n            toReturn.folders[key] = element.getSaveObject();\n          });\n\n          return toReturn;\n\n        },\n\n        save: function() {\n\n          if (!this.load.remembered) {\n            this.load.remembered = {};\n          }\n\n          this.load.remembered[this.preset] = getCurrentPreset(this);\n          markPresetModified(this, false);\n\n        },\n\n        saveAs: function(presetName) {\n\n          if (!this.load.remembered) {\n\n            // Retain default values upon first save\n            this.load.remembered = {};\n            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);\n\n          }\n\n          this.load.remembered[presetName] = getCurrentPreset(this);\n          this.preset = presetName;\n          addPresetOption(this, presetName, true);\n\n        },\n\n        revert: function(gui) {\n\n          common.each(this.__controllers, function(controller) {\n            // Make revert work on Default.\n            if (!this.getRoot().load.remembered) {\n              controller.setValue(controller.initialValue);\n            } else {\n              recallSavedValue(gui || this.getRoot(), controller);\n            }\n          }, this);\n\n          common.each(this.__folders, function(folder) {\n            folder.revert(folder);\n          });\n\n          if (!gui) {\n            markPresetModified(this.getRoot(), false);\n          }\n\n\n        },\n\n        listen: function(controller) {\n\n          var init = this.__listening.length == 0;\n          this.__listening.push(controller);\n          if (init) updateDisplays(this.__listening);\n\n        }\n\n      }\n\n  );\n\n  function add(gui, object, property, params) {\n\n    if (object[property] === undefined) {\n      throw new Error(\"Object \" + object + \" has no property \\\"\" + property + \"\\\"\");\n    }\n\n    var controller;\n\n    if (params.color) {\n\n      controller = new ColorController(object, property);\n\n    } else {\n\n      var factoryArgs = [object,property].concat(params.factoryArgs);\n      controller = controllerFactory.apply(gui, factoryArgs);\n\n    }\n\n    if (params.before instanceof Controller) {\n      params.before = params.before.__li;\n    }\n\n    recallSavedValue(gui, controller);\n\n    dom.addClass(controller.domElement, 'c');\n\n    var name = document.createElement('span');\n    dom.addClass(name, 'property-name');\n    name.innerHTML = controller.property;\n\n    var container = document.createElement('div');\n    container.appendChild(name);\n    container.appendChild(controller.domElement);\n\n    var li = addRow(gui, container, params.before);\n\n    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);\n    dom.addClass(li, typeof controller.getValue());\n\n    augmentController(gui, li, controller);\n\n    gui.__controllers.push(controller);\n\n    return controller;\n\n  }\n\n  /**\n   * Add a row to the end of the GUI or before another row.\n   *\n   * @param gui\n   * @param [dom] If specified, inserts the dom content in the new row\n   * @param [liBefore] If specified, places the new row before another row\n   */\n  function addRow(gui, dom, liBefore) {\n    var li = document.createElement('li');\n    if (dom) li.appendChild(dom);\n    if (liBefore) {\n      gui.__ul.insertBefore(li, params.before);\n    } else {\n      gui.__ul.appendChild(li);\n    }\n    gui.onResize();\n    return li;\n  }\n\n  function augmentController(gui, li, controller) {\n\n    controller.__li = li;\n    controller.__gui = gui;\n\n    common.extend(controller, {\n\n      options: function(options) {\n\n        if (arguments.length > 1) {\n          controller.remove();\n\n          return add(\n              gui,\n              controller.object,\n              controller.property,\n              {\n                before: controller.__li.nextElementSibling,\n                factoryArgs: [common.toArray(arguments)]\n              }\n          );\n\n        }\n\n        if (common.isArray(options) || common.isObject(options)) {\n          controller.remove();\n\n          return add(\n              gui,\n              controller.object,\n              controller.property,\n              {\n                before: controller.__li.nextElementSibling,\n                factoryArgs: [options]\n              }\n          );\n\n        }\n\n      },\n\n      name: function(v) {\n        controller.__li.firstElementChild.firstElementChild.innerHTML = v;\n        return controller;\n      },\n\n      listen: function() {\n        controller.__gui.listen(controller);\n        return controller;\n      },\n\n      remove: function() {\n        controller.__gui.remove(controller);\n        return controller;\n      }\n\n    });\n\n    // All sliders should be accompanied by a box.\n    if (controller instanceof NumberControllerSlider) {\n\n      var box = new NumberControllerBox(controller.object, controller.property,\n          { min: controller.__min, max: controller.__max, step: controller.__step });\n\n      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {\n        var pc = controller[method];\n        var pb = box[method];\n        controller[method] = box[method] = function() {\n          var args = Array.prototype.slice.call(arguments);\n          pc.apply(controller, args);\n          return pb.apply(box, args);\n        }\n      });\n\n      dom.addClass(li, 'has-slider');\n      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);\n\n    }\n    else if (controller instanceof NumberControllerBox) {\n\n      var r = function(returned) {\n\n        // Have we defined both boundaries?\n        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {\n\n          // Well, then lets just replace this with a slider.\n          controller.remove();\n          return add(\n              gui,\n              controller.object,\n              controller.property,\n              {\n                before: controller.__li.nextElementSibling,\n                factoryArgs: [controller.__min, controller.__max, controller.__step]\n              });\n\n        }\n\n        return returned;\n\n      };\n\n      controller.min = common.compose(r, controller.min);\n      controller.max = common.compose(r, controller.max);\n\n    }\n    else if (controller instanceof BooleanController) {\n\n      dom.bind(li, 'click', function() {\n        dom.fakeEvent(controller.__checkbox, 'click');\n      });\n\n      dom.bind(controller.__checkbox, 'click', function(e) {\n        e.stopPropagation(); // Prevents double-toggle\n      })\n\n    }\n    else if (controller instanceof FunctionController) {\n\n      dom.bind(li, 'click', function() {\n        dom.fakeEvent(controller.__button, 'click');\n      });\n\n      dom.bind(li, 'mouseover', function() {\n        dom.addClass(controller.__button, 'hover');\n      });\n\n      dom.bind(li, 'mouseout', function() {\n        dom.removeClass(controller.__button, 'hover');\n      });\n\n    }\n    else if (controller instanceof ColorController) {\n\n      dom.addClass(li, 'color');\n      controller.updateDisplay = common.compose(function(r) {\n        li.style.borderLeftColor = controller.__color.toString();\n        return r;\n      }, controller.updateDisplay);\n\n      controller.updateDisplay();\n\n    }\n\n    controller.setValue = common.compose(function(r) {\n      if (gui.getRoot().__preset_select && controller.isModified()) {\n        markPresetModified(gui.getRoot(), true);\n      }\n      return r;\n    }, controller.setValue);\n\n  }\n\n  function recallSavedValue(gui, controller) {\n\n    // Find the topmost GUI, that's where remembered objects live.\n    var root = gui.getRoot();\n\n    // Does the object we're controlling match anything we've been told to\n    // remember?\n    var matched_index = root.__rememberedObjects.indexOf(controller.object);\n\n    // Why yes, it does!\n    if (matched_index != -1) {\n\n      // Let me fetch a map of controllers for thcommon.isObject.\n      var controller_map =\n          root.__rememberedObjectIndecesToControllers[matched_index];\n\n      // Ohp, I believe this is the first controller we've created for this\n      // object. Lets make the map fresh.\n      if (controller_map === undefined) {\n        controller_map = {};\n        root.__rememberedObjectIndecesToControllers[matched_index] =\n            controller_map;\n      }\n\n      // Keep track of this controller\n      controller_map[controller.property] = controller;\n\n      // Okay, now have we saved any values for this controller?\n      if (root.load && root.load.remembered) {\n\n        var preset_map = root.load.remembered;\n\n        // Which preset are we trying to load?\n        var preset;\n\n        if (preset_map[gui.preset]) {\n\n          preset = preset_map[gui.preset];\n\n        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {\n\n          // Uhh, you can have the default instead?\n          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];\n\n        } else {\n\n          // Nada.\n\n          return;\n\n        }\n\n\n        // Did the loaded object remember thcommon.isObject?\n        if (preset[matched_index] &&\n\n          // Did we remember this particular property?\n            preset[matched_index][controller.property] !== undefined) {\n\n          // We did remember something for this guy ...\n          var value = preset[matched_index][controller.property];\n\n          // And that's what it is.\n          controller.initialValue = value;\n          controller.setValue(value);\n\n        }\n\n      }\n\n    }\n\n  }\n\n  function getLocalStorageHash(gui, key) {\n    // TODO how does this deal with multiple GUI's?\n    return document.location.href + '.' + key;\n\n  }\n\n  function addSaveMenu(gui) {\n\n    var div = gui.__save_row = document.createElement('li');\n\n    dom.addClass(gui.domElement, 'has-save');\n\n    gui.__ul.insertBefore(div, gui.__ul.firstChild);\n\n    dom.addClass(div, 'save-row');\n\n    var gears = document.createElement('span');\n    gears.innerHTML = '&nbsp;';\n    dom.addClass(gears, 'button gears');\n\n    // TODO replace with FunctionController\n    var button = document.createElement('span');\n    button.innerHTML = 'Save';\n    dom.addClass(button, 'button');\n    dom.addClass(button, 'save');\n\n    var button2 = document.createElement('span');\n    button2.innerHTML = 'New';\n    dom.addClass(button2, 'button');\n    dom.addClass(button2, 'save-as');\n\n    var button3 = document.createElement('span');\n    button3.innerHTML = 'Revert';\n    dom.addClass(button3, 'button');\n    dom.addClass(button3, 'revert');\n\n    var select = gui.__preset_select = document.createElement('select');\n\n    if (gui.load && gui.load.remembered) {\n\n      common.each(gui.load.remembered, function(value, key) {\n        addPresetOption(gui, key, key == gui.preset);\n      });\n\n    } else {\n      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);\n    }\n\n    dom.bind(select, 'change', function() {\n\n\n      for (var index = 0; index < gui.__preset_select.length; index++) {\n        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;\n      }\n\n      gui.preset = this.value;\n\n    });\n\n    div.appendChild(select);\n    div.appendChild(gears);\n    div.appendChild(button);\n    div.appendChild(button2);\n    div.appendChild(button3);\n\n    if (SUPPORTS_LOCAL_STORAGE) {\n\n      var saveLocally = document.getElementById('dg-save-locally');\n      var explain = document.getElementById('dg-local-explain');\n\n      saveLocally.style.display = 'block';\n\n      var localStorageCheckBox = document.getElementById('dg-local-storage');\n\n      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {\n        localStorageCheckBox.setAttribute('checked', 'checked');\n      }\n\n      function showHideExplain() {\n        explain.style.display = gui.useLocalStorage ? 'block' : 'none';\n      }\n\n      showHideExplain();\n\n      // TODO: Use a boolean controller, fool!\n      dom.bind(localStorageCheckBox, 'change', function() {\n        gui.useLocalStorage = !gui.useLocalStorage;\n        showHideExplain();\n      });\n\n    }\n\n    var newConstructorTextArea = document.getElementById('dg-new-constructor');\n\n    dom.bind(newConstructorTextArea, 'keydown', function(e) {\n      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {\n        SAVE_DIALOGUE.hide();\n      }\n    });\n\n    dom.bind(gears, 'click', function() {\n      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);\n      SAVE_DIALOGUE.show();\n      newConstructorTextArea.focus();\n      newConstructorTextArea.select();\n    });\n\n    dom.bind(button, 'click', function() {\n      gui.save();\n    });\n\n    dom.bind(button2, 'click', function() {\n      var presetName = prompt('Enter a new preset name.');\n      if (presetName) gui.saveAs(presetName);\n    });\n\n    dom.bind(button3, 'click', function() {\n      gui.revert();\n    });\n\n//    div.appendChild(button2);\n\n  }\n\n  function addResizeHandle(gui) {\n\n    gui.__resize_handle = document.createElement('div');\n\n    common.extend(gui.__resize_handle.style, {\n\n      width: '6px',\n      marginLeft: '-3px',\n      height: '200px',\n      cursor: 'ew-resize',\n      position: 'absolute'\n//      border: '1px solid blue'\n\n    });\n\n    var pmouseX;\n\n    dom.bind(gui.__resize_handle, 'mousedown', dragStart);\n    dom.bind(gui.__closeButton, 'mousedown', dragStart);\n\n    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);\n\n    function dragStart(e) {\n\n      e.preventDefault();\n\n      pmouseX = e.clientX;\n\n      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);\n      dom.bind(window, 'mousemove', drag);\n      dom.bind(window, 'mouseup', dragStop);\n\n      return false;\n\n    }\n\n    function drag(e) {\n\n      e.preventDefault();\n\n      gui.width += pmouseX - e.clientX;\n      gui.onResize();\n      pmouseX = e.clientX;\n\n      return false;\n\n    }\n\n    function dragStop() {\n\n      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);\n      dom.unbind(window, 'mousemove', drag);\n      dom.unbind(window, 'mouseup', dragStop);\n\n    }\n\n  }\n\n  function setWidth(gui, w) {\n    gui.domElement.style.width = w + 'px';\n    // Auto placed save-rows are position fixed, so we have to\n    // set the width manually if we want it to bleed to the edge\n    if (gui.__save_row && gui.autoPlace) {\n      gui.__save_row.style.width = w + 'px';\n    }if (gui.__closeButton) {\n      gui.__closeButton.style.width = w + 'px';\n    }\n  }\n\n  function getCurrentPreset(gui, useInitialValues) {\n\n    var toReturn = {};\n\n    // For each object I'm remembering\n    common.each(gui.__rememberedObjects, function(val, index) {\n\n      var saved_values = {};\n\n      // The controllers I've made for thcommon.isObject by property\n      var controller_map =\n          gui.__rememberedObjectIndecesToControllers[index];\n\n      // Remember each value for each property\n      common.each(controller_map, function(controller, property) {\n        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();\n      });\n\n      // Save the values for thcommon.isObject\n      toReturn[index] = saved_values;\n\n    });\n\n    return toReturn;\n\n  }\n\n  function addPresetOption(gui, name, setSelected) {\n    var opt = document.createElement('option');\n    opt.innerHTML = name;\n    opt.value = name;\n    gui.__preset_select.appendChild(opt);\n    if (setSelected) {\n      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;\n    }\n  }\n\n  function setPresetSelectIndex(gui) {\n    for (var index = 0; index < gui.__preset_select.length; index++) {\n      if (gui.__preset_select[index].value == gui.preset) {\n        gui.__preset_select.selectedIndex = index;\n      }\n    }\n  }\n\n  function markPresetModified(gui, modified) {\n    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];\n//    console.log('mark', modified, opt);\n    if (modified) {\n      opt.innerHTML = opt.value + \"*\";\n    } else {\n      opt.innerHTML = opt.value;\n    }\n  }\n\n  function updateDisplays(controllerArray) {\n\n\n    if (controllerArray.length != 0) {\n\n      requestAnimationFrame(function() {\n        updateDisplays(controllerArray);\n      });\n\n    }\n\n    common.each(controllerArray, function(c) {\n      c.updateDisplay();\n    });\n\n  }\n\n  return GUI;\n\n})(dat.utils.css,\n\"<div id=\\\"dg-save\\\" class=\\\"dg dialogue\\\">\\n\\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\\n\\n  <textarea id=\\\"dg-new-constructor\\\"></textarea>\\n\\n  <div id=\\\"dg-save-locally\\\">\\n\\n    <input id=\\\"dg-local-storage\\\" type=\\\"checkbox\\\"/> Automatically save\\n    values to <code>localStorage</code> on exit.\\n\\n    <div id=\\\"dg-local-explain\\\">The values saved to <code>localStorage</code> will\\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\\n      easier to work incrementally, but <code>localStorage</code> is fragile,\\n      and your friends may not see the same values you do.\\n      \\n    </div>\\n    \\n  </div>\\n\\n</div>\",\n\".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\\n\",\ndat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {\n\n      return function(object, property) {\n\n        var initialValue = object[property];\n\n        // Providing options?\n        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {\n          return new OptionController(object, property, arguments[2]);\n        }\n\n        // Providing a map?\n\n        if (common.isNumber(initialValue)) {\n\n          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {\n\n            // Has min and max.\n            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);\n\n          } else {\n\n            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });\n\n          }\n\n        }\n\n        if (common.isString(initialValue)) {\n          return new StringController(object, property);\n        }\n\n        if (common.isFunction(initialValue)) {\n          return new FunctionController(object, property, '');\n        }\n\n        if (common.isBoolean(initialValue)) {\n          return new BooleanController(object, property);\n        }\n\n      }\n\n    })(dat.controllers.OptionController,\ndat.controllers.NumberControllerBox,\ndat.controllers.NumberControllerSlider,\ndat.controllers.StringController = (function (Controller, dom, common) {\n\n  /**\n   * @class Provides a text input to alter the string property of an object.\n   *\n   * @extends dat.controllers.Controller\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   *\n   * @member dat.controllers\n   */\n  var StringController = function(object, property) {\n\n    StringController.superclass.call(this, object, property);\n\n    var _this = this;\n\n    this.__input = document.createElement('input');\n    this.__input.setAttribute('type', 'text');\n\n    dom.bind(this.__input, 'keyup', onChange);\n    dom.bind(this.__input, 'change', onChange);\n    dom.bind(this.__input, 'blur', onBlur);\n    dom.bind(this.__input, 'keydown', function(e) {\n      if (e.keyCode === 13) {\n        this.blur();\n      }\n    });\n    \n\n    function onChange() {\n      _this.setValue(_this.__input.value);\n    }\n\n    function onBlur() {\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n\n    this.updateDisplay();\n\n    this.domElement.appendChild(this.__input);\n\n  };\n\n  StringController.superclass = Controller;\n\n  common.extend(\n\n      StringController.prototype,\n      Controller.prototype,\n\n      {\n\n        updateDisplay: function() {\n          // Stops the caret from moving on account of:\n          // keyup -> setValue -> updateDisplay\n          if (!dom.isActive(this.__input)) {\n            this.__input.value = this.getValue();\n          }\n          return StringController.superclass.prototype.updateDisplay.call(this);\n        }\n\n      }\n\n  );\n\n  return StringController;\n\n})(dat.controllers.Controller,\ndat.dom.dom,\ndat.utils.common),\ndat.controllers.FunctionController,\ndat.controllers.BooleanController,\ndat.utils.common),\ndat.controllers.Controller,\ndat.controllers.BooleanController,\ndat.controllers.FunctionController,\ndat.controllers.NumberControllerBox,\ndat.controllers.NumberControllerSlider,\ndat.controllers.OptionController,\ndat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {\n\n  var ColorController = function(object, property) {\n\n    ColorController.superclass.call(this, object, property);\n\n    this.__color = new Color(this.getValue());\n    this.__temp = new Color(0);\n\n    var _this = this;\n\n    this.domElement = document.createElement('div');\n\n    dom.makeSelectable(this.domElement, false);\n\n    this.__selector = document.createElement('div');\n    this.__selector.className = 'selector';\n\n    this.__saturation_field = document.createElement('div');\n    this.__saturation_field.className = 'saturation-field';\n\n    this.__field_knob = document.createElement('div');\n    this.__field_knob.className = 'field-knob';\n    this.__field_knob_border = '2px solid ';\n\n    this.__hue_knob = document.createElement('div');\n    this.__hue_knob.className = 'hue-knob';\n\n    this.__hue_field = document.createElement('div');\n    this.__hue_field.className = 'hue-field';\n\n    this.__input = document.createElement('input');\n    this.__input.type = 'text';\n    this.__input_textShadow = '0 1px 1px ';\n\n    dom.bind(this.__input, 'keydown', function(e) {\n      if (e.keyCode === 13) { // on enter\n        onBlur.call(this);\n      }\n    });\n\n    dom.bind(this.__input, 'blur', onBlur);\n\n    dom.bind(this.__selector, 'mousedown', function(e) {\n\n      dom\n        .addClass(this, 'drag')\n        .bind(window, 'mouseup', function(e) {\n          dom.removeClass(_this.__selector, 'drag');\n        });\n\n    });\n\n    var value_field = document.createElement('div');\n\n    common.extend(this.__selector.style, {\n      width: '122px',\n      height: '102px',\n      padding: '3px',\n      backgroundColor: '#222',\n      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'\n    });\n\n    common.extend(this.__field_knob.style, {\n      position: 'absolute',\n      width: '12px',\n      height: '12px',\n      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),\n      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',\n      borderRadius: '12px',\n      zIndex: 1\n    });\n    \n    common.extend(this.__hue_knob.style, {\n      position: 'absolute',\n      width: '15px',\n      height: '2px',\n      borderRight: '4px solid #fff',\n      zIndex: 1\n    });\n\n    common.extend(this.__saturation_field.style, {\n      width: '100px',\n      height: '100px',\n      border: '1px solid #555',\n      marginRight: '3px',\n      display: 'inline-block',\n      cursor: 'pointer'\n    });\n\n    common.extend(value_field.style, {\n      width: '100%',\n      height: '100%',\n      background: 'none'\n    });\n    \n    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');\n\n    common.extend(this.__hue_field.style, {\n      width: '15px',\n      height: '100px',\n      display: 'inline-block',\n      border: '1px solid #555',\n      cursor: 'ns-resize'\n    });\n\n    hueGradient(this.__hue_field);\n\n    common.extend(this.__input.style, {\n      outline: 'none',\n//      width: '120px',\n      textAlign: 'center',\n//      padding: '4px',\n//      marginBottom: '6px',\n      color: '#fff',\n      border: 0,\n      fontWeight: 'bold',\n      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'\n    });\n\n    dom.bind(this.__saturation_field, 'mousedown', fieldDown);\n    dom.bind(this.__field_knob, 'mousedown', fieldDown);\n\n    dom.bind(this.__hue_field, 'mousedown', function(e) {\n      setH(e);\n      dom.bind(window, 'mousemove', setH);\n      dom.bind(window, 'mouseup', unbindH);\n    });\n\n    function fieldDown(e) {\n      setSV(e);\n      // document.body.style.cursor = 'none';\n      dom.bind(window, 'mousemove', setSV);\n      dom.bind(window, 'mouseup', unbindSV);\n    }\n\n    function unbindSV() {\n      dom.unbind(window, 'mousemove', setSV);\n      dom.unbind(window, 'mouseup', unbindSV);\n      // document.body.style.cursor = 'default';\n    }\n\n    function onBlur() {\n      var i = interpret(this.value);\n      if (i !== false) {\n        _this.__color.__state = i;\n        _this.setValue(_this.__color.toOriginal());\n      } else {\n        this.value = _this.__color.toString();\n      }\n    }\n\n    function unbindH() {\n      dom.unbind(window, 'mousemove', setH);\n      dom.unbind(window, 'mouseup', unbindH);\n    }\n\n    this.__saturation_field.appendChild(value_field);\n    this.__selector.appendChild(this.__field_knob);\n    this.__selector.appendChild(this.__saturation_field);\n    this.__selector.appendChild(this.__hue_field);\n    this.__hue_field.appendChild(this.__hue_knob);\n\n    this.domElement.appendChild(this.__input);\n    this.domElement.appendChild(this.__selector);\n\n    this.updateDisplay();\n\n    function setSV(e) {\n\n      e.preventDefault();\n\n      var w = dom.getWidth(_this.__saturation_field);\n      var o = dom.getOffset(_this.__saturation_field);\n      var s = (e.clientX - o.left + document.body.scrollLeft) / w;\n      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;\n\n      if (v > 1) v = 1;\n      else if (v < 0) v = 0;\n\n      if (s > 1) s = 1;\n      else if (s < 0) s = 0;\n\n      _this.__color.v = v;\n      _this.__color.s = s;\n\n      _this.setValue(_this.__color.toOriginal());\n\n\n      return false;\n\n    }\n\n    function setH(e) {\n\n      e.preventDefault();\n\n      var s = dom.getHeight(_this.__hue_field);\n      var o = dom.getOffset(_this.__hue_field);\n      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;\n\n      if (h > 1) h = 1;\n      else if (h < 0) h = 0;\n\n      _this.__color.h = h * 360;\n\n      _this.setValue(_this.__color.toOriginal());\n\n      return false;\n\n    }\n\n  };\n\n  ColorController.superclass = Controller;\n\n  common.extend(\n\n      ColorController.prototype,\n      Controller.prototype,\n\n      {\n\n        updateDisplay: function() {\n\n          var i = interpret(this.getValue());\n\n          if (i !== false) {\n\n            var mismatch = false;\n\n            // Check for mismatch on the interpreted value.\n\n            common.each(Color.COMPONENTS, function(component) {\n              if (!common.isUndefined(i[component]) &&\n                  !common.isUndefined(this.__color.__state[component]) &&\n                  i[component] !== this.__color.__state[component]) {\n                mismatch = true;\n                return {}; // break\n              }\n            }, this);\n\n            // If nothing diverges, we keep our previous values\n            // for statefulness, otherwise we recalculate fresh\n            if (mismatch) {\n              common.extend(this.__color.__state, i);\n            }\n\n          }\n\n          common.extend(this.__temp.__state, this.__color.__state);\n\n          this.__temp.a = 1;\n\n          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;\n          var _flip = 255 - flip;\n\n          common.extend(this.__field_knob.style, {\n            marginLeft: 100 * this.__color.s - 7 + 'px',\n            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',\n            backgroundColor: this.__temp.toString(),\n            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'\n          });\n\n          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'\n\n          this.__temp.s = 1;\n          this.__temp.v = 1;\n\n          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());\n\n          common.extend(this.__input.style, {\n            backgroundColor: this.__input.value = this.__color.toString(),\n            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',\n            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'\n          });\n\n        }\n\n      }\n\n  );\n  \n  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];\n  \n  function linearGradient(elem, x, a, b) {\n    elem.style.background = '';\n    common.each(vendors, function(vendor) {\n      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';\n    });\n  }\n  \n  function hueGradient(elem) {\n    elem.style.background = '';\n    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'\n    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n  }\n\n\n  return ColorController;\n\n})(dat.controllers.Controller,\ndat.dom.dom,\ndat.color.Color = (function (interpret, math, toString, common) {\n\n  var Color = function() {\n\n    this.__state = interpret.apply(this, arguments);\n\n    if (this.__state === false) {\n      throw 'Failed to interpret color arguments';\n    }\n\n    this.__state.a = this.__state.a || 1;\n\n\n  };\n\n  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];\n\n  common.extend(Color.prototype, {\n\n    toString: function() {\n      return toString(this);\n    },\n\n    toOriginal: function() {\n      return this.__state.conversion.write(this);\n    }\n\n  });\n\n  defineRGBComponent(Color.prototype, 'r', 2);\n  defineRGBComponent(Color.prototype, 'g', 1);\n  defineRGBComponent(Color.prototype, 'b', 0);\n\n  defineHSVComponent(Color.prototype, 'h');\n  defineHSVComponent(Color.prototype, 's');\n  defineHSVComponent(Color.prototype, 'v');\n\n  Object.defineProperty(Color.prototype, 'a', {\n\n    get: function() {\n      return this.__state.a;\n    },\n\n    set: function(v) {\n      this.__state.a = v;\n    }\n\n  });\n\n  Object.defineProperty(Color.prototype, 'hex', {\n\n    get: function() {\n\n      if (!this.__state.space !== 'HEX') {\n        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);\n      }\n\n      return this.__state.hex;\n\n    },\n\n    set: function(v) {\n\n      this.__state.space = 'HEX';\n      this.__state.hex = v;\n\n    }\n\n  });\n\n  function defineRGBComponent(target, component, componentHexIndex) {\n\n    Object.defineProperty(target, component, {\n\n      get: function() {\n\n        if (this.__state.space === 'RGB') {\n          return this.__state[component];\n        }\n\n        recalculateRGB(this, component, componentHexIndex);\n\n        return this.__state[component];\n\n      },\n\n      set: function(v) {\n\n        if (this.__state.space !== 'RGB') {\n          recalculateRGB(this, component, componentHexIndex);\n          this.__state.space = 'RGB';\n        }\n\n        this.__state[component] = v;\n\n      }\n\n    });\n\n  }\n\n  function defineHSVComponent(target, component) {\n\n    Object.defineProperty(target, component, {\n\n      get: function() {\n\n        if (this.__state.space === 'HSV')\n          return this.__state[component];\n\n        recalculateHSV(this);\n\n        return this.__state[component];\n\n      },\n\n      set: function(v) {\n\n        if (this.__state.space !== 'HSV') {\n          recalculateHSV(this);\n          this.__state.space = 'HSV';\n        }\n\n        this.__state[component] = v;\n\n      }\n\n    });\n\n  }\n\n  function recalculateRGB(color, component, componentHexIndex) {\n\n    if (color.__state.space === 'HEX') {\n\n      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);\n\n    } else if (color.__state.space === 'HSV') {\n\n      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));\n\n    } else {\n\n      throw 'Corrupted color state';\n\n    }\n\n  }\n\n  function recalculateHSV(color) {\n\n    var result = math.rgb_to_hsv(color.r, color.g, color.b);\n\n    common.extend(color.__state,\n        {\n          s: result.s,\n          v: result.v\n        }\n    );\n\n    if (!common.isNaN(result.h)) {\n      color.__state.h = result.h;\n    } else if (common.isUndefined(color.__state.h)) {\n      color.__state.h = 0;\n    }\n\n  }\n\n  return Color;\n\n})(dat.color.interpret,\ndat.color.math = (function () {\n\n  var tmpComponent;\n\n  return {\n\n    hsv_to_rgb: function(h, s, v) {\n\n      var hi = Math.floor(h / 60) % 6;\n\n      var f = h / 60 - Math.floor(h / 60);\n      var p = v * (1.0 - s);\n      var q = v * (1.0 - (f * s));\n      var t = v * (1.0 - ((1.0 - f) * s));\n      var c = [\n        [v, t, p],\n        [q, v, p],\n        [p, v, t],\n        [p, q, v],\n        [t, p, v],\n        [v, p, q]\n      ][hi];\n\n      return {\n        r: c[0] * 255,\n        g: c[1] * 255,\n        b: c[2] * 255\n      };\n\n    },\n\n    rgb_to_hsv: function(r, g, b) {\n\n      var min = Math.min(r, g, b),\n          max = Math.max(r, g, b),\n          delta = max - min,\n          h, s;\n\n      if (max != 0) {\n        s = delta / max;\n      } else {\n        return {\n          h: NaN,\n          s: 0,\n          v: 0\n        };\n      }\n\n      if (r == max) {\n        h = (g - b) / delta;\n      } else if (g == max) {\n        h = 2 + (b - r) / delta;\n      } else {\n        h = 4 + (r - g) / delta;\n      }\n      h /= 6;\n      if (h < 0) {\n        h += 1;\n      }\n\n      return {\n        h: h * 360,\n        s: s,\n        v: max / 255\n      };\n    },\n\n    rgb_to_hex: function(r, g, b) {\n      var hex = this.hex_with_component(0, 2, r);\n      hex = this.hex_with_component(hex, 1, g);\n      hex = this.hex_with_component(hex, 0, b);\n      return hex;\n    },\n\n    component_from_hex: function(hex, componentIndex) {\n      return (hex >> (componentIndex * 8)) & 0xFF;\n    },\n\n    hex_with_component: function(hex, componentIndex, value) {\n      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));\n    }\n\n  }\n\n})(),\ndat.color.toString,\ndat.utils.common),\ndat.color.interpret,\ndat.utils.common),\ndat.utils.requestAnimationFrame = (function () {\n\n  /**\n   * requirejs version of Paul Irish's RequestAnimationFrame\n   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n   */\n\n  return window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      function(callback, element) {\n\n        window.setTimeout(callback, 1000 / 60);\n\n      };\n})(),\ndat.dom.CenteredDiv = (function (dom, common) {\n\n\n  var CenteredDiv = function() {\n\n    this.backgroundElement = document.createElement('div');\n    common.extend(this.backgroundElement.style, {\n      backgroundColor: 'rgba(0,0,0,0.8)',\n      top: 0,\n      left: 0,\n      display: 'none',\n      zIndex: '1000',\n      opacity: 0,\n      WebkitTransition: 'opacity 0.2s linear'\n    });\n\n    dom.makeFullscreen(this.backgroundElement);\n    this.backgroundElement.style.position = 'fixed';\n\n    this.domElement = document.createElement('div');\n    common.extend(this.domElement.style, {\n      position: 'fixed',\n      display: 'none',\n      zIndex: '1001',\n      opacity: 0,\n      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'\n    });\n\n\n    document.body.appendChild(this.backgroundElement);\n    document.body.appendChild(this.domElement);\n\n    var _this = this;\n    dom.bind(this.backgroundElement, 'click', function() {\n      _this.hide();\n    });\n\n\n  };\n\n  CenteredDiv.prototype.show = function() {\n\n    var _this = this;\n    \n\n\n    this.backgroundElement.style.display = 'block';\n\n    this.domElement.style.display = 'block';\n    this.domElement.style.opacity = 0;\n//    this.domElement.style.top = '52%';\n    this.domElement.style.webkitTransform = 'scale(1.1)';\n\n    this.layout();\n\n    common.defer(function() {\n      _this.backgroundElement.style.opacity = 1;\n      _this.domElement.style.opacity = 1;\n      _this.domElement.style.webkitTransform = 'scale(1)';\n    });\n\n  };\n\n  CenteredDiv.prototype.hide = function() {\n\n    var _this = this;\n\n    var hide = function() {\n\n      _this.domElement.style.display = 'none';\n      _this.backgroundElement.style.display = 'none';\n\n      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);\n      dom.unbind(_this.domElement, 'transitionend', hide);\n      dom.unbind(_this.domElement, 'oTransitionEnd', hide);\n\n    };\n\n    dom.bind(this.domElement, 'webkitTransitionEnd', hide);\n    dom.bind(this.domElement, 'transitionend', hide);\n    dom.bind(this.domElement, 'oTransitionEnd', hide);\n\n    this.backgroundElement.style.opacity = 0;\n//    this.domElement.style.top = '48%';\n    this.domElement.style.opacity = 0;\n    this.domElement.style.webkitTransform = 'scale(1.1)';\n\n  };\n\n  CenteredDiv.prototype.layout = function() {\n    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';\n    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';\n  };\n  \n  function lockScroll(e) {\n    console.log(e);\n  }\n\n  return CenteredDiv;\n\n})(dat.dom.dom,\ndat.utils.common),\ndat.dom.dom,\ndat.utils.common);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/dat-gui/vendor/dat.gui.js\n// module id = 6\n// module chunks = 0","/**\n * dat-gui JavaScript Controller Library\n * http://code.google.com/p/dat-gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\n/** @namespace */\nvar dat = module.exports = dat || {};\n\n/** @namespace */\ndat.color = dat.color || {};\n\n/** @namespace */\ndat.utils = dat.utils || {};\n\ndat.utils.common = (function () {\n  \n  var ARR_EACH = Array.prototype.forEach;\n  var ARR_SLICE = Array.prototype.slice;\n\n  /**\n   * Band-aid methods for things that should be a lot easier in JavaScript.\n   * Implementation and structure inspired by underscore.js\n   * http://documentcloud.github.com/underscore/\n   */\n\n  return { \n    \n    BREAK: {},\n  \n    extend: function(target) {\n      \n      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n        \n        for (var key in obj)\n          if (!this.isUndefined(obj[key])) \n            target[key] = obj[key];\n        \n      }, this);\n      \n      return target;\n      \n    },\n    \n    defaults: function(target) {\n      \n      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n        \n        for (var key in obj)\n          if (this.isUndefined(target[key])) \n            target[key] = obj[key];\n        \n      }, this);\n      \n      return target;\n    \n    },\n    \n    compose: function() {\n      var toCall = ARR_SLICE.call(arguments);\n            return function() {\n              var args = ARR_SLICE.call(arguments);\n              for (var i = toCall.length -1; i >= 0; i--) {\n                args = [toCall[i].apply(this, args)];\n              }\n              return args[0];\n            }\n    },\n    \n    each: function(obj, itr, scope) {\n\n      \n      if (ARR_EACH && obj.forEach === ARR_EACH) { \n        \n        obj.forEach(itr, scope);\n        \n      } else if (obj.length === obj.length + 0) { // Is number but not NaN\n        \n        for (var key = 0, l = obj.length; key < l; key++)\n          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) \n            return;\n            \n      } else {\n\n        for (var key in obj) \n          if (itr.call(scope, obj[key], key) === this.BREAK)\n            return;\n            \n      }\n            \n    },\n    \n    defer: function(fnc) {\n      setTimeout(fnc, 0);\n    },\n    \n    toArray: function(obj) {\n      if (obj.toArray) return obj.toArray();\n      return ARR_SLICE.call(obj);\n    },\n\n    isUndefined: function(obj) {\n      return obj === undefined;\n    },\n    \n    isNull: function(obj) {\n      return obj === null;\n    },\n    \n    isNaN: function(obj) {\n      return obj !== obj;\n    },\n    \n    isArray: Array.isArray || function(obj) {\n      return obj.constructor === Array;\n    },\n    \n    isObject: function(obj) {\n      return obj === Object(obj);\n    },\n    \n    isNumber: function(obj) {\n      return obj === obj+0;\n    },\n    \n    isString: function(obj) {\n      return obj === obj+'';\n    },\n    \n    isBoolean: function(obj) {\n      return obj === false || obj === true;\n    },\n    \n    isFunction: function(obj) {\n      return Object.prototype.toString.call(obj) === '[object Function]';\n    }\n  \n  };\n    \n})();\n\n\ndat.color.toString = (function (common) {\n\n  return function(color) {\n\n    if (color.a == 1 || common.isUndefined(color.a)) {\n\n      var s = color.hex.toString(16);\n      while (s.length < 6) {\n        s = '0' + s;\n      }\n\n      return '#' + s;\n\n    } else {\n\n      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';\n\n    }\n\n  }\n\n})(dat.utils.common);\n\n\ndat.Color = dat.color.Color = (function (interpret, math, toString, common) {\n\n  var Color = function() {\n\n    this.__state = interpret.apply(this, arguments);\n\n    if (this.__state === false) {\n      throw 'Failed to interpret color arguments';\n    }\n\n    this.__state.a = this.__state.a || 1;\n\n\n  };\n\n  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];\n\n  common.extend(Color.prototype, {\n\n    toString: function() {\n      return toString(this);\n    },\n\n    toOriginal: function() {\n      return this.__state.conversion.write(this);\n    }\n\n  });\n\n  defineRGBComponent(Color.prototype, 'r', 2);\n  defineRGBComponent(Color.prototype, 'g', 1);\n  defineRGBComponent(Color.prototype, 'b', 0);\n\n  defineHSVComponent(Color.prototype, 'h');\n  defineHSVComponent(Color.prototype, 's');\n  defineHSVComponent(Color.prototype, 'v');\n\n  Object.defineProperty(Color.prototype, 'a', {\n\n    get: function() {\n      return this.__state.a;\n    },\n\n    set: function(v) {\n      this.__state.a = v;\n    }\n\n  });\n\n  Object.defineProperty(Color.prototype, 'hex', {\n\n    get: function() {\n\n      if (!this.__state.space !== 'HEX') {\n        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);\n      }\n\n      return this.__state.hex;\n\n    },\n\n    set: function(v) {\n\n      this.__state.space = 'HEX';\n      this.__state.hex = v;\n\n    }\n\n  });\n\n  function defineRGBComponent(target, component, componentHexIndex) {\n\n    Object.defineProperty(target, component, {\n\n      get: function() {\n\n        if (this.__state.space === 'RGB') {\n          return this.__state[component];\n        }\n\n        recalculateRGB(this, component, componentHexIndex);\n\n        return this.__state[component];\n\n      },\n\n      set: function(v) {\n\n        if (this.__state.space !== 'RGB') {\n          recalculateRGB(this, component, componentHexIndex);\n          this.__state.space = 'RGB';\n        }\n\n        this.__state[component] = v;\n\n      }\n\n    });\n\n  }\n\n  function defineHSVComponent(target, component) {\n\n    Object.defineProperty(target, component, {\n\n      get: function() {\n\n        if (this.__state.space === 'HSV')\n          return this.__state[component];\n\n        recalculateHSV(this);\n\n        return this.__state[component];\n\n      },\n\n      set: function(v) {\n\n        if (this.__state.space !== 'HSV') {\n          recalculateHSV(this);\n          this.__state.space = 'HSV';\n        }\n\n        this.__state[component] = v;\n\n      }\n\n    });\n\n  }\n\n  function recalculateRGB(color, component, componentHexIndex) {\n\n    if (color.__state.space === 'HEX') {\n\n      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);\n\n    } else if (color.__state.space === 'HSV') {\n\n      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));\n\n    } else {\n\n      throw 'Corrupted color state';\n\n    }\n\n  }\n\n  function recalculateHSV(color) {\n\n    var result = math.rgb_to_hsv(color.r, color.g, color.b);\n\n    common.extend(color.__state,\n        {\n          s: result.s,\n          v: result.v\n        }\n    );\n\n    if (!common.isNaN(result.h)) {\n      color.__state.h = result.h;\n    } else if (common.isUndefined(color.__state.h)) {\n      color.__state.h = 0;\n    }\n\n  }\n\n  return Color;\n\n})(dat.color.interpret = (function (toString, common) {\n\n  var result, toReturn;\n\n  var interpret = function() {\n\n    toReturn = false;\n\n    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];\n\n    common.each(INTERPRETATIONS, function(family) {\n\n      if (family.litmus(original)) {\n\n        common.each(family.conversions, function(conversion, conversionName) {\n\n          result = conversion.read(original);\n\n          if (toReturn === false && result !== false) {\n            toReturn = result;\n            result.conversionName = conversionName;\n            result.conversion = conversion;\n            return common.BREAK;\n\n          }\n\n        });\n\n        return common.BREAK;\n\n      }\n\n    });\n\n    return toReturn;\n\n  };\n\n  var INTERPRETATIONS = [\n\n    // Strings\n    {\n\n      litmus: common.isString,\n\n      conversions: {\n\n        THREE_CHAR_HEX: {\n\n          read: function(original) {\n\n            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);\n            if (test === null) return false;\n\n            return {\n              space: 'HEX',\n              hex: parseInt(\n                  '0x' +\n                      test[1].toString() + test[1].toString() +\n                      test[2].toString() + test[2].toString() +\n                      test[3].toString() + test[3].toString())\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        SIX_CHAR_HEX: {\n\n          read: function(original) {\n\n            var test = original.match(/^#([A-F0-9]{6})$/i);\n            if (test === null) return false;\n\n            return {\n              space: 'HEX',\n              hex: parseInt('0x' + test[1].toString())\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        CSS_RGB: {\n\n          read: function(original) {\n\n            var test = original.match(/^rgb\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);\n            if (test === null) return false;\n\n            return {\n              space: 'RGB',\n              r: parseFloat(test[1]),\n              g: parseFloat(test[2]),\n              b: parseFloat(test[3])\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        CSS_RGBA: {\n\n          read: function(original) {\n\n            var test = original.match(/^rgba\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\,\\s*(.+)\\s*\\)/);\n            if (test === null) return false;\n\n            return {\n              space: 'RGB',\n              r: parseFloat(test[1]),\n              g: parseFloat(test[2]),\n              b: parseFloat(test[3]),\n              a: parseFloat(test[4])\n            };\n\n          },\n\n          write: toString\n\n        }\n\n      }\n\n    },\n\n    // Numbers\n    {\n\n      litmus: common.isNumber,\n\n      conversions: {\n\n        HEX: {\n          read: function(original) {\n            return {\n              space: 'HEX',\n              hex: original,\n              conversionName: 'HEX'\n            }\n          },\n\n          write: function(color) {\n            return color.hex;\n          }\n        }\n\n      }\n\n    },\n\n    // Arrays\n    {\n\n      litmus: common.isArray,\n\n      conversions: {\n\n        RGB_ARRAY: {\n          read: function(original) {\n            if (original.length != 3) return false;\n            return {\n              space: 'RGB',\n              r: original[0],\n              g: original[1],\n              b: original[2]\n            };\n          },\n\n          write: function(color) {\n            return [color.r, color.g, color.b];\n          }\n\n        },\n\n        RGBA_ARRAY: {\n          read: function(original) {\n            if (original.length != 4) return false;\n            return {\n              space: 'RGB',\n              r: original[0],\n              g: original[1],\n              b: original[2],\n              a: original[3]\n            };\n          },\n\n          write: function(color) {\n            return [color.r, color.g, color.b, color.a];\n          }\n\n        }\n\n      }\n\n    },\n\n    // Objects\n    {\n\n      litmus: common.isObject,\n\n      conversions: {\n\n        RGBA_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.r) &&\n                common.isNumber(original.g) &&\n                common.isNumber(original.b) &&\n                common.isNumber(original.a)) {\n              return {\n                space: 'RGB',\n                r: original.r,\n                g: original.g,\n                b: original.b,\n                a: original.a\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              r: color.r,\n              g: color.g,\n              b: color.b,\n              a: color.a\n            }\n          }\n        },\n\n        RGB_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.r) &&\n                common.isNumber(original.g) &&\n                common.isNumber(original.b)) {\n              return {\n                space: 'RGB',\n                r: original.r,\n                g: original.g,\n                b: original.b\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              r: color.r,\n              g: color.g,\n              b: color.b\n            }\n          }\n        },\n\n        HSVA_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.h) &&\n                common.isNumber(original.s) &&\n                common.isNumber(original.v) &&\n                common.isNumber(original.a)) {\n              return {\n                space: 'HSV',\n                h: original.h,\n                s: original.s,\n                v: original.v,\n                a: original.a\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              h: color.h,\n              s: color.s,\n              v: color.v,\n              a: color.a\n            }\n          }\n        },\n\n        HSV_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.h) &&\n                common.isNumber(original.s) &&\n                common.isNumber(original.v)) {\n              return {\n                space: 'HSV',\n                h: original.h,\n                s: original.s,\n                v: original.v\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              h: color.h,\n              s: color.s,\n              v: color.v\n            }\n          }\n\n        }\n\n      }\n\n    }\n\n\n  ];\n\n  return interpret;\n\n\n})(dat.color.toString,\ndat.utils.common),\ndat.color.math = (function () {\n\n  var tmpComponent;\n\n  return {\n\n    hsv_to_rgb: function(h, s, v) {\n\n      var hi = Math.floor(h / 60) % 6;\n\n      var f = h / 60 - Math.floor(h / 60);\n      var p = v * (1.0 - s);\n      var q = v * (1.0 - (f * s));\n      var t = v * (1.0 - ((1.0 - f) * s));\n      var c = [\n        [v, t, p],\n        [q, v, p],\n        [p, v, t],\n        [p, q, v],\n        [t, p, v],\n        [v, p, q]\n      ][hi];\n\n      return {\n        r: c[0] * 255,\n        g: c[1] * 255,\n        b: c[2] * 255\n      };\n\n    },\n\n    rgb_to_hsv: function(r, g, b) {\n\n      var min = Math.min(r, g, b),\n          max = Math.max(r, g, b),\n          delta = max - min,\n          h, s;\n\n      if (max != 0) {\n        s = delta / max;\n      } else {\n        return {\n          h: NaN,\n          s: 0,\n          v: 0\n        };\n      }\n\n      if (r == max) {\n        h = (g - b) / delta;\n      } else if (g == max) {\n        h = 2 + (b - r) / delta;\n      } else {\n        h = 4 + (r - g) / delta;\n      }\n      h /= 6;\n      if (h < 0) {\n        h += 1;\n      }\n\n      return {\n        h: h * 360,\n        s: s,\n        v: max / 255\n      };\n    },\n\n    rgb_to_hex: function(r, g, b) {\n      var hex = this.hex_with_component(0, 2, r);\n      hex = this.hex_with_component(hex, 1, g);\n      hex = this.hex_with_component(hex, 0, b);\n      return hex;\n    },\n\n    component_from_hex: function(hex, componentIndex) {\n      return (hex >> (componentIndex * 8)) & 0xFF;\n    },\n\n    hex_with_component: function(hex, componentIndex, value) {\n      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));\n    }\n\n  }\n\n})(),\ndat.color.toString,\ndat.utils.common);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/dat-gui/vendor/dat.color.js\n// module id = 7\n// module chunks = 0","window.THREE = require('three');\n\n(function(){\n  /**\n   * Planeクラス\n   */\n  var Plane = window.Plane || {};\n\n  window.Plane = function () {\n    //Planeクラスをイニシャライズ\n    p.init();\n  };\n\n  var p, s;\n\n  s = window.Plane;\n  p = s.prototype;\n\n  /**\n   * Planeクラスイニシャライズ\n   **/\n  p.init = function () {\n    var self = this;\n\n    //planeGeometry\n    self.planeGeometry = new THREE.PlaneGeometry(60, 40, 1, 1);\n\n    //planeMaterial\n    self.planeMaterial = new THREE.MeshLambertMaterial({\n      color: 0xffffff\n    });\n\n    //plane\n    self.PlaneObject = new THREE.Mesh(self.planeGeometry, self.planeMaterial);\n    self.PlaneObject.receiveShadow = true;\n    //planeを回転\n    self.PlaneObject.rotation.x = -0.5 * Math.PI;\n    self.PlaneObject.position.x = 0;\n    self.PlaneObject.position.y = 0;\n    self.PlaneObject.position.z = 0;\n\n    //オブジェクトとしてPlaneObject返す\n    return self.PlaneObject;\n  };\n\n})();\n\n\n// WEBPACK FOOTER //\n// ./src/js/object/Plane.js","window.THREE = require('three');\n\n/**\n * Scene\n */\n\n'use strict';\n\nvar Scene = (function () {\n\n  function Scene() {\n    this.init.apply(this, arguments);\n  }\n\n  var p, s;\n\n  s = Scene;\n  p = s.prototype;\n\n  p.init = function() {\n    this.scene;\n\n    this.setup();\n    this.create();\n  };\n\n  p.setup = function() {\n\n    // console.log('this',this);\n    // console.log('Scene_setup!!!!!');\n\n  };\n\n  //\n  p.create = function () {\n    this.scene = new THREE.Scene();\n  };\n\n  //\n  p.update = function () {\n\n  };\n\n  //\n  p.setEvents = function () {\n\n  };\n\n  return Scene;\n\n}());\n\nmodule.exports = Scene;\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/object/Scene.js","window.THREE = require('three');\n\n/**\n * Camera\n */\n\n'use strict';\n\n\nvar Camera = (function () {\n\n  function Camera() {\n    this.init.apply(this, arguments);\n  }\n\n  var p, s;\n\n  s = Camera;\n  p = s.prototype;\n\n  p.init = function() {\n    this.camera;\n    this.vec3 = new THREE.Vector3(0,0,0);\n\n    this.setup();\n    this.create();\n\n    this.update();\n  };\n\n  p.setup = function() {\n\n    // console.log('this',this);\n    // console.log('Camera_setup!!!!!');\n\n  };\n\n  //\n  p.create = function () {\n    // this.scene = new THREE.Camera();\n\n    this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\n\n    this.camera.position.x = -30;\n    this.camera.position.y = 40;\n    this.camera.position.z = 30;\n    // this.camera.lookAt( gb.in.scene.scene.position );\n    this.camera.lookAt(this.vec3);\n    // window.console.log('A',this.camera);\n  };\n\n  //\n  p.update = function () {\n\n    // window.console.log('B',this.camera);\n    // this.camera.position.x = Math.cos(this.timer) * 500;\n    // this.camera.position.y = Math.sin(this.timer*2) * 100;\n    // this.camera.position.z = Math.sin(this.timer) * 100 + 200;\n    // //\n    // this.camera.lookAt(this.vec3);\n\n    // this.lookat_x = Math.sin(this.timer*0.8)*10;\n    // this.lookat_y = Math.cos(this.timer*2)*10;\n    // this.camera.lookAt(new THREE.Vector3(this.lookat_x, this.lookat_y, 0));\n    // gb.in.camera.lookAt(new THREE.Vector3(0, 0, 0));\n\n    // requestAnimationFrame(p.update);\n    // gb.in.renderer.render(gb.in.scene.scene, this.camera);\n  };\n\n  //\n  p.setEvents = function () {\n\n  };\n\n  return Camera;\n\n}());\n\nmodule.exports = Camera;\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/object/Camera.js","window.THREE = require('three');\nvar Stats = require('../libs/stats.js');\n\n/**\n * Cube\n */\n'use strict';\n\nvar Cube = (function () {\n  // globalオブジェクト\n  if (window.gb === undefined) window.gb = {};\n  window.gb.in = {}; //instance\n\n\n  function Cube() {\n    this.init.apply(this, arguments);\n  }\n\n  var p, s;\n\n  s = Cube;\n  p = s.prototype;\n\n  p.init = function() {\n    this.cube = null;\n    this.geometry = null;\n    this.material = null;\n\n    //イニシャライズ実行\n    this.setup();\n\n    this.update();\n  };\n\n  p.setup = function() {\n    // console.log('this',this);\n    // console.log('Cube_setup!!!!!');\n\n    //cubeGeometry\n    this.geometry = new THREE.BoxGeometry(10,10,10);\n\n    //cubeMaterial\n    this.material = new THREE.MeshLambertMaterial({\n      color: 0xff0000, wireframe: false\n    });\n\n    this.cube = new THREE.Mesh(this.geometry, this.material);\n    this.cube.castShadow = true;\n    //Cubeを回転\n    this.cube.position.x = -4;\n    this.cube.position.y = 3;\n    this.cube.position.z = 0;\n\n    // this.cube.rotation.x += 0.02;\n    // this.cube.rotation.y += 0.02;\n    // this.cube.rotation.z += 0.02;\n\n    return this.cube;\n\n  };\n\n  //\n  p.create = function () {\n\n  };\n\n  //\n  p.update = function () {\n\n    // this.CubeObject.cube.rotation.x += 0.02;\n    // this.cube.rotation.x += 0.02;\n    //\n    // gb.in.renderer.render(gb.in.scene.scene, gb.in.camera.camera);\n    // requestAnimationFrame(p.update);\n\n  };\n\n  //\n  p.setEvents = function () {\n\n  };\n\n  return Cube;\n\n  //グローバルオブジェクト化\n  // gb.Cube = Cube;\n\n}());\n\nmodule.exports = Cube;\n\n//   p.animate = function () {\n//     var self = this;\n//\n//     // self.CubeObject.rotation.x += 0.02;\n//     // self.CubeObject.rotation.y += 0.02;\n//     // self.CubeObject.rotation.z += 0.02;\n//\n//   };\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/object/Cube.js"],"sourceRoot":""}